
nil.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000005fa  00800100  000106c2  00010756  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000106c2  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00002bbb  008006fa  008006fa  00010d50  2**0
                  ALLOC
  3 .debug_aranges 00000420  00000000  00000000  00010d50  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 00001e76  00000000  00000000  00011170  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00016538  00000000  00000000  00012fe6  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00005961  00000000  00000000  0002951e  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   0000c700  00000000  00000000  0002ee7f  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  000014e0  00000000  00000000  0003b580  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00003e6c  00000000  00000000  0003ca60  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    000091d7  00000000  00000000  000408cc  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 000007e8  00000000  00000000  00049aa3  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 f4 06 	jmp	0xde8	; 0xde8 <__ctors_end>
       4:	0c 94 13 07 	jmp	0xe26	; 0xe26 <__bad_interrupt>
       8:	0c 94 13 07 	jmp	0xe26	; 0xe26 <__bad_interrupt>
       c:	0c 94 13 07 	jmp	0xe26	; 0xe26 <__bad_interrupt>
      10:	0c 94 bc 61 	jmp	0xc378	; 0xc378 <__vector_4>
      14:	0c 94 13 07 	jmp	0xe26	; 0xe26 <__bad_interrupt>
      18:	0c 94 13 07 	jmp	0xe26	; 0xe26 <__bad_interrupt>
      1c:	0c 94 13 07 	jmp	0xe26	; 0xe26 <__bad_interrupt>
      20:	0c 94 13 07 	jmp	0xe26	; 0xe26 <__bad_interrupt>
      24:	0c 94 24 62 	jmp	0xc448	; 0xc448 <__vector_9>
      28:	0c 94 13 07 	jmp	0xe26	; 0xe26 <__bad_interrupt>
      2c:	0c 94 fb 61 	jmp	0xc3f6	; 0xc3f6 <__vector_11>
      30:	0c 94 13 07 	jmp	0xe26	; 0xe26 <__bad_interrupt>
      34:	0c 94 13 07 	jmp	0xe26	; 0xe26 <__bad_interrupt>
      38:	0c 94 13 07 	jmp	0xe26	; 0xe26 <__bad_interrupt>
      3c:	0c 94 13 07 	jmp	0xe26	; 0xe26 <__bad_interrupt>
      40:	0c 94 5a 14 	jmp	0x28b4	; 0x28b4 <__vector_16>
      44:	0c 94 13 07 	jmp	0xe26	; 0xe26 <__bad_interrupt>
      48:	0c 94 13 07 	jmp	0xe26	; 0xe26 <__bad_interrupt>
      4c:	0c 94 13 07 	jmp	0xe26	; 0xe26 <__bad_interrupt>
      50:	0c 94 f1 13 	jmp	0x27e2	; 0x27e2 <__vector_20>
      54:	0c 94 bb 13 	jmp	0x2776	; 0x2776 <__vector_21>
      58:	0c 94 13 07 	jmp	0xe26	; 0xe26 <__bad_interrupt>
      5c:	0c 94 13 07 	jmp	0xe26	; 0xe26 <__bad_interrupt>
      60:	0c 94 13 07 	jmp	0xe26	; 0xe26 <__bad_interrupt>
      64:	0c 94 13 07 	jmp	0xe26	; 0xe26 <__bad_interrupt>
      68:	0c 94 13 07 	jmp	0xe26	; 0xe26 <__bad_interrupt>
      6c:	0c 94 13 07 	jmp	0xe26	; 0xe26 <__bad_interrupt>
      70:	0c 94 13 07 	jmp	0xe26	; 0xe26 <__bad_interrupt>
      74:	0c 94 13 07 	jmp	0xe26	; 0xe26 <__bad_interrupt>
      78:	0c 94 13 07 	jmp	0xe26	; 0xe26 <__bad_interrupt>
      7c:	0c 94 13 07 	jmp	0xe26	; 0xe26 <__bad_interrupt>
      80:	0c 94 13 07 	jmp	0xe26	; 0xe26 <__bad_interrupt>
      84:	0c 94 13 07 	jmp	0xe26	; 0xe26 <__bad_interrupt>
      88:	0c 94 13 07 	jmp	0xe26	; 0xe26 <__bad_interrupt>
      8c:	08 4a       	sbci	r16, 0xA8	; 168
      8e:	d7 3b       	cpi	r29, 0xB7	; 183
      90:	3b ce       	rjmp	.-906    	; 0xfffffd08 <__eeprom_end+0xff7efd08>
      92:	01 6e       	ori	r16, 0xE1	; 225
      94:	84 bc       	out	0x24, r8	; 36
      96:	bf fd       	.word	0xfdbf	; ????
      98:	c1 2f       	mov	r28, r17
      9a:	3d 6c       	ori	r19, 0xCD	; 205
      9c:	74 31       	cpi	r23, 0x14	; 20
      9e:	9a bd       	out	0x2a, r25	; 42
      a0:	56 83       	std	Z+6, r21	; 0x06
      a2:	3d da       	rcall	.-2950   	; 0xfffff51e <__eeprom_end+0xff7ef51e>
      a4:	3d 00       	.word	0x003d	; ????
      a6:	c7 7f       	andi	r28, 0xF7	; 247
      a8:	11 be       	out	0x31, r1	; 49
      aa:	d9 e4       	ldi	r29, 0x49	; 73
      ac:	bb 4c       	sbci	r27, 0xCB	; 203
      ae:	3e 91       	ld	r19, -X
      b0:	6b aa       	std	Y+51, r6	; 0x33
      b2:	aa be       	out	0x3a, r10	; 58
      b4:	00 00       	nop
      b6:	00 80       	ld	r0, Z
      b8:	3f 0f       	add	r19, r31

000000b9 <st7735_red_init1>:
      b9:	0f 01 80 96 11 80 ff b1 03 01 2c 2d b2 03 01 2c     ..........,-...,
      c9:	2d b3 06 01 2c 2d 01 2c 2d b4 01 07 c0 03 a2 02     -...,-.,-.......
      d9:	84 c1 01 c5 c2 02 0a 00 c3 02 8a 2a c4 02 8a ee     ...........*....
      e9:	c5 01 0e 20 00 36 01 c8 3a 01 05                    ... .6..:..

000000f4 <st7735_red_init_red2>:
      f4:	02 2a 04 00 00 00 7f 2b 04 00 00 00 9f              .*.....+.....

00000101 <st7735_red_init3>:
     101:	04 e0 10 02 1c 07 12 37 32 29 2d 29 25 2b 39 00     .......72)-)%+9.
     111:	01 03 10 e1 10 03 1d 07 06 2e 2c 29 2d 2e 2e 37     ..........,)-..7
     121:	3f 00 00 02 10 13 80 0a 29 80 64                    ?.......).d

0000012c <font>:
     12c:	00 00 00 00 00 3e 5b 4f 5b 3e 3e 6b 4f 6b 3e 18     .....>[O[>>kOk>.
     13c:	3c 78 3c 18 18 3c 7e 3c 18 1c 57 7d 57 1c 1c 5e     <x<..<~<..W}W..^
     14c:	7f 5e 1c 00 18 3c 18 00 ff e7 c3 e7 ff 00 18 24     .^...<.........$
     15c:	18 00 ff e7 db e7 ff 30 48 3a 06 0e 26 29 79 29     .......0H:..&)y)
     16c:	26 40 7f 05 05 07 40 7f 05 25 3f 5a 3c e7 3c 5a     &@....@..%?Z<.<Z
     17c:	7f 3e 1c 1c 08 08 1c 1c 3e 7f 14 22 7f 22 14 5f     .>......>.."."._
     18c:	5f 00 5f 5f 06 09 7f 01 7f 00 66 89 95 6a 60 60     _.__......f..j``
     19c:	60 60 60 94 a2 ff a2 94 08 04 7e 04 08 10 20 7e     ```.......~... ~
     1ac:	20 10 08 08 2a 1c 08 08 1c 2a 08 08 1e 10 10 10      ...*....*......
     1bc:	10 0c 1e 0c 1e 0c 30 38 3e 38 30 06 0e 3e 0e 06     ......08>80..>..
     1cc:	00 00 00 00 00 00 00 5f 00 00 00 07 00 07 00 14     ......._........
     1dc:	7f 14 7f 14 24 2a 7f 2a 12 23 13 08 64 62 36 49     ....$*.*.#..db6I
     1ec:	56 20 50 00 08 07 03 00 00 1c 22 41 00 00 41 22     V P......."A..A"
     1fc:	1c 00 2a 1c 7f 1c 2a 08 08 3e 08 08 00 80 70 30     ..*...*..>....p0
     20c:	00 08 08 08 08 08 00 00 60 60 00 20 10 08 04 02     ........``. ....
     21c:	3e 51 49 45 3e 00 42 7f 40 00 72 49 49 49 46 21     >QIE>.B.@.rIIIF!
     22c:	41 49 4d 33 18 14 12 7f 10 27 45 45 45 39 3c 4a     AIM3.....'EEE9<J
     23c:	49 49 31 41 21 11 09 07 36 49 49 49 36 46 49 49     II1A!...6III6FII
     24c:	29 1e 00 00 14 00 00 00 40 34 00 00 00 08 14 22     ).......@4....."
     25c:	41 14 14 14 14 14 00 41 22 14 08 02 01 59 09 06     A......A"....Y..
     26c:	3e 41 5d 59 4e 7c 12 11 12 7c 7f 49 49 49 36 3e     >A]YN|...|.III6>
     27c:	41 41 41 22 7f 41 41 41 3e 7f 49 49 49 41 7f 09     AAA".AAA>.IIIA..
     28c:	09 09 01 3e 41 41 51 73 7f 08 08 08 7f 00 41 7f     ...>AAQs......A.
     29c:	41 00 20 40 41 3f 01 7f 08 14 22 41 7f 40 40 40     A. @A?...."A.@@@
     2ac:	40 7f 02 1c 02 7f 7f 04 08 10 7f 3e 41 41 41 3e     @..........>AAA>
     2bc:	7f 09 09 09 06 3e 41 51 21 5e 7f 09 19 29 46 26     .....>AQ!^...)F&
     2cc:	49 49 49 32 03 01 7f 01 03 3f 40 40 40 3f 1f 20     III2.....?@@@?. 
     2dc:	40 20 1f 3f 40 38 40 3f 63 14 08 14 63 03 04 78     @ .?@8@?c...c..x
     2ec:	04 03 61 59 49 4d 43 00 7f 41 41 41 02 04 08 10     ..aYIMC..AAA....
     2fc:	20 00 41 41 41 7f 04 02 01 02 04 40 40 40 40 40      .AAA......@@@@@
     30c:	00 03 07 08 00 20 54 54 78 40 7f 28 44 44 38 38     ..... TTx@.(DD88
     31c:	44 44 44 28 38 44 44 28 7f 38 54 54 54 18 00 08     DDD(8DD(.8TTT...
     32c:	7e 09 02 18 a4 a4 9c 78 7f 08 04 04 78 00 44 7d     ~......x....x.D}
     33c:	40 00 20 40 40 3d 00 7f 10 28 44 00 00 41 7f 40     @. @@=...(D..A.@
     34c:	00 7c 04 78 04 78 7c 08 04 04 78 38 44 44 44 38     .|.x.x|...x8DDD8
     35c:	fc 18 24 24 18 18 24 24 18 fc 7c 08 04 04 08 48     ..$$..$$..|....H
     36c:	54 54 54 24 04 04 3f 44 24 3c 40 40 20 7c 1c 20     TTT$..?D$<@@ |. 
     37c:	40 20 1c 3c 40 30 40 3c 44 28 10 28 44 4c 90 90     @ .<@0@<D(.(DL..
     38c:	90 7c 44 64 54 4c 44 00 08 36 41 00 00 00 77 00     .|DdTLD..6A...w.
     39c:	00 00 41 36 08 00 02 01 02 04 02 3c 26 23 26 3c     ..A6.......<&#&<
     3ac:	1e a1 a1 61 12 3a 40 40 20 7a 38 54 54 55 59 21     ...a.:@@ z8TTUY!
     3bc:	55 55 79 41 21 54 54 78 41 21 55 54 78 40 20 54     UUyA!TTxA!UTx@ T
     3cc:	55 79 40 0c 1e 52 72 12 39 55 55 55 59 39 54 54     Uy@..Rr.9UUUY9TT
     3dc:	54 59 39 55 54 54 58 00 00 45 7c 41 00 02 45 7d     TY9UTTX..E|A..E}
     3ec:	42 00 01 45 7c 40 f0 29 24 29 f0 f0 28 25 28 f0     B..E|@.)$)..(%(.
     3fc:	7c 54 55 45 00 20 54 54 7c 54 7c 0a 09 7f 49 32     |TUE. TT|T|...I2
     40c:	49 49 49 32 32 48 48 48 32 32 4a 48 48 30 3a 41     III22HHH22JHH0:A
     41c:	41 21 7a 3a 42 40 20 78 00 9d a0 a0 7d 39 44 44     A!z:B@ x....}9DD
     42c:	44 39 3d 40 40 40 3d 3c 24 ff 24 24 48 7e 49 43     D9=@@@=<$.$$H~IC
     43c:	66 2b 2f fc 2f 2b ff 09 29 f6 20 c0 88 7e 09 03     f+/./+..). ..~..
     44c:	20 54 54 79 41 00 00 44 7d 41 30 48 48 4a 32 38      TTyA..D}A0HHJ28
     45c:	40 40 22 7a 00 7a 0a 0a 72 7d 0d 19 31 7d 26 29     @@"z.z..r}..1}&)
     46c:	29 2f 28 26 29 29 29 26 30 48 4d 40 20 38 08 08     )/(&)))&0HM@ 8..
     47c:	08 08 08 08 08 08 38 2f 10 c8 ac ba 2f 10 28 34     ......8/..../.(4
     48c:	fa 00 00 7b 00 00 08 14 2a 14 22 22 14 2a 14 08     ...{....*."".*..
     49c:	aa 00 55 00 aa aa 55 aa 55 aa 00 00 00 ff 00 10     ..U...U.U.......
     4ac:	10 10 ff 00 14 14 14 ff 00 10 10 ff 00 ff 10 10     ................
     4bc:	f0 10 f0 14 14 14 fc 00 14 14 f7 00 ff 00 00 ff     ................
     4cc:	00 ff 14 14 f4 04 fc 14 14 17 10 1f 10 10 1f 10     ................
     4dc:	1f 14 14 14 1f 00 10 10 10 f0 00 00 00 00 1f 10     ................
     4ec:	10 10 10 1f 10 10 10 10 f0 10 00 00 00 ff 10 10     ................
     4fc:	10 10 10 10 10 10 10 ff 10 00 00 00 ff 14 00 00     ................
     50c:	ff 00 ff 00 00 1f 10 17 00 00 fc 04 f4 14 14 17     ................
     51c:	10 17 14 14 f4 04 f4 00 00 ff 00 f7 14 14 14 14     ................
     52c:	14 14 14 f7 00 f7 14 14 14 17 14 10 10 1f 10 1f     ................
     53c:	14 14 14 f4 14 10 10 f0 10 f0 00 00 1f 10 1f 00     ................
     54c:	00 00 1f 14 00 00 00 fc 14 00 00 f0 10 f0 10 10     ................
     55c:	ff 10 ff 14 14 14 ff 14 10 10 10 1f 00 00 00 00     ................
     56c:	f0 10 ff ff ff ff ff f0 f0 f0 f0 f0 ff ff ff 00     ................
     57c:	00 00 00 00 ff ff 0f 0f 0f 0f 0f 38 44 44 38 44     ...........8DD8D
     58c:	7c 2a 2a 3e 14 7e 02 02 06 06 02 7e 02 7e 02 63     |**>.~.....~.~.c
     59c:	55 49 41 63 38 44 44 3c 04 40 7e 20 1e 20 06 02     UIAc8DD<.@~ . ..
     5ac:	7e 02 02 99 a5 e7 a5 99 1c 2a 49 2a 1c 4c 72 01     ~........*I*.Lr.
     5bc:	72 4c 30 4a 4d 4d 30 30 48 78 48 30 bc 62 5a 46     rL0JMM00HxH0.bZF
     5cc:	3d 3e 49 49 49 00 7e 01 01 01 7e 2a 2a 2a 2a 2a     =>III.~...~*****
     5dc:	44 44 5f 44 44 40 51 4a 44 40 40 44 4a 51 40 00     DD_DD@QJD@@DJQ@.
     5ec:	00 ff 01 03 e0 80 ff 00 00 08 08 6b 6b 08 36 12     ...........kk.6.
     5fc:	36 24 36 06 0f 09 0f 06 00 00 18 18 00 00 00 10     6$6.............
     60c:	10 00 30 40 ff 01 01 00 1f 01 01 1e 00 19 1d 17     ..0@............
     61c:	12 00 3c 3c 3c 3c 00 00 00 00 00                    ..<<<<.....

00000627 <__c.4366>:
     627:	25 32 75 3a 25 30 32 75 3a 25 30 32 75 20 41 4d     %2u:%02u:%02u AM
	...

00000638 <__c.4364>:
     638:	25 32 75 3a 25 30 32 75 3a 25 30 32 75 20 50 4d     %2u:%02u:%02u PM
	...

00000649 <__c.4361>:
     649:	25 32 75 3a 25 30 32 75 3a 25 30 32 75 20 41 4d     %2u:%02u:%02u AM
	...

0000065a <__c.4359>:
     65a:	25 32 75 3a 25 30 32 75 3a 25 30 32 75 20 50 4d     %2u:%02u:%02u PM
	...

0000066b <__c.4221>:
     66b:	25 33 6c 64 00                                      %3ld.

00000670 <__c.4219>:
     670:	20 00                                                .

00000672 <__c.4214>:
     672:	20 00                                                .

00000674 <__c.4212>:
     674:	25 63 00                                            %c.

00000677 <__c.4210>:
     677:	25 33 64 00                                         %3d.

0000067b <__c.4208>:
     67b:	32 00                                               2.

0000067d <__c.4206>:
     67d:	25 25 4f 00                                         %%O.

00000681 <__c.4204>:
     681:	2d 2d 2d 00                                         ---.

00000685 <__c.4202>:
     685:	42 50 4d 00                                         BPM.

00000689 <__c.4200>:
     689:	25 73 00                                            %s.

0000068c <__c.4198>:
     68c:	25 30 31 30 6c 75 2c 25 31 31 6c 64 2c 25 31 31     %010lu,%11ld,%11
     69c:	6c 64 2c 25 31 31 6c 64 2c 25 31 75 2c 25 33 6c     ld,%11ld,%1u,%3l
     6ac:	64 0d 0a 00                                         d...

000006b0 <__c.4195>:
     6b0:	66 5f 77 72 69 74 65 31 3a 20 25 64 20 28 30 20     f_write1: %d (0 
     6c0:	3d 20 4f 4b 29 20 0d 0a 00                          = OK) ...

000006c9 <__c.4193>:
     6c9:	66 5f 6c 73 65 65 6b 3a 20 25 64 20 28 30 20 3d     f_lseek: %d (0 =
     6d9:	20 4f 4b 29 20 0d 0a 00                              OK) ...

000006e1 <__c.4191>:
     6e1:	66 5f 6f 70 65 6e 3a 20 25 64 20 28 30 20 3d 20     f_open: %d (0 = 
     6f1:	4f 4b 29 20 0d 0a 00                                OK) ...

000006f8 <__c.4189>:
     6f8:	66 5f 6d 6f 75 6e 74 3a 20 25 64 20 28 30 20 3d     f_mount: %d (0 =
     708:	20 4f 4b 29 20 0d 0a 00                              OK) ...

00000710 <__c.4187>:
     710:	44 69 73 6b 20 49 6e 69 74 3a 20 25 64 20 28 30     Disk Init: %d (0
     720:	20 3d 20 4f 4b 29 20 0d 0a 00                        = OK) ...

0000072a <__c.4185>:
     72a:	4d 41 58 33 30 31 30 35 20 73 65 74 20 75 70 20     MAX30105 set up 
     73a:	2e 2e 20 6c 65 74 73 20 67 6f 2e 20 0d 0a 00        .. lets go. ...

00000749 <__c.4183>:
     749:	4d 41 58 33 30 31 30 35 20 77 61 73 20 6e 6f 74     MAX30105 was not
     759:	20 66 6f 75 6e 64 2e 20 50 6c 65 61 73 65 20 63      found. Please c
     769:	68 65 63 6b 20 77 69 72 69 6e 67 2f 70 6f 77 65     heck wiring/powe
     779:	72 2e 20 0d 0a 00                                   r. ...

0000077f <__c.4113>:
     77f:	48 65 61 64 69 6e 67 3a 20 25 37 2e 31 66 20 0d     Heading: %7.1f .
     78f:	0a 00                                               ..

00000791 <__c.4111>:
     791:	6d 69 6e 3a 20 25 37 2e 31 66 20 25 37 2e 31 66     min: %7.1f %7.1f
     7a1:	20 25 37 2e 31 66 20 6d 61 78 3a 20 25 37 2e 31      %7.1f max: %7.1
     7b1:	66 20 25 37 2e 31 66 20 25 37 2e 31 66 20 0d 0a     f %7.1f %7.1f ..
	...

000007c2 <__c.4109>:
     7c2:	4d 61 67 6e 65 74 6f 6d 65 74 65 72 20 6d 67 61     Magnetometer mga
     7d2:	75 73 73 20 78 3a 25 37 2e 31 66 20 79 3a 25 37     uss x:%7.1f y:%7
     7e2:	2e 31 66 20 7a 3a 25 37 2e 31 66 20 0d 0a 00        .1f z:%7.1f ...

000007f1 <__c.4107>:
     7f1:	41 63 63 65 6c 65 72 61 74 69 6f 6e 20 67 27 73     Acceleration g's
     801:	20 78 3a 25 37 2e 31 66 20 79 3a 25 37 2e 31 66      x:%7.1f y:%7.1f
     811:	20 7a 3a 25 37 2e 31 66 20 0d 0a 00                  z:%7.1f ...

0000081d <__c.4105>:
     81d:	78 3a 20 25 2d 37 2e 33 66 6d 20 79 3a 20 25 2d     x: %-7.3fm y: %-
     82d:	37 2e 33 66 20 50 61 20 7a 3a 20 25 2d 37 2e 33     7.3f Pa z: %-7.3
     83d:	66 0d 0a 00                                         f...

00000841 <__c.4103>:
     841:	41 3a 20 25 2d 37 2e 33 66 6d 20 50 3a 20 25 2d     A: %-7.3fm P: %-
     851:	37 2e 33 66 20 50 61 20 54 3a 20 25 2d 37 2e 33     7.3f Pa T: %-7.3
     861:	66 20 43 20 0d 0a 00                                f C ...

00000868 <__c.4101>:
     868:	0d 0a 00                                            ...

0000086b <__c.4089>:
     86b:	0d 0a 00                                            ...

0000086e <__c.4087>:
     86e:	44 53 33 32 33 31 20 69 6e 69 74 20 73 75 63 63     DS3231 init succ
     87e:	65 73 73 66 75 6c 0d 0a 00                          essful...

00000887 <__c.4085>:
     887:	69 32 63 20 69 6e 69 74 20 73 75 63 63 65 73 73     i2c init success
     897:	66 75 6c 0d 0a 00                                   ful...

0000089d <__c.4056>:
     89d:	4c 43 44 20 53 45 4d 3a 25 32 64 00                 LCD SEM:%2d.

000008a9 <__c.4054>:
     8a9:	63 6f 75 6e 74 3a 25 75 00                          count:%u.

000008b2 <__c.4040>:
     8b2:	0d 0a 00                                            ...

000008b5 <__c.4035>:
     8b5:	25 33 75 00                                         %3u.

000008b9 <__c.4033>:
     8b9:	0d 0a 00                                            ...

000008bc <__c.4028>:
     8bc:	20 2d 2d 00                                          --.

000008c0 <__c.4026>:
     8c0:	0d 0a 00                                            ...

000008c3 <__c.4021>:
     8c3:	25 33 75 00                                         %3u.

000008c7 <__c.4019>:
     8c7:	54 48 52 45 41 44 20 53 54 41 54 55 53 0d 0a 00     THREAD STATUS...

000008d7 <__c.4003>:
     8d7:	0d 0a 20 4e 49 4c 52 54 4f 53 20 31 2e 31 20 0d     .. NILRTOS 1.1 .
     8e7:	0a 00                                               ..

000008e9 <__c.3942>:
     8e9:	54 65 6d 70 3a 20 25 2d 33 2e 31 66 20 43 0d 0a     Temp: %-3.1f C..
	...

000008fa <__c.3940>:
     8fa:	25 30 32 75 3a 25 30 32 75 3a 25 30 32 75 0d 0a     %02u:%02u:%02u..
	...

0000090b <__c.3938>:
     90b:	41 4d 0d 0a 00                                      AM...

00000910 <__c.3936>:
     910:	25 32 75 3a 25 30 32 75 3a 25 30 32 75 0d 0a 00     %2u:%02u:%02u...

00000920 <__c.3934>:
     920:	50 4d 0d 0a 00                                      PM...

00000925 <__c.3932>:
     925:	25 32 75 3a 25 30 32 75 3a 25 30 32 75 0d 0a 00     %2u:%02u:%02u...

00000935 <__c.3930>:
     935:	25 32 75 2f 25 30 32 75 2f 25 30 32 75 0d 0a 00     %2u/%02u/%02u...

00000945 <__c.3928>:
     945:	25 73 00                                            %s.

00000948 <__c.3925>:
     948:	5e 20 4e 6f 72 74 68 20 25 33 2e 30 66 20 64 65     ^ North %3.0f de
     958:	67 72 65 65 73 20 45 61 73 74 20 5e 0d 0a 00        grees East ^...

00000967 <__c.3923>:
     967:	0d 0a 00                                            ...

0000096a <__c.3921>:
     96a:	20 20 20 20 20 20 20 20 20 20 20 7a 3a 20 25 2d                z: %-
     97a:	36 2e 31 66 0d 0a 00                                6.1f...

00000981 <__c.3919>:
     981:	5b 6d 67 61 75 73 73 5d 20 20 20 79 3a 20 25 2d     [mgauss]   y: %-
     991:	36 2e 31 66 0d 0a 00                                6.1f...

00000998 <__c.3917>:
     998:	4d 61 67 20 46 69 65 6c 64 20 20 78 3a 20 25 2d     Mag Field  x: %-
     9a8:	36 2e 31 66 0d 0a 00                                6.1f...

000009af <__c.3915>:
     9af:	0d 0a 00                                            ...

000009b2 <__c.3913>:
     9b2:	20 20 20 20 20 20 20 20 20 20 20 7a 3a 20 25 2d                z: %-
     9c2:	34 2e 31 66 0d 0a 00                                4.1f...

000009c9 <__c.3911>:
     9c9:	5b 67 27 73 5d 20 20 20 20 20 20 79 3a 20 25 2d     [g's]      y: %-
     9d9:	34 2e 31 66 0d 0a 00                                4.1f...

000009e0 <__c.3909>:
     9e0:	41 63 63 65 6c 27 6e 20 20 20 20 78 3a 20 25 2d     Accel'n    x: %-
     9f0:	34 2e 31 66 0d 0a 00                                4.1f...

000009f7 <__c.3907>:
     9f7:	0d 0a 00                                            ...

000009fa <__c.3905>:
     9fa:	20 20 20 20 20 20 20 20 20 20 20 7a 3a 20 25 2d                z: %-
     a0a:	37 2e 30 66 0d 0a 00                                7.0f...

00000a11 <__c.3903>:
     a11:	5b 6d 64 65 67 2f 73 5d 20 20 20 79 3a 20 25 2d     [mdeg/s]   y: %-
     a21:	37 2e 30 66 0d 0a 00                                7.0f...

00000a28 <__c.3901>:
     a28:	52 6f 74 61 74 69 6f 6e 20 20 20 78 3a 20 25 2d     Rotation   x: %-
     a38:	37 2e 30 66 0d 0a 00                                7.0f...

00000a3f <__c.3897>:
     a3f:	46 69 72 6d 77 61 72 65 20 56 65 72 73 69 6f 6e     Firmware Version
     a4f:	3a 20 30 2e 31 32 0d 0a 00                          : 0.12...

00000a58 <__c.3895>:
     a58:	20 42 61 74 74 65 72 79 20 56 6f 6c 74 61 67 65      Battery Voltage
     a68:	3a 20 25 75 2e 25 75 25 75 0d 0a 00                 : %u.%u%u...

00000a74 <__c.3893>:
     a74:	20 20 20 44 53 33 32 33 31 20 73 74 61 74 75 73        DS3231 status
     a84:	3a 20 30 78 25 30 32 58 0d 0a 00                    : 0x%02X...

00000a8f <__c.3891>:
     a8f:	54 65 6d 70 65 72 61 74 75 72 65 3a 20 25 2d 34     Temperature: %-4
     a9f:	2e 31 66 20 43 0d 0a 00                             .1f C...

00000aa7 <__c.3889>:
     aa7:	20 20 20 50 72 65 73 73 75 72 65 3a 20 25 2d 37        Pressure: %-7
     ab7:	2e 30 66 50 61 0d 0a 00                             .0fPa...

00000abf <__c.3887>:
     abf:	20 20 20 41 6c 74 69 74 75 64 65 3a 20 25 2d 34        Altitude: %-4
     acf:	2e 30 66 6d 0d 0a 00                                .0fm...

00000ad6 <__c.3869>:
     ad6:	25 30 32 64 3a 25 30 32 64 20 0d 0a 00              %02d:%02d ...

00000ae3 <__c.3866>:
     ae3:	53 79 73 74 65 6d 20 74 69 6d 65 3a 00              System time:.

00000af0 <__c.3851>:
     af0:	63 61 6e 27 74 20 6f 70 65 6e 20 66 69 6c 65 00     can't open file.

00000b00 <__c.3684>:
     b00:	20 25 73 00                                          %s.

00000b04 <__c.3682>:
     b04:	3e 25 73 00                                         >%s.

00000b08 <__c.3680>:
     b08:	25 73 00                                            %s.

00000b0b <__c.3573>:
     b0b:	25 64 0d 0a 00                                      %d...

00000b10 <__c.3568>:
     b10:	25 33 64 20 00                                      %3d .

00000b15 <__c.3566>:
     b15:	55 6e 75 73 65 64 20 53 74 61 63 6b 3a 20 00        Unused Stack: .

00000b24 <__c.3554>:
     b24:	25 64 0d 0a 00                                      %d...

00000b29 <__c.3549>:
     b29:	25 33 64 20 00                                      %3d .

00000b2e <__c.3547>:
     b2e:	20 53 74 61 63 6b 20 53 69 7a 65 73 3a 20 00         Stack Sizes: .

00000b3d <__c.3477>:
     b3d:	49 6d 61 67 65 20 73 69 7a 65 3a 20 25 64 20 62     Image size: %d b
     b4d:	79 20 25 64 20 70 69 78 65 6c 73 20 0d 0a 00        y %d pixels ...

00000b5c <__c.3475>:
     b5c:	69 6e 76 61 6c 69 64 20 64 65 70 74 68 20 6f 72     invalid depth or
     b6c:	20 63 6f 6d 70 72 65 73 73 69 6f 6e 20 0d 0a 00      compression ...

00000b7c <__c.3473>:
     b7c:	42 69 74 20 44 65 70 74 68 3a 20 25 64 20 0d 0a     Bit Depth: %d ..
	...

00000b8d <__c.3471>:
     b8d:	70 6c 61 6e 65 73 20 6e 6f 74 20 31 20 0d 0a 00     planes not 1 ...

00000b9d <__c.3469>:
     b9d:	48 65 61 64 65 72 20 73 69 7a 65 3a 20 25 6c 64     Header size: %ld
     bad:	20 0d 0a 00                                          ...

00000bb1 <__c.3467>:
     bb1:	49 6d 61 67 65 20 4f 66 66 73 65 74 3a 20 25 6c     Image Offset: %l
     bc1:	64 20 0d 0a 00                                      d ...

00000bc6 <__c.3465>:
     bc6:	46 69 6c 65 20 73 69 7a 65 3a 20 25 6c 64 20 0d     File size: %ld .
     bd6:	0a 00                                               ..

00000bd8 <__c.3463>:
     bd8:	69 6e 76 61 6c 69 64 20 62 6d 70 20 0d 0a 00        invalid bmp ...

00000be7 <__c.3461>:
     be7:	46 69 6c 65 20 6f 70 65 6e 20 65 72 72 6f 72 20     File open error 
     bf7:	0d 0a 00                                            ...

00000bfa <__c.3459>:
     bfa:	4c 6f 61 64 69 6e 67 20 69 6d 61 67 65 20 0d 0a     Loading image ..
	...

00000c0b <__c.3457>:
     c0b:	62 61 64 20 70 6f 73 69 74 69 6f 6e 20 0d 0a 00     bad position ...

00000c1b <__c.3340>:
     c1b:	54 69 6d 65 3a 20 25 30 32 75 3a 25 30 32 75 3a     Time: %02u:%02u:
     c2b:	25 30 32 75 20 0d 0a 00                             %02u ...

00000c33 <__c.3336>:
     c33:	54 69 6d 65 3a 20 25 30 32 75 3a 25 30 32 75 3a     Time: %02u:%02u:
     c43:	25 30 32 75 20 41 4d 20 0d 0a 00                    %02u AM ...

00000c4e <__c.3332>:
     c4e:	54 69 6d 65 3a 20 25 30 32 75 3a 25 30 32 75 3a     Time: %02u:%02u:
     c5e:	25 30 32 75 20 50 4d 20 0d 0a 00                    %02u PM ...

00000c69 <__c.3328>:
     c69:	44 53 33 32 33 31 5f 54 65 6d 70 3a 20 25 32 2e     DS3231_Temp: %2.
     c79:	32 67 27 43 20 0d 0a 00                             2g'C ...

00000c81 <__c.3326>:
     c81:	44 61 74 65 3a 20 25 30 32 75 2f 25 30 32 75 2f     Date: %02u/%02u/
     c91:	25 30 32 75 20 0d 0a 00                             %02u ...

00000c99 <__c.1790>:
     c99:	6e 61 6e 00                                         nan.

00000c9d <__c.1788>:
     c9d:	69 6e 66 00                                         inf.

00000ca1 <__c.2085>:
     ca1:	63 64 69 6e 6f 70 73 75 78 58 5b 65 66 67 45 46     cdinopsuxX[efgEF
     cb1:	47 00                                               G.

00000cb3 <pstr_an>:
     cb3:	61 6e 00                                            an.

00000cb6 <pstr_nfinity>:
     cb6:	6e 66 69 6e 69 74 79 00                             nfinity.

00000cbe <pwr_m10>:
     cbe:	cd cc cc 3d 0a d7 23 3c 17 b7 d1 38 77 cc 2b 32     ...=..#<...8w.+2
     cce:	95 95 e6 24 1f b1 4f 0a                             ...$..O.

00000cd6 <pwr_p10>:
     cd6:	00 00 20 41 00 00 c8 42 00 40 1c 46 20 bc be 4c     .. A...B.@.F ..L
     ce6:	ca 1b 0e 5a ae c5 9d 74 00 40 7a 10 f3 5a 00 a0     ...Z...t.@z..Z..
     cf6:	72 4e 18 09 00 10 a5 d4 e8 00 00 e8 76 48 17 00     rN..........vH..
     d06:	00 e4 0b 54 02 00 00 ca 9a 3b 00 00 00 e1 f5 05     ...T.....;......
     d16:	00 00 80 96 98 00 00 00 40 42 0f 00 00 00 a0 86     ........@B......
     d26:	01 00 00 00 10 27 00 00 00 00 e8 03 00 00 00 00     .....'..........
     d36:	64 00 00 00 00 00 0a 00 00 00 00 00 01 00 00 00     d...............
     d46:	00 00 2c 76 d8 88 dc 67 4f 08 23 df c1 df ae 59     ..,v...gO.#....Y
     d56:	e1 b1 b7 96 e5 e3 e4 53 c6 3a e6 51 99 76 96 e8     .......S.:.Q.v..
     d66:	e6 c2 84 26 eb 89 8c 9b 62 ed 40 7c 6f fc ef bc     ...&....b.@|o...
     d76:	9c 9f 40 f2 ba a5 6f a5 f4 90 05 5a 2a f7 5c 93     ..@...o....Z*.\.
     d86:	6b 6c f9 67 6d c1 1b fc e0 e4 0d 47 fe f5 20 e6     kl.gm......G.. .
     d96:	b5 00 d0 ed 90 2e 03 00 94 35 77 05 00 80 84 1e     .........5w.....
     da6:	08 00 00 20 4e 0a 00 00 00 c8 0c 33 33 33 33 0f     ... N......3333.
     db6:	98 6e 12 83 11 41 ef 8d 21 14 89 3b e6 55 16 cf     .n...A..!..;.U..
     dc6:	fe e6 db 18 d1 84 4b 38 1b f7 7c 1d 90 1d a4 bb     ......K8..|.....
     dd6:	e4 24 20 32 84 72 5e 22 81 00 c9 f1 24 ec a1 e5     .$ 2.r^"....$...
     de6:	3d 27                                               ='

00000de8 <__ctors_end>:
     de8:	11 24       	eor	r1, r1
     dea:	1f be       	out	0x3f, r1	; 63
     dec:	cf ef       	ldi	r28, 0xFF	; 255
     dee:	d0 e4       	ldi	r29, 0x40	; 64
     df0:	de bf       	out	0x3e, r29	; 62
     df2:	cd bf       	out	0x3d, r28	; 61

00000df4 <__do_copy_data>:
     df4:	16 e0       	ldi	r17, 0x06	; 6
     df6:	a0 e0       	ldi	r26, 0x00	; 0
     df8:	b1 e0       	ldi	r27, 0x01	; 1
     dfa:	e2 ec       	ldi	r30, 0xC2	; 194
     dfc:	f6 e0       	ldi	r31, 0x06	; 6
     dfe:	01 e0       	ldi	r16, 0x01	; 1
     e00:	0b bf       	out	0x3b, r16	; 59
     e02:	02 c0       	rjmp	.+4      	; 0xe08 <__do_copy_data+0x14>
     e04:	07 90       	elpm	r0, Z+
     e06:	0d 92       	st	X+, r0
     e08:	aa 3f       	cpi	r26, 0xFA	; 250
     e0a:	b1 07       	cpc	r27, r17
     e0c:	d9 f7       	brne	.-10     	; 0xe04 <__do_copy_data+0x10>

00000e0e <__do_clear_bss>:
     e0e:	12 e3       	ldi	r17, 0x32	; 50
     e10:	aa ef       	ldi	r26, 0xFA	; 250
     e12:	b6 e0       	ldi	r27, 0x06	; 6
     e14:	01 c0       	rjmp	.+2      	; 0xe18 <.do_clear_bss_start>

00000e16 <.do_clear_bss_loop>:
     e16:	1d 92       	st	X+, r1

00000e18 <.do_clear_bss_start>:
     e18:	a5 3b       	cpi	r26, 0xB5	; 181
     e1a:	b1 07       	cpc	r27, r17
     e1c:	e1 f7       	brne	.-8      	; 0xe16 <.do_clear_bss_loop>
     e1e:	0e 94 f8 4e 	call	0x9df0	; 0x9df0 <main>
     e22:	0c 94 5f 83 	jmp	0x106be	; 0x106be <_exit>

00000e26 <__bad_interrupt>:
     e26:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000e2a <_port_switch>:
#if !defined(__DOXYGEN__)
__attribute__((naked, weak))
#endif
void _port_switch(thread_t *ntp, thread_t *otp) {

  asm volatile ("push    r2");
     e2a:	2f 92       	push	r2
  asm volatile ("push    r3");
     e2c:	3f 92       	push	r3
  asm volatile ("push    r4");
     e2e:	4f 92       	push	r4
  asm volatile ("push    r5");
     e30:	5f 92       	push	r5
  asm volatile ("push    r6");
     e32:	6f 92       	push	r6
  asm volatile ("push    r7");
     e34:	7f 92       	push	r7
  asm volatile ("push    r8");
     e36:	8f 92       	push	r8
  asm volatile ("push    r9");
     e38:	9f 92       	push	r9
  asm volatile ("push    r10");
     e3a:	af 92       	push	r10
  asm volatile ("push    r11");
     e3c:	bf 92       	push	r11
  asm volatile ("push    r12");
     e3e:	cf 92       	push	r12
  asm volatile ("push    r13");
     e40:	df 92       	push	r13
  asm volatile ("push    r14");
     e42:	ef 92       	push	r14
  asm volatile ("push    r15");
     e44:	ff 92       	push	r15
  asm volatile ("push    r16");
     e46:	0f 93       	push	r16
  asm volatile ("push    r17");
     e48:	1f 93       	push	r17
  asm volatile ("push    r28");
     e4a:	cf 93       	push	r28
  asm volatile ("push    r29");
     e4c:	df 93       	push	r29

  asm volatile ("movw    r30, r22");
     e4e:	fb 01       	movw	r30, r22
  asm volatile ("in      r0, 0x3d");
     e50:	0d b6       	in	r0, 0x3d	; 61
  asm volatile ("std     Z+0, r0");
     e52:	00 82       	st	Z, r0
  asm volatile ("in      r0, 0x3e");
     e54:	0e b6       	in	r0, 0x3e	; 62
  asm volatile ("std     Z+1, r0");
     e56:	01 82       	std	Z+1, r0	; 0x01

  asm volatile ("movw    r30, r24");
     e58:	fc 01       	movw	r30, r24
  asm volatile ("ldd     r0, Z+0");
     e5a:	00 80       	ld	r0, Z
  asm volatile ("out     0x3d, r0");
     e5c:	0d be       	out	0x3d, r0	; 61
  asm volatile ("ldd     r0, Z+1");
     e5e:	01 80       	ldd	r0, Z+1	; 0x01
  asm volatile ("out     0x3e, r0");
     e60:	0e be       	out	0x3e, r0	; 62

  asm volatile ("pop     r29");
     e62:	df 91       	pop	r29
  asm volatile ("pop     r28");
     e64:	cf 91       	pop	r28
  asm volatile ("pop     r17");
     e66:	1f 91       	pop	r17
  asm volatile ("pop     r16");
     e68:	0f 91       	pop	r16
  asm volatile ("pop     r15");
     e6a:	ff 90       	pop	r15
  asm volatile ("pop     r14");
     e6c:	ef 90       	pop	r14
  asm volatile ("pop     r13");
     e6e:	df 90       	pop	r13
  asm volatile ("pop     r12");
     e70:	cf 90       	pop	r12
  asm volatile ("pop     r11");
     e72:	bf 90       	pop	r11
  asm volatile ("pop     r10");
     e74:	af 90       	pop	r10
  asm volatile ("pop     r9");
     e76:	9f 90       	pop	r9
  asm volatile ("pop     r8");
     e78:	8f 90       	pop	r8
  asm volatile ("pop     r7");
     e7a:	7f 90       	pop	r7
  asm volatile ("pop     r6");
     e7c:	6f 90       	pop	r6
  asm volatile ("pop     r5");
     e7e:	5f 90       	pop	r5
  asm volatile ("pop     r4");
     e80:	4f 90       	pop	r4
  asm volatile ("pop     r3");
     e82:	3f 90       	pop	r3
  asm volatile ("pop     r2");
     e84:	2f 90       	pop	r2
  asm volatile ("ret");
     e86:	08 95       	ret

00000e88 <_port_thread_start>:
     e88:	78 94       	sei
 *          invoked.
 */
void _port_thread_start(void) {

  chSysUnlock();
  asm volatile ("movw    r24, r4");
     e8a:	c2 01       	movw	r24, r4
  asm volatile ("movw    r30, r2");
     e8c:	f1 01       	movw	r30, r2
  asm volatile ("icall");
     e8e:	09 95       	icall
  chSysHalt(0);
     e90:	80 e0       	ldi	r24, 0x00	; 0
     e92:	90 e0       	ldi	r25, 0x00	; 0
     e94:	0e 94 4d 07 	call	0xe9a	; 0xe9a <chSysHalt>
}
     e98:	08 95       	ret

00000e9a <chSysHalt>:
     e9a:	f8 94       	cli
     e9c:	ff cf       	rjmp	.-2      	; 0xe9c <chSysHalt+0x2>

00000e9e <chSysTimerHandlerI>:
 * @note    This handler has to be invoked by a periodic ISR in order to
 *          reschedule the waiting threads.
 *
 * @iclass
 */
void chSysTimerHandlerI(void) {
     e9e:	cf 93       	push	r28
     ea0:	df 93       	push	r29

#if NIL_CFG_ST_TIMEDELTA == 0
  thread_t *tp = &nil.threads[0];
  nil.systime++;
     ea2:	80 91 d2 07 	lds	r24, 0x07D2
     ea6:	90 91 d3 07 	lds	r25, 0x07D3
     eaa:	a0 91 d4 07 	lds	r26, 0x07D4
     eae:	b0 91 d5 07 	lds	r27, 0x07D5
     eb2:	01 96       	adiw	r24, 0x01	; 1
     eb4:	a1 1d       	adc	r26, r1
     eb6:	b1 1d       	adc	r27, r1
     eb8:	80 93 d2 07 	sts	0x07D2, r24
     ebc:	90 93 d3 07 	sts	0x07D3, r25
     ec0:	a0 93 d4 07 	sts	0x07D4, r26
     ec4:	b0 93 d5 07 	sts	0x07D5, r27
     ec8:	c6 ed       	ldi	r28, 0xD6	; 214
     eca:	d7 e0       	ldi	r29, 0x07	; 7
              (tp < &nil.threads[NIL_CFG_NUM_THREADS]),
              "pointer out of range");
  chDbgAssert(!NIL_THD_IS_READY(tp), "already ready");
  chDbgAssert(nil.next <= nil.current, "priority ordering");

  tp->u1.msg = msg;
     ecc:	2f ef       	ldi	r18, 0xFF	; 255
     ece:	3f ef       	ldi	r19, 0xFF	; 255
     ed0:	19 c0       	rjmp	.+50     	; 0xf04 <chSysTimerHandlerI+0x66>
      if (--tp->timeout == 0) {
        /* Timeout on semaphores requires a special handling because the
           semaphore counter must be incremented.*/
        if (NIL_THD_IS_WTSEM(tp))
          tp->u1.semp->cnt++;
        else if (NIL_THD_IS_SUSP(tp))
     ed2:	82 30       	cpi	r24, 0x02	; 2
     ed4:	f1 f1       	breq	.+124    	; 0xf52 <chSysTimerHandlerI+0xb4>
              (tp < &nil.threads[NIL_CFG_NUM_THREADS]),
              "pointer out of range");
  chDbgAssert(!NIL_THD_IS_READY(tp), "already ready");
  chDbgAssert(nil.next <= nil.current, "priority ordering");

  tp->u1.msg = msg;
     ed6:	3c 83       	std	Y+4, r19	; 0x04
     ed8:	2b 83       	std	Y+3, r18	; 0x03
  tp->state = NIL_STATE_READY;
     eda:	1a 82       	std	Y+2, r1	; 0x02
  tp->timeout = 0;
     edc:	1d 82       	std	Y+5, r1	; 0x05
     ede:	1e 82       	std	Y+6, r1	; 0x06
     ee0:	1f 82       	std	Y+7, r1	; 0x07
     ee2:	18 86       	std	Y+8, r1	; 0x08
  if (tp < nil.next)
     ee4:	80 91 d0 07 	lds	r24, 0x07D0
     ee8:	90 91 d1 07 	lds	r25, 0x07D1
     eec:	c8 17       	cp	r28, r24
     eee:	d9 07       	cpc	r29, r25
     ef0:	20 f4       	brcc	.+8      	; 0xefa <chSysTimerHandlerI+0x5c>
    nil.next = tp;
     ef2:	d0 93 d1 07 	sts	0x07D1, r29
     ef6:	c0 93 d0 07 	sts	0x07D0, r28
      }
    }
    /* Lock released in order to give a preemption chance on those
       architectures supporting IRQ preemption.*/
    chSysUnlockFromISR();
    tp++;
     efa:	2a 96       	adiw	r28, 0x0a	; 10
    chSysLockFromISR();
  } while (tp < &nil.threads[NIL_CFG_NUM_THREADS]);
     efc:	88 e0       	ldi	r24, 0x08	; 8
     efe:	c6 37       	cpi	r28, 0x76	; 118
     f00:	d8 07       	cpc	r29, r24
     f02:	21 f1       	breq	.+72     	; 0xf4c <chSysTimerHandlerI+0xae>
#if NIL_CFG_ST_TIMEDELTA == 0
  thread_t *tp = &nil.threads[0];
  nil.systime++;
  do {
    /* Is the thread in a wait state with timeout?.*/
    if (tp->timeout > 0) {
     f04:	8d 81       	ldd	r24, Y+5	; 0x05
     f06:	9e 81       	ldd	r25, Y+6	; 0x06
     f08:	af 81       	ldd	r26, Y+7	; 0x07
     f0a:	b8 85       	ldd	r27, Y+8	; 0x08
     f0c:	00 97       	sbiw	r24, 0x00	; 0
     f0e:	a1 05       	cpc	r26, r1
     f10:	b1 05       	cpc	r27, r1
     f12:	99 f3       	breq	.-26     	; 0xefa <chSysTimerHandlerI+0x5c>

      chDbgAssert(!NIL_THD_IS_READY(tp), "is ready");

     /* Did the timer reach zero?*/
      if (--tp->timeout == 0) {
     f14:	8d 81       	ldd	r24, Y+5	; 0x05
     f16:	9e 81       	ldd	r25, Y+6	; 0x06
     f18:	af 81       	ldd	r26, Y+7	; 0x07
     f1a:	b8 85       	ldd	r27, Y+8	; 0x08
     f1c:	01 97       	sbiw	r24, 0x01	; 1
     f1e:	a1 09       	sbc	r26, r1
     f20:	b1 09       	sbc	r27, r1
     f22:	8d 83       	std	Y+5, r24	; 0x05
     f24:	9e 83       	std	Y+6, r25	; 0x06
     f26:	af 83       	std	Y+7, r26	; 0x07
     f28:	b8 87       	std	Y+8, r27	; 0x08
     f2a:	8d 81       	ldd	r24, Y+5	; 0x05
     f2c:	9e 81       	ldd	r25, Y+6	; 0x06
     f2e:	af 81       	ldd	r26, Y+7	; 0x07
     f30:	b8 85       	ldd	r27, Y+8	; 0x08
     f32:	00 97       	sbiw	r24, 0x00	; 0
     f34:	a1 05       	cpc	r26, r1
     f36:	b1 05       	cpc	r27, r1
     f38:	01 f7       	brne	.-64     	; 0xefa <chSysTimerHandlerI+0x5c>
        /* Timeout on semaphores requires a special handling because the
           semaphore counter must be incremented.*/
        if (NIL_THD_IS_WTSEM(tp))
     f3a:	8a 81       	ldd	r24, Y+2	; 0x02
     f3c:	83 30       	cpi	r24, 0x03	; 3
     f3e:	49 f6       	brne	.-110    	; 0xed2 <chSysTimerHandlerI+0x34>
          tp->u1.semp->cnt++;
     f40:	eb 81       	ldd	r30, Y+3	; 0x03
     f42:	fc 81       	ldd	r31, Y+4	; 0x04
     f44:	80 81       	ld	r24, Z
     f46:	8f 5f       	subi	r24, 0xFF	; 255
     f48:	80 83       	st	Z, r24
     f4a:	c5 cf       	rjmp	.-118    	; 0xed6 <chSysTimerHandlerI+0x38>
  else {
    /* No tick event needed.*/
    port_timer_stop_alarm();
  }
#endif
}
     f4c:	df 91       	pop	r29
     f4e:	cf 91       	pop	r28
     f50:	08 95       	ret
        /* Timeout on semaphores requires a special handling because the
           semaphore counter must be incremented.*/
        if (NIL_THD_IS_WTSEM(tp))
          tp->u1.semp->cnt++;
        else if (NIL_THD_IS_SUSP(tp))
          *tp->u1.trp = NULL;
     f52:	eb 81       	ldd	r30, Y+3	; 0x03
     f54:	fc 81       	ldd	r31, Y+4	; 0x04
     f56:	11 82       	std	Z+1, r1	; 0x01
     f58:	10 82       	st	Z, r1
     f5a:	bd cf       	rjmp	.-134    	; 0xed6 <chSysTimerHandlerI+0x38>

00000f5c <chSysConditionalLock>:
 */
void chSysConditionalLock(void) {

  if (port_irq_enabled(port_get_irq_status()))
    chSysLock();
}
     f5c:	08 95       	ret

00000f5e <chSysConditionalUnlock>:
     f5e:	78 94       	sei
 */
void chSysConditionalUnlock(void) {

  if (!port_irq_enabled(port_get_irq_status()))
    chSysUnlock();
}
     f60:	08 95       	ret

00000f62 <chSysGetStatusAndLockX>:
      chSysLockFromISR();
    else
      chSysLock();
  }
  return sts;
}
     f62:	80 e0       	ldi	r24, 0x00	; 0
     f64:	08 95       	ret

00000f66 <chSysRestoreStatusX>:
    else {
      chSchRescheduleS();
      chSysUnlock();
    }
  }
}
     f66:	08 95       	ret

00000f68 <chSchReadyI>:
 * @param[in] tp        pointer to the @p thread_t object
 * @param[in] msg       the wakeup message
 *
 * @return              The same reference passed as parameter.
 */
thread_t *chSchReadyI(thread_t *tp, msg_t msg) {
     f68:	fc 01       	movw	r30, r24
              (tp < &nil.threads[NIL_CFG_NUM_THREADS]),
              "pointer out of range");
  chDbgAssert(!NIL_THD_IS_READY(tp), "already ready");
  chDbgAssert(nil.next <= nil.current, "priority ordering");

  tp->u1.msg = msg;
     f6a:	74 83       	std	Z+4, r23	; 0x04
     f6c:	63 83       	std	Z+3, r22	; 0x03
  tp->state = NIL_STATE_READY;
     f6e:	12 82       	std	Z+2, r1	; 0x02
  tp->timeout = 0;
     f70:	15 82       	std	Z+5, r1	; 0x05
     f72:	16 82       	std	Z+6, r1	; 0x06
     f74:	17 82       	std	Z+7, r1	; 0x07
     f76:	10 86       	std	Z+8, r1	; 0x08
  if (tp < nil.next)
     f78:	80 91 d0 07 	lds	r24, 0x07D0
     f7c:	90 91 d1 07 	lds	r25, 0x07D1
     f80:	e8 17       	cp	r30, r24
     f82:	f9 07       	cpc	r31, r25
     f84:	20 f4       	brcc	.+8      	; 0xf8e <chSchReadyI+0x26>
    nil.next = tp;
     f86:	f0 93 d1 07 	sts	0x07D1, r31
     f8a:	e0 93 d0 07 	sts	0x07D0, r30
  return tp;
}
     f8e:	cf 01       	movw	r24, r30
     f90:	08 95       	ret

00000f92 <chThdResumeI>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdResumeI(thread_reference_t *trp, msg_t msg) {
     f92:	dc 01       	movw	r26, r24

  if (*trp != NULL) {
     f94:	ed 91       	ld	r30, X+
     f96:	fc 91       	ld	r31, X
     f98:	11 97       	sbiw	r26, 0x01	; 1
     f9a:	30 97       	sbiw	r30, 0x00	; 0
     f9c:	a1 f0       	breq	.+40     	; 0xfc6 <chThdResumeI+0x34>
    thread_reference_t tr = *trp;

    chDbgAssert(NIL_THD_IS_SUSP(tr), "not suspended");

    *trp = NULL;
     f9e:	1d 92       	st	X+, r1
     fa0:	1c 92       	st	X, r1
              (tp < &nil.threads[NIL_CFG_NUM_THREADS]),
              "pointer out of range");
  chDbgAssert(!NIL_THD_IS_READY(tp), "already ready");
  chDbgAssert(nil.next <= nil.current, "priority ordering");

  tp->u1.msg = msg;
     fa2:	74 83       	std	Z+4, r23	; 0x04
     fa4:	63 83       	std	Z+3, r22	; 0x03
  tp->state = NIL_STATE_READY;
     fa6:	12 82       	std	Z+2, r1	; 0x02
  tp->timeout = 0;
     fa8:	15 82       	std	Z+5, r1	; 0x05
     faa:	16 82       	std	Z+6, r1	; 0x06
     fac:	17 82       	std	Z+7, r1	; 0x07
     fae:	10 86       	std	Z+8, r1	; 0x08
  if (tp < nil.next)
     fb0:	80 91 d0 07 	lds	r24, 0x07D0
     fb4:	90 91 d1 07 	lds	r25, 0x07D1
     fb8:	e8 17       	cp	r30, r24
     fba:	f9 07       	cpc	r31, r25
     fbc:	20 f4       	brcc	.+8      	; 0xfc6 <chThdResumeI+0x34>
    nil.next = tp;
     fbe:	f0 93 d1 07 	sts	0x07D1, r31
     fc2:	e0 93 d0 07 	sts	0x07D0, r30
     fc6:	08 95       	ret

00000fc8 <chSemSignalI>:
 *
 * @param[in] sp    pointer to a @p semaphore_t structure
 *
 * @iclass
 */
void chSemSignalI(semaphore_t *sp) {
     fc8:	dc 01       	movw	r26, r24

  if (++sp->cnt <= 0) {
     fca:	8c 91       	ld	r24, X
     fcc:	8f 5f       	subi	r24, 0xFF	; 255
     fce:	8c 93       	st	X, r24
     fd0:	8c 91       	ld	r24, X
     fd2:	18 16       	cp	r1, r24
     fd4:	0c f4       	brge	.+2      	; 0xfd8 <chSemSignalI+0x10>
     fd6:	08 95       	ret
    thread_reference_t tr = nil.threads;
    while (true) {
      /* Is this thread waiting on this semaphore?*/
      if (tr->u1.semp == sp) {
     fd8:	80 91 d9 07 	lds	r24, 0x07D9
     fdc:	90 91 da 07 	lds	r25, 0x07DA
     fe0:	8a 17       	cp	r24, r26
     fe2:	9b 07       	cpc	r25, r27
     fe4:	d9 f0       	breq	.+54     	; 0x101c <chSemSignalI+0x54>

  tp->u1.msg = msg;
  tp->state = NIL_STATE_READY;
  tp->timeout = 0;
  if (tp < nil.next)
    nil.next = tp;
     fe6:	e6 ed       	ldi	r30, 0xD6	; 214
     fe8:	f7 e0       	ldi	r31, 0x07	; 7
        chDbgAssert(NIL_THD_IS_WTSEM(tr), "not waiting");

        chSchReadyI(tr, MSG_OK);
        return;
      }
      tr++;
     fea:	3a 96       	adiw	r30, 0x0a	; 10

  if (++sp->cnt <= 0) {
    thread_reference_t tr = nil.threads;
    while (true) {
      /* Is this thread waiting on this semaphore?*/
      if (tr->u1.semp == sp) {
     fec:	83 81       	ldd	r24, Z+3	; 0x03
     fee:	94 81       	ldd	r25, Z+4	; 0x04
     ff0:	8a 17       	cp	r24, r26
     ff2:	9b 07       	cpc	r25, r27
     ff4:	d1 f7       	brne	.-12     	; 0xfea <chSemSignalI+0x22>
              (tp < &nil.threads[NIL_CFG_NUM_THREADS]),
              "pointer out of range");
  chDbgAssert(!NIL_THD_IS_READY(tp), "already ready");
  chDbgAssert(nil.next <= nil.current, "priority ordering");

  tp->u1.msg = msg;
     ff6:	14 82       	std	Z+4, r1	; 0x04
     ff8:	13 82       	std	Z+3, r1	; 0x03
  tp->state = NIL_STATE_READY;
     ffa:	12 82       	std	Z+2, r1	; 0x02
  tp->timeout = 0;
     ffc:	15 82       	std	Z+5, r1	; 0x05
     ffe:	16 82       	std	Z+6, r1	; 0x06
    1000:	17 82       	std	Z+7, r1	; 0x07
    1002:	10 86       	std	Z+8, r1	; 0x08
  if (tp < nil.next)
    1004:	80 91 d0 07 	lds	r24, 0x07D0
    1008:	90 91 d1 07 	lds	r25, 0x07D1
    100c:	e8 17       	cp	r30, r24
    100e:	f9 07       	cpc	r31, r25
    1010:	10 f7       	brcc	.-60     	; 0xfd6 <chSemSignalI+0xe>
    nil.next = tp;
    1012:	f0 93 d1 07 	sts	0x07D1, r31
    1016:	e0 93 d0 07 	sts	0x07D0, r30
    101a:	08 95       	ret

  if (++sp->cnt <= 0) {
    thread_reference_t tr = nil.threads;
    while (true) {
      /* Is this thread waiting on this semaphore?*/
      if (tr->u1.semp == sp) {
    101c:	e6 ed       	ldi	r30, 0xD6	; 214
    101e:	f7 e0       	ldi	r31, 0x07	; 7
    1020:	ea cf       	rjmp	.-44     	; 0xff6 <chSemSignalI+0x2e>

00001022 <chSemResetI>:
 * @param[in] n         the new value of the semaphore counter. The value must
 *                      be non-negative.
 *
 * @iclass
 */
void chSemResetI(semaphore_t *sp, cnt_t n) {
    1022:	dc 01       	movw	r26, r24
  thread_t *tp;
  cnt_t cnt;

  cnt = sp->cnt;
    1024:	2c 91       	ld	r18, X
  sp->cnt = n;
    1026:	6c 93       	st	X, r22
  tp = nil.threads;
  while (cnt < 0) {
    1028:	27 ff       	sbrs	r18, 7
    102a:	23 c0       	rjmp	.+70     	; 0x1072 <chSemResetI+0x50>
    102c:	40 91 d0 07 	lds	r20, 0x07D0
    1030:	50 91 d1 07 	lds	r21, 0x07D1
    1034:	e6 ed       	ldi	r30, 0xD6	; 214
    1036:	f7 e0       	ldi	r31, 0x07	; 7
              (tp < &nil.threads[NIL_CFG_NUM_THREADS]),
              "pointer out of range");
  chDbgAssert(!NIL_THD_IS_READY(tp), "already ready");
  chDbgAssert(nil.next <= nil.current, "priority ordering");

  tp->u1.msg = msg;
    1038:	6e ef       	ldi	r22, 0xFE	; 254
    103a:	7f ef       	ldi	r23, 0xFF	; 255
    103c:	03 c0       	rjmp	.+6      	; 0x1044 <chSemResetI+0x22>
  cnt_t cnt;

  cnt = sp->cnt;
  sp->cnt = n;
  tp = nil.threads;
  while (cnt < 0) {
    103e:	27 ff       	sbrs	r18, 7
    1040:	14 c0       	rjmp	.+40     	; 0x106a <chSemResetI+0x48>
      chDbgAssert(NIL_THD_IS_WTSEM(tp), "not waiting");

      cnt++;
      chSchReadyI(tp, MSG_RESET);
    }
    tp++;
    1042:	3a 96       	adiw	r30, 0x0a	; 10
  cnt = sp->cnt;
  sp->cnt = n;
  tp = nil.threads;
  while (cnt < 0) {
    /* Is this thread waiting on this semaphore?*/
    if (tp->u1.semp == sp) {
    1044:	83 81       	ldd	r24, Z+3	; 0x03
    1046:	94 81       	ldd	r25, Z+4	; 0x04
    1048:	8a 17       	cp	r24, r26
    104a:	9b 07       	cpc	r25, r27
    104c:	c1 f7       	brne	.-16     	; 0x103e <chSemResetI+0x1c>

      chDbgAssert(NIL_THD_IS_WTSEM(tp), "not waiting");

      cnt++;
    104e:	2f 5f       	subi	r18, 0xFF	; 255
              (tp < &nil.threads[NIL_CFG_NUM_THREADS]),
              "pointer out of range");
  chDbgAssert(!NIL_THD_IS_READY(tp), "already ready");
  chDbgAssert(nil.next <= nil.current, "priority ordering");

  tp->u1.msg = msg;
    1050:	74 83       	std	Z+4, r23	; 0x04
    1052:	63 83       	std	Z+3, r22	; 0x03
  tp->state = NIL_STATE_READY;
    1054:	12 82       	std	Z+2, r1	; 0x02
  tp->timeout = 0;
    1056:	15 82       	std	Z+5, r1	; 0x05
    1058:	16 82       	std	Z+6, r1	; 0x06
    105a:	17 82       	std	Z+7, r1	; 0x07
    105c:	10 86       	std	Z+8, r1	; 0x08
  if (tp < nil.next)
    105e:	e4 17       	cp	r30, r20
    1060:	f5 07       	cpc	r31, r21
    1062:	68 f7       	brcc	.-38     	; 0x103e <chSemResetI+0x1c>
    1064:	af 01       	movw	r20, r30
  cnt_t cnt;

  cnt = sp->cnt;
  sp->cnt = n;
  tp = nil.threads;
  while (cnt < 0) {
    1066:	27 fd       	sbrc	r18, 7
    1068:	ec cf       	rjmp	.-40     	; 0x1042 <chSemResetI+0x20>
      chDbgAssert(NIL_THD_IS_WTSEM(tp), "not waiting");

      cnt++;
      chSchReadyI(tp, MSG_RESET);
    }
    tp++;
    106a:	50 93 d1 07 	sts	0x07D1, r21
    106e:	40 93 d0 07 	sts	0x07D0, r20
    1072:	08 95       	ret

00001074 <chEvtSignalI>:
 * @param[in] tp        the thread to be signaled
 * @param[in] mask      the event flags set to be ORed
 *
 * @iclass
 */
void chEvtSignalI(thread_t *tp, eventmask_t mask) {
    1074:	fc 01       	movw	r30, r24

  tp->epmask |= mask;
    1076:	81 85       	ldd	r24, Z+9	; 0x09
    1078:	68 2b       	or	r22, r24
    107a:	61 87       	std	Z+9, r22	; 0x09
  if (NIL_THD_IS_WTOREVT(tp) && ((tp->epmask & tp->u1.ewmask) != 0))
    107c:	82 81       	ldd	r24, Z+2	; 0x02
    107e:	84 30       	cpi	r24, 0x04	; 4
    1080:	09 f0       	breq	.+2      	; 0x1084 <chEvtSignalI+0x10>
    1082:	08 95       	ret
    1084:	83 81       	ldd	r24, Z+3	; 0x03
    1086:	68 23       	and	r22, r24
    1088:	e1 f3       	breq	.-8      	; 0x1082 <chEvtSignalI+0xe>
              (tp < &nil.threads[NIL_CFG_NUM_THREADS]),
              "pointer out of range");
  chDbgAssert(!NIL_THD_IS_READY(tp), "already ready");
  chDbgAssert(nil.next <= nil.current, "priority ordering");

  tp->u1.msg = msg;
    108a:	14 82       	std	Z+4, r1	; 0x04
    108c:	13 82       	std	Z+3, r1	; 0x03
  tp->state = NIL_STATE_READY;
    108e:	12 82       	std	Z+2, r1	; 0x02
  tp->timeout = 0;
    1090:	15 82       	std	Z+5, r1	; 0x05
    1092:	16 82       	std	Z+6, r1	; 0x06
    1094:	17 82       	std	Z+7, r1	; 0x07
    1096:	10 86       	std	Z+8, r1	; 0x08
  if (tp < nil.next)
    1098:	80 91 d0 07 	lds	r24, 0x07D0
    109c:	90 91 d1 07 	lds	r25, 0x07D1
    10a0:	e8 17       	cp	r30, r24
    10a2:	f9 07       	cpc	r31, r25
    10a4:	70 f7       	brcc	.-36     	; 0x1082 <chEvtSignalI+0xe>
    nil.next = tp;
    10a6:	f0 93 d1 07 	sts	0x07D1, r31
    10aa:	e0 93 d0 07 	sts	0x07D0, r30
    10ae:	08 95       	ret

000010b0 <chSchGoSleepTimeoutS>:
 * @retval NIL_MSG_TMO  if a timeout occurred.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t timeout) {
  thread_t *ntp, *otp = nil.current;
    10b0:	a0 91 ce 07 	lds	r26, 0x07CE
    10b4:	b0 91 cf 07 	lds	r27, 0x07CF

  chDbgAssert(otp != &nil.threads[NIL_CFG_NUM_THREADS],
               "idle cannot sleep");

  /* Storing the wait object for the current thread.*/
  otp->state = newstate;
    10b8:	12 96       	adiw	r26, 0x02	; 2
    10ba:	8c 93       	st	X, r24
    10bc:	12 97       	sbiw	r26, 0x02	; 2
    otp->timeout = abstime - nil.lasttime;
  }
#else

  /* Timeout settings.*/
  otp->timeout = timeout;
    10be:	15 96       	adiw	r26, 0x05	; 5
    10c0:	4d 93       	st	X+, r20
    10c2:	5d 93       	st	X+, r21
    10c4:	6d 93       	st	X+, r22
    10c6:	7c 93       	st	X, r23
    10c8:	18 97       	sbiw	r26, 0x08	; 8

  /* Scanning the whole threads array.*/
  ntp = nil.threads;
  while (true) {
    /* Is this thread ready to execute?*/
    if (NIL_THD_IS_READY(ntp)) {
    10ca:	80 91 d8 07 	lds	r24, 0x07D8
    10ce:	88 23       	and	r24, r24
    10d0:	c9 f0       	breq	.+50     	; 0x1104 <chSchGoSleepTimeoutS+0x54>
      nil.current = nil.next = ntp;
      if (ntp == &nil.threads[NIL_CFG_NUM_THREADS]) {
        NIL_CFG_IDLE_ENTER_HOOK();
      }
      port_switch(ntp, otp);
    10d2:	e6 ed       	ldi	r30, 0xD6	; 214
    10d4:	f7 e0       	ldi	r31, 0x07	; 7
      return nil.current->u1.msg;
    }

    /* Points to the next thread in lowering priority order.*/
    ntp++;
    10d6:	3a 96       	adiw	r30, 0x0a	; 10

  /* Scanning the whole threads array.*/
  ntp = nil.threads;
  while (true) {
    /* Is this thread ready to execute?*/
    if (NIL_THD_IS_READY(ntp)) {
    10d8:	82 81       	ldd	r24, Z+2	; 0x02
    10da:	88 23       	and	r24, r24
    10dc:	e1 f7       	brne	.-8      	; 0x10d6 <chSchGoSleepTimeoutS+0x26>
      nil.current = nil.next = ntp;
    10de:	f0 93 d1 07 	sts	0x07D1, r31
    10e2:	e0 93 d0 07 	sts	0x07D0, r30
    10e6:	f0 93 cf 07 	sts	0x07CF, r31
    10ea:	e0 93 ce 07 	sts	0x07CE, r30
      if (ntp == &nil.threads[NIL_CFG_NUM_THREADS]) {
        NIL_CFG_IDLE_ENTER_HOOK();
      }
      port_switch(ntp, otp);
    10ee:	cf 01       	movw	r24, r30
    10f0:	bd 01       	movw	r22, r26
    10f2:	0e 94 15 07 	call	0xe2a	; 0xe2a <_port_switch>
    10f6:	e0 91 ce 07 	lds	r30, 0x07CE
    10fa:	f0 91 cf 07 	lds	r31, 0x07CF
    /* Points to the next thread in lowering priority order.*/
    ntp++;
    chDbgAssert(ntp <= &nil.threads[NIL_CFG_NUM_THREADS],
                "pointer out of range");
  }
}
    10fe:	83 81       	ldd	r24, Z+3	; 0x03
    1100:	94 81       	ldd	r25, Z+4	; 0x04
    1102:	08 95       	ret

  /* Scanning the whole threads array.*/
  ntp = nil.threads;
  while (true) {
    /* Is this thread ready to execute?*/
    if (NIL_THD_IS_READY(ntp)) {
    1104:	e6 ed       	ldi	r30, 0xD6	; 214
    1106:	f7 e0       	ldi	r31, 0x07	; 7
    1108:	ea cf       	rjmp	.-44     	; 0x10de <chSchGoSleepTimeoutS+0x2e>

0000110a <chEvtWaitAnyTimeoutS>:
 * @return              The mask of the served and cleared events.
 * @retval 0            if the operation has timed out.
 *
 * @sclass
 */
eventmask_t chEvtWaitAnyTimeoutS(eventmask_t mask, systime_t timeout) {
    110a:	0f 93       	push	r16
    110c:	1f 93       	push	r17
    110e:	cf 93       	push	r28
    1110:	df 93       	push	r29
    1112:	08 2f       	mov	r16, r24
  thread_t *ctp = nil.current;
    1114:	c0 91 ce 07 	lds	r28, 0x07CE
    1118:	d0 91 cf 07 	lds	r29, 0x07CF
  eventmask_t m;

  if ((m = (ctp->epmask & mask)) == 0) {
    111c:	99 85       	ldd	r25, Y+9	; 0x09
    111e:	18 2f       	mov	r17, r24
    1120:	19 23       	and	r17, r25
    1122:	89 f4       	brne	.+34     	; 0x1146 <chEvtWaitAnyTimeoutS+0x3c>
    if (TIME_IMMEDIATE == timeout) {
    1124:	4f 3f       	cpi	r20, 0xFF	; 255
    1126:	8f ef       	ldi	r24, 0xFF	; 255
    1128:	58 07       	cpc	r21, r24
    112a:	8f ef       	ldi	r24, 0xFF	; 255
    112c:	68 07       	cpc	r22, r24
    112e:	8f ef       	ldi	r24, 0xFF	; 255
    1130:	78 07       	cpc	r23, r24
    1132:	99 f0       	breq	.+38     	; 0x115a <chEvtWaitAnyTimeoutS+0x50>
      chSysUnlock();
      return (eventmask_t)0;
    }
    ctp->u1.ewmask = mask;
    1134:	0b 83       	std	Y+3, r16	; 0x03
    if (chSchGoSleepTimeoutS(NIL_STATE_WTOREVT, timeout) < MSG_OK) {
    1136:	84 e0       	ldi	r24, 0x04	; 4
    1138:	0e 94 58 08 	call	0x10b0	; 0x10b0 <chSchGoSleepTimeoutS>
    113c:	97 fd       	sbrc	r25, 7
    113e:	0d c0       	rjmp	.+26     	; 0x115a <chEvtWaitAnyTimeoutS+0x50>
      chSysUnlock();
      return (eventmask_t)0;
    }
    m = ctp->epmask & mask;
    1140:	99 85       	ldd	r25, Y+9	; 0x09
    1142:	10 2f       	mov	r17, r16
    1144:	19 23       	and	r17, r25
  }
  ctp->epmask &= ~m;
    1146:	81 2f       	mov	r24, r17
    1148:	80 95       	com	r24
    114a:	89 23       	and	r24, r25
    114c:	89 87       	std	Y+9, r24	; 0x09
  return m;
}
    114e:	81 2f       	mov	r24, r17
    1150:	df 91       	pop	r29
    1152:	cf 91       	pop	r28
    1154:	1f 91       	pop	r17
    1156:	0f 91       	pop	r16
    1158:	08 95       	ret
    115a:	78 94       	sei
    115c:	81 2f       	mov	r24, r17
    115e:	df 91       	pop	r29
    1160:	cf 91       	pop	r28
    1162:	1f 91       	pop	r17
    1164:	0f 91       	pop	r16
    1166:	08 95       	ret

00001168 <chEvtWaitAnyTimeout>:
    1168:	f8 94       	cli
eventmask_t chEvtWaitAnyTimeout(eventmask_t mask, systime_t timeout) {
  eventmask_t m;

  chSysLock();

  m = chEvtWaitAnyTimeoutS(mask, timeout);
    116a:	0e 94 85 08 	call	0x110a	; 0x110a <chEvtWaitAnyTimeoutS>
    116e:	78 94       	sei

  chSysUnlock();
  return m;
}
    1170:	08 95       	ret

00001172 <chSemWaitTimeoutS>:
 * @retval NIL_MSG_TMO  if the semaphore has not been signaled or reset within
 *                      the specified timeout.
 *
 * @sclass
 */
msg_t chSemWaitTimeoutS(semaphore_t *sp, systime_t timeout) {
    1172:	dc 01       	movw	r26, r24

  /* Note, the semaphore counter is a volatile variable so accesses are
     manually optimized.*/
  cnt_t cnt = sp->cnt;
    1174:	8c 91       	ld	r24, X
  if (cnt <= 0) {
    1176:	18 16       	cp	r1, r24
    1178:	34 f4       	brge	.+12     	; 0x1186 <chSemWaitTimeoutS+0x14>
      return MSG_TIMEOUT;
    sp->cnt = cnt - 1;
    nil.current->u1.semp = sp;
    return chSchGoSleepTimeoutS(NIL_STATE_WTSEM, timeout);
  }
  sp->cnt = cnt - 1;
    117a:	81 50       	subi	r24, 0x01	; 1
    117c:	8c 93       	st	X, r24
    117e:	20 e0       	ldi	r18, 0x00	; 0
    1180:	30 e0       	ldi	r19, 0x00	; 0
  return MSG_OK;
}
    1182:	c9 01       	movw	r24, r18
    1184:	08 95       	ret

  /* Note, the semaphore counter is a volatile variable so accesses are
     manually optimized.*/
  cnt_t cnt = sp->cnt;
  if (cnt <= 0) {
    if (TIME_IMMEDIATE == timeout)
    1186:	4f 3f       	cpi	r20, 0xFF	; 255
    1188:	9f ef       	ldi	r25, 0xFF	; 255
    118a:	59 07       	cpc	r21, r25
    118c:	9f ef       	ldi	r25, 0xFF	; 255
    118e:	69 07       	cpc	r22, r25
    1190:	9f ef       	ldi	r25, 0xFF	; 255
    1192:	79 07       	cpc	r23, r25
    1194:	19 f4       	brne	.+6      	; 0x119c <chSemWaitTimeoutS+0x2a>
    1196:	2f ef       	ldi	r18, 0xFF	; 255
    1198:	3f ef       	ldi	r19, 0xFF	; 255
    119a:	f3 cf       	rjmp	.-26     	; 0x1182 <chSemWaitTimeoutS+0x10>
      return MSG_TIMEOUT;
    sp->cnt = cnt - 1;
    119c:	81 50       	subi	r24, 0x01	; 1
    119e:	8c 93       	st	X, r24
    nil.current->u1.semp = sp;
    11a0:	e0 91 ce 07 	lds	r30, 0x07CE
    11a4:	f0 91 cf 07 	lds	r31, 0x07CF
    11a8:	b4 83       	std	Z+4, r27	; 0x04
    11aa:	a3 83       	std	Z+3, r26	; 0x03
    return chSchGoSleepTimeoutS(NIL_STATE_WTSEM, timeout);
    11ac:	83 e0       	ldi	r24, 0x03	; 3
    11ae:	0e 94 58 08 	call	0x10b0	; 0x10b0 <chSchGoSleepTimeoutS>
    11b2:	9c 01       	movw	r18, r24
    11b4:	e6 cf       	rjmp	.-52     	; 0x1182 <chSemWaitTimeoutS+0x10>

000011b6 <chSemWaitTimeout>:
    11b6:	f8 94       	cli
msg_t chSemWaitTimeout(semaphore_t *sp, systime_t timeout) {
  msg_t msg;

  chSysLock();

  msg = chSemWaitTimeoutS(sp, timeout);
    11b8:	0e 94 b9 08 	call	0x1172	; 0x1172 <chSemWaitTimeoutS>
    11bc:	78 94       	sei

  chSysUnlock();
  return msg;
}
    11be:	08 95       	ret

000011c0 <chThdSleepUntil>:
 *
 * @param[in] time      absolute system time
 *
 * @api
 */
void chThdSleepUntil(systime_t time) {
    11c0:	ab 01       	movw	r20, r22
    11c2:	bc 01       	movw	r22, r24
    11c4:	f8 94       	cli

  chSysLock();

  chThdSleepUntilS(time);
    11c6:	80 91 d2 07 	lds	r24, 0x07D2
    11ca:	90 91 d3 07 	lds	r25, 0x07D3
    11ce:	a0 91 d4 07 	lds	r26, 0x07D4
    11d2:	b0 91 d5 07 	lds	r27, 0x07D5
    11d6:	48 1b       	sub	r20, r24
    11d8:	59 0b       	sbc	r21, r25
    11da:	6a 0b       	sbc	r22, r26
    11dc:	7b 0b       	sbc	r23, r27
    11de:	81 e0       	ldi	r24, 0x01	; 1
    11e0:	0e 94 58 08 	call	0x10b0	; 0x10b0 <chSchGoSleepTimeoutS>
    11e4:	78 94       	sei

  chSysUnlock();
}
    11e6:	08 95       	ret

000011e8 <chThdSleep>:
 *
 * @param[in] time      the delay in system ticks
 *
 * @api
 */
void chThdSleep(systime_t time) {
    11e8:	ab 01       	movw	r20, r22
    11ea:	bc 01       	movw	r22, r24
    11ec:	f8 94       	cli

  chSysLock();

  chThdSleepS(time);
    11ee:	81 e0       	ldi	r24, 0x01	; 1
    11f0:	0e 94 58 08 	call	0x10b0	; 0x10b0 <chSchGoSleepTimeoutS>
    11f4:	78 94       	sei

  chSysUnlock();
}
    11f6:	08 95       	ret

000011f8 <chThdSuspendTimeoutS>:
 *                      .
 * @return              The wake up message.
 *
 * @sclass
 */
msg_t chThdSuspendTimeoutS(thread_reference_t *trp, systime_t timeout) {
    11f8:	dc 01       	movw	r26, r24

  chDbgAssert(*trp == NULL, "not NULL");

  *trp = nil.current;
    11fa:	80 91 ce 07 	lds	r24, 0x07CE
    11fe:	90 91 cf 07 	lds	r25, 0x07CF
    1202:	11 96       	adiw	r26, 0x01	; 1
    1204:	9c 93       	st	X, r25
    1206:	8e 93       	st	-X, r24
  nil.current->u1.trp = trp;
    1208:	e0 91 ce 07 	lds	r30, 0x07CE
    120c:	f0 91 cf 07 	lds	r31, 0x07CF
    1210:	b4 83       	std	Z+4, r27	; 0x04
    1212:	a3 83       	std	Z+3, r26	; 0x03
  return chSchGoSleepTimeoutS(NIL_STATE_SUSP, timeout);
    1214:	82 e0       	ldi	r24, 0x02	; 2
    1216:	0e 94 58 08 	call	0x10b0	; 0x10b0 <chSchGoSleepTimeoutS>
}
    121a:	08 95       	ret

0000121c <chSchRescheduleS>:
 *
 * @sclass
 */
void chSchRescheduleS(void) {

  if (chSchIsRescRequiredI()) {
    121c:	60 91 ce 07 	lds	r22, 0x07CE
    1220:	70 91 cf 07 	lds	r23, 0x07CF
    1224:	80 91 d0 07 	lds	r24, 0x07D0
    1228:	90 91 d1 07 	lds	r25, 0x07D1
    122c:	68 17       	cp	r22, r24
    122e:	79 07       	cpc	r23, r25
    1230:	31 f0       	breq	.+12     	; 0x123e <chSchRescheduleS+0x22>
    thread_t *otp = nil.current;

    nil.current = nil.next;
    1232:	90 93 cf 07 	sts	0x07CF, r25
    1236:	80 93 ce 07 	sts	0x07CE, r24
    if (otp == &nil.threads[NIL_CFG_NUM_THREADS]) {
      NIL_CFG_IDLE_LEAVE_HOOK();
    }
    port_switch(nil.next, otp);
    123a:	0e 94 15 07 	call	0xe2a	; 0xe2a <_port_switch>
    123e:	08 95       	ret

00001240 <chEvtSignal>:
    1240:	f8 94       	cli
 */
void chEvtSignal(thread_t *tp, eventmask_t mask) {

  chSysLock();

  chEvtSignalI(tp, mask);
    1242:	0e 94 3a 08 	call	0x1074	; 0x1074 <chEvtSignalI>
  chSchRescheduleS();
    1246:	0e 94 0e 09 	call	0x121c	; 0x121c <chSchRescheduleS>
    124a:	78 94       	sei

  chSysUnlock();
}
    124c:	08 95       	ret

0000124e <chSemReset>:
    124e:	f8 94       	cli
 */
void chSemReset(semaphore_t *sp, cnt_t n) {

  chSysLock();

  chSemResetI(sp, n);
    1250:	0e 94 11 08 	call	0x1022	; 0x1022 <chSemResetI>
  chSchRescheduleS();
    1254:	0e 94 0e 09 	call	0x121c	; 0x121c <chSchRescheduleS>
    1258:	78 94       	sei

  chSysUnlock();
}
    125a:	08 95       	ret

0000125c <chSemSignal>:
    125c:	f8 94       	cli
 */
void chSemSignal(semaphore_t *sp) {

  chSysLock();

  chSemSignalI(sp);
    125e:	0e 94 e4 07 	call	0xfc8	; 0xfc8 <chSemSignalI>
  chSchRescheduleS();
    1262:	0e 94 0e 09 	call	0x121c	; 0x121c <chSchRescheduleS>
    1266:	78 94       	sei

  chSysUnlock();
}
    1268:	08 95       	ret

0000126a <chSysInit>:
 *          zeroed by the runtime environment. If this is not the case then
 *          make sure to clear it before calling this function.
 *
 * @special
 */
void chSysInit(void) {
    126a:	cf 93       	push	r28
    126c:	df 93       	push	r29
    126e:	24 e4       	ldi	r18, 0x44	; 68
    1270:	37 e0       	ldi	r19, 0x07	; 7
    1272:	83 2f       	mov	r24, r19
    1274:	99 27       	eor	r25, r25
    1276:	87 fd       	sbrc	r24, 7
    1278:	9a 95       	dec	r25
    127a:	48 2f       	mov	r20, r24
    127c:	66 ed       	ldi	r22, 0xD6	; 214
    127e:	77 e0       	ldi	r23, 0x07	; 7
    1280:	db 01       	movw	r26, r22
    1282:	c2 e1       	ldi	r28, 0x12	; 18
    1284:	d6 e0       	ldi	r29, 0x06	; 6
#if NIL_CFG_ENABLE_STACK_CHECK
    tp->stklim  = (stkalign_t *)tcp->wbase;
#endif

    /* Port dependent thread initialization.*/
    PORT_SETUP_CONTEXT(tp, tcp->wend, tcp->funcp, tcp->arg);
    1286:	ea 81       	ldd	r30, Y+2	; 0x02
    1288:	fb 81       	ldd	r31, Y+3	; 0x03
    128a:	75 97       	sbiw	r30, 0x15	; 21
    128c:	11 96       	adiw	r26, 0x01	; 1
    128e:	fc 93       	st	X, r31
    1290:	ee 93       	st	-X, r30
    1292:	8e 81       	ldd	r24, Y+6	; 0x06
    1294:	82 8b       	std	Z+18, r24	; 0x12
    1296:	ed 91       	ld	r30, X+
    1298:	fc 91       	ld	r31, X
    129a:	11 97       	sbiw	r26, 0x01	; 1
    129c:	8e 81       	ldd	r24, Y+6	; 0x06
    129e:	9f 81       	ldd	r25, Y+7	; 0x07
    12a0:	89 2f       	mov	r24, r25
    12a2:	99 0f       	add	r25, r25
    12a4:	99 0b       	sbc	r25, r25
    12a6:	81 8b       	std	Z+17, r24	; 0x11
    12a8:	ed 91       	ld	r30, X+
    12aa:	fc 91       	ld	r31, X
    12ac:	11 97       	sbiw	r26, 0x01	; 1
    12ae:	88 85       	ldd	r24, Y+8	; 0x08
    12b0:	80 8b       	std	Z+16, r24	; 0x10
    12b2:	ed 91       	ld	r30, X+
    12b4:	fc 91       	ld	r31, X
    12b6:	11 97       	sbiw	r26, 0x01	; 1
    12b8:	88 85       	ldd	r24, Y+8	; 0x08
    12ba:	99 85       	ldd	r25, Y+9	; 0x09
    12bc:	89 2f       	mov	r24, r25
    12be:	99 0f       	add	r25, r25
    12c0:	99 0b       	sbc	r25, r25
    12c2:	87 87       	std	Z+15, r24	; 0x0f
    12c4:	ed 91       	ld	r30, X+
    12c6:	fc 91       	ld	r31, X
    12c8:	11 97       	sbiw	r26, 0x01	; 1
    12ca:	43 8b       	std	Z+19, r20	; 0x13
    12cc:	ed 91       	ld	r30, X+
    12ce:	fc 91       	ld	r31, X
    12d0:	11 97       	sbiw	r26, 0x01	; 1
    12d2:	24 8b       	std	Z+20, r18	; 0x14

    /* Initialization hook.*/
    NIL_CFG_THREAD_EXT_INIT_HOOK(tp);

    tp++, tcp++;
    12d4:	1a 96       	adiw	r26, 0x0a	; 10
    12d6:	2a 96       	adiw	r28, 0x0a	; 10
  NIL_CFG_SYSTEM_INIT_HOOK();

  /* Iterates through the list of defined threads.*/
  tp = &nil.threads[0];
  tcp = nil_thd_configs;
  while (tp < &nil.threads[NIL_CFG_NUM_THREADS]) {
    12d8:	88 e0       	ldi	r24, 0x08	; 8
    12da:	a6 37       	cpi	r26, 0x76	; 118
    12dc:	b8 07       	cpc	r27, r24
    12de:	99 f6       	brne	.-90     	; 0x1286 <chSysInit+0x1c>
  tp->stklim  = THD_IDLE_BASE;
#endif

  /* Runs the highest priority thread, the current one becomes the null
     thread.*/
  nil.current = nil.next = nil.threads;
    12e0:	70 93 d1 07 	sts	0x07D1, r23
    12e4:	60 93 d0 07 	sts	0x07D0, r22
    12e8:	70 93 cf 07 	sts	0x07CF, r23
    12ec:	60 93 ce 07 	sts	0x07CE, r22
  port_switch(nil.current, tp);
    12f0:	cb 01       	movw	r24, r22
    12f2:	bd 01       	movw	r22, r26
    12f4:	0e 94 15 07 	call	0xe2a	; 0xe2a <_port_switch>
    12f8:	78 94       	sei

  /* Interrupts enabled for the idle thread.*/
  chSysEnable();
}
    12fa:	df 91       	pop	r29
    12fc:	cf 91       	pop	r28
    12fe:	08 95       	ret

00001300 <print_line>:
  tcp->execute();
  if (tcp->teardown != NULL)
    tcp->teardown();
}

static void print_line(void) {
    1300:	cf 93       	push	r28
    1302:	df 93       	push	r29
    1304:	c0 e0       	ldi	r28, 0x00	; 0
    1306:	d0 e0       	ldi	r29, 0x00	; 0
  unsigned i;

  for (i = 0; i < 76; i++)
    streamPut(test_chp, '-');
    1308:	e0 91 10 07 	lds	r30, 0x0710
    130c:	f0 91 11 07 	lds	r31, 0x0711
    1310:	a0 81       	ld	r26, Z
    1312:	b1 81       	ldd	r27, Z+1	; 0x01
    1314:	14 96       	adiw	r26, 0x04	; 4
    1316:	2d 91       	ld	r18, X+
    1318:	3c 91       	ld	r19, X
    131a:	15 97       	sbiw	r26, 0x05	; 5
    131c:	cf 01       	movw	r24, r30
    131e:	6d e2       	ldi	r22, 0x2D	; 45
    1320:	f9 01       	movw	r30, r18
    1322:	09 95       	icall
}

static void print_line(void) {
  unsigned i;

  for (i = 0; i < 76; i++)
    1324:	21 96       	adiw	r28, 0x01	; 1
    1326:	cc 34       	cpi	r28, 0x4C	; 76
    1328:	d1 05       	cpc	r29, r1
    132a:	71 f7       	brne	.-36     	; 0x1308 <print_line+0x8>
    streamPut(test_chp, '-');
  streamWrite(test_chp, (const uint8_t *)"\r\n", 2);
    132c:	e0 91 10 07 	lds	r30, 0x0710
    1330:	f0 91 11 07 	lds	r31, 0x0711
    1334:	a0 81       	ld	r26, Z
    1336:	b1 81       	ldd	r27, Z+1	; 0x01
    1338:	2d 91       	ld	r18, X+
    133a:	3c 91       	ld	r19, X
    133c:	cf 01       	movw	r24, r30
    133e:	60 e0       	ldi	r22, 0x00	; 0
    1340:	71 e0       	ldi	r23, 0x01	; 1
    1342:	42 e0       	ldi	r20, 0x02	; 2
    1344:	50 e0       	ldi	r21, 0x00	; 0
    1346:	f9 01       	movw	r30, r18
    1348:	09 95       	icall
}
    134a:	df 91       	pop	r29
    134c:	cf 91       	pop	r28
    134e:	08 95       	ret

00001350 <_test_fail>:
/* Module exported functions.                                                */
/*===========================================================================*/

bool _test_fail(const char *msg) {

  test_local_fail = TRUE;
    1350:	21 e0       	ldi	r18, 0x01	; 1
    1352:	20 93 fa 06 	sts	0x06FA, r18
  test_global_fail = TRUE;
    1356:	20 93 fb 06 	sts	0x06FB, r18
  test_failure_message = msg;
    135a:	90 93 fd 06 	sts	0x06FD, r25
    135e:	80 93 fc 06 	sts	0x06FC, r24
  return TRUE;
}
    1362:	81 e0       	ldi	r24, 0x01	; 1
    1364:	08 95       	ret

00001366 <_test_assert>:

bool _test_assert(bool condition, const char *msg) {

  if (!condition)
    1366:	88 23       	and	r24, r24
    1368:	51 f4       	brne	.+20     	; 0x137e <_test_assert+0x18>
/* Module exported functions.                                                */
/*===========================================================================*/

bool _test_fail(const char *msg) {

  test_local_fail = TRUE;
    136a:	81 e0       	ldi	r24, 0x01	; 1
    136c:	80 93 fa 06 	sts	0x06FA, r24
  test_global_fail = TRUE;
    1370:	80 93 fb 06 	sts	0x06FB, r24
  test_failure_message = msg;
    1374:	70 93 fd 06 	sts	0x06FD, r23
    1378:	60 93 fc 06 	sts	0x06FC, r22
bool _test_assert(bool condition, const char *msg) {

  if (!condition)
    return _test_fail(msg);
  return FALSE;
}
    137c:	08 95       	ret
  return TRUE;
}

bool _test_assert(bool condition, const char *msg) {

  if (!condition)
    137e:	80 e0       	ldi	r24, 0x00	; 0
    1380:	08 95       	ret

00001382 <_test_assert_sequence>:
    return _test_fail(msg);
  return FALSE;
}

bool _test_assert_sequence(char *expected, const char *msg) {
    1382:	dc 01       	movw	r26, r24
  char *cp = test_tokens_buffer;

  while (cp < test_tokp) {
    1384:	20 91 0e 07 	lds	r18, 0x070E
    1388:	30 91 0f 07 	lds	r19, 0x070F
    138c:	4e ef       	ldi	r20, 0xFE	; 254
    138e:	56 e0       	ldi	r21, 0x06	; 6
    1390:	fa 01       	movw	r30, r20
    1392:	02 c0       	rjmp	.+4      	; 0x1398 <_test_assert_sequence+0x16>
    if (*cp++ != *expected++)
    1394:	31 96       	adiw	r30, 0x01	; 1
    1396:	11 96       	adiw	r26, 0x01	; 1
}

bool _test_assert_sequence(char *expected, const char *msg) {
  char *cp = test_tokens_buffer;

  while (cp < test_tokp) {
    1398:	e2 17       	cp	r30, r18
    139a:	f3 07       	cpc	r31, r19
    139c:	70 f4       	brcc	.+28     	; 0x13ba <_test_assert_sequence+0x38>
    if (*cp++ != *expected++)
    139e:	90 81       	ld	r25, Z
    13a0:	8c 91       	ld	r24, X
    13a2:	98 17       	cp	r25, r24
    13a4:	b9 f3       	breq	.-18     	; 0x1394 <_test_assert_sequence+0x12>
/* Module exported functions.                                                */
/*===========================================================================*/

bool _test_fail(const char *msg) {

  test_local_fail = TRUE;
    13a6:	81 e0       	ldi	r24, 0x01	; 1
    13a8:	80 93 fa 06 	sts	0x06FA, r24
  test_global_fail = TRUE;
    13ac:	80 93 fb 06 	sts	0x06FB, r24
  test_failure_message = msg;
    13b0:	70 93 fd 06 	sts	0x06FD, r23
    13b4:	60 93 fc 06 	sts	0x06FC, r22
    13b8:	08 95       	ret
  while (cp < test_tokp) {
    if (*cp++ != *expected++)
     return _test_fail(msg);
  }

  if (*expected)
    13ba:	8c 91       	ld	r24, X
    13bc:	88 23       	and	r24, r24
    13be:	99 f7       	brne	.-26     	; 0x13a6 <_test_assert_sequence+0x24>
/* Module local functions.                                                   */
/*===========================================================================*/

static void clear_tokens(void) {

  test_tokp = test_tokens_buffer;
    13c0:	50 93 0f 07 	sts	0x070F, r21
    13c4:	40 93 0e 07 	sts	0x070E, r20
    13c8:	80 e0       	ldi	r24, 0x00	; 0
    return _test_fail(msg);

  clear_tokens();

  return FALSE;
}
    13ca:	08 95       	ret

000013cc <_test_assert_time_window>:

bool _test_assert_time_window(systime_t start,
                              systime_t end,
                              const char *msg) {
    13cc:	ef 92       	push	r14
    13ce:	ff 92       	push	r15
    13d0:	0f 93       	push	r16
    13d2:	1f 93       	push	r17
    13d4:	f8 01       	movw	r30, r16
  return TRUE;
}

bool _test_assert(bool condition, const char *msg) {

  if (!condition)
    13d6:	e0 90 d2 07 	lds	r14, 0x07D2
    13da:	f0 90 d3 07 	lds	r15, 0x07D3
    13de:	00 91 d4 07 	lds	r16, 0x07D4
    13e2:	10 91 d5 07 	lds	r17, 0x07D5
    13e6:	e6 1a       	sub	r14, r22
    13e8:	f7 0a       	sbc	r15, r23
    13ea:	08 0b       	sbc	r16, r24
    13ec:	19 0b       	sbc	r17, r25
    13ee:	26 1b       	sub	r18, r22
    13f0:	37 0b       	sbc	r19, r23
    13f2:	48 0b       	sbc	r20, r24
    13f4:	59 0b       	sbc	r21, r25
    13f6:	e2 16       	cp	r14, r18
    13f8:	f3 06       	cpc	r15, r19
    13fa:	04 07       	cpc	r16, r20
    13fc:	15 07       	cpc	r17, r21
    13fe:	70 f0       	brcs	.+28     	; 0x141c <_test_assert_time_window+0x50>
/* Module exported functions.                                                */
/*===========================================================================*/

bool _test_fail(const char *msg) {

  test_local_fail = TRUE;
    1400:	81 e0       	ldi	r24, 0x01	; 1
    1402:	80 93 fa 06 	sts	0x06FA, r24
  test_global_fail = TRUE;
    1406:	80 93 fb 06 	sts	0x06FB, r24
  test_failure_message = msg;
    140a:	f0 93 fd 06 	sts	0x06FD, r31
    140e:	e0 93 fc 06 	sts	0x06FC, r30
                              systime_t end,
                              const char *msg) {

  return _test_assert(osalOsIsTimeWithinX(osalOsGetSystemTimeX(), start, end),
                      msg);
}
    1412:	1f 91       	pop	r17
    1414:	0f 91       	pop	r16
    1416:	ff 90       	pop	r15
    1418:	ef 90       	pop	r14
    141a:	08 95       	ret
  return TRUE;
}

bool _test_assert(bool condition, const char *msg) {

  if (!condition)
    141c:	80 e0       	ldi	r24, 0x00	; 0
                              systime_t end,
                              const char *msg) {

  return _test_assert(osalOsIsTimeWithinX(osalOsGetSystemTimeX(), start, end),
                      msg);
}
    141e:	1f 91       	pop	r17
    1420:	0f 91       	pop	r16
    1422:	ff 90       	pop	r15
    1424:	ef 90       	pop	r14
    1426:	08 95       	ret

00001428 <test_printn>:
 *
 * @param[in] n         the number to be printed
 *
 * @api
 */
void test_printn(uint32_t n) {
    1428:	af 92       	push	r10
    142a:	bf 92       	push	r11
    142c:	cf 92       	push	r12
    142e:	df 92       	push	r13
    1430:	ef 92       	push	r14
    1432:	ff 92       	push	r15
    1434:	0f 93       	push	r16
    1436:	1f 93       	push	r17
    1438:	df 93       	push	r29
    143a:	cf 93       	push	r28
    143c:	cd b7       	in	r28, 0x3d	; 61
    143e:	de b7       	in	r29, 0x3e	; 62
    1440:	60 97       	sbiw	r28, 0x10	; 16
    1442:	0f b6       	in	r0, 0x3f	; 63
    1444:	f8 94       	cli
    1446:	de bf       	out	0x3e, r29	; 62
    1448:	0f be       	out	0x3f, r0	; 63
    144a:	cd bf       	out	0x3d, r28	; 61
    144c:	7b 01       	movw	r14, r22
    144e:	8c 01       	movw	r16, r24
  char buf[16], *p;

  if (!n)
    1450:	61 15       	cp	r22, r1
    1452:	71 05       	cpc	r23, r1
    1454:	81 05       	cpc	r24, r1
    1456:	91 05       	cpc	r25, r1
    1458:	09 f4       	brne	.+2      	; 0x145c <test_printn+0x34>
    145a:	49 c0       	rjmp	.+146    	; 0x14ee <test_printn+0xc6>
    streamPut(test_chp, '0');
    145c:	5e 01       	movw	r10, r28
    145e:	08 94       	sec
    1460:	a1 1c       	adc	r10, r1
    1462:	b1 1c       	adc	r11, r1
    1464:	65 01       	movw	r12, r10
  else {
    p = buf;
    while (n)
      *p++ = (n % 10) + '0', n /= 10;
    1466:	c8 01       	movw	r24, r16
    1468:	b7 01       	movw	r22, r14
    146a:	2a e0       	ldi	r18, 0x0A	; 10
    146c:	30 e0       	ldi	r19, 0x00	; 0
    146e:	40 e0       	ldi	r20, 0x00	; 0
    1470:	50 e0       	ldi	r21, 0x00	; 0
    1472:	0e 94 0d 80 	call	0x1001a	; 0x1001a <__udivmodsi4>
    1476:	60 5d       	subi	r22, 0xD0	; 208
    1478:	f6 01       	movw	r30, r12
    147a:	61 93       	st	Z+, r22
    147c:	6f 01       	movw	r12, r30
    147e:	c8 01       	movw	r24, r16
    1480:	b7 01       	movw	r22, r14
    1482:	2a e0       	ldi	r18, 0x0A	; 10
    1484:	30 e0       	ldi	r19, 0x00	; 0
    1486:	40 e0       	ldi	r20, 0x00	; 0
    1488:	50 e0       	ldi	r21, 0x00	; 0
    148a:	0e 94 0d 80 	call	0x1001a	; 0x1001a <__udivmodsi4>
    148e:	c9 01       	movw	r24, r18
    1490:	da 01       	movw	r26, r20
    1492:	7c 01       	movw	r14, r24
    1494:	8d 01       	movw	r16, r26

  if (!n)
    streamPut(test_chp, '0');
  else {
    p = buf;
    while (n)
    1496:	e1 14       	cp	r14, r1
    1498:	f1 04       	cpc	r15, r1
    149a:	01 05       	cpc	r16, r1
    149c:	11 05       	cpc	r17, r1
    149e:	19 f7       	brne	.-58     	; 0x1466 <test_printn+0x3e>
      *p++ = (n % 10) + '0', n /= 10;
    while (p > buf)
    14a0:	ac 14       	cp	r10, r12
    14a2:	bd 04       	cpc	r11, r13
    14a4:	98 f4       	brcc	.+38     	; 0x14cc <test_printn+0xa4>
      streamPut(test_chp, *--p);
    14a6:	e0 91 10 07 	lds	r30, 0x0710
    14aa:	f0 91 11 07 	lds	r31, 0x0711
    14ae:	a0 81       	ld	r26, Z
    14b0:	b1 81       	ldd	r27, Z+1	; 0x01
    14b2:	14 96       	adiw	r26, 0x04	; 4
    14b4:	2d 91       	ld	r18, X+
    14b6:	3c 91       	ld	r19, X
    14b8:	15 97       	sbiw	r26, 0x05	; 5
    14ba:	cf 01       	movw	r24, r30
    14bc:	f6 01       	movw	r30, r12
    14be:	62 91       	ld	r22, -Z
    14c0:	6f 01       	movw	r12, r30
    14c2:	f9 01       	movw	r30, r18
    14c4:	09 95       	icall
    streamPut(test_chp, '0');
  else {
    p = buf;
    while (n)
      *p++ = (n % 10) + '0', n /= 10;
    while (p > buf)
    14c6:	ac 14       	cp	r10, r12
    14c8:	bd 04       	cpc	r11, r13
    14ca:	68 f3       	brcs	.-38     	; 0x14a6 <test_printn+0x7e>
      streamPut(test_chp, *--p);
  }
}
    14cc:	60 96       	adiw	r28, 0x10	; 16
    14ce:	0f b6       	in	r0, 0x3f	; 63
    14d0:	f8 94       	cli
    14d2:	de bf       	out	0x3e, r29	; 62
    14d4:	0f be       	out	0x3f, r0	; 63
    14d6:	cd bf       	out	0x3d, r28	; 61
    14d8:	cf 91       	pop	r28
    14da:	df 91       	pop	r29
    14dc:	1f 91       	pop	r17
    14de:	0f 91       	pop	r16
    14e0:	ff 90       	pop	r15
    14e2:	ef 90       	pop	r14
    14e4:	df 90       	pop	r13
    14e6:	cf 90       	pop	r12
    14e8:	bf 90       	pop	r11
    14ea:	af 90       	pop	r10
    14ec:	08 95       	ret
 */
void test_printn(uint32_t n) {
  char buf[16], *p;

  if (!n)
    streamPut(test_chp, '0');
    14ee:	e0 91 10 07 	lds	r30, 0x0710
    14f2:	f0 91 11 07 	lds	r31, 0x0711
    14f6:	a0 81       	ld	r26, Z
    14f8:	b1 81       	ldd	r27, Z+1	; 0x01
    14fa:	14 96       	adiw	r26, 0x04	; 4
    14fc:	2d 91       	ld	r18, X+
    14fe:	3c 91       	ld	r19, X
    1500:	15 97       	sbiw	r26, 0x05	; 5
    1502:	cf 01       	movw	r24, r30
    1504:	60 e3       	ldi	r22, 0x30	; 48
    1506:	f9 01       	movw	r30, r18
    1508:	09 95       	icall
    150a:	e0 cf       	rjmp	.-64     	; 0x14cc <test_printn+0xa4>

0000150c <test_print>:
 *
 * @param[in] msgp      the message
 *
 * @api
 */
void test_print(const char *msgp) {
    150c:	cf 93       	push	r28
    150e:	df 93       	push	r29
    1510:	ec 01       	movw	r28, r24

  while (*msgp)
    1512:	68 81       	ld	r22, Y
    1514:	66 23       	and	r22, r22
    1516:	89 f0       	breq	.+34     	; 0x153a <test_print+0x2e>
    streamPut(test_chp, *msgp++);
    1518:	e0 91 10 07 	lds	r30, 0x0710
    151c:	f0 91 11 07 	lds	r31, 0x0711
    1520:	21 96       	adiw	r28, 0x01	; 1
    1522:	a0 81       	ld	r26, Z
    1524:	b1 81       	ldd	r27, Z+1	; 0x01
    1526:	14 96       	adiw	r26, 0x04	; 4
    1528:	2d 91       	ld	r18, X+
    152a:	3c 91       	ld	r19, X
    152c:	15 97       	sbiw	r26, 0x05	; 5
    152e:	cf 01       	movw	r24, r30
    1530:	f9 01       	movw	r30, r18
    1532:	09 95       	icall
 *
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
    1534:	68 81       	ld	r22, Y
    1536:	66 23       	and	r22, r22
    1538:	79 f7       	brne	.-34     	; 0x1518 <test_print+0xc>
    streamPut(test_chp, *msgp++);
}
    153a:	df 91       	pop	r29
    153c:	cf 91       	pop	r28
    153e:	08 95       	ret

00001540 <test_println>:
 *
 * @api
 */
void test_println(const char *msgp) {

  test_print(msgp);
    1540:	0e 94 86 0a 	call	0x150c	; 0x150c <test_print>
  streamWrite(test_chp, (const uint8_t *)"\r\n", 2);
    1544:	e0 91 10 07 	lds	r30, 0x0710
    1548:	f0 91 11 07 	lds	r31, 0x0711
    154c:	a0 81       	ld	r26, Z
    154e:	b1 81       	ldd	r27, Z+1	; 0x01
    1550:	2d 91       	ld	r18, X+
    1552:	3c 91       	ld	r19, X
    1554:	cf 01       	movw	r24, r30
    1556:	60 e0       	ldi	r22, 0x00	; 0
    1558:	71 e0       	ldi	r23, 0x01	; 1
    155a:	42 e0       	ldi	r20, 0x02	; 2
    155c:	50 e0       	ldi	r21, 0x00	; 0
    155e:	f9 01       	movw	r30, r18
    1560:	09 95       	icall
}
    1562:	08 95       	ret

00001564 <test_emit_token>:
    1564:	f8 94       	cli
 * @api
 */
void test_emit_token(char token) {

  osalSysLock();
  if (test_tokp < &test_tokens_buffer[TEST_MAX_TOKENS])
    1566:	e0 91 0e 07 	lds	r30, 0x070E
    156a:	f0 91 0f 07 	lds	r31, 0x070F
    156e:	97 e0       	ldi	r25, 0x07	; 7
    1570:	ee 30       	cpi	r30, 0x0E	; 14
    1572:	f9 07       	cpc	r31, r25
    1574:	28 f4       	brcc	.+10     	; 0x1580 <test_emit_token+0x1c>
    *test_tokp++ = token;
    1576:	81 93       	st	Z+, r24
    1578:	f0 93 0f 07 	sts	0x070F, r31
    157c:	e0 93 0e 07 	sts	0x070E, r30
    1580:	78 94       	sei
  osalSysUnlock();
}
    1582:	08 95       	ret

00001584 <test_emit_token_i>:
 *
 * @iclass
 */
void test_emit_token_i(char token) {

  if (test_tokp < &test_tokens_buffer[TEST_MAX_TOKENS])
    1584:	e0 91 0e 07 	lds	r30, 0x070E
    1588:	f0 91 0f 07 	lds	r31, 0x070F
    158c:	97 e0       	ldi	r25, 0x07	; 7
    158e:	ee 30       	cpi	r30, 0x0E	; 14
    1590:	f9 07       	cpc	r31, r25
    1592:	28 f4       	brcc	.+10     	; 0x159e <test_emit_token_i+0x1a>
    *test_tokp++ = token;
    1594:	81 93       	st	Z+, r24
    1596:	f0 93 0f 07 	sts	0x070F, r31
    159a:	e0 93 0e 07 	sts	0x070E, r30
    159e:	08 95       	ret

000015a0 <test_execute>:
 * @retval FALSE        if no errors occurred.
 * @retval TRUE         if one or more tests failed.
 *
 * @api
 */
msg_t test_execute(BaseSequentialStream *stream) {
    15a0:	4f 92       	push	r4
    15a2:	5f 92       	push	r5
    15a4:	6f 92       	push	r6
    15a6:	7f 92       	push	r7
    15a8:	8f 92       	push	r8
    15aa:	9f 92       	push	r9
    15ac:	af 92       	push	r10
    15ae:	bf 92       	push	r11
    15b0:	cf 92       	push	r12
    15b2:	df 92       	push	r13
    15b4:	ef 92       	push	r14
    15b6:	ff 92       	push	r15
    15b8:	0f 93       	push	r16
    15ba:	1f 93       	push	r17
    15bc:	cf 93       	push	r28
    15be:	df 93       	push	r29
  int i, j;

  test_chp = stream;
    15c0:	90 93 11 07 	sts	0x0711, r25
    15c4:	80 93 10 07 	sts	0x0710, r24
  test_println("");
    15c8:	83 e0       	ldi	r24, 0x03	; 3
    15ca:	91 e0       	ldi	r25, 0x01	; 1
    15cc:	0e 94 a0 0a 	call	0x1540	; 0x1540 <test_println>
#if defined(TEST_SUITE_NAME)
  test_println("*** " TEST_SUITE_NAME);
    15d0:	84 e0       	ldi	r24, 0x04	; 4
    15d2:	91 e0       	ldi	r25, 0x01	; 1
    15d4:	0e 94 a0 0a 	call	0x1540	; 0x1540 <test_println>
#else
  test_println("*** ChibiOS test suite");
#endif
  test_println("***");
    15d8:	8f e1       	ldi	r24, 0x1F	; 31
    15da:	91 e0       	ldi	r25, 0x01	; 1
    15dc:	0e 94 a0 0a 	call	0x1540	; 0x1540 <test_println>
  test_print("*** Compiled:     ");
    15e0:	83 e2       	ldi	r24, 0x23	; 35
    15e2:	91 e0       	ldi	r25, 0x01	; 1
    15e4:	0e 94 86 0a 	call	0x150c	; 0x150c <test_print>
  test_println(__DATE__ " - " __TIME__);
    15e8:	86 e3       	ldi	r24, 0x36	; 54
    15ea:	91 e0       	ldi	r25, 0x01	; 1
    15ec:	0e 94 a0 0a 	call	0x1540	; 0x1540 <test_println>
#ifdef PLATFORM_NAME
  test_print("*** Platform:     ");
    15f0:	8d e4       	ldi	r24, 0x4D	; 77
    15f2:	91 e0       	ldi	r25, 0x01	; 1
    15f4:	0e 94 86 0a 	call	0x150c	; 0x150c <test_print>
  test_println(PLATFORM_NAME);
    15f8:	80 e6       	ldi	r24, 0x60	; 96
    15fa:	91 e0       	ldi	r25, 0x01	; 1
    15fc:	0e 94 a0 0a 	call	0x1540	; 0x1540 <test_println>
#endif
#ifdef BOARD_NAME
  test_print("*** Test Board:   ");
    1600:	84 e6       	ldi	r24, 0x64	; 100
    1602:	91 e0       	ldi	r25, 0x01	; 1
    1604:	0e 94 86 0a 	call	0x150c	; 0x150c <test_print>
  test_println(BOARD_NAME);
    1608:	87 e7       	ldi	r24, 0x77	; 119
    160a:	91 e0       	ldi	r25, 0x01	; 1
    160c:	0e 94 a0 0a 	call	0x1540	; 0x1540 <test_println>
#endif
  test_println("");
    1610:	83 e0       	ldi	r24, 0x03	; 3
    1612:	91 e0       	ldi	r25, 0x01	; 1
    1614:	0e 94 a0 0a 	call	0x1540	; 0x1540 <test_println>

  test_global_fail = FALSE;
    1618:	10 92 fb 06 	sts	0x06FB, r1
  i = 0;
  while (test_suite[i]) {
    161c:	e0 91 e8 01 	lds	r30, 0x01E8
    1620:	f0 91 e9 01 	lds	r31, 0x01E9
    1624:	30 97       	sbiw	r30, 0x00	; 0
    1626:	09 f4       	brne	.+2      	; 0x162a <test_execute+0x8a>
    1628:	c6 c0       	rjmp	.+396    	; 0x17b6 <test_execute+0x216>
    162a:	38 ee       	ldi	r19, 0xE8	; 232
    162c:	a3 2e       	mov	r10, r19
    162e:	31 e0       	ldi	r19, 0x01	; 1
    1630:	b3 2e       	mov	r11, r19
    1632:	21 e0       	ldi	r18, 0x01	; 1
    1634:	62 2e       	mov	r6, r18
    1636:	71 2c       	mov	r7, r1
    1638:	81 2c       	mov	r8, r1
    163a:	91 2c       	mov	r9, r1
/* Module local functions.                                                   */
/*===========================================================================*/

static void clear_tokens(void) {

  test_tokp = test_tokens_buffer;
    163c:	9e ef       	ldi	r25, 0xFE	; 254
    163e:	49 2e       	mov	r4, r25
    1640:	96 e0       	ldi	r25, 0x06	; 6
    1642:	59 2e       	mov	r5, r25
#endif
  test_println("");

  test_global_fail = FALSE;
  i = 0;
  while (test_suite[i]) {
    1644:	cc 24       	eor	r12, r12
    1646:	dd 24       	eor	r13, r13
    1648:	81 e0       	ldi	r24, 0x01	; 1
    164a:	e8 2e       	mov	r14, r24
    164c:	f1 2c       	mov	r15, r1
    164e:	01 2d       	mov	r16, r1
    1650:	11 2d       	mov	r17, r1
    j = 0;
    while (test_suite[i][j]) {
    1652:	ec 0d       	add	r30, r12
    1654:	fd 1d       	adc	r31, r13
    1656:	80 81       	ld	r24, Z
    1658:	91 81       	ldd	r25, Z+1	; 0x01
    165a:	89 2b       	or	r24, r25
    165c:	09 f4       	brne	.+2      	; 0x1660 <test_execute+0xc0>
    165e:	9a c0       	rjmp	.+308    	; 0x1794 <test_execute+0x1f4>
      print_line();
    1660:	0e 94 80 09 	call	0x1300	; 0x1300 <print_line>
      test_print("--- Test Case ");
    1664:	8e e7       	ldi	r24, 0x7E	; 126
    1666:	91 e0       	ldi	r25, 0x01	; 1
    1668:	0e 94 86 0a 	call	0x150c	; 0x150c <test_print>
      test_printn(i + 1);
    166c:	c4 01       	movw	r24, r8
    166e:	b3 01       	movw	r22, r6
    1670:	0e 94 14 0a 	call	0x1428	; 0x1428 <test_printn>
      test_print(".");
    1674:	8d e8       	ldi	r24, 0x8D	; 141
    1676:	91 e0       	ldi	r25, 0x01	; 1
    1678:	0e 94 86 0a 	call	0x150c	; 0x150c <test_print>
      test_printn(j + 1);
    167c:	c8 01       	movw	r24, r16
    167e:	b7 01       	movw	r22, r14
    1680:	0e 94 14 0a 	call	0x1428	; 0x1428 <test_printn>
      test_print(" (");
    1684:	8f e8       	ldi	r24, 0x8F	; 143
    1686:	91 e0       	ldi	r25, 0x01	; 1
    1688:	0e 94 86 0a 	call	0x150c	; 0x150c <test_print>
      test_print(test_suite[i][j]->name);
    168c:	d5 01       	movw	r26, r10
    168e:	ed 91       	ld	r30, X+
    1690:	fc 91       	ld	r31, X
    1692:	ec 0d       	add	r30, r12
    1694:	fd 1d       	adc	r31, r13
    1696:	01 90       	ld	r0, Z+
    1698:	f0 81       	ld	r31, Z
    169a:	e0 2d       	mov	r30, r0
    169c:	80 81       	ld	r24, Z
    169e:	91 81       	ldd	r25, Z+1	; 0x01
    16a0:	0e 94 86 0a 	call	0x150c	; 0x150c <test_print>
      test_println(")");
    16a4:	82 e9       	ldi	r24, 0x92	; 146
    16a6:	91 e0       	ldi	r25, 0x01	; 1
    16a8:	0e 94 a0 0a 	call	0x1540	; 0x1540 <test_println>
    16ac:	60 ea       	ldi	r22, 0xA0	; 160
    16ae:	7f e0       	ldi	r23, 0x0F	; 15
    16b0:	80 e0       	ldi	r24, 0x00	; 0
    16b2:	90 e0       	ldi	r25, 0x00	; 0
    16b4:	0e 94 f4 08 	call	0x11e8	; 0x11e8 <chThdSleep>
#if TEST_DELAY_BETWEEN_TESTS > 0
      osalThreadSleepMilliseconds(TEST_DELAY_BETWEEN_TESTS);
#endif
      execute_test(test_suite[i][j]);
    16b8:	d5 01       	movw	r26, r10
    16ba:	ed 91       	ld	r30, X+
    16bc:	fc 91       	ld	r31, X
    16be:	ec 0d       	add	r30, r12
    16c0:	fd 1d       	adc	r31, r13
    16c2:	c0 81       	ld	r28, Z
    16c4:	d1 81       	ldd	r29, Z+1	; 0x01
/* Module local functions.                                                   */
/*===========================================================================*/

static void clear_tokens(void) {

  test_tokp = test_tokens_buffer;
    16c6:	50 92 0f 07 	sts	0x070F, r5
    16ca:	40 92 0e 07 	sts	0x070E, r4

static void execute_test(const testcase_t *tcp) {

  /* Initialization */
  clear_tokens();
  test_local_fail = FALSE;
    16ce:	10 92 fa 06 	sts	0x06FA, r1

  if (tcp->setup != NULL)
    16d2:	ea 81       	ldd	r30, Y+2	; 0x02
    16d4:	fb 81       	ldd	r31, Y+3	; 0x03
    16d6:	30 97       	sbiw	r30, 0x00	; 0
    16d8:	09 f0       	breq	.+2      	; 0x16dc <test_execute+0x13c>
    tcp->setup();
    16da:	09 95       	icall
  tcp->execute();
    16dc:	ee 81       	ldd	r30, Y+6	; 0x06
    16de:	ff 81       	ldd	r31, Y+7	; 0x07
    16e0:	09 95       	icall
  if (tcp->teardown != NULL)
    16e2:	ec 81       	ldd	r30, Y+4	; 0x04
    16e4:	fd 81       	ldd	r31, Y+5	; 0x05
    16e6:	30 97       	sbiw	r30, 0x00	; 0
    16e8:	09 f0       	breq	.+2      	; 0x16ec <test_execute+0x14c>
    tcp->teardown();
    16ea:	09 95       	icall
      test_println(")");
#if TEST_DELAY_BETWEEN_TESTS > 0
      osalThreadSleepMilliseconds(TEST_DELAY_BETWEEN_TESTS);
#endif
      execute_test(test_suite[i][j]);
      if (test_local_fail) {
    16ec:	80 91 fa 06 	lds	r24, 0x06FA
    16f0:	88 23       	and	r24, r24
    16f2:	09 f4       	brne	.+2      	; 0x16f6 <test_execute+0x156>
    16f4:	86 c0       	rjmp	.+268    	; 0x1802 <test_execute+0x262>
        test_print("--- Result: FAILURE (#");
    16f6:	84 e9       	ldi	r24, 0x94	; 148
    16f8:	91 e0       	ldi	r25, 0x01	; 1
    16fa:	0e 94 86 0a 	call	0x150c	; 0x150c <test_print>
        test_printn(test_step);
    16fe:	60 91 80 08 	lds	r22, 0x0880
    1702:	70 91 81 08 	lds	r23, 0x0881
    1706:	80 e0       	ldi	r24, 0x00	; 0
    1708:	90 e0       	ldi	r25, 0x00	; 0
    170a:	0e 94 14 0a 	call	0x1428	; 0x1428 <test_printn>
        test_print(" [");
    170e:	8b ea       	ldi	r24, 0xAB	; 171
    1710:	91 e0       	ldi	r25, 0x01	; 1
    1712:	0e 94 86 0a 	call	0x150c	; 0x150c <test_print>
}

static void print_tokens(void) {
  char *cp = test_tokens_buffer;

  while (cp < test_tokp)
    1716:	80 91 0e 07 	lds	r24, 0x070E
    171a:	90 91 0f 07 	lds	r25, 0x070F
    171e:	8e 5f       	subi	r24, 0xFE	; 254
    1720:	96 40       	sbci	r25, 0x06	; 6
    1722:	b9 f0       	breq	.+46     	; 0x1752 <test_execute+0x1b2>
    1724:	b0 f0       	brcs	.+44     	; 0x1752 <test_execute+0x1b2>
    1726:	ce ef       	ldi	r28, 0xFE	; 254
    1728:	d6 e0       	ldi	r29, 0x06	; 6
    streamPut(test_chp, *cp++);
    172a:	a0 91 10 07 	lds	r26, 0x0710
    172e:	b0 91 11 07 	lds	r27, 0x0711
    1732:	69 91       	ld	r22, Y+
    1734:	ed 91       	ld	r30, X+
    1736:	fc 91       	ld	r31, X
    1738:	11 97       	sbiw	r26, 0x01	; 1
    173a:	04 80       	ldd	r0, Z+4	; 0x04
    173c:	f5 81       	ldd	r31, Z+5	; 0x05
    173e:	e0 2d       	mov	r30, r0
    1740:	cd 01       	movw	r24, r26
    1742:	09 95       	icall
}

static void print_tokens(void) {
  char *cp = test_tokens_buffer;

  while (cp < test_tokp)
    1744:	80 91 0e 07 	lds	r24, 0x070E
    1748:	90 91 0f 07 	lds	r25, 0x070F
    174c:	c8 17       	cp	r28, r24
    174e:	d9 07       	cpc	r29, r25
    1750:	60 f3       	brcs	.-40     	; 0x172a <test_execute+0x18a>
      if (test_local_fail) {
        test_print("--- Result: FAILURE (#");
        test_printn(test_step);
        test_print(" [");
        print_tokens();
        test_print("] \"");
    1752:	8e ea       	ldi	r24, 0xAE	; 174
    1754:	91 e0       	ldi	r25, 0x01	; 1
    1756:	0e 94 86 0a 	call	0x150c	; 0x150c <test_print>
        test_print(test_failure_message);
    175a:	80 91 fc 06 	lds	r24, 0x06FC
    175e:	90 91 fd 06 	lds	r25, 0x06FD
    1762:	0e 94 86 0a 	call	0x150c	; 0x150c <test_print>
        test_println("\")");
    1766:	82 eb       	ldi	r24, 0xB2	; 178
    1768:	91 e0       	ldi	r25, 0x01	; 1
    176a:	0e 94 a0 0a 	call	0x1540	; 0x1540 <test_println>
      }
      else
        test_println("--- Result: SUCCESS");
    176e:	d5 01       	movw	r26, r10
    1770:	ed 91       	ld	r30, X+
    1772:	fc 91       	ld	r31, X
    1774:	82 e0       	ldi	r24, 0x02	; 2
    1776:	90 e0       	ldi	r25, 0x00	; 0
    1778:	c8 0e       	add	r12, r24
    177a:	d9 1e       	adc	r13, r25
    177c:	08 94       	sec
    177e:	e1 1c       	adc	r14, r1
    1780:	f1 1c       	adc	r15, r1
    1782:	01 1d       	adc	r16, r1
    1784:	11 1d       	adc	r17, r1

  test_global_fail = FALSE;
  i = 0;
  while (test_suite[i]) {
    j = 0;
    while (test_suite[i][j]) {
    1786:	ec 0d       	add	r30, r12
    1788:	fd 1d       	adc	r31, r13
    178a:	80 81       	ld	r24, Z
    178c:	91 81       	ldd	r25, Z+1	; 0x01
    178e:	89 2b       	or	r24, r25
    1790:	09 f0       	breq	.+2      	; 0x1794 <test_execute+0x1f4>
    1792:	66 cf       	rjmp	.-308    	; 0x1660 <test_execute+0xc0>
#endif
  test_println("");

  test_global_fail = FALSE;
  i = 0;
  while (test_suite[i]) {
    1794:	d5 01       	movw	r26, r10
    1796:	12 96       	adiw	r26, 0x02	; 2
    1798:	ed 91       	ld	r30, X+
    179a:	fc 91       	ld	r31, X
    179c:	13 97       	sbiw	r26, 0x03	; 3
    179e:	82 e0       	ldi	r24, 0x02	; 2
    17a0:	90 e0       	ldi	r25, 0x00	; 0
    17a2:	a8 0e       	add	r10, r24
    17a4:	b9 1e       	adc	r11, r25
    17a6:	08 94       	sec
    17a8:	61 1c       	adc	r6, r1
    17aa:	71 1c       	adc	r7, r1
    17ac:	81 1c       	adc	r8, r1
    17ae:	91 1c       	adc	r9, r1
    17b0:	30 97       	sbiw	r30, 0x00	; 0
    17b2:	09 f0       	breq	.+2      	; 0x17b6 <test_execute+0x216>
    17b4:	47 cf       	rjmp	.-370    	; 0x1644 <test_execute+0xa4>
        test_println("--- Result: SUCCESS");
      j++;
    }
    i++;
  }
  print_line();
    17b6:	0e 94 80 09 	call	0x1300	; 0x1300 <print_line>
  test_println("");
    17ba:	83 e0       	ldi	r24, 0x03	; 3
    17bc:	91 e0       	ldi	r25, 0x01	; 1
    17be:	0e 94 a0 0a 	call	0x1540	; 0x1540 <test_println>
  test_print("Final result: ");
    17c2:	89 ec       	ldi	r24, 0xC9	; 201
    17c4:	91 e0       	ldi	r25, 0x01	; 1
    17c6:	0e 94 86 0a 	call	0x150c	; 0x150c <test_print>
  if (test_global_fail)
    17ca:	80 91 fb 06 	lds	r24, 0x06FB
    17ce:	88 23       	and	r24, r24
    17d0:	e9 f4       	brne	.+58     	; 0x180c <test_execute+0x26c>
    test_println("FAILURE");
  else
    test_println("SUCCESS");
    17d2:	80 ee       	ldi	r24, 0xE0	; 224
    17d4:	91 e0       	ldi	r25, 0x01	; 1
    17d6:	0e 94 a0 0a 	call	0x1540	; 0x1540 <test_println>

  return (msg_t)test_global_fail;
}
    17da:	80 91 fb 06 	lds	r24, 0x06FB
    17de:	90 e0       	ldi	r25, 0x00	; 0
    17e0:	df 91       	pop	r29
    17e2:	cf 91       	pop	r28
    17e4:	1f 91       	pop	r17
    17e6:	0f 91       	pop	r16
    17e8:	ff 90       	pop	r15
    17ea:	ef 90       	pop	r14
    17ec:	df 90       	pop	r13
    17ee:	cf 90       	pop	r12
    17f0:	bf 90       	pop	r11
    17f2:	af 90       	pop	r10
    17f4:	9f 90       	pop	r9
    17f6:	8f 90       	pop	r8
    17f8:	7f 90       	pop	r7
    17fa:	6f 90       	pop	r6
    17fc:	5f 90       	pop	r5
    17fe:	4f 90       	pop	r4
    1800:	08 95       	ret
        test_print("] \"");
        test_print(test_failure_message);
        test_println("\")");
      }
      else
        test_println("--- Result: SUCCESS");
    1802:	85 eb       	ldi	r24, 0xB5	; 181
    1804:	91 e0       	ldi	r25, 0x01	; 1
    1806:	0e 94 a0 0a 	call	0x1540	; 0x1540 <test_println>
    180a:	b1 cf       	rjmp	.-158    	; 0x176e <test_execute+0x1ce>
  }
  print_line();
  test_println("");
  test_print("Final result: ");
  if (test_global_fail)
    test_println("FAILURE");
    180c:	88 ed       	ldi	r24, 0xD8	; 216
    180e:	91 e0       	ldi	r25, 0x01	; 1
    1810:	0e 94 a0 0a 	call	0x1540	; 0x1540 <test_println>
    1814:	e2 cf       	rjmp	.-60     	; 0x17da <test_execute+0x23a>

00001816 <test_support>:

/*
 * Support thread.
 */
THD_WORKING_AREA(wa_test_support, 128);
THD_FUNCTION(test_support, arg) {
    1816:	8c 01       	movw	r16, r24
  thread_t *tp = (thread_t *)arg;

  /* Initializing global resources.*/
  chSemObjectInit(&gsem1, 0);
    1818:	10 92 36 09 	sts	0x0936, r1
  chSemObjectInit(&gsem2, 0);
    181c:	10 92 39 09 	sts	0x0939, r1
    1820:	18 c0       	rjmp	.+48     	; 0x1852 <test_support+0x3c>
  /* Waiting for button push and activation of the test suite.*/
  while (true) {
    chSysLock();
    if (chSemGetCounterI(&gsem1) < 0)
      chSemSignalI(&gsem1);
    chSemResetI(&gsem2, 0);
    1822:	89 e3       	ldi	r24, 0x39	; 57
    1824:	99 e0       	ldi	r25, 0x09	; 9
    1826:	60 e0       	ldi	r22, 0x00	; 0
    1828:	0e 94 11 08 	call	0x1022	; 0x1022 <chSemResetI>
    chThdResumeI(&gtr1, MSG_OK);
    182c:	87 e3       	ldi	r24, 0x37	; 55
    182e:	99 e0       	ldi	r25, 0x09	; 9
    1830:	60 e0       	ldi	r22, 0x00	; 0
    1832:	70 e0       	ldi	r23, 0x00	; 0
    1834:	0e 94 c9 07 	call	0xf92	; 0xf92 <chThdResumeI>
    chEvtSignalI(tp, 0x55);
    1838:	c8 01       	movw	r24, r16
    183a:	65 e5       	ldi	r22, 0x55	; 85
    183c:	0e 94 3a 08 	call	0x1074	; 0x1074 <chEvtSignalI>
    chSchRescheduleS();
    1840:	0e 94 0e 09 	call	0x121c	; 0x121c <chSchRescheduleS>
    1844:	78 94       	sei
    chSysUnlock();

    chThdSleepMilliseconds(250);
    1846:	68 e8       	ldi	r22, 0x88	; 136
    1848:	73 e1       	ldi	r23, 0x13	; 19
    184a:	80 e0       	ldi	r24, 0x00	; 0
    184c:	90 e0       	ldi	r25, 0x00	; 0
    184e:	0e 94 f4 08 	call	0x11e8	; 0x11e8 <chThdSleep>
    1852:	f8 94       	cli
  chSemObjectInit(&gsem2, 0);

  /* Waiting for button push and activation of the test suite.*/
  while (true) {
    chSysLock();
    if (chSemGetCounterI(&gsem1) < 0)
    1854:	80 91 36 09 	lds	r24, 0x0936
    1858:	87 ff       	sbrs	r24, 7
    185a:	e3 cf       	rjmp	.-58     	; 0x1822 <test_support+0xc>
      chSemSignalI(&gsem1);
    185c:	86 e3       	ldi	r24, 0x36	; 54
    185e:	99 e0       	ldi	r25, 0x09	; 9
    1860:	0e 94 e4 07 	call	0xfc8	; 0xfc8 <chSemSignalI>
    1864:	de cf       	rjmp	.-68     	; 0x1822 <test_support+0xc>

00001866 <test_001_001_execute>:
 *   it does not happen.
 * .
 */


static void test_001_001_execute(void) {
    1866:	ef 92       	push	r14
    1868:	ff 92       	push	r15
    186a:	0f 93       	push	r16
    186c:	1f 93       	push	r17
  systime_t time;

  /* A System Tick Counter increment is expected, the test simply hangs if
     it does not happen.*/
  test_set_step(1);
    186e:	81 e0       	ldi	r24, 0x01	; 1
    1870:	90 e0       	ldi	r25, 0x00	; 0
    1872:	90 93 81 08 	sts	0x0881, r25
    1876:	80 93 80 08 	sts	0x0880, r24
  
  {
    time = chVTGetSystemTimeX();
    187a:	e0 90 d2 07 	lds	r14, 0x07D2
    187e:	f0 90 d3 07 	lds	r15, 0x07D3
    1882:	00 91 d4 07 	lds	r16, 0x07D4
    1886:	10 91 d5 07 	lds	r17, 0x07D5
    chThdSleepMilliseconds(1); //had to add this after the fact or test hangs with a periodic tick clock.
    188a:	64 e1       	ldi	r22, 0x14	; 20
    188c:	70 e0       	ldi	r23, 0x00	; 0
    188e:	80 e0       	ldi	r24, 0x00	; 0
    1890:	90 e0       	ldi	r25, 0x00	; 0
    1892:	0e 94 f4 08 	call	0x11e8	; 0x11e8 <chThdSleep>
    while (time == chVTGetSystemTimeX()) {
    1896:	80 91 d2 07 	lds	r24, 0x07D2
    189a:	90 91 d3 07 	lds	r25, 0x07D3
    189e:	a0 91 d4 07 	lds	r26, 0x07D4
    18a2:	b0 91 d5 07 	lds	r27, 0x07D5
    18a6:	e8 16       	cp	r14, r24
    18a8:	f9 06       	cpc	r15, r25
    18aa:	0a 07       	cpc	r16, r26
    18ac:	1b 07       	cpc	r17, r27
    18ae:	29 f0       	breq	.+10     	; 0x18ba <test_001_001_execute+0x54>
    }
  }
  
}
    18b0:	1f 91       	pop	r17
    18b2:	0f 91       	pop	r16
    18b4:	ff 90       	pop	r15
    18b6:	ef 90       	pop	r14
    18b8:	08 95       	ret
    18ba:	ff cf       	rjmp	.-2      	; 0x18ba <test_001_001_execute+0x54>

000018bc <test_001_002_execute>:
 * - The current system time is read then a sleep is performed for 1
 *   second and on exit the system time is verified again.
 * .
 */

static void test_001_002_execute(void) {
    18bc:	af 92       	push	r10
    18be:	bf 92       	push	r11
    18c0:	cf 92       	push	r12
    18c2:	df 92       	push	r13
    18c4:	ef 92       	push	r14
    18c6:	ff 92       	push	r15
    18c8:	0f 93       	push	r16
    18ca:	1f 93       	push	r17
  systime_t time;

  /* The current system time is read then a sleep is performed for 100 system
     ticks and on exit the system time is verified again.*/
  test_set_step(1);
    18cc:	81 e0       	ldi	r24, 0x01	; 1
    18ce:	90 e0       	ldi	r25, 0x00	; 0
    18d0:	90 93 81 08 	sts	0x0881, r25
    18d4:	80 93 80 08 	sts	0x0880, r24
  {
    time = chVTGetSystemTimeX();
    18d8:	e0 90 d2 07 	lds	r14, 0x07D2
    18dc:	f0 90 d3 07 	lds	r15, 0x07D3
    18e0:	00 91 d4 07 	lds	r16, 0x07D4
    18e4:	10 91 d5 07 	lds	r17, 0x07D5
    chThdSleep(100);
    18e8:	64 e6       	ldi	r22, 0x64	; 100
    18ea:	70 e0       	ldi	r23, 0x00	; 0
    18ec:	80 e0       	ldi	r24, 0x00	; 0
    18ee:	90 e0       	ldi	r25, 0x00	; 0
    18f0:	0e 94 f4 08 	call	0x11e8	; 0x11e8 <chThdSleep>
    test_assert_time_window(time + 100,
    18f4:	a8 01       	movw	r20, r16
    18f6:	97 01       	movw	r18, r14
    18f8:	2b 59       	subi	r18, 0x9B	; 155
    18fa:	3f 4f       	sbci	r19, 0xFF	; 255
    18fc:	4f 4f       	sbci	r20, 0xFF	; 255
    18fe:	5f 4f       	sbci	r21, 0xFF	; 255
    1900:	84 e6       	ldi	r24, 0x64	; 100
    1902:	90 e0       	ldi	r25, 0x00	; 0
    1904:	a0 e0       	ldi	r26, 0x00	; 0
    1906:	b0 e0       	ldi	r27, 0x00	; 0
    1908:	e8 0e       	add	r14, r24
    190a:	f9 1e       	adc	r15, r25
    190c:	0a 1f       	adc	r16, r26
    190e:	1b 1f       	adc	r17, r27
    1910:	c8 01       	movw	r24, r16
    1912:	b7 01       	movw	r22, r14
    1914:	0e ee       	ldi	r16, 0xEE	; 238
    1916:	11 e0       	ldi	r17, 0x01	; 1
    1918:	0e 94 e6 09 	call	0x13cc	; 0x13cc <_test_assert_time_window>
    191c:	88 23       	and	r24, r24
    191e:	49 f0       	breq	.+18     	; 0x1932 <test_001_002_execute+0x76>
    chThdSleepUntil(time + 100);
    test_assert_time_window(time + 100,
                            time + 100 + US2ST(50),
                            "out of time window");
  }
}
    1920:	1f 91       	pop	r17
    1922:	0f 91       	pop	r16
    1924:	ff 90       	pop	r15
    1926:	ef 90       	pop	r14
    1928:	df 90       	pop	r13
    192a:	cf 90       	pop	r12
    192c:	bf 90       	pop	r11
    192e:	af 90       	pop	r10
    1930:	08 95       	ret
                            "out of time window");
  }

  /* The current system time is read then a sleep is performed for 100000
     microseconds and on exit the system time is verified again.*/
  test_set_step(2);
    1932:	82 e0       	ldi	r24, 0x02	; 2
    1934:	90 e0       	ldi	r25, 0x00	; 0
    1936:	90 93 81 08 	sts	0x0881, r25
    193a:	80 93 80 08 	sts	0x0880, r24
  {
    time = chVTGetSystemTimeX();
    193e:	e0 90 d2 07 	lds	r14, 0x07D2
    1942:	f0 90 d3 07 	lds	r15, 0x07D3
    1946:	00 91 d4 07 	lds	r16, 0x07D4
    194a:	10 91 d5 07 	lds	r17, 0x07D5
    chThdSleepMicroseconds(100);
    194e:	62 e0       	ldi	r22, 0x02	; 2
    1950:	70 e0       	ldi	r23, 0x00	; 0
    1952:	80 e0       	ldi	r24, 0x00	; 0
    1954:	90 e0       	ldi	r25, 0x00	; 0
    1956:	0e 94 f4 08 	call	0x11e8	; 0x11e8 <chThdSleep>
    test_assert_time_window(time + US2ST(100),
    195a:	a8 01       	movw	r20, r16
    195c:	97 01       	movw	r18, r14
    195e:	2d 5f       	subi	r18, 0xFD	; 253
    1960:	3f 4f       	sbci	r19, 0xFF	; 255
    1962:	4f 4f       	sbci	r20, 0xFF	; 255
    1964:	5f 4f       	sbci	r21, 0xFF	; 255
    1966:	82 e0       	ldi	r24, 0x02	; 2
    1968:	90 e0       	ldi	r25, 0x00	; 0
    196a:	a0 e0       	ldi	r26, 0x00	; 0
    196c:	b0 e0       	ldi	r27, 0x00	; 0
    196e:	e8 0e       	add	r14, r24
    1970:	f9 1e       	adc	r15, r25
    1972:	0a 1f       	adc	r16, r26
    1974:	1b 1f       	adc	r17, r27
    1976:	c8 01       	movw	r24, r16
    1978:	b7 01       	movw	r22, r14
    197a:	0e ee       	ldi	r16, 0xEE	; 238
    197c:	11 e0       	ldi	r17, 0x01	; 1
    197e:	0e 94 e6 09 	call	0x13cc	; 0x13cc <_test_assert_time_window>
    1982:	88 23       	and	r24, r24
    1984:	69 f6       	brne	.-102    	; 0x1920 <test_001_002_execute+0x64>
                            "out of time window");
  }

  /* The current system time is read then a sleep is performed for 100
     milliseconds and on exit the system time is verified again.*/
  test_set_step(3);
    1986:	83 e0       	ldi	r24, 0x03	; 3
    1988:	90 e0       	ldi	r25, 0x00	; 0
    198a:	90 93 81 08 	sts	0x0881, r25
    198e:	80 93 80 08 	sts	0x0880, r24
  {
    time = chVTGetSystemTimeX();
    1992:	e0 90 d2 07 	lds	r14, 0x07D2
    1996:	f0 90 d3 07 	lds	r15, 0x07D3
    199a:	00 91 d4 07 	lds	r16, 0x07D4
    199e:	10 91 d5 07 	lds	r17, 0x07D5
    chThdSleepMilliseconds(100);
    19a2:	60 ed       	ldi	r22, 0xD0	; 208
    19a4:	77 e0       	ldi	r23, 0x07	; 7
    19a6:	80 e0       	ldi	r24, 0x00	; 0
    19a8:	90 e0       	ldi	r25, 0x00	; 0
    19aa:	0e 94 f4 08 	call	0x11e8	; 0x11e8 <chThdSleep>
    test_assert_time_window(time + MS2ST(100),
    19ae:	a8 01       	movw	r20, r16
    19b0:	97 01       	movw	r18, r14
    19b2:	2f 52       	subi	r18, 0x2F	; 47
    19b4:	38 4f       	sbci	r19, 0xF8	; 248
    19b6:	4f 4f       	sbci	r20, 0xFF	; 255
    19b8:	5f 4f       	sbci	r21, 0xFF	; 255
    19ba:	80 ed       	ldi	r24, 0xD0	; 208
    19bc:	97 e0       	ldi	r25, 0x07	; 7
    19be:	a0 e0       	ldi	r26, 0x00	; 0
    19c0:	b0 e0       	ldi	r27, 0x00	; 0
    19c2:	e8 0e       	add	r14, r24
    19c4:	f9 1e       	adc	r15, r25
    19c6:	0a 1f       	adc	r16, r26
    19c8:	1b 1f       	adc	r17, r27
    19ca:	c8 01       	movw	r24, r16
    19cc:	b7 01       	movw	r22, r14
    19ce:	0e ee       	ldi	r16, 0xEE	; 238
    19d0:	11 e0       	ldi	r17, 0x01	; 1
    19d2:	0e 94 e6 09 	call	0x13cc	; 0x13cc <_test_assert_time_window>
    19d6:	88 23       	and	r24, r24
    19d8:	09 f0       	breq	.+2      	; 0x19dc <test_001_002_execute+0x120>
    19da:	a2 cf       	rjmp	.-188    	; 0x1920 <test_001_002_execute+0x64>
                            "out of time window");
  }

  /* The current system time is read then a sleep is performed for 1
     second and on exit the system time is verified again.*/
  test_set_step(4);
    19dc:	84 e0       	ldi	r24, 0x04	; 4
    19de:	90 e0       	ldi	r25, 0x00	; 0
    19e0:	90 93 81 08 	sts	0x0881, r25
    19e4:	80 93 80 08 	sts	0x0880, r24
  {
    time = chVTGetSystemTimeX();
    19e8:	e0 90 d2 07 	lds	r14, 0x07D2
    19ec:	f0 90 d3 07 	lds	r15, 0x07D3
    19f0:	00 91 d4 07 	lds	r16, 0x07D4
    19f4:	10 91 d5 07 	lds	r17, 0x07D5
    chThdSleepSeconds(1);
    19f8:	60 e2       	ldi	r22, 0x20	; 32
    19fa:	7e e4       	ldi	r23, 0x4E	; 78
    19fc:	80 e0       	ldi	r24, 0x00	; 0
    19fe:	90 e0       	ldi	r25, 0x00	; 0
    1a00:	0e 94 f4 08 	call	0x11e8	; 0x11e8 <chThdSleep>
    test_assert_time_window(time + S2ST(1),
    1a04:	a8 01       	movw	r20, r16
    1a06:	97 01       	movw	r18, r14
    1a08:	2f 5d       	subi	r18, 0xDF	; 223
    1a0a:	31 4b       	sbci	r19, 0xB1	; 177
    1a0c:	4f 4f       	sbci	r20, 0xFF	; 255
    1a0e:	5f 4f       	sbci	r21, 0xFF	; 255
    1a10:	80 e2       	ldi	r24, 0x20	; 32
    1a12:	9e e4       	ldi	r25, 0x4E	; 78
    1a14:	a0 e0       	ldi	r26, 0x00	; 0
    1a16:	b0 e0       	ldi	r27, 0x00	; 0
    1a18:	e8 0e       	add	r14, r24
    1a1a:	f9 1e       	adc	r15, r25
    1a1c:	0a 1f       	adc	r16, r26
    1a1e:	1b 1f       	adc	r17, r27
    1a20:	c8 01       	movw	r24, r16
    1a22:	b7 01       	movw	r22, r14
    1a24:	0e ee       	ldi	r16, 0xEE	; 238
    1a26:	11 e0       	ldi	r17, 0x01	; 1
    1a28:	0e 94 e6 09 	call	0x13cc	; 0x13cc <_test_assert_time_window>
    1a2c:	88 23       	and	r24, r24
    1a2e:	09 f0       	breq	.+2      	; 0x1a32 <test_001_002_execute+0x176>
    1a30:	77 cf       	rjmp	.-274    	; 0x1920 <test_001_002_execute+0x64>
                            time + S2ST(1) + US2ST(50),
                            "out of time window");
  }

  test_set_step(5);
    1a32:	85 e0       	ldi	r24, 0x05	; 5
    1a34:	90 e0       	ldi	r25, 0x00	; 0
    1a36:	90 93 81 08 	sts	0x0881, r25
    1a3a:	80 93 80 08 	sts	0x0880, r24
  {
    time = chVTGetSystemTimeX();
    1a3e:	e0 90 d2 07 	lds	r14, 0x07D2
    1a42:	f0 90 d3 07 	lds	r15, 0x07D3
    1a46:	00 91 d4 07 	lds	r16, 0x07D4
    1a4a:	10 91 d5 07 	lds	r17, 0x07D5
    chThdSleepUntil(time + 100);
    1a4e:	84 e6       	ldi	r24, 0x64	; 100
    1a50:	a8 2e       	mov	r10, r24
    1a52:	b1 2c       	mov	r11, r1
    1a54:	c1 2c       	mov	r12, r1
    1a56:	d1 2c       	mov	r13, r1
    1a58:	ae 0c       	add	r10, r14
    1a5a:	bf 1c       	adc	r11, r15
    1a5c:	c0 1e       	adc	r12, r16
    1a5e:	d1 1e       	adc	r13, r17
    1a60:	c6 01       	movw	r24, r12
    1a62:	b5 01       	movw	r22, r10
    1a64:	0e 94 e0 08 	call	0x11c0	; 0x11c0 <chThdSleepUntil>
    test_assert_time_window(time + 100,
    1a68:	85 e6       	ldi	r24, 0x65	; 101
    1a6a:	90 e0       	ldi	r25, 0x00	; 0
    1a6c:	a0 e0       	ldi	r26, 0x00	; 0
    1a6e:	b0 e0       	ldi	r27, 0x00	; 0
    1a70:	e8 0e       	add	r14, r24
    1a72:	f9 1e       	adc	r15, r25
    1a74:	0a 1f       	adc	r16, r26
    1a76:	1b 1f       	adc	r17, r27
    1a78:	c6 01       	movw	r24, r12
    1a7a:	b5 01       	movw	r22, r10
    1a7c:	a8 01       	movw	r20, r16
    1a7e:	97 01       	movw	r18, r14
    1a80:	0e ee       	ldi	r16, 0xEE	; 238
    1a82:	11 e0       	ldi	r17, 0x01	; 1
    1a84:	0e 94 e6 09 	call	0x13cc	; 0x13cc <_test_assert_time_window>
    1a88:	4b cf       	rjmp	.-362    	; 0x1920 <test_001_002_execute+0x64>

00001a8a <test_002_001_setup>:
 * .
 */

static void test_002_001_setup(void) {

  chSemObjectInit(&sem1, 1);
    1a8a:	81 e0       	ldi	r24, 0x01	; 1
    1a8c:	80 93 12 07 	sts	0x0712, r24
}
    1a90:	08 95       	ret

00001a92 <test_002_002_setup>:
 * .
 */

static void test_002_002_setup(void) {

  chSemObjectInit(&sem1, 0);
    1a92:	10 92 12 07 	sts	0x0712, r1
}
    1a96:	08 95       	ret

00001a98 <test_002_003_setup>:
 * .
 */

static void test_002_003_setup(void) {

  chSemObjectInit(&sem1, 0);
    1a98:	10 92 12 07 	sts	0x0712, r1
}
    1a9c:	08 95       	ret

00001a9e <test_002_004_setup>:
 * .
 */

static void test_002_004_setup(void) {

  tr1 = NULL;
    1a9e:	10 92 14 07 	sts	0x0714, r1
    1aa2:	10 92 13 07 	sts	0x0713, r1
}
    1aa6:	08 95       	ret

00001aa8 <test_002_005_setup>:
 *   wakeup the thread, the function must return because timeout.
 */

static void test_002_005_setup(void) {

  chSemObjectInit(&sem1, 0);
    1aa8:	10 92 12 07 	sts	0x0712, r1
}
    1aac:	08 95       	ret

00001aae <test_002_005_execute>:

static void test_002_005_execute(void) {
    1aae:	df 92       	push	r13
    1ab0:	ef 92       	push	r14
    1ab2:	ff 92       	push	r15
    1ab4:	0f 93       	push	r16
    1ab6:	1f 93       	push	r17

  /* A set of event flags are set on the current thread then the
     function chVTGetSystemTimeX() is invoked, the function is supposed to
     return immediately because the event flags are already pending,
     after return the events mask is tested.*/
  test_set_step(1);
    1ab8:	81 e0       	ldi	r24, 0x01	; 1
    1aba:	90 e0       	ldi	r25, 0x00	; 0
    1abc:	90 93 81 08 	sts	0x0881, r25
    1ac0:	80 93 80 08 	sts	0x0880, r24
  {
    time = chVTGetSystemTimeX();
    chEvtSignalI(chThdGetSelfX(), 0x55);
    1ac4:	80 91 ce 07 	lds	r24, 0x07CE
    1ac8:	90 91 cf 07 	lds	r25, 0x07CF
    1acc:	65 e5       	ldi	r22, 0x55	; 85
    1ace:	0e 94 3a 08 	call	0x1074	; 0x1074 <chEvtSignalI>
    events = chEvtWaitAnyTimeout(ALL_EVENTS, MS2ST(1000));
    1ad2:	8f ef       	ldi	r24, 0xFF	; 255
    1ad4:	40 e2       	ldi	r20, 0x20	; 32
    1ad6:	5e e4       	ldi	r21, 0x4E	; 78
    1ad8:	60 e0       	ldi	r22, 0x00	; 0
    1ada:	70 e0       	ldi	r23, 0x00	; 0
    1adc:	0e 94 b4 08 	call	0x1168	; 0x1168 <chEvtWaitAnyTimeout>
    1ae0:	18 2f       	mov	r17, r24
    test_assert((eventmask_t)0 != events,
    1ae2:	80 e0       	ldi	r24, 0x00	; 0
    1ae4:	11 11       	cpse	r17, r1
    1ae6:	81 e0       	ldi	r24, 0x01	; 1
    1ae8:	64 e5       	ldi	r22, 0x54	; 84
    1aea:	72 e0       	ldi	r23, 0x02	; 2
    1aec:	0e 94 b3 09 	call	0x1366	; 0x1366 <_test_assert>
    1af0:	88 23       	and	r24, r24
    1af2:	31 f0       	breq	.+12     	; 0x1b00 <test_002_005_execute+0x52>
                            time + MS2ST(1000) + US2ST(100),
                            "out of time window");
    test_assert((eventmask_t)0 == events,
                "wrong events mask");
  }
}
    1af4:	1f 91       	pop	r17
    1af6:	0f 91       	pop	r16
    1af8:	ff 90       	pop	r15
    1afa:	ef 90       	pop	r14
    1afc:	df 90       	pop	r13
    1afe:	08 95       	ret
    time = chVTGetSystemTimeX();
    chEvtSignalI(chThdGetSelfX(), 0x55);
    events = chEvtWaitAnyTimeout(ALL_EVENTS, MS2ST(1000));
    test_assert((eventmask_t)0 != events,
                "timed out");
    test_assert((eventmask_t)0x55 == events,
    1b00:	15 35       	cpi	r17, 0x55	; 85
    1b02:	09 f4       	brne	.+2      	; 0x1b06 <test_002_005_execute+0x58>
    1b04:	62 c0       	rjmp	.+196    	; 0x1bca <test_002_005_execute+0x11c>
    1b06:	6e e5       	ldi	r22, 0x5E	; 94
    1b08:	72 e0       	ldi	r23, 0x02	; 2
    1b0a:	0e 94 b3 09 	call	0x1366	; 0x1366 <_test_assert>
    1b0e:	88 23       	and	r24, r24
    1b10:	89 f7       	brne	.-30     	; 0x1af4 <test_002_005_execute+0x46>
  }

  /* The pending event flags mask is cleared then the function
     chVTGetSystemTimeX() is invoked, after return the events
     mask is tested. The thread is signaled by another thread.*/
  test_set_step(2);
    1b12:	82 e0       	ldi	r24, 0x02	; 2
    1b14:	90 e0       	ldi	r25, 0x00	; 0
    1b16:	90 93 81 08 	sts	0x0881, r25
    1b1a:	80 93 80 08 	sts	0x0880, r24
  {
    time = chVTGetSystemTimeX();
    chThdGetSelfX()->epmask = 0;
    1b1e:	e0 91 ce 07 	lds	r30, 0x07CE
    1b22:	f0 91 cf 07 	lds	r31, 0x07CF
    1b26:	11 86       	std	Z+9, r1	; 0x09
    events = chEvtWaitAnyTimeout(ALL_EVENTS, MS2ST(1000));
    1b28:	8f ef       	ldi	r24, 0xFF	; 255
    1b2a:	40 e2       	ldi	r20, 0x20	; 32
    1b2c:	5e e4       	ldi	r21, 0x4E	; 78
    1b2e:	60 e0       	ldi	r22, 0x00	; 0
    1b30:	70 e0       	ldi	r23, 0x00	; 0
    1b32:	0e 94 b4 08 	call	0x1168	; 0x1168 <chEvtWaitAnyTimeout>
    1b36:	18 2f       	mov	r17, r24
    test_assert((eventmask_t)0 != events,
    1b38:	80 e0       	ldi	r24, 0x00	; 0
    1b3a:	11 11       	cpse	r17, r1
    1b3c:	81 e0       	ldi	r24, 0x01	; 1
    1b3e:	64 e5       	ldi	r22, 0x54	; 84
    1b40:	72 e0       	ldi	r23, 0x02	; 2
    1b42:	0e 94 b3 09 	call	0x1366	; 0x1366 <_test_assert>
    1b46:	88 23       	and	r24, r24
    1b48:	a9 f6       	brne	.-86     	; 0x1af4 <test_002_005_execute+0x46>
                "timed out");
    test_assert((eventmask_t)0x55 == events,
    1b4a:	15 35       	cpi	r17, 0x55	; 85
    1b4c:	09 f4       	brne	.+2      	; 0x1b50 <test_002_005_execute+0xa2>
    1b4e:	3f c0       	rjmp	.+126    	; 0x1bce <test_002_005_execute+0x120>
    1b50:	6e e5       	ldi	r22, 0x5E	; 94
    1b52:	72 e0       	ldi	r23, 0x02	; 2
    1b54:	0e 94 b3 09 	call	0x1366	; 0x1366 <_test_assert>
    1b58:	88 23       	and	r24, r24
    1b5a:	61 f6       	brne	.-104    	; 0x1af4 <test_002_005_execute+0x46>
                "wrong events mask");
  }

  /* The function chVTGetSystemTimeX() is invoked, no event can
     wakeup the thread, the function must return because timeout.*/
  test_set_step(3);
    1b5c:	83 e0       	ldi	r24, 0x03	; 3
    1b5e:	90 e0       	ldi	r25, 0x00	; 0
    1b60:	90 93 81 08 	sts	0x0881, r25
    1b64:	80 93 80 08 	sts	0x0880, r24
    1b68:	f8 94       	cli
  {
    chSysLock();
    time = chVTGetSystemTimeX();
    1b6a:	e0 90 d2 07 	lds	r14, 0x07D2
    1b6e:	f0 90 d3 07 	lds	r15, 0x07D3
    1b72:	00 91 d4 07 	lds	r16, 0x07D4
    1b76:	10 91 d5 07 	lds	r17, 0x07D5
    events = chEvtWaitAnyTimeoutS(0, MS2ST(1000));
    1b7a:	80 e0       	ldi	r24, 0x00	; 0
    1b7c:	40 e2       	ldi	r20, 0x20	; 32
    1b7e:	5e e4       	ldi	r21, 0x4E	; 78
    1b80:	60 e0       	ldi	r22, 0x00	; 0
    1b82:	70 e0       	ldi	r23, 0x00	; 0
    1b84:	0e 94 85 08 	call	0x110a	; 0x110a <chEvtWaitAnyTimeoutS>
    1b88:	d8 2e       	mov	r13, r24
    1b8a:	78 94       	sei
    chSysUnlock();
    test_assert_time_window(time + MS2ST(1000),
    1b8c:	a8 01       	movw	r20, r16
    1b8e:	97 01       	movw	r18, r14
    1b90:	2e 5d       	subi	r18, 0xDE	; 222
    1b92:	31 4b       	sbci	r19, 0xB1	; 177
    1b94:	4f 4f       	sbci	r20, 0xFF	; 255
    1b96:	5f 4f       	sbci	r21, 0xFF	; 255
    1b98:	80 e2       	ldi	r24, 0x20	; 32
    1b9a:	9e e4       	ldi	r25, 0x4E	; 78
    1b9c:	a0 e0       	ldi	r26, 0x00	; 0
    1b9e:	b0 e0       	ldi	r27, 0x00	; 0
    1ba0:	e8 0e       	add	r14, r24
    1ba2:	f9 1e       	adc	r15, r25
    1ba4:	0a 1f       	adc	r16, r26
    1ba6:	1b 1f       	adc	r17, r27
    1ba8:	c8 01       	movw	r24, r16
    1baa:	b7 01       	movw	r22, r14
    1bac:	00 e7       	ldi	r16, 0x70	; 112
    1bae:	12 e0       	ldi	r17, 0x02	; 2
    1bb0:	0e 94 e6 09 	call	0x13cc	; 0x13cc <_test_assert_time_window>
    1bb4:	88 23       	and	r24, r24
    1bb6:	09 f0       	breq	.+2      	; 0x1bba <test_002_005_execute+0x10c>
    1bb8:	9d cf       	rjmp	.-198    	; 0x1af4 <test_002_005_execute+0x46>
                            time + MS2ST(1000) + US2ST(100),
                            "out of time window");
    test_assert((eventmask_t)0 == events,
    1bba:	dd 20       	and	r13, r13
    1bbc:	09 f4       	brne	.+2      	; 0x1bc0 <test_002_005_execute+0x112>
    1bbe:	81 e0       	ldi	r24, 0x01	; 1
    1bc0:	6e e5       	ldi	r22, 0x5E	; 94
    1bc2:	72 e0       	ldi	r23, 0x02	; 2
    1bc4:	0e 94 b3 09 	call	0x1366	; 0x1366 <_test_assert>
    1bc8:	95 cf       	rjmp	.-214    	; 0x1af4 <test_002_005_execute+0x46>
    time = chVTGetSystemTimeX();
    chEvtSignalI(chThdGetSelfX(), 0x55);
    events = chEvtWaitAnyTimeout(ALL_EVENTS, MS2ST(1000));
    test_assert((eventmask_t)0 != events,
                "timed out");
    test_assert((eventmask_t)0x55 == events,
    1bca:	81 e0       	ldi	r24, 0x01	; 1
    1bcc:	9c cf       	rjmp	.-200    	; 0x1b06 <test_002_005_execute+0x58>
    time = chVTGetSystemTimeX();
    chThdGetSelfX()->epmask = 0;
    events = chEvtWaitAnyTimeout(ALL_EVENTS, MS2ST(1000));
    test_assert((eventmask_t)0 != events,
                "timed out");
    test_assert((eventmask_t)0x55 == events,
    1bce:	81 e0       	ldi	r24, 0x01	; 1
    1bd0:	bf cf       	rjmp	.-130    	; 0x1b50 <test_002_005_execute+0xa2>

00001bd2 <test_002_004_execute>:
static void test_002_004_setup(void) {

  tr1 = NULL;
}

static void test_002_004_execute(void) {
    1bd2:	ef 92       	push	r14
    1bd4:	ff 92       	push	r15
    1bd6:	0f 93       	push	r16
    1bd8:	1f 93       	push	r17
    1bda:	cf 93       	push	r28
    1bdc:	df 93       	push	r29
  msg_t msg;

  /* The function chThdSuspendTimeoutS() is invoked, the thread is
     remotely resumed with message @p MSG_OK. On return the message
     and the state of the reference are tested.*/
  test_set_step(1);
    1bde:	81 e0       	ldi	r24, 0x01	; 1
    1be0:	90 e0       	ldi	r25, 0x00	; 0
    1be2:	90 93 81 08 	sts	0x0881, r25
    1be6:	80 93 80 08 	sts	0x0880, r24
  {
    msg = chThdSuspendTimeoutS(&gtr1, TIME_INFINITE);
    1bea:	87 e3       	ldi	r24, 0x37	; 55
    1bec:	99 e0       	ldi	r25, 0x09	; 9
    1bee:	40 e0       	ldi	r20, 0x00	; 0
    1bf0:	50 e0       	ldi	r21, 0x00	; 0
    1bf2:	60 e0       	ldi	r22, 0x00	; 0
    1bf4:	70 e0       	ldi	r23, 0x00	; 0
    1bf6:	0e 94 fc 08 	call	0x11f8	; 0x11f8 <chThdSuspendTimeoutS>
    1bfa:	8c 01       	movw	r16, r24
    test_assert(NULL == gtr1,
    1bfc:	20 e0       	ldi	r18, 0x00	; 0
    1bfe:	80 91 37 09 	lds	r24, 0x0937
    1c02:	90 91 38 09 	lds	r25, 0x0938
    1c06:	89 2b       	or	r24, r25
    1c08:	09 f4       	brne	.+2      	; 0x1c0c <test_002_004_execute+0x3a>
    1c0a:	21 e0       	ldi	r18, 0x01	; 1
    1c0c:	82 2f       	mov	r24, r18
    1c0e:	63 e8       	ldi	r22, 0x83	; 131
    1c10:	72 e0       	ldi	r23, 0x02	; 2
    1c12:	0e 94 b3 09 	call	0x1366	; 0x1366 <_test_assert>
    1c16:	88 23       	and	r24, r24
    1c18:	39 f0       	breq	.+14     	; 0x1c28 <test_002_004_execute+0x56>
    test_assert(NULL == tr1,
                "not NULL");
    test_assert(MSG_TIMEOUT == msg,
                "wrong returned message");
  }
}
    1c1a:	df 91       	pop	r29
    1c1c:	cf 91       	pop	r28
    1c1e:	1f 91       	pop	r17
    1c20:	0f 91       	pop	r16
    1c22:	ff 90       	pop	r15
    1c24:	ef 90       	pop	r14
    1c26:	08 95       	ret
  test_set_step(1);
  {
    msg = chThdSuspendTimeoutS(&gtr1, TIME_INFINITE);
    test_assert(NULL == gtr1,
                "not NULL");
    test_assert(MSG_OK == msg,
    1c28:	01 2b       	or	r16, r17
    1c2a:	09 f4       	brne	.+2      	; 0x1c2e <test_002_004_execute+0x5c>
    1c2c:	4b c0       	rjmp	.+150    	; 0x1cc4 <test_002_004_execute+0xf2>
    1c2e:	6c e8       	ldi	r22, 0x8C	; 140
    1c30:	72 e0       	ldi	r23, 0x02	; 2
    1c32:	0e 94 b3 09 	call	0x1366	; 0x1366 <_test_assert>
    1c36:	88 23       	and	r24, r24
    1c38:	81 f7       	brne	.-32     	; 0x1c1a <test_002_004_execute+0x48>
  }

  /* The function chThdSuspendTimeoutS() is invoked, the thread is
     not resumed so a timeout must occur. On return the message
     and the state of the reference are tested.*/
  test_set_step(2);
    1c3a:	82 e0       	ldi	r24, 0x02	; 2
    1c3c:	90 e0       	ldi	r25, 0x00	; 0
    1c3e:	90 93 81 08 	sts	0x0881, r25
    1c42:	80 93 80 08 	sts	0x0880, r24
  {
    time = chVTGetSystemTimeX();
    1c46:	e0 90 d2 07 	lds	r14, 0x07D2
    1c4a:	f0 90 d3 07 	lds	r15, 0x07D3
    1c4e:	00 91 d4 07 	lds	r16, 0x07D4
    1c52:	10 91 d5 07 	lds	r17, 0x07D5
    msg = chThdSuspendTimeoutS(&tr1, MS2ST(1000));
    1c56:	83 e1       	ldi	r24, 0x13	; 19
    1c58:	97 e0       	ldi	r25, 0x07	; 7
    1c5a:	40 e2       	ldi	r20, 0x20	; 32
    1c5c:	5e e4       	ldi	r21, 0x4E	; 78
    1c5e:	60 e0       	ldi	r22, 0x00	; 0
    1c60:	70 e0       	ldi	r23, 0x00	; 0
    1c62:	0e 94 fc 08 	call	0x11f8	; 0x11f8 <chThdSuspendTimeoutS>
    1c66:	ec 01       	movw	r28, r24
    test_assert_time_window(time + MS2ST(1000),
    1c68:	a8 01       	movw	r20, r16
    1c6a:	97 01       	movw	r18, r14
    1c6c:	2f 5d       	subi	r18, 0xDF	; 223
    1c6e:	31 4b       	sbci	r19, 0xB1	; 177
    1c70:	4f 4f       	sbci	r20, 0xFF	; 255
    1c72:	5f 4f       	sbci	r21, 0xFF	; 255
    1c74:	80 e2       	ldi	r24, 0x20	; 32
    1c76:	9e e4       	ldi	r25, 0x4E	; 78
    1c78:	a0 e0       	ldi	r26, 0x00	; 0
    1c7a:	b0 e0       	ldi	r27, 0x00	; 0
    1c7c:	e8 0e       	add	r14, r24
    1c7e:	f9 1e       	adc	r15, r25
    1c80:	0a 1f       	adc	r16, r26
    1c82:	1b 1f       	adc	r17, r27
    1c84:	c8 01       	movw	r24, r16
    1c86:	b7 01       	movw	r22, r14
    1c88:	00 e7       	ldi	r16, 0x70	; 112
    1c8a:	12 e0       	ldi	r17, 0x02	; 2
    1c8c:	0e 94 e6 09 	call	0x13cc	; 0x13cc <_test_assert_time_window>
    1c90:	88 23       	and	r24, r24
    1c92:	19 f6       	brne	.-122    	; 0x1c1a <test_002_004_execute+0x48>
                            time + MS2ST(1000) + US2ST(50),
                            "out of time window");
    test_assert(NULL == tr1,
    1c94:	20 e0       	ldi	r18, 0x00	; 0
    1c96:	80 91 13 07 	lds	r24, 0x0713
    1c9a:	90 91 14 07 	lds	r25, 0x0714
    1c9e:	89 2b       	or	r24, r25
    1ca0:	09 f4       	brne	.+2      	; 0x1ca4 <test_002_004_execute+0xd2>
    1ca2:	21 e0       	ldi	r18, 0x01	; 1
    1ca4:	82 2f       	mov	r24, r18
    1ca6:	63 e8       	ldi	r22, 0x83	; 131
    1ca8:	72 e0       	ldi	r23, 0x02	; 2
    1caa:	0e 94 b3 09 	call	0x1366	; 0x1366 <_test_assert>
    1cae:	88 23       	and	r24, r24
    1cb0:	09 f0       	breq	.+2      	; 0x1cb4 <test_002_004_execute+0xe2>
    1cb2:	b3 cf       	rjmp	.-154    	; 0x1c1a <test_002_004_execute+0x48>
                "not NULL");
    test_assert(MSG_TIMEOUT == msg,
    1cb4:	cf 5f       	subi	r28, 0xFF	; 255
    1cb6:	df 4f       	sbci	r29, 0xFF	; 255
    1cb8:	71 f0       	breq	.+28     	; 0x1cd6 <test_002_004_execute+0x104>
    1cba:	6c e8       	ldi	r22, 0x8C	; 140
    1cbc:	72 e0       	ldi	r23, 0x02	; 2
    1cbe:	0e 94 b3 09 	call	0x1366	; 0x1366 <_test_assert>
    1cc2:	ab cf       	rjmp	.-170    	; 0x1c1a <test_002_004_execute+0x48>
  test_set_step(1);
  {
    msg = chThdSuspendTimeoutS(&gtr1, TIME_INFINITE);
    test_assert(NULL == gtr1,
                "not NULL");
    test_assert(MSG_OK == msg,
    1cc4:	81 e0       	ldi	r24, 0x01	; 1
    1cc6:	6c e8       	ldi	r22, 0x8C	; 140
    1cc8:	72 e0       	ldi	r23, 0x02	; 2
    1cca:	0e 94 b3 09 	call	0x1366	; 0x1366 <_test_assert>
    1cce:	88 23       	and	r24, r24
    1cd0:	09 f0       	breq	.+2      	; 0x1cd4 <test_002_004_execute+0x102>
    1cd2:	a3 cf       	rjmp	.-186    	; 0x1c1a <test_002_004_execute+0x48>
    1cd4:	b2 cf       	rjmp	.-156    	; 0x1c3a <test_002_004_execute+0x68>
    test_assert_time_window(time + MS2ST(1000),
                            time + MS2ST(1000) + US2ST(50),
                            "out of time window");
    test_assert(NULL == tr1,
                "not NULL");
    test_assert(MSG_TIMEOUT == msg,
    1cd6:	81 e0       	ldi	r24, 0x01	; 1
    1cd8:	f0 cf       	rjmp	.-32     	; 0x1cba <test_002_004_execute+0xe8>

00001cda <test_002_003_execute>:
static void test_002_003_teardown(void) {

  chSemReset(&sem1, 0);
}

static void test_002_003_execute(void) {
    1cda:	ef 92       	push	r14
    1cdc:	ff 92       	push	r15
    1cde:	0f 93       	push	r16
    1ce0:	1f 93       	push	r17
    1ce2:	cf 93       	push	r28
    1ce4:	df 93       	push	r29
  systime_t time;
  msg_t msg;

  /* The function chSemWaitTimeout() is invoked, after return the system
     time, the counter and the returned message are tested.*/
  test_set_step(1);
    1ce6:	81 e0       	ldi	r24, 0x01	; 1
    1ce8:	90 e0       	ldi	r25, 0x00	; 0
    1cea:	90 93 81 08 	sts	0x0881, r25
    1cee:	80 93 80 08 	sts	0x0880, r24
  {
    time = chVTGetSystemTimeX();
    1cf2:	e0 90 d2 07 	lds	r14, 0x07D2
    1cf6:	f0 90 d3 07 	lds	r15, 0x07D3
    1cfa:	00 91 d4 07 	lds	r16, 0x07D4
    1cfe:	10 91 d5 07 	lds	r17, 0x07D5
    msg = chSemWaitTimeout(&sem1, MS2ST(1000));
    1d02:	82 e1       	ldi	r24, 0x12	; 18
    1d04:	97 e0       	ldi	r25, 0x07	; 7
    1d06:	40 e2       	ldi	r20, 0x20	; 32
    1d08:	5e e4       	ldi	r21, 0x4E	; 78
    1d0a:	60 e0       	ldi	r22, 0x00	; 0
    1d0c:	70 e0       	ldi	r23, 0x00	; 0
    1d0e:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
    1d12:	ec 01       	movw	r28, r24
    test_assert_time_window(time + MS2ST(1000),
    1d14:	a8 01       	movw	r20, r16
    1d16:	97 01       	movw	r18, r14
    1d18:	2f 5d       	subi	r18, 0xDF	; 223
    1d1a:	31 4b       	sbci	r19, 0xB1	; 177
    1d1c:	4f 4f       	sbci	r20, 0xFF	; 255
    1d1e:	5f 4f       	sbci	r21, 0xFF	; 255
    1d20:	80 e2       	ldi	r24, 0x20	; 32
    1d22:	9e e4       	ldi	r25, 0x4E	; 78
    1d24:	a0 e0       	ldi	r26, 0x00	; 0
    1d26:	b0 e0       	ldi	r27, 0x00	; 0
    1d28:	e8 0e       	add	r14, r24
    1d2a:	f9 1e       	adc	r15, r25
    1d2c:	0a 1f       	adc	r16, r26
    1d2e:	1b 1f       	adc	r17, r27
    1d30:	c8 01       	movw	r24, r16
    1d32:	b7 01       	movw	r22, r14
    1d34:	00 e7       	ldi	r16, 0x70	; 112
    1d36:	12 e0       	ldi	r17, 0x02	; 2
    1d38:	0e 94 e6 09 	call	0x13cc	; 0x13cc <_test_assert_time_window>
    1d3c:	88 23       	and	r24, r24
    1d3e:	39 f0       	breq	.+14     	; 0x1d4e <test_002_003_execute+0x74>
    test_assert_lock(chSemGetCounterI(&sem1) == 0,
                     "wrong counter value");
    test_assert(MSG_TIMEOUT == msg,
                "wrong timeout message");
  }
}
    1d40:	df 91       	pop	r29
    1d42:	cf 91       	pop	r28
    1d44:	1f 91       	pop	r17
    1d46:	0f 91       	pop	r16
    1d48:	ff 90       	pop	r15
    1d4a:	ef 90       	pop	r14
    1d4c:	08 95       	ret
    1d4e:	f8 94       	cli
    time = chVTGetSystemTimeX();
    msg = chSemWaitTimeout(&sem1, MS2ST(1000));
    test_assert_time_window(time + MS2ST(1000),
                            time + MS2ST(1000) + US2ST(50),
                            "out of time window");
    test_assert_lock(chSemGetCounterI(&sem1) == 0,
    1d50:	80 91 12 07 	lds	r24, 0x0712
    1d54:	90 e0       	ldi	r25, 0x00	; 0
    1d56:	88 23       	and	r24, r24
    1d58:	79 f0       	breq	.+30     	; 0x1d78 <test_002_003_execute+0x9e>
    1d5a:	89 2f       	mov	r24, r25
    1d5c:	63 ea       	ldi	r22, 0xA3	; 163
    1d5e:	72 e0       	ldi	r23, 0x02	; 2
    1d60:	0e 94 b3 09 	call	0x1366	; 0x1366 <_test_assert>
    1d64:	88 23       	and	r24, r24
    1d66:	81 f0       	breq	.+32     	; 0x1d88 <test_002_003_execute+0xae>
    1d68:	78 94       	sei
    test_assert_lock(chSemGetCounterI(&sem1) == 0,
                     "wrong counter value");
    test_assert(MSG_TIMEOUT == msg,
                "wrong timeout message");
  }
}
    1d6a:	df 91       	pop	r29
    1d6c:	cf 91       	pop	r28
    1d6e:	1f 91       	pop	r17
    1d70:	0f 91       	pop	r16
    1d72:	ff 90       	pop	r15
    1d74:	ef 90       	pop	r14
    1d76:	08 95       	ret
    time = chVTGetSystemTimeX();
    msg = chSemWaitTimeout(&sem1, MS2ST(1000));
    test_assert_time_window(time + MS2ST(1000),
                            time + MS2ST(1000) + US2ST(50),
                            "out of time window");
    test_assert_lock(chSemGetCounterI(&sem1) == 0,
    1d78:	91 e0       	ldi	r25, 0x01	; 1
    1d7a:	89 2f       	mov	r24, r25
    1d7c:	63 ea       	ldi	r22, 0xA3	; 163
    1d7e:	72 e0       	ldi	r23, 0x02	; 2
    1d80:	0e 94 b3 09 	call	0x1366	; 0x1366 <_test_assert>
    1d84:	88 23       	and	r24, r24
    1d86:	81 f7       	brne	.-32     	; 0x1d68 <test_002_003_execute+0x8e>
                     "wrong counter value");
    test_assert(MSG_TIMEOUT == msg,
    1d88:	78 94       	sei
    1d8a:	80 e0       	ldi	r24, 0x00	; 0
    1d8c:	cf 5f       	subi	r28, 0xFF	; 255
    1d8e:	df 4f       	sbci	r29, 0xFF	; 255
    1d90:	09 f4       	brne	.+2      	; 0x1d94 <test_002_003_execute+0xba>
    1d92:	4d c0       	rjmp	.+154    	; 0x1e2e <test_002_003_execute+0x154>
    1d94:	67 eb       	ldi	r22, 0xB7	; 183
    1d96:	72 e0       	ldi	r23, 0x02	; 2
    1d98:	0e 94 b3 09 	call	0x1366	; 0x1366 <_test_assert>
    1d9c:	88 23       	and	r24, r24
    1d9e:	81 f6       	brne	.-96     	; 0x1d40 <test_002_003_execute+0x66>
                "wrong timeout message");
  }

  /* The function chSemWaitTimeout() is invoked, after return the system
     time, the counter and the returned message are tested.*/
  test_set_step(2);
    1da0:	82 e0       	ldi	r24, 0x02	; 2
    1da2:	90 e0       	ldi	r25, 0x00	; 0
    1da4:	90 93 81 08 	sts	0x0881, r25
    1da8:	80 93 80 08 	sts	0x0880, r24
  {
    time = chVTGetSystemTimeX();
    1dac:	e0 90 d2 07 	lds	r14, 0x07D2
    1db0:	f0 90 d3 07 	lds	r15, 0x07D3
    1db4:	00 91 d4 07 	lds	r16, 0x07D4
    1db8:	10 91 d5 07 	lds	r17, 0x07D5
    msg = chSemWaitTimeout(&sem1, MS2ST(1000));
    1dbc:	82 e1       	ldi	r24, 0x12	; 18
    1dbe:	97 e0       	ldi	r25, 0x07	; 7
    1dc0:	40 e2       	ldi	r20, 0x20	; 32
    1dc2:	5e e4       	ldi	r21, 0x4E	; 78
    1dc4:	60 e0       	ldi	r22, 0x00	; 0
    1dc6:	70 e0       	ldi	r23, 0x00	; 0
    1dc8:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
    1dcc:	ec 01       	movw	r28, r24
    test_assert_time_window(time + MS2ST(1000),
    1dce:	a8 01       	movw	r20, r16
    1dd0:	97 01       	movw	r18, r14
    1dd2:	2f 5d       	subi	r18, 0xDF	; 223
    1dd4:	31 4b       	sbci	r19, 0xB1	; 177
    1dd6:	4f 4f       	sbci	r20, 0xFF	; 255
    1dd8:	5f 4f       	sbci	r21, 0xFF	; 255
    1dda:	80 e2       	ldi	r24, 0x20	; 32
    1ddc:	9e e4       	ldi	r25, 0x4E	; 78
    1dde:	a0 e0       	ldi	r26, 0x00	; 0
    1de0:	b0 e0       	ldi	r27, 0x00	; 0
    1de2:	e8 0e       	add	r14, r24
    1de4:	f9 1e       	adc	r15, r25
    1de6:	0a 1f       	adc	r16, r26
    1de8:	1b 1f       	adc	r17, r27
    1dea:	c8 01       	movw	r24, r16
    1dec:	b7 01       	movw	r22, r14
    1dee:	00 e7       	ldi	r16, 0x70	; 112
    1df0:	12 e0       	ldi	r17, 0x02	; 2
    1df2:	0e 94 e6 09 	call	0x13cc	; 0x13cc <_test_assert_time_window>
    1df6:	88 23       	and	r24, r24
    1df8:	09 f0       	breq	.+2      	; 0x1dfc <test_002_003_execute+0x122>
    1dfa:	a2 cf       	rjmp	.-188    	; 0x1d40 <test_002_003_execute+0x66>
    1dfc:	f8 94       	cli
                            time + MS2ST(1000) + US2ST(50),
                            "out of time window");
    test_assert_lock(chSemGetCounterI(&sem1) == 0,
    1dfe:	80 91 12 07 	lds	r24, 0x0712
    1e02:	90 e0       	ldi	r25, 0x00	; 0
    1e04:	88 23       	and	r24, r24
    1e06:	09 f4       	brne	.+2      	; 0x1e0a <test_002_003_execute+0x130>
    1e08:	91 e0       	ldi	r25, 0x01	; 1
    1e0a:	89 2f       	mov	r24, r25
    1e0c:	63 ea       	ldi	r22, 0xA3	; 163
    1e0e:	72 e0       	ldi	r23, 0x02	; 2
    1e10:	0e 94 b3 09 	call	0x1366	; 0x1366 <_test_assert>
    1e14:	88 23       	and	r24, r24
    1e16:	09 f0       	breq	.+2      	; 0x1e1a <test_002_003_execute+0x140>
    1e18:	a7 cf       	rjmp	.-178    	; 0x1d68 <test_002_003_execute+0x8e>
                     "wrong counter value");
    test_assert(MSG_TIMEOUT == msg,
    1e1a:	78 94       	sei
    1e1c:	80 e0       	ldi	r24, 0x00	; 0
    1e1e:	cf 5f       	subi	r28, 0xFF	; 255
    1e20:	df 4f       	sbci	r29, 0xFF	; 255
    1e22:	39 f0       	breq	.+14     	; 0x1e32 <test_002_003_execute+0x158>
    1e24:	67 eb       	ldi	r22, 0xB7	; 183
    1e26:	72 e0       	ldi	r23, 0x02	; 2
    1e28:	0e 94 b3 09 	call	0x1366	; 0x1366 <_test_assert>
    1e2c:	89 cf       	rjmp	.-238    	; 0x1d40 <test_002_003_execute+0x66>
    test_assert_time_window(time + MS2ST(1000),
                            time + MS2ST(1000) + US2ST(50),
                            "out of time window");
    test_assert_lock(chSemGetCounterI(&sem1) == 0,
                     "wrong counter value");
    test_assert(MSG_TIMEOUT == msg,
    1e2e:	81 e0       	ldi	r24, 0x01	; 1
    1e30:	b1 cf       	rjmp	.-158    	; 0x1d94 <test_002_003_execute+0xba>
    test_assert_time_window(time + MS2ST(1000),
                            time + MS2ST(1000) + US2ST(50),
                            "out of time window");
    test_assert_lock(chSemGetCounterI(&sem1) == 0,
                     "wrong counter value");
    test_assert(MSG_TIMEOUT == msg,
    1e32:	81 e0       	ldi	r24, 0x01	; 1
    1e34:	f7 cf       	rjmp	.-18     	; 0x1e24 <test_002_003_execute+0x14a>

00001e36 <test_002_002_execute>:
static void test_002_002_teardown(void) {

  chSemReset(&sem1, 0);
}

static void test_002_002_execute(void) {
    1e36:	cf 93       	push	r28
    1e38:	df 93       	push	r29

  /* The function chSemWait() is invoked, after return the counter and
     the returned message are tested. The semaphore is signaled by another
     thread.*/
  test_set_step(1);
    1e3a:	81 e0       	ldi	r24, 0x01	; 1
    1e3c:	90 e0       	ldi	r25, 0x00	; 0
    1e3e:	90 93 81 08 	sts	0x0881, r25
    1e42:	80 93 80 08 	sts	0x0880, r24
  {
    msg_t msg;

    msg = chSemWait(&gsem1);
    1e46:	86 e3       	ldi	r24, 0x36	; 54
    1e48:	99 e0       	ldi	r25, 0x09	; 9
    1e4a:	40 e0       	ldi	r20, 0x00	; 0
    1e4c:	50 e0       	ldi	r21, 0x00	; 0
    1e4e:	60 e0       	ldi	r22, 0x00	; 0
    1e50:	70 e0       	ldi	r23, 0x00	; 0
    1e52:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
    1e56:	ec 01       	movw	r28, r24
    1e58:	f8 94       	cli
    test_assert_lock(chSemGetCounterI(&gsem1) == 0,
    1e5a:	80 91 36 09 	lds	r24, 0x0936
    1e5e:	90 e0       	ldi	r25, 0x00	; 0
    1e60:	88 23       	and	r24, r24
    1e62:	09 f4       	brne	.+2      	; 0x1e66 <test_002_002_execute+0x30>
    1e64:	91 e0       	ldi	r25, 0x01	; 1
    1e66:	89 2f       	mov	r24, r25
    1e68:	63 ea       	ldi	r22, 0xA3	; 163
    1e6a:	72 e0       	ldi	r23, 0x02	; 2
    1e6c:	0e 94 b3 09 	call	0x1366	; 0x1366 <_test_assert>
    1e70:	88 23       	and	r24, r24
    1e72:	21 f0       	breq	.+8      	; 0x1e7c <test_002_002_execute+0x46>
    1e74:	78 94       	sei
    test_assert_lock(chSemGetCounterI(&gsem2) == 0,
                     "wrong counter value");
    test_assert(MSG_RESET == msg,
                "wrong returned message");
  }
}
    1e76:	df 91       	pop	r29
    1e78:	cf 91       	pop	r28
    1e7a:	08 95       	ret
  test_set_step(1);
  {
    msg_t msg;

    msg = chSemWait(&gsem1);
    test_assert_lock(chSemGetCounterI(&gsem1) == 0,
    1e7c:	78 94       	sei
                     "wrong counter value");
    test_assert(MSG_OK == msg,
    1e7e:	80 e0       	ldi	r24, 0x00	; 0
    1e80:	cd 2b       	or	r28, r29
    1e82:	69 f1       	breq	.+90     	; 0x1ede <test_002_002_execute+0xa8>
    1e84:	6c e8       	ldi	r22, 0x8C	; 140
    1e86:	72 e0       	ldi	r23, 0x02	; 2
    1e88:	0e 94 b3 09 	call	0x1366	; 0x1366 <_test_assert>
    1e8c:	88 23       	and	r24, r24
    1e8e:	99 f7       	brne	.-26     	; 0x1e76 <test_002_002_execute+0x40>
  }

  /* The function chSemWait() is invoked, after return the counter and
     the returned message are tested. The semaphore is reset by another
     thread.*/
  test_set_step(2);
    1e90:	82 e0       	ldi	r24, 0x02	; 2
    1e92:	90 e0       	ldi	r25, 0x00	; 0
    1e94:	90 93 81 08 	sts	0x0881, r25
    1e98:	80 93 80 08 	sts	0x0880, r24
  {
    msg_t msg;

    msg = chSemWait(&gsem2);
    1e9c:	89 e3       	ldi	r24, 0x39	; 57
    1e9e:	99 e0       	ldi	r25, 0x09	; 9
    1ea0:	40 e0       	ldi	r20, 0x00	; 0
    1ea2:	50 e0       	ldi	r21, 0x00	; 0
    1ea4:	60 e0       	ldi	r22, 0x00	; 0
    1ea6:	70 e0       	ldi	r23, 0x00	; 0
    1ea8:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
    1eac:	ec 01       	movw	r28, r24
    1eae:	f8 94       	cli
    test_assert_lock(chSemGetCounterI(&gsem2) == 0,
    1eb0:	80 91 39 09 	lds	r24, 0x0939
    1eb4:	90 e0       	ldi	r25, 0x00	; 0
    1eb6:	88 23       	and	r24, r24
    1eb8:	09 f4       	brne	.+2      	; 0x1ebc <test_002_002_execute+0x86>
    1eba:	91 e0       	ldi	r25, 0x01	; 1
    1ebc:	89 2f       	mov	r24, r25
    1ebe:	63 ea       	ldi	r22, 0xA3	; 163
    1ec0:	72 e0       	ldi	r23, 0x02	; 2
    1ec2:	0e 94 b3 09 	call	0x1366	; 0x1366 <_test_assert>
    1ec6:	88 23       	and	r24, r24
    1ec8:	a9 f6       	brne	.-86     	; 0x1e74 <test_002_002_execute+0x3e>
                     "wrong counter value");
    test_assert(MSG_RESET == msg,
    1eca:	78 94       	sei
    1ecc:	80 e0       	ldi	r24, 0x00	; 0
    1ece:	ce 5f       	subi	r28, 0xFE	; 254
    1ed0:	df 4f       	sbci	r29, 0xFF	; 255
    1ed2:	69 f0       	breq	.+26     	; 0x1eee <test_002_002_execute+0xb8>
    1ed4:	6c e8       	ldi	r22, 0x8C	; 140
    1ed6:	72 e0       	ldi	r23, 0x02	; 2
    1ed8:	0e 94 b3 09 	call	0x1366	; 0x1366 <_test_assert>
    1edc:	cc cf       	rjmp	.-104    	; 0x1e76 <test_002_002_execute+0x40>
    msg_t msg;

    msg = chSemWait(&gsem1);
    test_assert_lock(chSemGetCounterI(&gsem1) == 0,
                     "wrong counter value");
    test_assert(MSG_OK == msg,
    1ede:	81 e0       	ldi	r24, 0x01	; 1
    1ee0:	6c e8       	ldi	r22, 0x8C	; 140
    1ee2:	72 e0       	ldi	r23, 0x02	; 2
    1ee4:	0e 94 b3 09 	call	0x1366	; 0x1366 <_test_assert>
    1ee8:	88 23       	and	r24, r24
    1eea:	29 f6       	brne	.-118    	; 0x1e76 <test_002_002_execute+0x40>
    1eec:	d1 cf       	rjmp	.-94     	; 0x1e90 <test_002_002_execute+0x5a>
    msg_t msg;

    msg = chSemWait(&gsem2);
    test_assert_lock(chSemGetCounterI(&gsem2) == 0,
                     "wrong counter value");
    test_assert(MSG_RESET == msg,
    1eee:	81 e0       	ldi	r24, 0x01	; 1
    1ef0:	f1 cf       	rjmp	.-30     	; 0x1ed4 <test_002_002_execute+0x9e>

00001ef2 <test_002_003_teardown>:
  chSemObjectInit(&sem1, 0);
}

static void test_002_003_teardown(void) {

  chSemReset(&sem1, 0);
    1ef2:	82 e1       	ldi	r24, 0x12	; 18
    1ef4:	97 e0       	ldi	r25, 0x07	; 7
    1ef6:	60 e0       	ldi	r22, 0x00	; 0
    1ef8:	0e 94 27 09 	call	0x124e	; 0x124e <chSemReset>
}
    1efc:	08 95       	ret

00001efe <test_002_002_teardown>:
  chSemObjectInit(&sem1, 0);
}

static void test_002_002_teardown(void) {

  chSemReset(&sem1, 0);
    1efe:	82 e1       	ldi	r24, 0x12	; 18
    1f00:	97 e0       	ldi	r25, 0x07	; 7
    1f02:	60 e0       	ldi	r22, 0x00	; 0
    1f04:	0e 94 27 09 	call	0x124e	; 0x124e <chSemReset>
}
    1f08:	08 95       	ret

00001f0a <test_002_001_teardown>:
  chSemObjectInit(&sem1, 1);
}

static void test_002_001_teardown(void) {

  chSemReset(&sem1, 0);
    1f0a:	82 e1       	ldi	r24, 0x12	; 18
    1f0c:	97 e0       	ldi	r25, 0x07	; 7
    1f0e:	60 e0       	ldi	r22, 0x00	; 0
    1f10:	0e 94 27 09 	call	0x124e	; 0x124e <chSemReset>
}
    1f14:	08 95       	ret

00001f16 <test_002_001_execute>:

static void test_002_001_execute(void) {
    1f16:	cf 93       	push	r28
    1f18:	df 93       	push	r29

  /* The function chSemWait() is invoked, after return the counter and
     the returned message are tested.*/
  test_set_step(1);
    1f1a:	81 e0       	ldi	r24, 0x01	; 1
    1f1c:	90 e0       	ldi	r25, 0x00	; 0
    1f1e:	90 93 81 08 	sts	0x0881, r25
    1f22:	80 93 80 08 	sts	0x0880, r24
  {
    msg_t msg;

    msg = chSemWait(&sem1);
    1f26:	82 e1       	ldi	r24, 0x12	; 18
    1f28:	97 e0       	ldi	r25, 0x07	; 7
    1f2a:	40 e0       	ldi	r20, 0x00	; 0
    1f2c:	50 e0       	ldi	r21, 0x00	; 0
    1f2e:	60 e0       	ldi	r22, 0x00	; 0
    1f30:	70 e0       	ldi	r23, 0x00	; 0
    1f32:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
    1f36:	ec 01       	movw	r28, r24
    1f38:	f8 94       	cli
    test_assert_lock(chSemGetCounterI(&sem1) == 0,
    1f3a:	80 91 12 07 	lds	r24, 0x0712
    1f3e:	90 e0       	ldi	r25, 0x00	; 0
    1f40:	88 23       	and	r24, r24
    1f42:	09 f4       	brne	.+2      	; 0x1f46 <test_002_001_execute+0x30>
    1f44:	91 e0       	ldi	r25, 0x01	; 1
    1f46:	89 2f       	mov	r24, r25
    1f48:	63 ea       	ldi	r22, 0xA3	; 163
    1f4a:	72 e0       	ldi	r23, 0x02	; 2
    1f4c:	0e 94 b3 09 	call	0x1366	; 0x1366 <_test_assert>
    1f50:	88 23       	and	r24, r24
    1f52:	21 f0       	breq	.+8      	; 0x1f5c <test_002_001_execute+0x46>
  /* The function chSemReset() is invoked, after return the counter
     is tested.*/
  test_set_step(3);
  {
    chSemReset(&sem1, 2);
    test_assert_lock(chSemGetCounterI(&sem1) == 2,
    1f54:	78 94       	sei
                     "wrong counter value");
  }
}
    1f56:	df 91       	pop	r29
    1f58:	cf 91       	pop	r28
    1f5a:	08 95       	ret
  test_set_step(1);
  {
    msg_t msg;

    msg = chSemWait(&sem1);
    test_assert_lock(chSemGetCounterI(&sem1) == 0,
    1f5c:	78 94       	sei
                     "wrong counter value");
    test_assert(MSG_OK == msg,
    1f5e:	80 e0       	ldi	r24, 0x00	; 0
    1f60:	cd 2b       	or	r28, r29
    1f62:	a9 f1       	breq	.+106    	; 0x1fce <test_002_001_execute+0xb8>
    1f64:	6c e8       	ldi	r22, 0x8C	; 140
    1f66:	72 e0       	ldi	r23, 0x02	; 2
    1f68:	0e 94 b3 09 	call	0x1366	; 0x1366 <_test_assert>
    1f6c:	88 23       	and	r24, r24
    1f6e:	99 f7       	brne	.-26     	; 0x1f56 <test_002_001_execute+0x40>
                "wrong returned message");
  }

  /* The function chSemSignal() is invoked, after return the counter
     is tested.*/
  test_set_step(2);
    1f70:	82 e0       	ldi	r24, 0x02	; 2
    1f72:	90 e0       	ldi	r25, 0x00	; 0
    1f74:	90 93 81 08 	sts	0x0881, r25
    1f78:	80 93 80 08 	sts	0x0880, r24
  {
    chSemSignal(&sem1);
    1f7c:	82 e1       	ldi	r24, 0x12	; 18
    1f7e:	97 e0       	ldi	r25, 0x07	; 7
    1f80:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
    1f84:	f8 94       	cli
    test_assert_lock(chSemGetCounterI(&sem1) == 1,
    1f86:	80 91 12 07 	lds	r24, 0x0712
    1f8a:	90 e0       	ldi	r25, 0x00	; 0
    1f8c:	81 30       	cpi	r24, 0x01	; 1
    1f8e:	41 f1       	breq	.+80     	; 0x1fe0 <test_002_001_execute+0xca>
    1f90:	89 2f       	mov	r24, r25
    1f92:	63 ea       	ldi	r22, 0xA3	; 163
    1f94:	72 e0       	ldi	r23, 0x02	; 2
    1f96:	0e 94 b3 09 	call	0x1366	; 0x1366 <_test_assert>
    1f9a:	88 23       	and	r24, r24
    1f9c:	d9 f6       	brne	.-74     	; 0x1f54 <test_002_001_execute+0x3e>
                     "wrong counter value");
  }

  /* The function chSemReset() is invoked, after return the counter
     is tested.*/
  test_set_step(3);
    1f9e:	78 94       	sei
    1fa0:	83 e0       	ldi	r24, 0x03	; 3
    1fa2:	90 e0       	ldi	r25, 0x00	; 0
    1fa4:	90 93 81 08 	sts	0x0881, r25
    1fa8:	80 93 80 08 	sts	0x0880, r24
  {
    chSemReset(&sem1, 2);
    1fac:	82 e1       	ldi	r24, 0x12	; 18
    1fae:	97 e0       	ldi	r25, 0x07	; 7
    1fb0:	62 e0       	ldi	r22, 0x02	; 2
    1fb2:	0e 94 27 09 	call	0x124e	; 0x124e <chSemReset>
    1fb6:	f8 94       	cli
    test_assert_lock(chSemGetCounterI(&sem1) == 2,
    1fb8:	80 91 12 07 	lds	r24, 0x0712
    1fbc:	90 e0       	ldi	r25, 0x00	; 0
    1fbe:	82 30       	cpi	r24, 0x02	; 2
    1fc0:	89 f0       	breq	.+34     	; 0x1fe4 <test_002_001_execute+0xce>
    1fc2:	89 2f       	mov	r24, r25
    1fc4:	63 ea       	ldi	r22, 0xA3	; 163
    1fc6:	72 e0       	ldi	r23, 0x02	; 2
    1fc8:	0e 94 b3 09 	call	0x1366	; 0x1366 <_test_assert>
    1fcc:	c3 cf       	rjmp	.-122    	; 0x1f54 <test_002_001_execute+0x3e>
    msg_t msg;

    msg = chSemWait(&sem1);
    test_assert_lock(chSemGetCounterI(&sem1) == 0,
                     "wrong counter value");
    test_assert(MSG_OK == msg,
    1fce:	81 e0       	ldi	r24, 0x01	; 1
    1fd0:	6c e8       	ldi	r22, 0x8C	; 140
    1fd2:	72 e0       	ldi	r23, 0x02	; 2
    1fd4:	0e 94 b3 09 	call	0x1366	; 0x1366 <_test_assert>
    1fd8:	88 23       	and	r24, r24
    1fda:	09 f0       	breq	.+2      	; 0x1fde <test_002_001_execute+0xc8>
    1fdc:	bc cf       	rjmp	.-136    	; 0x1f56 <test_002_001_execute+0x40>
    1fde:	c8 cf       	rjmp	.-112    	; 0x1f70 <test_002_001_execute+0x5a>
  /* The function chSemSignal() is invoked, after return the counter
     is tested.*/
  test_set_step(2);
  {
    chSemSignal(&sem1);
    test_assert_lock(chSemGetCounterI(&sem1) == 1,
    1fe0:	91 e0       	ldi	r25, 0x01	; 1
    1fe2:	d6 cf       	rjmp	.-84     	; 0x1f90 <test_002_001_execute+0x7a>
  /* The function chSemReset() is invoked, after return the counter
     is tested.*/
  test_set_step(3);
  {
    chSemReset(&sem1, 2);
    test_assert_lock(chSemGetCounterI(&sem1) == 2,
    1fe4:	91 e0       	ldi	r25, 0x01	; 1
    1fe6:	ed cf       	rjmp	.-38     	; 0x1fc2 <test_002_001_execute+0xac>

00001fe8 <halInit>:

  /* Initializes the OS Abstraction Layer.*/
  osalInit();

  /* Platform low level initializations.*/
  hal_lld_init();
    1fe8:	0e 94 69 13 	call	0x26d2	; 0x26d2 <hal_lld_init>
#endif
#if HAL_USE_PWM || defined(__DOXYGEN__)
  pwmInit();
#endif
#if HAL_USE_SERIAL || defined(__DOXYGEN__)
  sdInit();
    1fec:	0e 94 06 13 	call	0x260c	; 0x260c <sdInit>
#endif
#if HAL_USE_NAND || defined(__DOXYGEN__)
  nandInit();
#endif
  /* Board specific initialization.*/
  boardInit();
    1ff0:	0e 94 84 14 	call	0x2908	; 0x2908 <boardInit>

#if (OSAL_ST_MODE != OSAL_ST_MODE_NONE) || defined(__DOXYGEN__)
  /* System tick service if the underlying OS requires it.*/
  stInit();
    1ff4:	0e 94 22 13 	call	0x2644	; 0x2644 <stInit>
#endif
}
    1ff8:	08 95       	ret

00001ffa <iqObjectInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void iqObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                  qnotify_t infy, void *link) {
    1ffa:	0f 93       	push	r16
    1ffc:	1f 93       	push	r17
    1ffe:	fc 01       	movw	r30, r24
    2000:	10 82       	st	Z, r1

  osalThreadQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
    2002:	12 82       	std	Z+2, r1	; 0x02
    2004:	11 82       	std	Z+1, r1	; 0x01
  iqp->q_buffer  = iqp->q_rdptr = iqp->q_wrptr = bp;
    2006:	70 87       	std	Z+8, r23	; 0x08
    2008:	67 83       	std	Z+7, r22	; 0x07
    200a:	72 87       	std	Z+10, r23	; 0x0a
    200c:	61 87       	std	Z+9, r22	; 0x09
    200e:	74 83       	std	Z+4, r23	; 0x04
    2010:	63 83       	std	Z+3, r22	; 0x03
  iqp->q_top     = bp + size;
    2012:	64 0f       	add	r22, r20
    2014:	75 1f       	adc	r23, r21
    2016:	76 83       	std	Z+6, r23	; 0x06
    2018:	65 83       	std	Z+5, r22	; 0x05
  iqp->q_notify  = infy;
    201a:	34 87       	std	Z+12, r19	; 0x0c
    201c:	23 87       	std	Z+11, r18	; 0x0b
  iqp->q_link    = link;
    201e:	16 87       	std	Z+14, r17	; 0x0e
    2020:	05 87       	std	Z+13, r16	; 0x0d
}
    2022:	1f 91       	pop	r17
    2024:	0f 91       	pop	r16
    2026:	08 95       	ret

00002028 <oqObjectInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void oqObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                  qnotify_t onfy, void *link) {
    2028:	0f 93       	push	r16
    202a:	1f 93       	push	r17
    202c:	fc 01       	movw	r30, r24
    202e:	10 82       	st	Z, r1

  osalThreadQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
    2030:	52 83       	std	Z+2, r21	; 0x02
    2032:	41 83       	std	Z+1, r20	; 0x01
  oqp->q_buffer  = oqp->q_rdptr = oqp->q_wrptr = bp;
    2034:	70 87       	std	Z+8, r23	; 0x08
    2036:	67 83       	std	Z+7, r22	; 0x07
    2038:	72 87       	std	Z+10, r23	; 0x0a
    203a:	61 87       	std	Z+9, r22	; 0x09
    203c:	74 83       	std	Z+4, r23	; 0x04
    203e:	63 83       	std	Z+3, r22	; 0x03
  oqp->q_top     = bp + size;
    2040:	64 0f       	add	r22, r20
    2042:	75 1f       	adc	r23, r21
    2044:	76 83       	std	Z+6, r23	; 0x06
    2046:	65 83       	std	Z+5, r22	; 0x05
  oqp->q_notify  = onfy;
    2048:	34 87       	std	Z+12, r19	; 0x0c
    204a:	23 87       	std	Z+11, r18	; 0x0b
  oqp->q_link    = link;
    204c:	16 87       	std	Z+14, r17	; 0x0e
    204e:	05 87       	std	Z+13, r16	; 0x0d
}
    2050:	1f 91       	pop	r17
    2052:	0f 91       	pop	r16
    2054:	08 95       	ret

00002056 <oqWriteTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t oqWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                      size_t n, systime_t time) {
    2056:	4f 92       	push	r4
    2058:	5f 92       	push	r5
    205a:	6f 92       	push	r6
    205c:	7f 92       	push	r7
    205e:	8f 92       	push	r8
    2060:	9f 92       	push	r9
    2062:	af 92       	push	r10
    2064:	bf 92       	push	r11
    2066:	cf 92       	push	r12
    2068:	df 92       	push	r13
    206a:	ef 92       	push	r14
    206c:	ff 92       	push	r15
    206e:	0f 93       	push	r16
    2070:	1f 93       	push	r17
    2072:	cf 93       	push	r28
    2074:	df 93       	push	r29
    2076:	ec 01       	movw	r28, r24
    2078:	6b 01       	movw	r12, r22
    207a:	7a 01       	movw	r14, r20
    207c:	38 01       	movw	r6, r16
    207e:	49 01       	movw	r8, r18
  qnotify_t nfy = oqp->q_notify;
    2080:	ab 84       	ldd	r10, Y+11	; 0x0b
    2082:	bc 84       	ldd	r11, Y+12	; 0x0c
    2084:	f8 94       	cli
    2086:	2c 01       	movw	r4, r24
    2088:	00 e0       	ldi	r16, 0x00	; 0
    208a:	10 e0       	ldi	r17, 0x00	; 0

  osalDbgCheck(n > 0);

  osalSysLock();
  while (TRUE) {
    while (oqIsFullI(oqp)) {
    208c:	89 81       	ldd	r24, Y+1	; 0x01
    208e:	9a 81       	ldd	r25, Y+2	; 0x02
    2090:	00 97       	sbiw	r24, 0x00	; 0
    2092:	51 f1       	breq	.+84     	; 0x20e8 <oqWriteTimeout+0x92>
      if (osalThreadEnqueueTimeoutS(&oqp->q_waiting, time) != Q_OK) {
        osalSysUnlock();
        return w;
      }
    }
    oqp->q_counter--;
    2094:	01 97       	sbiw	r24, 0x01	; 1
    2096:	9a 83       	std	Y+2, r25	; 0x02
    2098:	89 83       	std	Y+1, r24	; 0x01
    *oqp->q_wrptr++ = *bp++;
    209a:	f6 01       	movw	r30, r12
    209c:	80 81       	ld	r24, Z
    209e:	ef 81       	ldd	r30, Y+7	; 0x07
    20a0:	f8 85       	ldd	r31, Y+8	; 0x08
    20a2:	81 93       	st	Z+, r24
    20a4:	f8 87       	std	Y+8, r31	; 0x08
    20a6:	ef 83       	std	Y+7, r30	; 0x07
    if (oqp->q_wrptr >= oqp->q_top)
    20a8:	8d 81       	ldd	r24, Y+5	; 0x05
    20aa:	9e 81       	ldd	r25, Y+6	; 0x06
    20ac:	e8 17       	cp	r30, r24
    20ae:	f9 07       	cpc	r31, r25
    20b0:	20 f0       	brcs	.+8      	; 0x20ba <oqWriteTimeout+0x64>
      oqp->q_wrptr = oqp->q_buffer;
    20b2:	8b 81       	ldd	r24, Y+3	; 0x03
    20b4:	9c 81       	ldd	r25, Y+4	; 0x04
    20b6:	98 87       	std	Y+8, r25	; 0x08
    20b8:	8f 83       	std	Y+7, r24	; 0x07

    if (nfy)
    20ba:	a1 14       	cp	r10, r1
    20bc:	b1 04       	cpc	r11, r1
    20be:	19 f0       	breq	.+6      	; 0x20c6 <oqWriteTimeout+0x70>
      nfy(oqp);
    20c0:	ce 01       	movw	r24, r28
    20c2:	f5 01       	movw	r30, r10
    20c4:	09 95       	icall
    20c6:	78 94       	sei

    osalSysUnlock(); /* Gives a preemption chance in a controlled point.*/
    w++;
    20c8:	0f 5f       	subi	r16, 0xFF	; 255
    20ca:	1f 4f       	sbci	r17, 0xFF	; 255
    if (--n == 0)
    20cc:	08 94       	sec
    20ce:	e1 08       	sbc	r14, r1
    20d0:	f1 08       	sbc	r15, r1
    20d2:	e1 14       	cp	r14, r1
    20d4:	f1 04       	cpc	r15, r1
    20d6:	81 f0       	breq	.+32     	; 0x20f8 <oqWriteTimeout+0xa2>
        osalSysUnlock();
        return w;
      }
    }
    oqp->q_counter--;
    *oqp->q_wrptr++ = *bp++;
    20d8:	08 94       	sec
    20da:	c1 1c       	adc	r12, r1
    20dc:	d1 1c       	adc	r13, r1
    20de:	f8 94       	cli

  osalDbgCheck(n > 0);

  osalSysLock();
  while (TRUE) {
    while (oqIsFullI(oqp)) {
    20e0:	89 81       	ldd	r24, Y+1	; 0x01
    20e2:	9a 81       	ldd	r25, Y+2	; 0x02
    20e4:	00 97       	sbiw	r24, 0x00	; 0
    20e6:	b1 f6       	brne	.-84     	; 0x2094 <oqWriteTimeout+0x3e>
    20e8:	c2 01       	movw	r24, r4
    20ea:	b4 01       	movw	r22, r8
    20ec:	a3 01       	movw	r20, r6
    20ee:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
      if (osalThreadEnqueueTimeoutS(&oqp->q_waiting, time) != Q_OK) {
    20f2:	89 2b       	or	r24, r25
    20f4:	59 f2       	breq	.-106    	; 0x208c <oqWriteTimeout+0x36>
    20f6:	78 94       	sei
    w++;
    if (--n == 0)
      return w;
    osalSysLock();
  }
}
    20f8:	c8 01       	movw	r24, r16
    20fa:	df 91       	pop	r29
    20fc:	cf 91       	pop	r28
    20fe:	1f 91       	pop	r17
    2100:	0f 91       	pop	r16
    2102:	ff 90       	pop	r15
    2104:	ef 90       	pop	r14
    2106:	df 90       	pop	r13
    2108:	cf 90       	pop	r12
    210a:	bf 90       	pop	r11
    210c:	af 90       	pop	r10
    210e:	9f 90       	pop	r9
    2110:	8f 90       	pop	r8
    2112:	7f 90       	pop	r7
    2114:	6f 90       	pop	r6
    2116:	5f 90       	pop	r5
    2118:	4f 90       	pop	r4
    211a:	08 95       	ret

0000211c <oqPutTimeout>:
 * @retval Q_TIMEOUT    if the specified time expired.
 * @retval Q_RESET      if the queue has been reset.
 *
 * @api
 */
msg_t oqPutTimeout(output_queue_t *oqp, uint8_t b, systime_t time) {
    211c:	bf 92       	push	r11
    211e:	cf 92       	push	r12
    2120:	df 92       	push	r13
    2122:	ef 92       	push	r14
    2124:	ff 92       	push	r15
    2126:	0f 93       	push	r16
    2128:	1f 93       	push	r17
    212a:	cf 93       	push	r28
    212c:	df 93       	push	r29
    212e:	ec 01       	movw	r28, r24
    2130:	b6 2e       	mov	r11, r22
    2132:	79 01       	movw	r14, r18
    2134:	8a 01       	movw	r16, r20
    2136:	f8 94       	cli
    2138:	6c 01       	movw	r12, r24

  osalSysLock();
  while (oqIsFullI(oqp)) {
    213a:	89 81       	ldd	r24, Y+1	; 0x01
    213c:	9a 81       	ldd	r25, Y+2	; 0x02
    213e:	00 97       	sbiw	r24, 0x00	; 0
    2140:	a1 f4       	brne	.+40     	; 0x216a <oqPutTimeout+0x4e>
    2142:	c6 01       	movw	r24, r12
    2144:	b8 01       	movw	r22, r16
    2146:	a7 01       	movw	r20, r14
    2148:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
    214c:	9c 01       	movw	r18, r24
    msg_t msg;

    if ((msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, time)) < Q_OK) {
    214e:	97 ff       	sbrs	r25, 7
    2150:	f4 cf       	rjmp	.-24     	; 0x213a <oqPutTimeout+0x1e>
    2152:	78 94       	sei
  if (oqp->q_notify)
    oqp->q_notify(oqp);

  osalSysUnlock();
  return Q_OK;
}
    2154:	c9 01       	movw	r24, r18
    2156:	df 91       	pop	r29
    2158:	cf 91       	pop	r28
    215a:	1f 91       	pop	r17
    215c:	0f 91       	pop	r16
    215e:	ff 90       	pop	r15
    2160:	ef 90       	pop	r14
    2162:	df 90       	pop	r13
    2164:	cf 90       	pop	r12
    2166:	bf 90       	pop	r11
    2168:	08 95       	ret
      osalSysUnlock();
      return msg;
    }
  }

  oqp->q_counter--;
    216a:	01 97       	sbiw	r24, 0x01	; 1
    216c:	9a 83       	std	Y+2, r25	; 0x02
    216e:	89 83       	std	Y+1, r24	; 0x01
  *oqp->q_wrptr++ = b;
    2170:	ef 81       	ldd	r30, Y+7	; 0x07
    2172:	f8 85       	ldd	r31, Y+8	; 0x08
    2174:	b1 92       	st	Z+, r11
    2176:	f8 87       	std	Y+8, r31	; 0x08
    2178:	ef 83       	std	Y+7, r30	; 0x07
  if (oqp->q_wrptr >= oqp->q_top)
    217a:	8d 81       	ldd	r24, Y+5	; 0x05
    217c:	9e 81       	ldd	r25, Y+6	; 0x06
    217e:	e8 17       	cp	r30, r24
    2180:	f9 07       	cpc	r31, r25
    2182:	20 f0       	brcs	.+8      	; 0x218c <oqPutTimeout+0x70>
    oqp->q_wrptr = oqp->q_buffer;
    2184:	8b 81       	ldd	r24, Y+3	; 0x03
    2186:	9c 81       	ldd	r25, Y+4	; 0x04
    2188:	98 87       	std	Y+8, r25	; 0x08
    218a:	8f 83       	std	Y+7, r24	; 0x07

  if (oqp->q_notify)
    218c:	eb 85       	ldd	r30, Y+11	; 0x0b
    218e:	fc 85       	ldd	r31, Y+12	; 0x0c
    2190:	30 97       	sbiw	r30, 0x00	; 0
    2192:	11 f0       	breq	.+4      	; 0x2198 <oqPutTimeout+0x7c>
    oqp->q_notify(oqp);
    2194:	ce 01       	movw	r24, r28
    2196:	09 95       	icall
    2198:	78 94       	sei
    219a:	20 e0       	ldi	r18, 0x00	; 0
    219c:	30 e0       	ldi	r19, 0x00	; 0
    219e:	da cf       	rjmp	.-76     	; 0x2154 <oqPutTimeout+0x38>

000021a0 <iqReadTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t iqReadTimeout(input_queue_t *iqp, uint8_t *bp,
                     size_t n, systime_t time) {
    21a0:	4f 92       	push	r4
    21a2:	5f 92       	push	r5
    21a4:	6f 92       	push	r6
    21a6:	7f 92       	push	r7
    21a8:	8f 92       	push	r8
    21aa:	9f 92       	push	r9
    21ac:	af 92       	push	r10
    21ae:	bf 92       	push	r11
    21b0:	cf 92       	push	r12
    21b2:	df 92       	push	r13
    21b4:	ef 92       	push	r14
    21b6:	ff 92       	push	r15
    21b8:	0f 93       	push	r16
    21ba:	1f 93       	push	r17
    21bc:	cf 93       	push	r28
    21be:	df 93       	push	r29
    21c0:	ec 01       	movw	r28, r24
    21c2:	4b 01       	movw	r8, r22
    21c4:	2a 01       	movw	r4, r20
    21c6:	78 01       	movw	r14, r16
    21c8:	89 01       	movw	r16, r18
  qnotify_t nfy = iqp->q_notify;
    21ca:	6b 84       	ldd	r6, Y+11	; 0x0b
    21cc:	7c 84       	ldd	r7, Y+12	; 0x0c
    21ce:	f8 94       	cli
    21d0:	5c 01       	movw	r10, r24
    21d2:	cc 24       	eor	r12, r12
    21d4:	dd 24       	eor	r13, r13

  osalDbgCheck(n > 0);

  osalSysLock();
  while (TRUE) {
    if (nfy)
    21d6:	61 14       	cp	r6, r1
    21d8:	71 04       	cpc	r7, r1
    21da:	19 f0       	breq	.+6      	; 0x21e2 <iqReadTimeout+0x42>
      nfy(iqp);
    21dc:	ce 01       	movw	r24, r28
    21de:	f3 01       	movw	r30, r6
    21e0:	09 95       	icall

    while (iqIsEmptyI(iqp)) {
    21e2:	89 81       	ldd	r24, Y+1	; 0x01
    21e4:	9a 81       	ldd	r25, Y+2	; 0x02
    21e6:	00 97       	sbiw	r24, 0x00	; 0
    21e8:	d1 f4       	brne	.+52     	; 0x221e <iqReadTimeout+0x7e>
    21ea:	c5 01       	movw	r24, r10
    21ec:	b8 01       	movw	r22, r16
    21ee:	a7 01       	movw	r20, r14
    21f0:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
      if (osalThreadEnqueueTimeoutS(&iqp->q_waiting, time) != Q_OK) {
    21f4:	89 2b       	or	r24, r25
    21f6:	a9 f3       	breq	.-22     	; 0x21e2 <iqReadTimeout+0x42>
    21f8:	78 94       	sei
    if (--n == 0)
      return r;

    osalSysLock();
  }
}
    21fa:	c6 01       	movw	r24, r12
    21fc:	df 91       	pop	r29
    21fe:	cf 91       	pop	r28
    2200:	1f 91       	pop	r17
    2202:	0f 91       	pop	r16
    2204:	ff 90       	pop	r15
    2206:	ef 90       	pop	r14
    2208:	df 90       	pop	r13
    220a:	cf 90       	pop	r12
    220c:	bf 90       	pop	r11
    220e:	af 90       	pop	r10
    2210:	9f 90       	pop	r9
    2212:	8f 90       	pop	r8
    2214:	7f 90       	pop	r7
    2216:	6f 90       	pop	r6
    2218:	5f 90       	pop	r5
    221a:	4f 90       	pop	r4
    221c:	08 95       	ret
        osalSysUnlock();
        return r;
      }
    }

    iqp->q_counter--;
    221e:	01 97       	sbiw	r24, 0x01	; 1
    2220:	9a 83       	std	Y+2, r25	; 0x02
    2222:	89 83       	std	Y+1, r24	; 0x01
    *bp++ = *iqp->q_rdptr++;
    2224:	e9 85       	ldd	r30, Y+9	; 0x09
    2226:	fa 85       	ldd	r31, Y+10	; 0x0a
    2228:	81 91       	ld	r24, Z+
    222a:	d4 01       	movw	r26, r8
    222c:	8c 93       	st	X, r24
    222e:	fa 87       	std	Y+10, r31	; 0x0a
    2230:	e9 87       	std	Y+9, r30	; 0x09
    if (iqp->q_rdptr >= iqp->q_top)
    2232:	8d 81       	ldd	r24, Y+5	; 0x05
    2234:	9e 81       	ldd	r25, Y+6	; 0x06
    2236:	e8 17       	cp	r30, r24
    2238:	f9 07       	cpc	r31, r25
    223a:	60 f4       	brcc	.+24     	; 0x2254 <iqReadTimeout+0xb4>
    223c:	78 94       	sei
      iqp->q_rdptr = iqp->q_buffer;

    osalSysUnlock(); /* Gives a preemption chance in a controlled point.*/
    r++;
    223e:	08 94       	sec
    2240:	c1 1c       	adc	r12, r1
    2242:	d1 1c       	adc	r13, r1
    if (--n == 0)
    2244:	4c 14       	cp	r4, r12
    2246:	5d 04       	cpc	r5, r13
    2248:	c1 f2       	breq	.-80     	; 0x21fa <iqReadTimeout+0x5a>
        return r;
      }
    }

    iqp->q_counter--;
    *bp++ = *iqp->q_rdptr++;
    224a:	08 94       	sec
    224c:	81 1c       	adc	r8, r1
    224e:	91 1c       	adc	r9, r1
    2250:	f8 94       	cli
    2252:	c1 cf       	rjmp	.-126    	; 0x21d6 <iqReadTimeout+0x36>
    if (iqp->q_rdptr >= iqp->q_top)
      iqp->q_rdptr = iqp->q_buffer;
    2254:	8b 81       	ldd	r24, Y+3	; 0x03
    2256:	9c 81       	ldd	r25, Y+4	; 0x04
    2258:	9a 87       	std	Y+10, r25	; 0x0a
    225a:	89 87       	std	Y+9, r24	; 0x09
    225c:	ef cf       	rjmp	.-34     	; 0x223c <iqReadTimeout+0x9c>

0000225e <iqGetTimeout>:
 * @retval Q_TIMEOUT    if the specified time expired.
 * @retval Q_RESET      if the queue has been reset.
 *
 * @api
 */
msg_t iqGetTimeout(input_queue_t *iqp, systime_t time) {
    225e:	cf 92       	push	r12
    2260:	df 92       	push	r13
    2262:	ef 92       	push	r14
    2264:	ff 92       	push	r15
    2266:	0f 93       	push	r16
    2268:	1f 93       	push	r17
    226a:	cf 93       	push	r28
    226c:	df 93       	push	r29
    226e:	ec 01       	movw	r28, r24
    2270:	7a 01       	movw	r14, r20
    2272:	8b 01       	movw	r16, r22
    2274:	f8 94       	cli
  uint8_t b;

  osalSysLock();
  if (iqp->q_notify)
    2276:	eb 85       	ldd	r30, Y+11	; 0x0b
    2278:	fc 85       	ldd	r31, Y+12	; 0x0c
    227a:	30 97       	sbiw	r30, 0x00	; 0
    227c:	09 f0       	breq	.+2      	; 0x2280 <iqGetTimeout+0x22>
    iqp->q_notify(iqp);
    227e:	09 95       	icall
    2280:	6e 01       	movw	r12, r28

  while (iqIsEmptyI(iqp)) {
    2282:	89 81       	ldd	r24, Y+1	; 0x01
    2284:	9a 81       	ldd	r25, Y+2	; 0x02
    2286:	00 97       	sbiw	r24, 0x00	; 0
    2288:	99 f4       	brne	.+38     	; 0x22b0 <iqGetTimeout+0x52>
    228a:	c6 01       	movw	r24, r12
    228c:	b8 01       	movw	r22, r16
    228e:	a7 01       	movw	r20, r14
    2290:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
    2294:	9c 01       	movw	r18, r24
    msg_t msg;
    if ((msg = osalThreadEnqueueTimeoutS(&iqp->q_waiting, time)) < Q_OK) {
    2296:	97 ff       	sbrs	r25, 7
    2298:	f4 cf       	rjmp	.-24     	; 0x2282 <iqGetTimeout+0x24>
    229a:	78 94       	sei
  if (iqp->q_rdptr >= iqp->q_top)
    iqp->q_rdptr = iqp->q_buffer;

  osalSysUnlock();
  return b;
}
    229c:	c9 01       	movw	r24, r18
    229e:	df 91       	pop	r29
    22a0:	cf 91       	pop	r28
    22a2:	1f 91       	pop	r17
    22a4:	0f 91       	pop	r16
    22a6:	ff 90       	pop	r15
    22a8:	ef 90       	pop	r14
    22aa:	df 90       	pop	r13
    22ac:	cf 90       	pop	r12
    22ae:	08 95       	ret
      osalSysUnlock();
      return msg;
    }
  }

  iqp->q_counter--;
    22b0:	01 97       	sbiw	r24, 0x01	; 1
    22b2:	9a 83       	std	Y+2, r25	; 0x02
    22b4:	89 83       	std	Y+1, r24	; 0x01
  b = *iqp->q_rdptr++;
    22b6:	e9 85       	ldd	r30, Y+9	; 0x09
    22b8:	fa 85       	ldd	r31, Y+10	; 0x0a
    22ba:	21 91       	ld	r18, Z+
    22bc:	fa 87       	std	Y+10, r31	; 0x0a
    22be:	e9 87       	std	Y+9, r30	; 0x09
  if (iqp->q_rdptr >= iqp->q_top)
    22c0:	8d 81       	ldd	r24, Y+5	; 0x05
    22c2:	9e 81       	ldd	r25, Y+6	; 0x06
    22c4:	e8 17       	cp	r30, r24
    22c6:	f9 07       	cpc	r31, r25
    22c8:	20 f0       	brcs	.+8      	; 0x22d2 <iqGetTimeout+0x74>
    iqp->q_rdptr = iqp->q_buffer;
    22ca:	8b 81       	ldd	r24, Y+3	; 0x03
    22cc:	9c 81       	ldd	r25, Y+4	; 0x04
    22ce:	9a 87       	std	Y+10, r25	; 0x0a
    22d0:	89 87       	std	Y+9, r24	; 0x09
    22d2:	78 94       	sei

  osalSysUnlock();
  return b;
    22d4:	30 e0       	ldi	r19, 0x00	; 0
    22d6:	e2 cf       	rjmp	.-60     	; 0x229c <iqGetTimeout+0x3e>

000022d8 <oqGetI>:
 * @return              The byte value from the queue.
 * @retval Q_EMPTY      if the queue is empty.
 *
 * @iclass
 */
msg_t oqGetI(output_queue_t *oqp) {
    22d8:	1f 93       	push	r17
    22da:	dc 01       	movw	r26, r24
  uint8_t b;

  osalDbgCheckClassI();

  if (oqIsEmptyI(oqp))
    22dc:	17 96       	adiw	r26, 0x07	; 7
    22de:	8d 91       	ld	r24, X+
    22e0:	9c 91       	ld	r25, X
    22e2:	18 97       	sbiw	r26, 0x08	; 8
    22e4:	19 96       	adiw	r26, 0x09	; 9
    22e6:	ed 91       	ld	r30, X+
    22e8:	fc 91       	ld	r31, X
    22ea:	1a 97       	sbiw	r26, 0x0a	; 10
    22ec:	8e 17       	cp	r24, r30
    22ee:	9f 07       	cpc	r25, r31
    22f0:	41 f1       	breq	.+80     	; 0x2342 <oqGetI+0x6a>
  if (oqp->q_rdptr >= oqp->q_top)
    oqp->q_rdptr = oqp->q_buffer;

  osalThreadDequeueNextI(&oqp->q_waiting, Q_OK);

  return b;
    22f2:	11 96       	adiw	r26, 0x01	; 1
    22f4:	8d 91       	ld	r24, X+
    22f6:	9c 91       	ld	r25, X
    22f8:	12 97       	sbiw	r26, 0x02	; 2
  osalDbgCheckClassI();

  if (oqIsEmptyI(oqp))
    return Q_EMPTY;

  oqp->q_counter++;
    22fa:	01 96       	adiw	r24, 0x01	; 1
    22fc:	12 96       	adiw	r26, 0x02	; 2
    22fe:	9c 93       	st	X, r25
    2300:	8e 93       	st	-X, r24
    2302:	11 97       	sbiw	r26, 0x01	; 1
  b = *oqp->q_rdptr++;
    2304:	11 91       	ld	r17, Z+
    2306:	1a 96       	adiw	r26, 0x0a	; 10
    2308:	fc 93       	st	X, r31
    230a:	ee 93       	st	-X, r30
    230c:	19 97       	sbiw	r26, 0x09	; 9
  if (oqp->q_rdptr >= oqp->q_top)
    230e:	15 96       	adiw	r26, 0x05	; 5
    2310:	8d 91       	ld	r24, X+
    2312:	9c 91       	ld	r25, X
    2314:	16 97       	sbiw	r26, 0x06	; 6
    2316:	e8 17       	cp	r30, r24
    2318:	f9 07       	cpc	r31, r25
    231a:	50 f4       	brcc	.+20     	; 0x2330 <oqGetI+0x58>
    oqp->q_rdptr = oqp->q_buffer;

  osalThreadDequeueNextI(&oqp->q_waiting, Q_OK);
    231c:	cd 01       	movw	r24, r26
    231e:	60 e0       	ldi	r22, 0x00	; 0
    2320:	70 e0       	ldi	r23, 0x00	; 0
    2322:	0e 94 4c 13 	call	0x2698	; 0x2698 <osalThreadDequeueNextI>

  return b;
    2326:	21 2f       	mov	r18, r17
    2328:	30 e0       	ldi	r19, 0x00	; 0
}
    232a:	c9 01       	movw	r24, r18
    232c:	1f 91       	pop	r17
    232e:	08 95       	ret
    return Q_EMPTY;

  oqp->q_counter++;
  b = *oqp->q_rdptr++;
  if (oqp->q_rdptr >= oqp->q_top)
    oqp->q_rdptr = oqp->q_buffer;
    2330:	13 96       	adiw	r26, 0x03	; 3
    2332:	8d 91       	ld	r24, X+
    2334:	9c 91       	ld	r25, X
    2336:	14 97       	sbiw	r26, 0x04	; 4
    2338:	1a 96       	adiw	r26, 0x0a	; 10
    233a:	9c 93       	st	X, r25
    233c:	8e 93       	st	-X, r24
    233e:	19 97       	sbiw	r26, 0x09	; 9
    2340:	ed cf       	rjmp	.-38     	; 0x231c <oqGetI+0x44>
msg_t oqGetI(output_queue_t *oqp) {
  uint8_t b;

  osalDbgCheckClassI();

  if (oqIsEmptyI(oqp))
    2342:	11 96       	adiw	r26, 0x01	; 1
    2344:	8d 91       	ld	r24, X+
    2346:	9c 91       	ld	r25, X
    2348:	12 97       	sbiw	r26, 0x02	; 2
    234a:	89 2b       	or	r24, r25
    234c:	19 f4       	brne	.+6      	; 0x2354 <oqGetI+0x7c>
    234e:	80 e0       	ldi	r24, 0x00	; 0
    2350:	90 e0       	ldi	r25, 0x00	; 0
    2352:	d3 cf       	rjmp	.-90     	; 0x22fa <oqGetI+0x22>
    2354:	2d ef       	ldi	r18, 0xFD	; 253
    2356:	3f ef       	ldi	r19, 0xFF	; 255
    2358:	e8 cf       	rjmp	.-48     	; 0x232a <oqGetI+0x52>

0000235a <iqPutI>:
 * @retval Q_FULL       if the queue is full and the operation cannot be
 *                      completed.
 *
 * @iclass
 */
msg_t iqPutI(input_queue_t *iqp, uint8_t b) {
    235a:	dc 01       	movw	r26, r24

  osalDbgCheckClassI();

  if (iqIsFullI(iqp))
    235c:	17 96       	adiw	r26, 0x07	; 7
    235e:	ed 91       	ld	r30, X+
    2360:	fc 91       	ld	r31, X
    2362:	18 97       	sbiw	r26, 0x08	; 8
    2364:	19 96       	adiw	r26, 0x09	; 9
    2366:	8d 91       	ld	r24, X+
    2368:	9c 91       	ld	r25, X
    236a:	1a 97       	sbiw	r26, 0x0a	; 10
    236c:	e8 17       	cp	r30, r24
    236e:	f9 07       	cpc	r31, r25
    2370:	39 f1       	breq	.+78     	; 0x23c0 <iqPutI+0x66>
  iqp->q_counter++;
  *iqp->q_wrptr++ = b;
  if (iqp->q_wrptr >= iqp->q_top)
    iqp->q_wrptr = iqp->q_buffer;

  osalThreadDequeueNextI(&iqp->q_waiting, Q_OK);
    2372:	11 96       	adiw	r26, 0x01	; 1
    2374:	8d 91       	ld	r24, X+
    2376:	9c 91       	ld	r25, X
    2378:	12 97       	sbiw	r26, 0x02	; 2
  osalDbgCheckClassI();

  if (iqIsFullI(iqp))
    return Q_FULL;

  iqp->q_counter++;
    237a:	01 96       	adiw	r24, 0x01	; 1
    237c:	12 96       	adiw	r26, 0x02	; 2
    237e:	9c 93       	st	X, r25
    2380:	8e 93       	st	-X, r24
    2382:	11 97       	sbiw	r26, 0x01	; 1
  *iqp->q_wrptr++ = b;
    2384:	61 93       	st	Z+, r22
    2386:	18 96       	adiw	r26, 0x08	; 8
    2388:	fc 93       	st	X, r31
    238a:	ee 93       	st	-X, r30
    238c:	17 97       	sbiw	r26, 0x07	; 7
  if (iqp->q_wrptr >= iqp->q_top)
    238e:	15 96       	adiw	r26, 0x05	; 5
    2390:	8d 91       	ld	r24, X+
    2392:	9c 91       	ld	r25, X
    2394:	16 97       	sbiw	r26, 0x06	; 6
    2396:	e8 17       	cp	r30, r24
    2398:	f9 07       	cpc	r31, r25
    239a:	48 f4       	brcc	.+18     	; 0x23ae <iqPutI+0x54>
    iqp->q_wrptr = iqp->q_buffer;

  osalThreadDequeueNextI(&iqp->q_waiting, Q_OK);
    239c:	cd 01       	movw	r24, r26
    239e:	60 e0       	ldi	r22, 0x00	; 0
    23a0:	70 e0       	ldi	r23, 0x00	; 0
    23a2:	0e 94 4c 13 	call	0x2698	; 0x2698 <osalThreadDequeueNextI>
    23a6:	20 e0       	ldi	r18, 0x00	; 0
    23a8:	30 e0       	ldi	r19, 0x00	; 0

  return Q_OK;
}
    23aa:	c9 01       	movw	r24, r18
    23ac:	08 95       	ret
    return Q_FULL;

  iqp->q_counter++;
  *iqp->q_wrptr++ = b;
  if (iqp->q_wrptr >= iqp->q_top)
    iqp->q_wrptr = iqp->q_buffer;
    23ae:	13 96       	adiw	r26, 0x03	; 3
    23b0:	8d 91       	ld	r24, X+
    23b2:	9c 91       	ld	r25, X
    23b4:	14 97       	sbiw	r26, 0x04	; 4
    23b6:	18 96       	adiw	r26, 0x08	; 8
    23b8:	9c 93       	st	X, r25
    23ba:	8e 93       	st	-X, r24
    23bc:	17 97       	sbiw	r26, 0x07	; 7
    23be:	ee cf       	rjmp	.-36     	; 0x239c <iqPutI+0x42>
 */
msg_t iqPutI(input_queue_t *iqp, uint8_t b) {

  osalDbgCheckClassI();

  if (iqIsFullI(iqp))
    23c0:	11 96       	adiw	r26, 0x01	; 1
    23c2:	8d 91       	ld	r24, X+
    23c4:	9c 91       	ld	r25, X
    23c6:	12 97       	sbiw	r26, 0x02	; 2
    23c8:	89 2b       	or	r24, r25
    23ca:	19 f4       	brne	.+6      	; 0x23d2 <iqPutI+0x78>
    23cc:	80 e0       	ldi	r24, 0x00	; 0
    23ce:	90 e0       	ldi	r25, 0x00	; 0
    23d0:	d4 cf       	rjmp	.-88     	; 0x237a <iqPutI+0x20>
    23d2:	2c ef       	ldi	r18, 0xFC	; 252
    23d4:	3f ef       	ldi	r19, 0xFF	; 255
    23d6:	e9 cf       	rjmp	.-46     	; 0x23aa <iqPutI+0x50>

000023d8 <oqResetI>:
 *
 * @param[in] oqp       pointer to an @p output_queue_t structure
 *
 * @iclass
 */
void oqResetI(output_queue_t *oqp) {
    23d8:	fc 01       	movw	r30, r24

  osalDbgCheckClassI();

  oqp->q_rdptr = oqp->q_wrptr = oqp->q_buffer;
    23da:	23 81       	ldd	r18, Z+3	; 0x03
    23dc:	34 81       	ldd	r19, Z+4	; 0x04
    23de:	30 87       	std	Z+8, r19	; 0x08
    23e0:	27 83       	std	Z+7, r18	; 0x07
    23e2:	32 87       	std	Z+10, r19	; 0x0a
    23e4:	21 87       	std	Z+9, r18	; 0x09
  oqp->q_counter = qSizeI(oqp);
    23e6:	85 81       	ldd	r24, Z+5	; 0x05
    23e8:	96 81       	ldd	r25, Z+6	; 0x06
    23ea:	82 1b       	sub	r24, r18
    23ec:	93 0b       	sbc	r25, r19
    23ee:	92 83       	std	Z+2, r25	; 0x02
    23f0:	81 83       	std	Z+1, r24	; 0x01
  osalThreadDequeueAllI(&oqp->q_waiting, Q_RESET);
    23f2:	cf 01       	movw	r24, r30
    23f4:	6e ef       	ldi	r22, 0xFE	; 254
    23f6:	7f ef       	ldi	r23, 0xFF	; 255
    23f8:	0e 94 25 13 	call	0x264a	; 0x264a <osalThreadDequeueAllI>
}
    23fc:	08 95       	ret

000023fe <iqResetI>:
 *
 * @param[in] iqp       pointer to an @p input_queue_t structure
 *
 * @iclass
 */
void iqResetI(input_queue_t *iqp) {
    23fe:	fc 01       	movw	r30, r24

  osalDbgCheckClassI();

  iqp->q_rdptr = iqp->q_wrptr = iqp->q_buffer;
    2400:	83 81       	ldd	r24, Z+3	; 0x03
    2402:	94 81       	ldd	r25, Z+4	; 0x04
    2404:	90 87       	std	Z+8, r25	; 0x08
    2406:	87 83       	std	Z+7, r24	; 0x07
    2408:	92 87       	std	Z+10, r25	; 0x0a
    240a:	81 87       	std	Z+9, r24	; 0x09
  iqp->q_counter = 0;
    240c:	12 82       	std	Z+2, r1	; 0x02
    240e:	11 82       	std	Z+1, r1	; 0x01
  osalThreadDequeueAllI(&iqp->q_waiting, Q_RESET);
    2410:	cf 01       	movw	r24, r30
    2412:	6e ef       	ldi	r22, 0xFE	; 254
    2414:	7f ef       	ldi	r23, 0xFF	; 255
    2416:	0e 94 25 13 	call	0x264a	; 0x264a <osalThreadDequeueAllI>
}
    241a:	08 95       	ret

0000241c <sdRequestDataI>:
 * @retval Q_EMPTY      if the queue is empty (the lower driver usually
 *                      disables the interrupt source when this happens).
 *
 * @iclass
 */
msg_t sdRequestDataI(SerialDriver *sdp) {
    241c:	0f 93       	push	r16
    241e:	1f 93       	push	r17
    2420:	cf 93       	push	r28
    2422:	df 93       	push	r29
    2424:	8c 01       	movw	r16, r24
  msg_t  b;

  osalDbgCheckClassI();
  osalDbgCheck(sdp != NULL);

  b = oqGetI(&sdp->oqueue);
    2426:	4a 96       	adiw	r24, 0x1a	; 26
    2428:	0e 94 6c 11 	call	0x22d8	; 0x22d8 <oqGetI>
    242c:	ec 01       	movw	r28, r24
  if (b < Q_OK)
    242e:	97 fd       	sbrc	r25, 7
    2430:	06 c0       	rjmp	.+12     	; 0x243e <sdRequestDataI+0x22>
    chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
  return b;
}
    2432:	ce 01       	movw	r24, r28
    2434:	df 91       	pop	r29
    2436:	cf 91       	pop	r28
    2438:	1f 91       	pop	r17
    243a:	0f 91       	pop	r16
    243c:	08 95       	ret
    243e:	f8 01       	movw	r30, r16
    2440:	82 81       	ldd	r24, Z+2	; 0x02
    2442:	93 81       	ldd	r25, Z+3	; 0x03
    2444:	a4 81       	ldd	r26, Z+4	; 0x04
    2446:	b5 81       	ldd	r27, Z+5	; 0x05
    2448:	88 60       	ori	r24, 0x08	; 8
    244a:	82 83       	std	Z+2, r24	; 0x02
    244c:	93 83       	std	Z+3, r25	; 0x03
    244e:	a4 83       	std	Z+4, r26	; 0x04
    2450:	b5 83       	std	Z+5, r27	; 0x05
    2452:	06 80       	ldd	r0, Z+6	; 0x06
    2454:	f7 81       	ldd	r31, Z+7	; 0x07
    2456:	e0 2d       	mov	r30, r0
    2458:	30 97       	sbiw	r30, 0x00	; 0
    245a:	59 f3       	breq	.-42     	; 0x2432 <sdRequestDataI+0x16>
    245c:	c8 01       	movw	r24, r16
    245e:	02 96       	adiw	r24, 0x02	; 2
    2460:	09 95       	icall
    2462:	ce 01       	movw	r24, r28
    2464:	df 91       	pop	r29
    2466:	cf 91       	pop	r28
    2468:	1f 91       	pop	r17
    246a:	0f 91       	pop	r16
    246c:	08 95       	ret

0000246e <sdIncomingDataI>:
 * @param[in] sdp       pointer to a @p SerialDriver structure
 * @param[in] b         the byte to be written in the driver's Input Queue
 *
 * @iclass
 */
void sdIncomingDataI(SerialDriver *sdp, uint8_t b) {
    246e:	1f 93       	push	r17
    2470:	cf 93       	push	r28
    2472:	df 93       	push	r29
    2474:	ec 01       	movw	r28, r24
    2476:	16 2f       	mov	r17, r22

  osalDbgCheckClassI();
  osalDbgCheck(sdp != NULL);

  if (iqIsEmptyI(&sdp->iqueue))
    2478:	8c 85       	ldd	r24, Y+12	; 0x0c
    247a:	9d 85       	ldd	r25, Y+13	; 0x0d
    247c:	89 2b       	or	r24, r25
    247e:	81 f4       	brne	.+32     	; 0x24a0 <sdIncomingDataI+0x32>
    2480:	8a 81       	ldd	r24, Y+2	; 0x02
    2482:	9b 81       	ldd	r25, Y+3	; 0x03
    2484:	ac 81       	ldd	r26, Y+4	; 0x04
    2486:	bd 81       	ldd	r27, Y+5	; 0x05
    2488:	84 60       	ori	r24, 0x04	; 4
    248a:	8a 83       	std	Y+2, r24	; 0x02
    248c:	9b 83       	std	Y+3, r25	; 0x03
    248e:	ac 83       	std	Y+4, r26	; 0x04
    2490:	bd 83       	std	Y+5, r27	; 0x05
    2492:	ee 81       	ldd	r30, Y+6	; 0x06
    2494:	ff 81       	ldd	r31, Y+7	; 0x07
    2496:	30 97       	sbiw	r30, 0x00	; 0
    2498:	19 f0       	breq	.+6      	; 0x24a0 <sdIncomingDataI+0x32>
    249a:	ce 01       	movw	r24, r28
    249c:	02 96       	adiw	r24, 0x02	; 2
    249e:	09 95       	icall
    chnAddFlagsI(sdp, CHN_INPUT_AVAILABLE);
  if (iqPutI(&sdp->iqueue, b) < Q_OK)
    24a0:	ce 01       	movw	r24, r28
    24a2:	0b 96       	adiw	r24, 0x0b	; 11
    24a4:	61 2f       	mov	r22, r17
    24a6:	0e 94 ad 11 	call	0x235a	; 0x235a <iqPutI>
    24aa:	97 fd       	sbrc	r25, 7
    24ac:	04 c0       	rjmp	.+8      	; 0x24b6 <sdIncomingDataI+0x48>
    chnAddFlagsI(sdp, SD_OVERRUN_ERROR);
}
    24ae:	df 91       	pop	r29
    24b0:	cf 91       	pop	r28
    24b2:	1f 91       	pop	r17
    24b4:	08 95       	ret
    24b6:	8a 81       	ldd	r24, Y+2	; 0x02
    24b8:	9b 81       	ldd	r25, Y+3	; 0x03
    24ba:	ac 81       	ldd	r26, Y+4	; 0x04
    24bc:	bd 81       	ldd	r27, Y+5	; 0x05
    24be:	80 68       	ori	r24, 0x80	; 128
    24c0:	8a 83       	std	Y+2, r24	; 0x02
    24c2:	9b 83       	std	Y+3, r25	; 0x03
    24c4:	ac 83       	std	Y+4, r26	; 0x04
    24c6:	bd 83       	std	Y+5, r27	; 0x05
    24c8:	ee 81       	ldd	r30, Y+6	; 0x06
    24ca:	ff 81       	ldd	r31, Y+7	; 0x07
    24cc:	30 97       	sbiw	r30, 0x00	; 0
    24ce:	79 f3       	breq	.-34     	; 0x24ae <sdIncomingDataI+0x40>
    24d0:	ce 01       	movw	r24, r28
    24d2:	02 96       	adiw	r24, 0x02	; 2
    24d4:	09 95       	icall
    24d6:	df 91       	pop	r29
    24d8:	cf 91       	pop	r28
    24da:	1f 91       	pop	r17
    24dc:	08 95       	ret

000024de <sdStop>:
 *
 * @param[in] sdp       pointer to a @p SerialDriver object
 *
 * @api
 */
void sdStop(SerialDriver *sdp) {
    24de:	0f 93       	push	r16
    24e0:	1f 93       	push	r17
    24e2:	8c 01       	movw	r16, r24
    24e4:	f8 94       	cli
  osalDbgCheck(sdp != NULL);

  osalSysLock();
  osalDbgAssert((sdp->state == SD_STOP) || (sdp->state == SD_READY),
                "invalid state");
  sd_lld_stop(sdp);
    24e6:	0e 94 a7 13 	call	0x274e	; 0x274e <sd_lld_stop>
  sdp->state = SD_STOP;
    24ea:	81 e0       	ldi	r24, 0x01	; 1
    24ec:	f8 01       	movw	r30, r16
    24ee:	82 87       	std	Z+10, r24	; 0x0a
  oqResetI(&sdp->oqueue);
    24f0:	c8 01       	movw	r24, r16
    24f2:	4a 96       	adiw	r24, 0x1a	; 26
    24f4:	0e 94 ec 11 	call	0x23d8	; 0x23d8 <oqResetI>
  iqResetI(&sdp->iqueue);
    24f8:	c8 01       	movw	r24, r16
    24fa:	0b 96       	adiw	r24, 0x0b	; 11
    24fc:	0e 94 ff 11 	call	0x23fe	; 0x23fe <iqResetI>
    2500:	0e 94 0e 09 	call	0x121c	; 0x121c <chSchRescheduleS>
    2504:	78 94       	sei
  osalOsRescheduleS();
  osalSysUnlock();
}
    2506:	1f 91       	pop	r17
    2508:	0f 91       	pop	r16
    250a:	08 95       	ret

0000250c <sdStart>:
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @api
 */
void sdStart(SerialDriver *sdp, const SerialConfig *config) {
    250c:	0f 93       	push	r16
    250e:	1f 93       	push	r17
    2510:	8c 01       	movw	r16, r24
    2512:	f8 94       	cli
  osalDbgCheck(sdp != NULL);

  osalSysLock();
  osalDbgAssert((sdp->state == SD_STOP) || (sdp->state == SD_READY),
                "invalid state");
  sd_lld_start(sdp, config);
    2514:	0e 94 70 13 	call	0x26e0	; 0x26e0 <sd_lld_start>
  sdp->state = SD_READY;
    2518:	82 e0       	ldi	r24, 0x02	; 2
    251a:	f8 01       	movw	r30, r16
    251c:	82 87       	std	Z+10, r24	; 0x0a
    251e:	78 94       	sei
  osalSysUnlock();
}
    2520:	1f 91       	pop	r17
    2522:	0f 91       	pop	r16
    2524:	08 95       	ret

00002526 <sdObjectInit>:
 *                      some data is written in the Queue. The value can be
 *                      @p NULL.
 *
 * @init
 */
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {
    2526:	cf 92       	push	r12
    2528:	df 92       	push	r13
    252a:	ef 92       	push	r14
    252c:	ff 92       	push	r15
    252e:	0f 93       	push	r16
    2530:	1f 93       	push	r17
    2532:	7c 01       	movw	r14, r24
    2534:	9b 01       	movw	r18, r22
    2536:	6a 01       	movw	r12, r20

  sdp->vmt = &vmt;
    2538:	88 e9       	ldi	r24, 0x98	; 152
    253a:	93 e0       	ldi	r25, 0x03	; 3
    253c:	f7 01       	movw	r30, r14
    253e:	91 83       	std	Z+1, r25	; 0x01
    2540:	80 83       	st	Z, r24
    2542:	12 82       	std	Z+2, r1	; 0x02
    2544:	13 82       	std	Z+3, r1	; 0x03
    2546:	14 82       	std	Z+4, r1	; 0x04
    2548:	15 82       	std	Z+5, r1	; 0x05
    254a:	17 82       	std	Z+7, r1	; 0x07
    254c:	16 82       	std	Z+6, r1	; 0x06
    254e:	11 86       	std	Z+9, r1	; 0x09
    2550:	10 86       	std	Z+8, r1	; 0x08
  osalEventObjectInit(&sdp->event);
  sdp->state = SD_STOP;
    2552:	81 e0       	ldi	r24, 0x01	; 1
    2554:	82 87       	std	Z+10, r24	; 0x0a
  iqObjectInit(&sdp->iqueue, sdp->ib, SERIAL_BUFFERS_SIZE, inotify, sdp);
    2556:	b7 01       	movw	r22, r14
    2558:	67 5d       	subi	r22, 0xD7	; 215
    255a:	7f 4f       	sbci	r23, 0xFF	; 255
    255c:	c7 01       	movw	r24, r14
    255e:	0b 96       	adiw	r24, 0x0b	; 11
    2560:	40 e1       	ldi	r20, 0x10	; 16
    2562:	50 e0       	ldi	r21, 0x00	; 0
    2564:	87 01       	movw	r16, r14
    2566:	0e 94 fd 0f 	call	0x1ffa	; 0x1ffa <iqObjectInit>
  oqObjectInit(&sdp->oqueue, sdp->ob, SERIAL_BUFFERS_SIZE, onotify, sdp);
    256a:	b7 01       	movw	r22, r14
    256c:	67 5c       	subi	r22, 0xC7	; 199
    256e:	7f 4f       	sbci	r23, 0xFF	; 255
    2570:	c7 01       	movw	r24, r14
    2572:	4a 96       	adiw	r24, 0x1a	; 26
    2574:	40 e1       	ldi	r20, 0x10	; 16
    2576:	50 e0       	ldi	r21, 0x00	; 0
    2578:	96 01       	movw	r18, r12
    257a:	0e 94 14 10 	call	0x2028	; 0x2028 <oqObjectInit>
}
    257e:	1f 91       	pop	r17
    2580:	0f 91       	pop	r16
    2582:	ff 90       	pop	r15
    2584:	ef 90       	pop	r14
    2586:	df 90       	pop	r13
    2588:	cf 90       	pop	r12
    258a:	08 95       	ret

0000258c <readt>:
static size_t writet(void *ip, const uint8_t *bp, size_t n, systime_t time) {

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, time);
}

static size_t readt(void *ip, uint8_t *bp, size_t n, systime_t time) {
    258c:	0f 93       	push	r16
    258e:	1f 93       	push	r17

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp, n, time);
    2590:	0b 96       	adiw	r24, 0x0b	; 11
    2592:	0e 94 d0 10 	call	0x21a0	; 0x21a0 <iqReadTimeout>
}
    2596:	1f 91       	pop	r17
    2598:	0f 91       	pop	r16
    259a:	08 95       	ret

0000259c <read>:

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
                        n, TIME_INFINITE);
}

static size_t read(void *ip, uint8_t *bp, size_t n) {
    259c:	0f 93       	push	r16
    259e:	1f 93       	push	r17

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
    25a0:	0b 96       	adiw	r24, 0x0b	; 11
    25a2:	00 e0       	ldi	r16, 0x00	; 0
    25a4:	10 e0       	ldi	r17, 0x00	; 0
    25a6:	20 e0       	ldi	r18, 0x00	; 0
    25a8:	30 e0       	ldi	r19, 0x00	; 0
    25aa:	0e 94 d0 10 	call	0x21a0	; 0x21a0 <iqReadTimeout>
                       n, TIME_INFINITE);
}
    25ae:	1f 91       	pop	r17
    25b0:	0f 91       	pop	r16
    25b2:	08 95       	ret

000025b4 <writet>:
static msg_t gett(void *ip, systime_t timeout) {

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
}

static size_t writet(void *ip, const uint8_t *bp, size_t n, systime_t time) {
    25b4:	0f 93       	push	r16
    25b6:	1f 93       	push	r17

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, time);
    25b8:	4a 96       	adiw	r24, 0x1a	; 26
    25ba:	0e 94 2b 10 	call	0x2056	; 0x2056 <oqWriteTimeout>
}
    25be:	1f 91       	pop	r17
    25c0:	0f 91       	pop	r16
    25c2:	08 95       	ret

000025c4 <write>:
/*
 * Interface implementation, the following functions just invoke the equivalent
 * queue-level function or macro.
 */

static size_t write(void *ip, const uint8_t *bp, size_t n) {
    25c4:	0f 93       	push	r16
    25c6:	1f 93       	push	r17

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
    25c8:	4a 96       	adiw	r24, 0x1a	; 26
    25ca:	00 e0       	ldi	r16, 0x00	; 0
    25cc:	10 e0       	ldi	r17, 0x00	; 0
    25ce:	20 e0       	ldi	r18, 0x00	; 0
    25d0:	30 e0       	ldi	r19, 0x00	; 0
    25d2:	0e 94 2b 10 	call	0x2056	; 0x2056 <oqWriteTimeout>
                        n, TIME_INFINITE);
}
    25d6:	1f 91       	pop	r17
    25d8:	0f 91       	pop	r16
    25da:	08 95       	ret

000025dc <gett>:
  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
}

static msg_t gett(void *ip, systime_t timeout) {

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
    25dc:	0b 96       	adiw	r24, 0x0b	; 11
    25de:	0e 94 2f 11 	call	0x225e	; 0x225e <iqGetTimeout>
}
    25e2:	08 95       	ret

000025e4 <get>:
  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
}

static msg_t get(void *ip) {

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
    25e4:	0b 96       	adiw	r24, 0x0b	; 11
    25e6:	40 e0       	ldi	r20, 0x00	; 0
    25e8:	50 e0       	ldi	r21, 0x00	; 0
    25ea:	60 e0       	ldi	r22, 0x00	; 0
    25ec:	70 e0       	ldi	r23, 0x00	; 0
    25ee:	0e 94 2f 11 	call	0x225e	; 0x225e <iqGetTimeout>
}
    25f2:	08 95       	ret

000025f4 <putt>:

static msg_t putt(void *ip, uint8_t b, systime_t timeout) {

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
    25f4:	4a 96       	adiw	r24, 0x1a	; 26
    25f6:	0e 94 8e 10 	call	0x211c	; 0x211c <oqPutTimeout>
}
    25fa:	08 95       	ret

000025fc <put>:
                       n, TIME_INFINITE);
}

static msg_t put(void *ip, uint8_t b) {

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
    25fc:	4a 96       	adiw	r24, 0x1a	; 26
    25fe:	20 e0       	ldi	r18, 0x00	; 0
    2600:	30 e0       	ldi	r19, 0x00	; 0
    2602:	40 e0       	ldi	r20, 0x00	; 0
    2604:	50 e0       	ldi	r21, 0x00	; 0
    2606:	0e 94 8e 10 	call	0x211c	; 0x211c <oqPutTimeout>
}
    260a:	08 95       	ret

0000260c <sdInit>:
 *
 * @init
 */
void sdInit(void) {

  sd_lld_init();
    260c:	0e 94 b2 13 	call	0x2764	; 0x2764 <sd_lld_init>
}
    2610:	08 95       	ret

00002612 <stStartAlarm>:
    2612:	70 93 89 00 	sts	0x0089, r23
    2616:	60 93 88 00 	sts	0x0088, r22
    261a:	82 e0       	ldi	r24, 0x02	; 2
    261c:	86 bb       	out	0x16, r24	; 22
    261e:	80 93 6f 00 	sts	0x006F, r24
void stStartAlarm(systime_t time) {

  osalDbgAssert(stIsAlarmActive() == false, "already active");

  st_lld_start_alarm(time);
}
    2622:	08 95       	ret

00002624 <stStopAlarm>:
    2624:	10 92 6f 00 	sts	0x006F, r1
void stStopAlarm(void) {

  osalDbgAssert(stIsAlarmActive() != false, "not active");

  st_lld_stop_alarm();
}
    2628:	08 95       	ret

0000262a <stSetAlarm>:
    262a:	70 93 89 00 	sts	0x0089, r23
    262e:	60 93 88 00 	sts	0x0088, r22
void stSetAlarm(systime_t time) {

  osalDbgAssert(stIsAlarmActive() != false, "not active");

  st_lld_set_alarm(time);
}
    2632:	08 95       	ret

00002634 <stGetAlarm>:
    2634:	80 91 88 00 	lds	r24, 0x0088
    2638:	90 91 89 00 	lds	r25, 0x0089
systime_t stGetAlarm(void) {

  osalDbgAssert(stIsAlarmActive() != false, "not active");

  return st_lld_get_alarm();
}
    263c:	bc 01       	movw	r22, r24
    263e:	80 e0       	ldi	r24, 0x00	; 0
    2640:	90 e0       	ldi	r25, 0x00	; 0
    2642:	08 95       	ret

00002644 <stInit>:
 *
 * @init
 */
void stInit(void) {

  st_lld_init();
    2644:	0e 94 50 14 	call	0x28a0	; 0x28a0 <st_lld_init>
}
    2648:	08 95       	ret

0000264a <osalThreadDequeueAllI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void osalThreadDequeueAllI(threads_queue_t *tqp, msg_t msg) {
    264a:	cf 92       	push	r12
    264c:	df 92       	push	r13
    264e:	ff 92       	push	r15
    2650:	0f 93       	push	r16
    2652:	1f 93       	push	r17
    2654:	cf 93       	push	r28
    2656:	df 93       	push	r29
    2658:	8c 01       	movw	r16, r24
    265a:	6b 01       	movw	r12, r22
  semaphore_t *sp = &tqp->sem;
  thread_reference_t tr;
  cnt_t cnt;

  cnt = sp->cnt;
    265c:	fc 01       	movw	r30, r24
    265e:	f0 80       	ld	r15, Z
  sp->cnt = 0;
    2660:	10 82       	st	Z, r1
  tr = nil.threads;
  while (cnt < 0) {
    2662:	f7 fe       	sbrs	r15, 7
    2664:	0b c0       	rjmp	.+22     	; 0x267c <osalThreadDequeueAllI+0x32>
    2666:	c6 ed       	ldi	r28, 0xD6	; 214
    2668:	d7 e0       	ldi	r29, 0x07	; 7
    266a:	01 c0       	rjmp	.+2      	; 0x266e <osalThreadDequeueAllI+0x24>
      chDbgAssert(NIL_THD_IS_WTSEM(tr), "not waiting");

      cnt++;
      chSchReadyI(tr, msg);
    }
    tr++;
    266c:	2a 96       	adiw	r28, 0x0a	; 10
  cnt = sp->cnt;
  sp->cnt = 0;
  tr = nil.threads;
  while (cnt < 0) {
    /* Is this thread waiting on this semaphore?*/
    if (tr->u1.semp == sp) {
    266e:	8b 81       	ldd	r24, Y+3	; 0x03
    2670:	9c 81       	ldd	r25, Y+4	; 0x04
    2672:	80 17       	cp	r24, r16
    2674:	91 07       	cpc	r25, r17
    2676:	51 f0       	breq	.+20     	; 0x268c <osalThreadDequeueAllI+0x42>
  cnt_t cnt;

  cnt = sp->cnt;
  sp->cnt = 0;
  tr = nil.threads;
  while (cnt < 0) {
    2678:	f7 fc       	sbrc	r15, 7
    267a:	f8 cf       	rjmp	.-16     	; 0x266c <osalThreadDequeueAllI+0x22>
    tr++;

    chDbgAssert(tr < &nil.threads[NIL_CFG_NUM_THREADS],
                "pointer out of range");
  }
}
    267c:	df 91       	pop	r29
    267e:	cf 91       	pop	r28
    2680:	1f 91       	pop	r17
    2682:	0f 91       	pop	r16
    2684:	ff 90       	pop	r15
    2686:	df 90       	pop	r13
    2688:	cf 90       	pop	r12
    268a:	08 95       	ret
    /* Is this thread waiting on this semaphore?*/
    if (tr->u1.semp == sp) {

      chDbgAssert(NIL_THD_IS_WTSEM(tr), "not waiting");

      cnt++;
    268c:	f3 94       	inc	r15
      chSchReadyI(tr, msg);
    268e:	ce 01       	movw	r24, r28
    2690:	b6 01       	movw	r22, r12
    2692:	0e 94 b4 07 	call	0xf68	; 0xf68 <chSchReadyI>
    2696:	f0 cf       	rjmp	.-32     	; 0x2678 <osalThreadDequeueAllI+0x2e>

00002698 <osalThreadDequeueNextI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void osalThreadDequeueNextI(threads_queue_t *tqp, msg_t msg) {
    2698:	dc 01       	movw	r26, r24
  semaphore_t *sp = &tqp->sem;

  if (chSemGetCounterI(&tqp->sem) < 0) {
    269a:	8c 91       	ld	r24, X
    269c:	87 ff       	sbrs	r24, 7
    269e:	08 95       	ret
    thread_reference_t tr = nil.threads;
    while (true) {
      /* Is this thread waiting on this semaphore?*/
      if (tr->u1.semp == sp) {
    26a0:	80 91 d9 07 	lds	r24, 0x07D9
    26a4:	90 91 da 07 	lds	r25, 0x07DA
    26a8:	8a 17       	cp	r24, r26
    26aa:	9b 07       	cpc	r25, r27
    26ac:	79 f0       	breq	.+30     	; 0x26cc <osalThreadDequeueNextI+0x34>
        sp->cnt++;

        chDbgAssert(NIL_THD_IS_WTSEM(tr), "not waiting");

        chSchReadyI(tr, msg);
        return;
    26ae:	e6 ed       	ldi	r30, 0xD6	; 214
    26b0:	f7 e0       	ldi	r31, 0x07	; 7
      }
      tr++;
    26b2:	3a 96       	adiw	r30, 0x0a	; 10

  if (chSemGetCounterI(&tqp->sem) < 0) {
    thread_reference_t tr = nil.threads;
    while (true) {
      /* Is this thread waiting on this semaphore?*/
      if (tr->u1.semp == sp) {
    26b4:	83 81       	ldd	r24, Z+3	; 0x03
    26b6:	94 81       	ldd	r25, Z+4	; 0x04
    26b8:	8a 17       	cp	r24, r26
    26ba:	9b 07       	cpc	r25, r27
    26bc:	d1 f7       	brne	.-12     	; 0x26b2 <osalThreadDequeueNextI+0x1a>
        sp->cnt++;
    26be:	8c 91       	ld	r24, X
    26c0:	8f 5f       	subi	r24, 0xFF	; 255
    26c2:	8c 93       	st	X, r24

        chDbgAssert(NIL_THD_IS_WTSEM(tr), "not waiting");

        chSchReadyI(tr, msg);
    26c4:	cf 01       	movw	r24, r30
    26c6:	0e 94 b4 07 	call	0xf68	; 0xf68 <chSchReadyI>
    26ca:	08 95       	ret

  if (chSemGetCounterI(&tqp->sem) < 0) {
    thread_reference_t tr = nil.threads;
    while (true) {
      /* Is this thread waiting on this semaphore?*/
      if (tr->u1.semp == sp) {
    26cc:	e6 ed       	ldi	r30, 0xD6	; 214
    26ce:	f7 e0       	ldi	r31, 0x07	; 7
    26d0:	f6 cf       	rjmp	.-20     	; 0x26be <osalThreadDequeueNextI+0x26>

000026d2 <hal_lld_init>:
 * @brief   Low level HAL driver initialization.
 *
 * @notapi
 */
void hal_lld_init(void) {
}
    26d2:	08 95       	ret

000026d4 <notify1>:

#if AVR_SERIAL_USE_USART0 || defined(__DOXYGEN__)
static void notify1(io_queue_t *qp) {

  (void)qp;
  UCSR0B |= (1 << UDRIE0);
    26d4:	e1 ec       	ldi	r30, 0xC1	; 193
    26d6:	f0 e0       	ldi	r31, 0x00	; 0
    26d8:	80 81       	ld	r24, Z
    26da:	80 62       	ori	r24, 0x20	; 32
    26dc:	80 83       	st	Z, r24
}
    26de:	08 95       	ret

000026e0 <sd_lld_start>:
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @notapi
 */
void sd_lld_start(SerialDriver *sdp, const SerialConfig *config) {
    26e0:	fb 01       	movw	r30, r22

  if (config == NULL)
    26e2:	61 15       	cp	r22, r1
    26e4:	71 05       	cpc	r23, r1
    26e6:	b9 f0       	breq	.+46     	; 0x2716 <sd_lld_start+0x36>
    config = &default_config;

#if AVR_SERIAL_USE_USART0
  if (&SD1 == sdp) {
    26e8:	8a 53       	subi	r24, 0x3A	; 58
    26ea:	99 40       	sbci	r25, 0x09	; 9
    26ec:	09 f0       	breq	.+2      	; 0x26f0 <sd_lld_start+0x10>
    26ee:	08 95       	ret
 *
 * @param[in] config    the architecture-dependent serial driver configuration
 */
static void usart0_init(const SerialConfig *config) {

  UBRR0L = config->sc_brr;
    26f0:	80 81       	ld	r24, Z
    26f2:	91 81       	ldd	r25, Z+1	; 0x01
    26f4:	80 93 c4 00 	sts	0x00C4, r24
  UBRR0H = config->sc_brr >> 8;
    26f8:	90 93 c5 00 	sts	0x00C5, r25
  UCSR0A = 0;
    26fc:	10 92 c0 00 	sts	0x00C0, r1
  UCSR0B = (1 << RXEN0) | (1 << TXEN0) | (1 << RXCIE0);
    2700:	88 e9       	ldi	r24, 0x98	; 152
    2702:	80 93 c1 00 	sts	0x00C1, r24
  switch (config->sc_bits_per_char) {
    2706:	62 81       	ldd	r22, Z+2	; 0x02
    2708:	61 30       	cpi	r22, 0x01	; 1
    270a:	a1 f0       	breq	.+40     	; 0x2734 <sd_lld_start+0x54>
    270c:	61 30       	cpi	r22, 0x01	; 1
    270e:	30 f4       	brcc	.+12     	; 0x271c <sd_lld_start+0x3c>
  case USART_CHAR_SIZE_5:
    UCSR0C = 0;
    2710:	10 92 c2 00 	sts	0x00C2, r1
    2714:	08 95       	ret
 *
 * @notapi
 */
void sd_lld_start(SerialDriver *sdp, const SerialConfig *config) {

  if (config == NULL)
    2716:	e8 ea       	ldi	r30, 0xA8	; 168
    2718:	f3 e0       	ldi	r31, 0x03	; 3
    271a:	e6 cf       	rjmp	.-52     	; 0x26e8 <sd_lld_start+0x8>

  UBRR0L = config->sc_brr;
  UBRR0H = config->sc_brr >> 8;
  UCSR0A = 0;
  UCSR0B = (1 << RXEN0) | (1 << TXEN0) | (1 << RXCIE0);
  switch (config->sc_bits_per_char) {
    271c:	62 30       	cpi	r22, 0x02	; 2
    271e:	31 f0       	breq	.+12     	; 0x272c <sd_lld_start+0x4c>
    2720:	64 30       	cpi	r22, 0x04	; 4
    2722:	61 f0       	breq	.+24     	; 0x273c <sd_lld_start+0x5c>
    UCSR0B |= (1 << UCSZ02);
    UCSR0C = (1 << UCSZ00) | (1 << UCSZ01);
    break;
  case USART_CHAR_SIZE_8:
  default:
    UCSR0C = (1 << UCSZ00) | (1 << UCSZ01);
    2724:	86 e0       	ldi	r24, 0x06	; 6
    2726:	80 93 c2 00 	sts	0x00C2, r24
    272a:	08 95       	ret
    break;
  case USART_CHAR_SIZE_6:
    UCSR0C = (1 << UCSZ00);
    break;
  case USART_CHAR_SIZE_7:
    UCSR0C = (1 << UCSZ01);
    272c:	84 e0       	ldi	r24, 0x04	; 4
    272e:	80 93 c2 00 	sts	0x00C2, r24
    2732:	08 95       	ret
  switch (config->sc_bits_per_char) {
  case USART_CHAR_SIZE_5:
    UCSR0C = 0;
    break;
  case USART_CHAR_SIZE_6:
    UCSR0C = (1 << UCSZ00);
    2734:	82 e0       	ldi	r24, 0x02	; 2
    2736:	80 93 c2 00 	sts	0x00C2, r24
    273a:	08 95       	ret
    break;
  case USART_CHAR_SIZE_7:
    UCSR0C = (1 << UCSZ01);
    break;
  case USART_CHAR_SIZE_9:
    UCSR0B |= (1 << UCSZ02);
    273c:	80 91 c1 00 	lds	r24, 0x00C1
    2740:	84 60       	ori	r24, 0x04	; 4
    2742:	80 93 c1 00 	sts	0x00C1, r24
    UCSR0C = (1 << UCSZ00) | (1 << UCSZ01);
    2746:	86 e0       	ldi	r24, 0x06	; 6
    2748:	80 93 c2 00 	sts	0x00C2, r24
    274c:	08 95       	ret

0000274e <sd_lld_stop>:
 * @notapi
 */
void sd_lld_stop(SerialDriver *sdp) {

#if AVR_SERIAL_USE_USART0
  if (&SD1 == sdp)
    274e:	8a 53       	subi	r24, 0x3A	; 58
    2750:	99 40       	sbci	r25, 0x09	; 9
    2752:	09 f0       	breq	.+2      	; 0x2756 <sd_lld_stop+0x8>
    2754:	08 95       	ret
/**
 * @brief   USART0 de-initialization.
 */
static void usart0_deinit(void) {

  UCSR0A = 0;
    2756:	10 92 c0 00 	sts	0x00C0, r1
  UCSR0B = 0;
    275a:	10 92 c1 00 	sts	0x00C1, r1
  UCSR0C = 0;
    275e:	10 92 c2 00 	sts	0x00C2, r1
    2762:	08 95       	ret

00002764 <sd_lld_init>:
 * @notapi
 */
void sd_lld_init(void) {

#if AVR_SERIAL_USE_USART0
  sdObjectInit(&SD1, NULL, notify1);
    2764:	8a e3       	ldi	r24, 0x3A	; 58
    2766:	99 e0       	ldi	r25, 0x09	; 9
    2768:	60 e0       	ldi	r22, 0x00	; 0
    276a:	70 e0       	ldi	r23, 0x00	; 0
    276c:	4a e6       	ldi	r20, 0x6A	; 106
    276e:	53 e1       	ldi	r21, 0x13	; 19
    2770:	0e 94 93 12 	call	0x2526	; 0x2526 <sdObjectInit>
#endif
#if AVR_SERIAL_USE_USART1
  sdObjectInit(&SD2, NULL, notify2);
#endif
}
    2774:	08 95       	ret

00002776 <__vector_21>:
/**
 * @brief   USART0 TX interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(AVR_SD1_TX_VECT) {
    2776:	1f 92       	push	r1
    2778:	0f 92       	push	r0
    277a:	0f b6       	in	r0, 0x3f	; 63
    277c:	0f 92       	push	r0
    277e:	0b b6       	in	r0, 0x3b	; 59
    2780:	0f 92       	push	r0
    2782:	11 24       	eor	r1, r1
    2784:	2f 93       	push	r18
    2786:	3f 93       	push	r19
    2788:	4f 93       	push	r20
    278a:	5f 93       	push	r21
    278c:	6f 93       	push	r22
    278e:	7f 93       	push	r23
    2790:	8f 93       	push	r24
    2792:	9f 93       	push	r25
    2794:	af 93       	push	r26
    2796:	bf 93       	push	r27
    2798:	ef 93       	push	r30
    279a:	ff 93       	push	r31
  msg_t b;

  OSAL_IRQ_PROLOGUE();

  osalSysLockFromISR();
  b = sdRequestDataI(&SD1);
    279c:	8a e3       	ldi	r24, 0x3A	; 58
    279e:	99 e0       	ldi	r25, 0x09	; 9
    27a0:	0e 94 0e 12 	call	0x241c	; 0x241c <sdRequestDataI>
  osalSysUnlockFromISR();
  if (b < Q_OK)
    27a4:	97 fd       	sbrc	r25, 7
    27a6:	17 c0       	rjmp	.+46     	; 0x27d6 <__vector_21+0x60>
    UCSR0B &= ~(1 << UDRIE0);
  else
    UDR0 = b;
    27a8:	80 93 c6 00 	sts	0x00C6, r24

  OSAL_IRQ_EPILOGUE();
    27ac:	0e 94 0e 09 	call	0x121c	; 0x121c <chSchRescheduleS>
}
    27b0:	ff 91       	pop	r31
    27b2:	ef 91       	pop	r30
    27b4:	bf 91       	pop	r27
    27b6:	af 91       	pop	r26
    27b8:	9f 91       	pop	r25
    27ba:	8f 91       	pop	r24
    27bc:	7f 91       	pop	r23
    27be:	6f 91       	pop	r22
    27c0:	5f 91       	pop	r21
    27c2:	4f 91       	pop	r20
    27c4:	3f 91       	pop	r19
    27c6:	2f 91       	pop	r18
    27c8:	0f 90       	pop	r0
    27ca:	0b be       	out	0x3b, r0	; 59
    27cc:	0f 90       	pop	r0
    27ce:	0f be       	out	0x3f, r0	; 63
    27d0:	0f 90       	pop	r0
    27d2:	1f 90       	pop	r1
    27d4:	18 95       	reti

  osalSysLockFromISR();
  b = sdRequestDataI(&SD1);
  osalSysUnlockFromISR();
  if (b < Q_OK)
    UCSR0B &= ~(1 << UDRIE0);
    27d6:	80 91 c1 00 	lds	r24, 0x00C1
    27da:	8f 7d       	andi	r24, 0xDF	; 223
    27dc:	80 93 c1 00 	sts	0x00C1, r24
    27e0:	e5 cf       	rjmp	.-54     	; 0x27ac <__vector_21+0x36>

000027e2 <__vector_20>:
/**
 * @brief   USART0 RX interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(AVR_SD1_RX_VECT) {
    27e2:	1f 92       	push	r1
    27e4:	0f 92       	push	r0
    27e6:	0f b6       	in	r0, 0x3f	; 63
    27e8:	0f 92       	push	r0
    27ea:	0b b6       	in	r0, 0x3b	; 59
    27ec:	0f 92       	push	r0
    27ee:	11 24       	eor	r1, r1
    27f0:	2f 93       	push	r18
    27f2:	3f 93       	push	r19
    27f4:	4f 93       	push	r20
    27f6:	5f 93       	push	r21
    27f8:	6f 93       	push	r22
    27fa:	7f 93       	push	r23
    27fc:	8f 93       	push	r24
    27fe:	9f 93       	push	r25
    2800:	af 93       	push	r26
    2802:	bf 93       	push	r27
    2804:	ef 93       	push	r30
    2806:	ff 93       	push	r31
  uint8_t sra;

  OSAL_IRQ_PROLOGUE();

  sra = UCSR0A;
    2808:	90 91 c0 00 	lds	r25, 0x00C0
  if (sra & ((1 << DOR0) | (1 << UPE0) | (1 << FE0)))
    280c:	89 2f       	mov	r24, r25
    280e:	8c 71       	andi	r24, 0x1C	; 28
    2810:	39 f1       	breq	.+78     	; 0x2860 <__vector_20+0x7e>
    upe = (1 << UPE1);
    fe = (1 << FE1);
  }
#endif

  if (sra & dor)
    2812:	93 fd       	sbrc	r25, 3
    2814:	40 c0       	rjmp	.+128    	; 0x2896 <__vector_20+0xb4>
    2816:	20 e0       	ldi	r18, 0x00	; 0
    2818:	30 e0       	ldi	r19, 0x00	; 0
    281a:	40 e0       	ldi	r20, 0x00	; 0
    281c:	50 e0       	ldi	r21, 0x00	; 0
    sts |= SD_OVERRUN_ERROR;
  if (sra & upe)
    281e:	92 fd       	sbrc	r25, 2
    sts |= SD_PARITY_ERROR;
    2820:	20 62       	ori	r18, 0x20	; 32
  if (sra & fe)
    2822:	94 fd       	sbrc	r25, 4
    sts |= SD_FRAMING_ERROR;
    2824:	20 64       	ori	r18, 0x40	; 64
    2826:	80 91 3c 09 	lds	r24, 0x093C
    282a:	90 91 3d 09 	lds	r25, 0x093D
    282e:	a0 91 3e 09 	lds	r26, 0x093E
    2832:	b0 91 3f 09 	lds	r27, 0x093F
    2836:	28 2b       	or	r18, r24
    2838:	39 2b       	or	r19, r25
    283a:	4a 2b       	or	r20, r26
    283c:	5b 2b       	or	r21, r27
    283e:	20 93 3c 09 	sts	0x093C, r18
    2842:	30 93 3d 09 	sts	0x093D, r19
    2846:	40 93 3e 09 	sts	0x093E, r20
    284a:	50 93 3f 09 	sts	0x093F, r21
    284e:	e0 91 40 09 	lds	r30, 0x0940
    2852:	f0 91 41 09 	lds	r31, 0x0941
    2856:	30 97       	sbiw	r30, 0x00	; 0
    2858:	19 f0       	breq	.+6      	; 0x2860 <__vector_20+0x7e>
    285a:	8c e3       	ldi	r24, 0x3C	; 60
    285c:	99 e0       	ldi	r25, 0x09	; 9
    285e:	09 95       	icall

  sra = UCSR0A;
  if (sra & ((1 << DOR0) | (1 << UPE0) | (1 << FE0)))
    set_error(sra, &SD1);
  osalSysLockFromISR();
  sdIncomingDataI(&SD1, UDR0);
    2860:	60 91 c6 00 	lds	r22, 0x00C6
    2864:	8a e3       	ldi	r24, 0x3A	; 58
    2866:	99 e0       	ldi	r25, 0x09	; 9
    2868:	0e 94 37 12 	call	0x246e	; 0x246e <sdIncomingDataI>
  osalSysUnlockFromISR();

  OSAL_IRQ_EPILOGUE();
    286c:	0e 94 0e 09 	call	0x121c	; 0x121c <chSchRescheduleS>
}
    2870:	ff 91       	pop	r31
    2872:	ef 91       	pop	r30
    2874:	bf 91       	pop	r27
    2876:	af 91       	pop	r26
    2878:	9f 91       	pop	r25
    287a:	8f 91       	pop	r24
    287c:	7f 91       	pop	r23
    287e:	6f 91       	pop	r22
    2880:	5f 91       	pop	r21
    2882:	4f 91       	pop	r20
    2884:	3f 91       	pop	r19
    2886:	2f 91       	pop	r18
    2888:	0f 90       	pop	r0
    288a:	0b be       	out	0x3b, r0	; 59
    288c:	0f 90       	pop	r0
    288e:	0f be       	out	0x3f, r0	; 63
    2890:	0f 90       	pop	r0
    2892:	1f 90       	pop	r1
    2894:	18 95       	reti
    upe = (1 << UPE1);
    fe = (1 << FE1);
  }
#endif

  if (sra & dor)
    2896:	20 e8       	ldi	r18, 0x80	; 128
    2898:	30 e0       	ldi	r19, 0x00	; 0
    289a:	40 e0       	ldi	r20, 0x00	; 0
    289c:	50 e0       	ldi	r21, 0x00	; 0
    289e:	bf cf       	rjmp	.-130    	; 0x281e <__vector_20+0x3c>

000028a0 <st_lld_init>:

  /*
   * Periodic mode uses Timer 0 (8 bit).
   */
#if defined(TCCR0B) /* Timer has multiple output comparators                       */
  TCCR0A  = (1 << WGM01) | (0 << WGM00) |                /* CTC mode.        */
    28a0:	92 e0       	ldi	r25, 0x02	; 2
    28a2:	94 bd       	out	0x24, r25	; 36
            (0 << COM0A1) | (0 << COM0A0) |              /* OC0A disabled.   */
            (0 << COM0B1) | (0 << COM0B0);               /* OC0B disabled.   */
  TCCR0B  = (0 << WGM02) | AVR_TIMER_PRESCALER_BITS;     /* CTC mode.        */
    28a4:	95 bd       	out	0x25, r25	; 37
  OCR0A   = AVR_TIMER_COUNTER - 1;
    28a6:	83 e6       	ldi	r24, 0x63	; 99
    28a8:	87 bd       	out	0x27, r24	; 39
  TCNT0   = 0;                                           /* Reset counter.   */
    28aa:	16 bc       	out	0x26, r1	; 38
  TIFR0   = (1 << OCF0A);                                /* Reset pending.   */
    28ac:	95 bb       	out	0x15, r25	; 21
  TIMSK0  = (1 << OCIE0A);                               /* IRQ on compare.  */
    28ae:	90 93 6e 00 	sts	0x006E, r25
  #error "Neither TCCR0A nor TCCR0 registers are defined"
#endif

#endif /* OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC */

}
    28b2:	08 95       	ret

000028b4 <__vector_16>:
#if (OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC) || defined(__DOXYGEN__)

/**
 * @brief Timer handler for periodic mode.
 */
OSAL_IRQ_HANDLER(AVR_TIMER_VECT) {
    28b4:	1f 92       	push	r1
    28b6:	0f 92       	push	r0
    28b8:	0f b6       	in	r0, 0x3f	; 63
    28ba:	0f 92       	push	r0
    28bc:	0b b6       	in	r0, 0x3b	; 59
    28be:	0f 92       	push	r0
    28c0:	11 24       	eor	r1, r1
    28c2:	2f 93       	push	r18
    28c4:	3f 93       	push	r19
    28c6:	4f 93       	push	r20
    28c8:	5f 93       	push	r21
    28ca:	6f 93       	push	r22
    28cc:	7f 93       	push	r23
    28ce:	8f 93       	push	r24
    28d0:	9f 93       	push	r25
    28d2:	af 93       	push	r26
    28d4:	bf 93       	push	r27
    28d6:	ef 93       	push	r30
    28d8:	ff 93       	push	r31
    28da:	0e 94 4f 07 	call	0xe9e	; 0xe9e <chSysTimerHandlerI>

  osalSysLockFromISR();
  osalOsTimerHandlerI();
  osalSysUnlockFromISR();

  OSAL_IRQ_EPILOGUE();
    28de:	0e 94 0e 09 	call	0x121c	; 0x121c <chSchRescheduleS>
}
    28e2:	ff 91       	pop	r31
    28e4:	ef 91       	pop	r30
    28e6:	bf 91       	pop	r27
    28e8:	af 91       	pop	r26
    28ea:	9f 91       	pop	r25
    28ec:	8f 91       	pop	r24
    28ee:	7f 91       	pop	r23
    28f0:	6f 91       	pop	r22
    28f2:	5f 91       	pop	r21
    28f4:	4f 91       	pop	r20
    28f6:	3f 91       	pop	r19
    28f8:	2f 91       	pop	r18
    28fa:	0f 90       	pop	r0
    28fc:	0b be       	out	0x3b, r0	; 59
    28fe:	0f 90       	pop	r0
    2900:	0f be       	out	0x3f, r0	; 63
    2902:	0f 90       	pop	r0
    2904:	1f 90       	pop	r1
    2906:	18 95       	reti

00002908 <boardInit>:
void boardInit(void) {

  /*
   * External interrupts setup, all disabled initially.
   */
  EICRA  = 0x00;
    2908:	10 92 69 00 	sts	0x0069, r1
  EIMSK  = 0x00;
    290c:	1d ba       	out	0x1d, r1	; 29

}
    290e:	08 95       	ret

00002910 <spi_init>:
PB7:SCK
*/

void spi_init(void) {
	// Set MOSI and SCK, SS/CS output, all others input
	DDRB |= (1<<PB7) | (1<<PB5) | (1<<PB4);
    2910:	84 b1       	in	r24, 0x04	; 4
    2912:	80 6b       	ori	r24, 0xB0	; 176
    2914:	84 b9       	out	0x04, r24	; 4
	// Enable SPI, Master, set clock rate fck/4, mode 0
	SPCR = (1<<SPE) | (1<<MSTR);
    2916:	80 e5       	ldi	r24, 0x50	; 80
    2918:	8c bd       	out	0x2c, r24	; 44

	// Set SS/CS
	PORTB |= (1 << PB4);
    291a:	2c 9a       	sbi	0x05, 4	; 5
}
    291c:	08 95       	ret

0000291e <i2c_init>:
 Initialization of the I2C bus interface. Need to be called only once
*************************************************************************/
void i2c_init(void)
{
  /* initialize TWI clock: 100 kHz clock, TWPS = 0 => prescaler = 1 */
  TWSR = 0;                         /* no prescaler */
    291e:	10 92 b9 00 	sts	0x00B9, r1
  TWBR = ((F_CPU/SCL_CLOCK)-16)/2;  /* must be > 10 for stable operation */
    2922:	8c e0       	ldi	r24, 0x0C	; 12
    2924:	80 93 b8 00 	sts	0x00B8, r24

}/* i2c_init */
    2928:	08 95       	ret

0000292a <i2c_start>:
/*************************************************************************	
  Issues a start condition and sends address and transfer direction.
  return 0 = device accessible, 1= failed to access device
*************************************************************************/
unsigned char i2c_start(unsigned char address)
{
    292a:	98 2f       	mov	r25, r24
    uint8_t   twst;
	// send START condition
	TWCR = (1<<TWINT) | (1<<TWSTA) | (1<<TWEN);
    292c:	84 ea       	ldi	r24, 0xA4	; 164
    292e:	80 93 bc 00 	sts	0x00BC, r24

	// wait until transmission completed
	while(!(TWCR & (1<<TWINT)));
    2932:	80 91 bc 00 	lds	r24, 0x00BC
    2936:	87 ff       	sbrs	r24, 7
    2938:	fc cf       	rjmp	.-8      	; 0x2932 <i2c_start+0x8>

	// check value of TWI Status Register. Mask prescaler bits.
	twst = TW_STATUS & 0xF8;
    293a:	80 91 b9 00 	lds	r24, 0x00B9
    293e:	88 7f       	andi	r24, 0xF8	; 248
	if ( (twst != TW_START) && (twst != TW_REP_START)) {
    2940:	88 30       	cpi	r24, 0x08	; 8
    2942:	21 f0       	breq	.+8      	; 0x294c <i2c_start+0x22>
    2944:	80 31       	cpi	r24, 0x10	; 16
    2946:	11 f0       	breq	.+4      	; 0x294c <i2c_start+0x22>
    2948:	81 e0       	ldi	r24, 0x01	; 1
    294a:	08 95       	ret
		return 1;
	}

	// send device address
	TWDR = address;
    294c:	90 93 bb 00 	sts	0x00BB, r25
	TWCR = (1<<TWINT) | (1<<TWEN);
    2950:	84 e8       	ldi	r24, 0x84	; 132
    2952:	80 93 bc 00 	sts	0x00BC, r24

	// wail until transmission completed and ACK/NACK has been received
	while(!(TWCR & (1<<TWINT)));
    2956:	80 91 bc 00 	lds	r24, 0x00BC
    295a:	87 ff       	sbrs	r24, 7
    295c:	fc cf       	rjmp	.-8      	; 0x2956 <i2c_start+0x2c>

	// check value of TWI Status Register. Mask prescaler bits.
	twst = TW_STATUS & 0xF8;
    295e:	90 91 b9 00 	lds	r25, 0x00B9
    2962:	98 7f       	andi	r25, 0xF8	; 248
	if ( (twst != TW_MT_SLA_ACK) && (twst != TW_MR_SLA_ACK) ) {
    2964:	98 31       	cpi	r25, 0x18	; 24
    2966:	29 f0       	breq	.+10     	; 0x2972 <i2c_start+0x48>
    2968:	80 e0       	ldi	r24, 0x00	; 0
    296a:	90 34       	cpi	r25, 0x40	; 64
    296c:	09 f0       	breq	.+2      	; 0x2970 <i2c_start+0x46>
    296e:	81 e0       	ldi	r24, 0x01	; 1
		return 1;
	}
	
	return 0;

}/* i2c_start */
    2970:	08 95       	ret
	// wail until transmission completed and ACK/NACK has been received
	while(!(TWCR & (1<<TWINT)));

	// check value of TWI Status Register. Mask prescaler bits.
	twst = TW_STATUS & 0xF8;
	if ( (twst != TW_MT_SLA_ACK) && (twst != TW_MR_SLA_ACK) ) {
    2972:	80 e0       	ldi	r24, 0x00	; 0
    2974:	08 95       	ret

00002976 <i2c_start_wait>:
 If device is busy, use ack polling to wait until device is ready
 
 Input:   address and transfer direction of I2C device
*************************************************************************/
void i2c_start_wait(unsigned char address)
{
    2976:	98 2f       	mov	r25, r24
    uint8_t   twst;

    while ( 1 )
    {
	    // send START condition
	    TWCR = (1<<TWINT) | (1<<TWSTA) | (1<<TWEN);
    2978:	24 ea       	ldi	r18, 0xA4	; 164
    	twst = TW_STATUS & 0xF8;
    	if ( (twst != TW_START) && (twst != TW_REP_START)) continue;
    
    	// send device address
    	TWDR = address;
    	TWCR = (1<<TWINT) | (1<<TWEN);
    297a:	34 e8       	ldi	r19, 0x84	; 132
    	// check value of TWI Status Register. Mask prescaler bits.
    	twst = TW_STATUS & 0xF8;
    	if ( (twst == TW_MT_SLA_NACK )||(twst ==TW_MR_DATA_NACK) ) 
    	{    	    
    	    /* device busy, send stop condition to terminate write operation */
	        TWCR = (1<<TWINT) | (1<<TWEN) | (1<<TWSTO);
    297c:	44 e9       	ldi	r20, 0x94	; 148
    uint8_t   twst;

    while ( 1 )
    {
	    // send START condition
	    TWCR = (1<<TWINT) | (1<<TWSTA) | (1<<TWEN);
    297e:	20 93 bc 00 	sts	0x00BC, r18
    
    	// wait until transmission completed
    	while(!(TWCR & (1<<TWINT)));
    2982:	80 91 bc 00 	lds	r24, 0x00BC
    2986:	87 ff       	sbrs	r24, 7
    2988:	fc cf       	rjmp	.-8      	; 0x2982 <i2c_start_wait+0xc>
    
    	// check value of TWI Status Register. Mask prescaler bits.
    	twst = TW_STATUS & 0xF8;
    298a:	80 91 b9 00 	lds	r24, 0x00B9
    298e:	88 7f       	andi	r24, 0xF8	; 248
    	if ( (twst != TW_START) && (twst != TW_REP_START)) continue;
    2990:	88 30       	cpi	r24, 0x08	; 8
    2992:	11 f0       	breq	.+4      	; 0x2998 <i2c_start_wait+0x22>
    2994:	80 31       	cpi	r24, 0x10	; 16
    2996:	99 f7       	brne	.-26     	; 0x297e <i2c_start_wait+0x8>
    
    	// send device address
    	TWDR = address;
    2998:	90 93 bb 00 	sts	0x00BB, r25
    	TWCR = (1<<TWINT) | (1<<TWEN);
    299c:	30 93 bc 00 	sts	0x00BC, r19
    
    	// wail until transmission completed
    	while(!(TWCR & (1<<TWINT)));
    29a0:	80 91 bc 00 	lds	r24, 0x00BC
    29a4:	87 ff       	sbrs	r24, 7
    29a6:	fc cf       	rjmp	.-8      	; 0x29a0 <i2c_start_wait+0x2a>
    
    	// check value of TWI Status Register. Mask prescaler bits.
    	twst = TW_STATUS & 0xF8;
    29a8:	80 91 b9 00 	lds	r24, 0x00B9
    29ac:	88 7f       	andi	r24, 0xF8	; 248
    	if ( (twst == TW_MT_SLA_NACK )||(twst ==TW_MR_DATA_NACK) ) 
    29ae:	80 32       	cpi	r24, 0x20	; 32
    29b0:	11 f0       	breq	.+4      	; 0x29b6 <i2c_start_wait+0x40>
    29b2:	88 35       	cpi	r24, 0x58	; 88
    29b4:	39 f4       	brne	.+14     	; 0x29c4 <i2c_start_wait+0x4e>
    	{    	    
    	    /* device busy, send stop condition to terminate write operation */
	        TWCR = (1<<TWINT) | (1<<TWEN) | (1<<TWSTO);
    29b6:	40 93 bc 00 	sts	0x00BC, r20
	        
	        // wait until stop condition is executed and bus released
	        while(TWCR & (1<<TWSTO));
    29ba:	80 91 bc 00 	lds	r24, 0x00BC
    29be:	84 fd       	sbrc	r24, 4
    29c0:	fc cf       	rjmp	.-8      	; 0x29ba <i2c_start_wait+0x44>
    29c2:	dd cf       	rjmp	.-70     	; 0x297e <i2c_start_wait+0x8>
    29c4:	08 95       	ret

000029c6 <i2c_rep_start>:
 Return:  0 device accessible
          1 failed to access device
*************************************************************************/
unsigned char i2c_rep_start(unsigned char address)
{
    return i2c_start(address);
    29c6:	0e 94 95 14 	call	0x292a	; 0x292a <i2c_start>

}/* i2c_rep_start */
    29ca:	08 95       	ret

000029cc <i2c_stop>:
 Terminates the data transfer and releases the I2C bus
*************************************************************************/
void i2c_stop(void)
{
	/* send stop condition */
	TWCR = (1<<TWINT) | (1<<TWEN) | (1<<TWSTO);
    29cc:	84 e9       	ldi	r24, 0x94	; 148
    29ce:	80 93 bc 00 	sts	0x00BC, r24
	// wait until stop condition is executed and bus released
	while(TWCR & (1<<TWSTO));
    29d2:	80 91 bc 00 	lds	r24, 0x00BC
    29d6:	84 fd       	sbrc	r24, 4
    29d8:	fc cf       	rjmp	.-8      	; 0x29d2 <i2c_stop+0x6>

}/* i2c_stop */
    29da:	08 95       	ret

000029dc <i2c_write>:
unsigned char i2c_write(unsigned char data)
{	
    uint8_t   twst;
    
	// send data to the previously addressed device
	TWDR = data;
    29dc:	80 93 bb 00 	sts	0x00BB, r24
	TWCR = (1<<TWINT) | (1<<TWEN);
    29e0:	84 e8       	ldi	r24, 0x84	; 132
    29e2:	80 93 bc 00 	sts	0x00BC, r24

	// wait until transmission completed
	while(!(TWCR & (1<<TWINT)));
    29e6:	80 91 bc 00 	lds	r24, 0x00BC
    29ea:	87 ff       	sbrs	r24, 7
    29ec:	fc cf       	rjmp	.-8      	; 0x29e6 <i2c_write+0xa>

	// check value of TWI Status Register. Mask prescaler bits
	twst = TW_STATUS & 0xF8;
    29ee:	80 91 b9 00 	lds	r24, 0x00B9
    29f2:	90 e0       	ldi	r25, 0x00	; 0
    29f4:	88 7f       	andi	r24, 0xF8	; 248
    29f6:	88 32       	cpi	r24, 0x28	; 40
    29f8:	09 f0       	breq	.+2      	; 0x29fc <i2c_write+0x20>
    29fa:	91 e0       	ldi	r25, 0x01	; 1
	if( twst != TW_MT_DATA_ACK) {
	 return 1;
	}
	return 0;

}/* i2c_write */
    29fc:	89 2f       	mov	r24, r25
    29fe:	08 95       	ret

00002a00 <i2c_readAck>:
 
 Return:  byte read from I2C device
*************************************************************************/
unsigned char i2c_readAck(void)
{
	TWCR = (1<<TWINT) | (1<<TWEN) | (1<<TWEA);
    2a00:	84 ec       	ldi	r24, 0xC4	; 196
    2a02:	80 93 bc 00 	sts	0x00BC, r24
	while(!(TWCR & (1<<TWINT)));    
    2a06:	80 91 bc 00 	lds	r24, 0x00BC
    2a0a:	87 ff       	sbrs	r24, 7
    2a0c:	fc cf       	rjmp	.-8      	; 0x2a06 <i2c_readAck+0x6>
    return TWDR;
    2a0e:	80 91 bb 00 	lds	r24, 0x00BB

}/* i2c_readAck */
    2a12:	08 95       	ret

00002a14 <i2c_readNak>:
 
 Return:  byte read from I2C device
*************************************************************************/
unsigned char i2c_readNak(void)
{
	TWCR = (1<<TWINT) | (1<<TWEN);
    2a14:	84 e8       	ldi	r24, 0x84	; 132
    2a16:	80 93 bc 00 	sts	0x00BC, r24
	while(!(TWCR & (1<<TWINT)));
    2a1a:	80 91 bc 00 	lds	r24, 0x00BC
    2a1e:	87 ff       	sbrs	r24, 7
    2a20:	fc cf       	rjmp	.-8      	; 0x2a1a <i2c_readNak+0x6>
    return TWDR;
    2a22:	80 91 bb 00 	lds	r24, 0x00BB

}/* i2c_readNak */
    2a26:	08 95       	ret

00002a28 <st7735_write_self_color>:
uint8_t st7735_width = 0;
uint8_t st7735_height = 0;
enum ST7735_ORIENTATION st7735_orientation = ST7735_LANDSCAPE_INV;

static inline void st7735_set_rs(void) {
	PORTB |= (1 << PB0);
    2a28:	28 9a       	sbi	0x05, 0	; 5
static inline void spi_set_cs(void) {
	PORTB |= (1 << PB4);
}

static inline void spi_unset_cs(void) {
	PORTB &= ~(1 << PB4);
    2a2a:	2c 98       	cbi	0x05, 4	; 5
#include<avr/io.h>

void spi_init(void);

static inline void spi_write(uint8_t byte) {
	SPDR = byte;
    2a2c:	9e bd       	out	0x2e, r25	; 46
	while(!(SPSR & (1<<SPIF)));
    2a2e:	0d b4       	in	r0, 0x2d	; 45
    2a30:	07 fe       	sbrs	r0, 7
    2a32:	fd cf       	rjmp	.-6      	; 0x2a2e <st7735_write_self_color+0x6>
#include<avr/io.h>

void spi_init(void);

static inline void spi_write(uint8_t byte) {
	SPDR = byte;
    2a34:	8e bd       	out	0x2e, r24	; 46
	while(!(SPSR & (1<<SPIF)));
    2a36:	0d b4       	in	r0, 0x2d	; 45
    2a38:	07 fe       	sbrs	r0, 7
    2a3a:	fd cf       	rjmp	.-6      	; 0x2a36 <st7735_write_self_color+0xe>
}

static inline void spi_set_cs(void) {
	PORTB |= (1 << PB4);
    2a3c:	2c 9a       	sbi	0x05, 4	; 5
void st7735_write_self_color(uint16_t color) {
	st7735_set_rs();
  	spi_unset_cs();
	st7735_write_color(color);
  	spi_set_cs();
}
    2a3e:	08 95       	ret

00002a40 <st7735_run_command_list>:
	//_delay_ms(500);
	chThdSleepMilliseconds(500);
}


void st7735_run_command_list(const uint8_t *addr) {
    2a40:	cf 92       	push	r12
    2a42:	df 92       	push	r13
    2a44:	ef 92       	push	r14
    2a46:	ff 92       	push	r15
    2a48:	0f 93       	push	r16
    2a4a:	1f 93       	push	r17
    2a4c:	cf 93       	push	r28
    2a4e:	df 93       	push	r29
    2a50:	fc 01       	movw	r30, r24
	uint8_t  cmd_count, arg_count, has_delay;

	cmd_count = pgm_read_byte(addr++);   // Number of commands to follow
    2a52:	c4 90       	lpm	r12, Z+
	for(uint8_t cmd_pos = 0; cmd_pos < cmd_count; cmd_pos++) {
    2a54:	cc 20       	and	r12, r12
    2a56:	09 f4       	brne	.+2      	; 0x2a5a <st7735_run_command_list+0x1a>
    2a58:	56 c0       	rjmp	.+172    	; 0x2b06 <st7735_run_command_list+0xc6>


void st7735_run_command_list(const uint8_t *addr) {
	uint8_t  cmd_count, arg_count, has_delay;

	cmd_count = pgm_read_byte(addr++);   // Number of commands to follow
    2a5a:	7c 01       	movw	r14, r24
    2a5c:	08 94       	sec
    2a5e:	e1 1c       	adc	r14, r1
    2a60:	f1 1c       	adc	r15, r1
    2a62:	dd 24       	eor	r13, r13
	for(uint8_t cmd_pos = 0; cmd_pos < cmd_count; cmd_pos++) {
		st7735_write_cmd(pgm_read_byte(addr++)); 	// Read, send command
    2a64:	97 01       	movw	r18, r14
    2a66:	2f 5f       	subi	r18, 0xFF	; 255
    2a68:	3f 4f       	sbci	r19, 0xFF	; 255
    2a6a:	f7 01       	movw	r30, r14
    2a6c:	84 91       	lpm	r24, Z+
static inline void st7735_set_rs(void) {
	PORTB |= (1 << PB0);
}

static inline void st7735_unset_rs(void) {
	PORTB &= ~(1 << PB0);
    2a6e:	28 98       	cbi	0x05, 0	; 5
}

static inline void spi_unset_cs(void) {
	PORTB &= ~(1 << PB4);
    2a70:	2c 98       	cbi	0x05, 4	; 5
#include<avr/io.h>

void spi_init(void);

static inline void spi_write(uint8_t byte) {
	SPDR = byte;
    2a72:	8e bd       	out	0x2e, r24	; 46
	while(!(SPSR & (1<<SPIF)));
    2a74:	0d b4       	in	r0, 0x2d	; 45
    2a76:	07 fe       	sbrs	r0, 7
    2a78:	fd cf       	rjmp	.-6      	; 0x2a74 <st7735_run_command_list+0x34>
}

static inline void spi_set_cs(void) {
	PORTB |= (1 << PB4);
    2a7a:	2c 9a       	sbi	0x05, 4	; 5
	uint8_t  cmd_count, arg_count, has_delay;

	cmd_count = pgm_read_byte(addr++);   // Number of commands to follow
	for(uint8_t cmd_pos = 0; cmd_pos < cmd_count; cmd_pos++) {
		st7735_write_cmd(pgm_read_byte(addr++)); 	// Read, send command
		arg_count  = pgm_read_byte(addr++);    		// Number of args to follow
    2a7c:	b9 01       	movw	r22, r18
    2a7e:	6f 5f       	subi	r22, 0xFF	; 255
    2a80:	7f 4f       	sbci	r23, 0xFF	; 255
    2a82:	f9 01       	movw	r30, r18
    2a84:	a4 91       	lpm	r26, Z+
		has_delay = arg_count & DELAY_FLAG;         // If set, delay follows args
		arg_count &= ~DELAY_FLAG;                  	// Number of args
    2a86:	8a 2f       	mov	r24, r26
    2a88:	8f 77       	andi	r24, 0x7F	; 127
		for(uint8_t arg_pos = 0; arg_pos < arg_count; arg_pos++) { // For each argument...
    2a8a:	e9 f0       	breq	.+58     	; 0x2ac6 <st7735_run_command_list+0x86>
    2a8c:	9b 01       	movw	r18, r22
    2a8e:	81 50       	subi	r24, 0x01	; 1
    2a90:	48 2f       	mov	r20, r24
    2a92:	50 e0       	ldi	r21, 0x00	; 0
    2a94:	4d 5f       	subi	r20, 0xFD	; 253
    2a96:	5f 4f       	sbci	r21, 0xFF	; 255
    2a98:	c7 01       	movw	r24, r14
    2a9a:	84 0f       	add	r24, r20
    2a9c:	95 1f       	adc	r25, r21
    2a9e:	43 50       	subi	r20, 0x03	; 3
    2aa0:	50 40       	sbci	r21, 0x00	; 0
    2aa2:	f9 01       	movw	r30, r18
			st7735_write_data(pgm_read_byte(addr++));  		// Read, send argument
    2aa4:	2f 5f       	subi	r18, 0xFF	; 255
    2aa6:	3f 4f       	sbci	r19, 0xFF	; 255
    2aa8:	e4 91       	lpm	r30, Z+
uint8_t st7735_width = 0;
uint8_t st7735_height = 0;
enum ST7735_ORIENTATION st7735_orientation = ST7735_LANDSCAPE_INV;

static inline void st7735_set_rs(void) {
	PORTB |= (1 << PB0);
    2aaa:	28 9a       	sbi	0x05, 0	; 5
}

static inline void spi_unset_cs(void) {
	PORTB &= ~(1 << PB4);
    2aac:	2c 98       	cbi	0x05, 4	; 5
#include<avr/io.h>

void spi_init(void);

static inline void spi_write(uint8_t byte) {
	SPDR = byte;
    2aae:	ee bd       	out	0x2e, r30	; 46
	while(!(SPSR & (1<<SPIF)));
    2ab0:	0d b4       	in	r0, 0x2d	; 45
    2ab2:	07 fe       	sbrs	r0, 7
    2ab4:	fd cf       	rjmp	.-6      	; 0x2ab0 <st7735_run_command_list+0x70>
}

static inline void spi_set_cs(void) {
	PORTB |= (1 << PB4);
    2ab6:	2c 9a       	sbi	0x05, 4	; 5
	for(uint8_t cmd_pos = 0; cmd_pos < cmd_count; cmd_pos++) {
		st7735_write_cmd(pgm_read_byte(addr++)); 	// Read, send command
		arg_count  = pgm_read_byte(addr++);    		// Number of args to follow
		has_delay = arg_count & DELAY_FLAG;         // If set, delay follows args
		arg_count &= ~DELAY_FLAG;                  	// Number of args
		for(uint8_t arg_pos = 0; arg_pos < arg_count; arg_pos++) { // For each argument...
    2ab8:	28 17       	cp	r18, r24
    2aba:	39 07       	cpc	r19, r25
    2abc:	91 f7       	brne	.-28     	; 0x2aa2 <st7735_run_command_list+0x62>
    2abe:	4f 5f       	subi	r20, 0xFF	; 255
    2ac0:	5f 4f       	sbci	r21, 0xFF	; 255
    2ac2:	64 0f       	add	r22, r20
    2ac4:	75 1f       	adc	r23, r21
    2ac6:	7b 01       	movw	r14, r22
			st7735_write_data(pgm_read_byte(addr++));  		// Read, send argument
		}

		if(has_delay) {
    2ac8:	a7 ff       	sbrs	r26, 7
    2aca:	19 c0       	rjmp	.+50     	; 0x2afe <st7735_run_command_list+0xbe>
			uint8_t ms;
			ms = pgm_read_byte(addr++); // Read post-command delay time (ms)
    2acc:	7b 01       	movw	r14, r22
    2ace:	08 94       	sec
    2ad0:	e1 1c       	adc	r14, r1
    2ad2:	f1 1c       	adc	r15, r1
    2ad4:	fb 01       	movw	r30, r22
    2ad6:	84 91       	lpm	r24, Z+
			if(ms == 255) {  // If 255, delay for 500 ms
    2ad8:	8f 3f       	cpi	r24, 0xFF	; 255
    2ada:	f1 f0       	breq	.+60     	; 0x2b18 <st7735_run_command_list+0xd8>
				//_delay_ms(500);
				chThdSleepMilliseconds(500);
			}
			else {
				for(int i = 0; i < ms; i += 5) {
    2adc:	08 2f       	mov	r16, r24
    2ade:	10 e0       	ldi	r17, 0x00	; 0
    2ae0:	01 15       	cp	r16, r1
    2ae2:	11 05       	cpc	r17, r1
    2ae4:	61 f0       	breq	.+24     	; 0x2afe <st7735_run_command_list+0xbe>
		if(has_delay) {
			uint8_t ms;
			ms = pgm_read_byte(addr++); // Read post-command delay time (ms)
			if(ms == 255) {  // If 255, delay for 500 ms
				//_delay_ms(500);
				chThdSleepMilliseconds(500);
    2ae6:	c0 e0       	ldi	r28, 0x00	; 0
    2ae8:	d0 e0       	ldi	r29, 0x00	; 0
			}
			else {
				for(int i = 0; i < ms; i += 5) {
					//_delay_ms(5);
					chThdSleepMilliseconds(5);
    2aea:	64 e6       	ldi	r22, 0x64	; 100
    2aec:	70 e0       	ldi	r23, 0x00	; 0
    2aee:	80 e0       	ldi	r24, 0x00	; 0
    2af0:	90 e0       	ldi	r25, 0x00	; 0
    2af2:	0e 94 f4 08 	call	0x11e8	; 0x11e8 <chThdSleep>
			if(ms == 255) {  // If 255, delay for 500 ms
				//_delay_ms(500);
				chThdSleepMilliseconds(500);
			}
			else {
				for(int i = 0; i < ms; i += 5) {
    2af6:	25 96       	adiw	r28, 0x05	; 5
    2af8:	c0 17       	cp	r28, r16
    2afa:	d1 07       	cpc	r29, r17
    2afc:	b4 f3       	brlt	.-20     	; 0x2aea <st7735_run_command_list+0xaa>

void st7735_run_command_list(const uint8_t *addr) {
	uint8_t  cmd_count, arg_count, has_delay;

	cmd_count = pgm_read_byte(addr++);   // Number of commands to follow
	for(uint8_t cmd_pos = 0; cmd_pos < cmd_count; cmd_pos++) {
    2afe:	d3 94       	inc	r13
    2b00:	dc 14       	cp	r13, r12
    2b02:	08 f4       	brcc	.+2      	; 0x2b06 <st7735_run_command_list+0xc6>
    2b04:	af cf       	rjmp	.-162    	; 0x2a64 <st7735_run_command_list+0x24>
				}
			}

		}
	}
}
    2b06:	df 91       	pop	r29
    2b08:	cf 91       	pop	r28
    2b0a:	1f 91       	pop	r17
    2b0c:	0f 91       	pop	r16
    2b0e:	ff 90       	pop	r15
    2b10:	ef 90       	pop	r14
    2b12:	df 90       	pop	r13
    2b14:	cf 90       	pop	r12
    2b16:	08 95       	ret
		if(has_delay) {
			uint8_t ms;
			ms = pgm_read_byte(addr++); // Read post-command delay time (ms)
			if(ms == 255) {  // If 255, delay for 500 ms
				//_delay_ms(500);
				chThdSleepMilliseconds(500);
    2b18:	60 e1       	ldi	r22, 0x10	; 16
    2b1a:	77 e2       	ldi	r23, 0x27	; 39
    2b1c:	80 e0       	ldi	r24, 0x00	; 0
    2b1e:	90 e0       	ldi	r25, 0x00	; 0
    2b20:	0e 94 f4 08 	call	0x11e8	; 0x11e8 <chThdSleep>

void st7735_run_command_list(const uint8_t *addr) {
	uint8_t  cmd_count, arg_count, has_delay;

	cmd_count = pgm_read_byte(addr++);   // Number of commands to follow
	for(uint8_t cmd_pos = 0; cmd_pos < cmd_count; cmd_pos++) {
    2b24:	d3 94       	inc	r13
    2b26:	dc 14       	cp	r13, r12
    2b28:	08 f4       	brcc	.+2      	; 0x2b2c <st7735_run_command_list+0xec>
    2b2a:	9c cf       	rjmp	.-200    	; 0x2a64 <st7735_run_command_list+0x24>
    2b2c:	ec cf       	rjmp	.-40     	; 0x2b06 <st7735_run_command_list+0xc6>

00002b2e <st7735_init>:
}


void st7735_init() {
	// Set rs and rst output
	DDRB |= (1 << PB0) | (1 << PB1);
    2b2e:	84 b1       	in	r24, 0x04	; 4
    2b30:	83 60       	ori	r24, 0x03	; 3
    2b32:	84 b9       	out	0x04, r24	; 4
}

static inline void spi_unset_cs(void) {
	PORTB &= ~(1 << PB4);
    2b34:	2c 98       	cbi	0x05, 4	; 5
static inline void st7735_unset_rs(void) {
	PORTB &= ~(1 << PB0);
}

static inline void st7735_set_rst(void) {
	PORTB |= (1 << PB1);
    2b36:	29 9a       	sbi	0x05, 1	; 5

static inline void st7735_reset(void) {
	spi_unset_cs();
	st7735_set_rst();
	//_delay_ms(500);
	chThdSleepMilliseconds(500);
    2b38:	60 e1       	ldi	r22, 0x10	; 16
    2b3a:	77 e2       	ldi	r23, 0x27	; 39
    2b3c:	80 e0       	ldi	r24, 0x00	; 0
    2b3e:	90 e0       	ldi	r25, 0x00	; 0
    2b40:	0e 94 f4 08 	call	0x11e8	; 0x11e8 <chThdSleep>
static inline void st7735_set_rst(void) {
	PORTB |= (1 << PB1);
}

static inline void st7735_unset_rst(void) {
	PORTB &= ~(1 << PB1);
    2b44:	29 98       	cbi	0x05, 1	; 5
	st7735_set_rst();
	//_delay_ms(500);
	chThdSleepMilliseconds(500);
	st7735_unset_rst();
	//_delay_ms(500);
	chThdSleepMilliseconds(500);
    2b46:	60 e1       	ldi	r22, 0x10	; 16
    2b48:	77 e2       	ldi	r23, 0x27	; 39
    2b4a:	80 e0       	ldi	r24, 0x00	; 0
    2b4c:	90 e0       	ldi	r25, 0x00	; 0
    2b4e:	0e 94 f4 08 	call	0x11e8	; 0x11e8 <chThdSleep>
static inline void st7735_unset_rs(void) {
	PORTB &= ~(1 << PB0);
}

static inline void st7735_set_rst(void) {
	PORTB |= (1 << PB1);
    2b52:	29 9a       	sbi	0x05, 1	; 5
	st7735_unset_rst();
	//_delay_ms(500);
	chThdSleepMilliseconds(500);
	st7735_set_rst();
	//_delay_ms(500);
	chThdSleepMilliseconds(500);
    2b54:	60 e1       	ldi	r22, 0x10	; 16
    2b56:	77 e2       	ldi	r23, 0x27	; 39
    2b58:	80 e0       	ldi	r24, 0x00	; 0
    2b5a:	90 e0       	ldi	r25, 0x00	; 0
    2b5c:	0e 94 f4 08 	call	0x11e8	; 0x11e8 <chThdSleep>
			st7735_width = st7735_default_width;
			st7735_height = st7735_default_height_18;
			break;

		case ST7735_RED_18_BLACKTAB:
			st7735_run_command_list(st7735_red_init1);
    2b60:	89 eb       	ldi	r24, 0xB9	; 185
    2b62:	90 e0       	ldi	r25, 0x00	; 0
    2b64:	0e 94 20 15 	call	0x2a40	; 0x2a40 <st7735_run_command_list>
			st7735_run_command_list(st7735_red_init_red2);
    2b68:	84 ef       	ldi	r24, 0xF4	; 244
    2b6a:	90 e0       	ldi	r25, 0x00	; 0
    2b6c:	0e 94 20 15 	call	0x2a40	; 0x2a40 <st7735_run_command_list>
			st7735_run_command_list(st7735_red_init3);
    2b70:	81 e0       	ldi	r24, 0x01	; 1
    2b72:	91 e0       	ldi	r25, 0x01	; 1
    2b74:	0e 94 20 15 	call	0x2a40	; 0x2a40 <st7735_run_command_list>
static inline void st7735_set_rs(void) {
	PORTB |= (1 << PB0);
}

static inline void st7735_unset_rs(void) {
	PORTB &= ~(1 << PB0);
    2b78:	28 98       	cbi	0x05, 0	; 5
    2b7a:	2c 98       	cbi	0x05, 4	; 5
#include<avr/io.h>

void spi_init(void);

static inline void spi_write(uint8_t byte) {
	SPDR = byte;
    2b7c:	86 e3       	ldi	r24, 0x36	; 54
    2b7e:	8e bd       	out	0x2e, r24	; 46
	while(!(SPSR & (1<<SPIF)));
    2b80:	0d b4       	in	r0, 0x2d	; 45
    2b82:	07 fe       	sbrs	r0, 7
    2b84:	fd cf       	rjmp	.-6      	; 0x2b80 <st7735_init+0x52>
}

static inline void spi_set_cs(void) {
	PORTB |= (1 << PB4);
    2b86:	2c 9a       	sbi	0x05, 4	; 5
uint8_t st7735_width = 0;
uint8_t st7735_height = 0;
enum ST7735_ORIENTATION st7735_orientation = ST7735_LANDSCAPE_INV;

static inline void st7735_set_rs(void) {
	PORTB |= (1 << PB0);
    2b88:	28 9a       	sbi	0x05, 0	; 5
}

static inline void spi_unset_cs(void) {
	PORTB &= ~(1 << PB4);
    2b8a:	2c 98       	cbi	0x05, 4	; 5
#include<avr/io.h>

void spi_init(void);

static inline void spi_write(uint8_t byte) {
	SPDR = byte;
    2b8c:	80 ec       	ldi	r24, 0xC0	; 192
    2b8e:	8e bd       	out	0x2e, r24	; 46
	while(!(SPSR & (1<<SPIF)));
    2b90:	0d b4       	in	r0, 0x2d	; 45
    2b92:	07 fe       	sbrs	r0, 7
    2b94:	fd cf       	rjmp	.-6      	; 0x2b90 <st7735_init+0x62>
}

static inline void spi_set_cs(void) {
	PORTB |= (1 << PB4);
    2b96:	2c 9a       	sbi	0x05, 4	; 5
			st7735_run_command_list(st7735_red_init_red2);
			st7735_run_command_list(st7735_red_init3);
			// Change MADCTL color filter for black
			st7735_write_cmd(ST7735_MADCTL);
			st7735_write_data(0xC0);
			st7735_width = st7735_default_width;
    2b98:	80 e8       	ldi	r24, 0x80	; 128
    2b9a:	80 93 17 07 	sts	0x0717, r24
			st7735_height = st7735_default_height_18;
    2b9e:	80 ea       	ldi	r24, 0xA0	; 160
    2ba0:	80 93 18 07 	sts	0x0718, r24
			st7735_row_start = 3;
			st7735_width = st7735_default_width;
			st7735_height = st7735_default_height_144;
			break;
	}
}
    2ba4:	08 95       	ret

00002ba6 <st7735_set_addr_win>:
			st7735_height = st7735_default_width;
			break;
	}
}

void st7735_set_addr_win(uint8_t x0, uint8_t y0, uint8_t x1, uint8_t y1) {
    2ba6:	98 2f       	mov	r25, r24
static inline void st7735_set_rs(void) {
	PORTB |= (1 << PB0);
}

static inline void st7735_unset_rs(void) {
	PORTB &= ~(1 << PB0);
    2ba8:	28 98       	cbi	0x05, 0	; 5
}

static inline void spi_unset_cs(void) {
	PORTB &= ~(1 << PB4);
    2baa:	2c 98       	cbi	0x05, 4	; 5
#include<avr/io.h>

void spi_init(void);

static inline void spi_write(uint8_t byte) {
	SPDR = byte;
    2bac:	8a e2       	ldi	r24, 0x2A	; 42
    2bae:	8e bd       	out	0x2e, r24	; 46
	while(!(SPSR & (1<<SPIF)));
    2bb0:	0d b4       	in	r0, 0x2d	; 45
    2bb2:	07 fe       	sbrs	r0, 7
    2bb4:	fd cf       	rjmp	.-6      	; 0x2bb0 <st7735_set_addr_win+0xa>
}

static inline void spi_set_cs(void) {
	PORTB |= (1 << PB4);
    2bb6:	2c 9a       	sbi	0x05, 4	; 5
uint8_t st7735_width = 0;
uint8_t st7735_height = 0;
enum ST7735_ORIENTATION st7735_orientation = ST7735_LANDSCAPE_INV;

static inline void st7735_set_rs(void) {
	PORTB |= (1 << PB0);
    2bb8:	28 9a       	sbi	0x05, 0	; 5
}

static inline void spi_unset_cs(void) {
	PORTB &= ~(1 << PB4);
    2bba:	2c 98       	cbi	0x05, 4	; 5
#include<avr/io.h>

void spi_init(void);

static inline void spi_write(uint8_t byte) {
	SPDR = byte;
    2bbc:	1e bc       	out	0x2e, r1	; 46
	while(!(SPSR & (1<<SPIF)));
    2bbe:	0d b4       	in	r0, 0x2d	; 45
    2bc0:	07 fe       	sbrs	r0, 7
    2bc2:	fd cf       	rjmp	.-6      	; 0x2bbe <st7735_set_addr_win+0x18>
}

static inline void spi_set_cs(void) {
	PORTB |= (1 << PB4);
    2bc4:	2c 9a       	sbi	0x05, 4	; 5
}

void st7735_set_addr_win(uint8_t x0, uint8_t y0, uint8_t x1, uint8_t y1) {
	st7735_write_cmd(ST7735_CASET); // Column addr set
	st7735_write_data(0x00);
	st7735_write_data(x0 + st7735_column_start);	// XSTART
    2bc6:	80 91 16 07 	lds	r24, 0x0716
    2bca:	98 0f       	add	r25, r24
uint8_t st7735_width = 0;
uint8_t st7735_height = 0;
enum ST7735_ORIENTATION st7735_orientation = ST7735_LANDSCAPE_INV;

static inline void st7735_set_rs(void) {
	PORTB |= (1 << PB0);
    2bcc:	28 9a       	sbi	0x05, 0	; 5
}

static inline void spi_unset_cs(void) {
	PORTB &= ~(1 << PB4);
    2bce:	2c 98       	cbi	0x05, 4	; 5
#include<avr/io.h>

void spi_init(void);

static inline void spi_write(uint8_t byte) {
	SPDR = byte;
    2bd0:	9e bd       	out	0x2e, r25	; 46
	while(!(SPSR & (1<<SPIF)));
    2bd2:	0d b4       	in	r0, 0x2d	; 45
    2bd4:	07 fe       	sbrs	r0, 7
    2bd6:	fd cf       	rjmp	.-6      	; 0x2bd2 <st7735_set_addr_win+0x2c>
}

static inline void spi_set_cs(void) {
	PORTB |= (1 << PB4);
    2bd8:	2c 9a       	sbi	0x05, 4	; 5
    2bda:	28 9a       	sbi	0x05, 0	; 5
}

static inline void spi_unset_cs(void) {
	PORTB &= ~(1 << PB4);
    2bdc:	2c 98       	cbi	0x05, 4	; 5
#include<avr/io.h>

void spi_init(void);

static inline void spi_write(uint8_t byte) {
	SPDR = byte;
    2bde:	1e bc       	out	0x2e, r1	; 46
	while(!(SPSR & (1<<SPIF)));
    2be0:	0d b4       	in	r0, 0x2d	; 45
    2be2:	07 fe       	sbrs	r0, 7
    2be4:	fd cf       	rjmp	.-6      	; 0x2be0 <st7735_set_addr_win+0x3a>
}

static inline void spi_set_cs(void) {
	PORTB |= (1 << PB4);
    2be6:	2c 9a       	sbi	0x05, 4	; 5
void st7735_set_addr_win(uint8_t x0, uint8_t y0, uint8_t x1, uint8_t y1) {
	st7735_write_cmd(ST7735_CASET); // Column addr set
	st7735_write_data(0x00);
	st7735_write_data(x0 + st7735_column_start);	// XSTART
	st7735_write_data(0x00);
	st7735_write_data(x1 + st7735_column_start); // XEND
    2be8:	84 0f       	add	r24, r20
uint8_t st7735_width = 0;
uint8_t st7735_height = 0;
enum ST7735_ORIENTATION st7735_orientation = ST7735_LANDSCAPE_INV;

static inline void st7735_set_rs(void) {
	PORTB |= (1 << PB0);
    2bea:	28 9a       	sbi	0x05, 0	; 5
}

static inline void spi_unset_cs(void) {
	PORTB &= ~(1 << PB4);
    2bec:	2c 98       	cbi	0x05, 4	; 5
#include<avr/io.h>

void spi_init(void);

static inline void spi_write(uint8_t byte) {
	SPDR = byte;
    2bee:	8e bd       	out	0x2e, r24	; 46
	while(!(SPSR & (1<<SPIF)));
    2bf0:	0d b4       	in	r0, 0x2d	; 45
    2bf2:	07 fe       	sbrs	r0, 7
    2bf4:	fd cf       	rjmp	.-6      	; 0x2bf0 <st7735_set_addr_win+0x4a>
}

static inline void spi_set_cs(void) {
	PORTB |= (1 << PB4);
    2bf6:	2c 9a       	sbi	0x05, 4	; 5
}

static inline void st7735_unset_rs(void) {
	PORTB &= ~(1 << PB0);
    2bf8:	28 98       	cbi	0x05, 0	; 5
}

static inline void spi_unset_cs(void) {
	PORTB &= ~(1 << PB4);
    2bfa:	2c 98       	cbi	0x05, 4	; 5
#include<avr/io.h>

void spi_init(void);

static inline void spi_write(uint8_t byte) {
	SPDR = byte;
    2bfc:	8b e2       	ldi	r24, 0x2B	; 43
    2bfe:	8e bd       	out	0x2e, r24	; 46
	while(!(SPSR & (1<<SPIF)));
    2c00:	0d b4       	in	r0, 0x2d	; 45
    2c02:	07 fe       	sbrs	r0, 7
    2c04:	fd cf       	rjmp	.-6      	; 0x2c00 <st7735_set_addr_win+0x5a>
}

static inline void spi_set_cs(void) {
	PORTB |= (1 << PB4);
    2c06:	2c 9a       	sbi	0x05, 4	; 5
uint8_t st7735_width = 0;
uint8_t st7735_height = 0;
enum ST7735_ORIENTATION st7735_orientation = ST7735_LANDSCAPE_INV;

static inline void st7735_set_rs(void) {
	PORTB |= (1 << PB0);
    2c08:	28 9a       	sbi	0x05, 0	; 5
}

static inline void spi_unset_cs(void) {
	PORTB &= ~(1 << PB4);
    2c0a:	2c 98       	cbi	0x05, 4	; 5
#include<avr/io.h>

void spi_init(void);

static inline void spi_write(uint8_t byte) {
	SPDR = byte;
    2c0c:	1e bc       	out	0x2e, r1	; 46
	while(!(SPSR & (1<<SPIF)));
    2c0e:	0d b4       	in	r0, 0x2d	; 45
    2c10:	07 fe       	sbrs	r0, 7
    2c12:	fd cf       	rjmp	.-6      	; 0x2c0e <st7735_set_addr_win+0x68>
}

static inline void spi_set_cs(void) {
	PORTB |= (1 << PB4);
    2c14:	2c 9a       	sbi	0x05, 4	; 5
	st7735_write_data(0x00);
	st7735_write_data(x1 + st7735_column_start); // XEND

	st7735_write_cmd(ST7735_RASET); // Row addr set
	st7735_write_data(0x00);
	st7735_write_data(y0 + st7735_row_start); // YSTART
    2c16:	80 91 15 07 	lds	r24, 0x0715
    2c1a:	68 0f       	add	r22, r24
uint8_t st7735_width = 0;
uint8_t st7735_height = 0;
enum ST7735_ORIENTATION st7735_orientation = ST7735_LANDSCAPE_INV;

static inline void st7735_set_rs(void) {
	PORTB |= (1 << PB0);
    2c1c:	28 9a       	sbi	0x05, 0	; 5
}

static inline void spi_unset_cs(void) {
	PORTB &= ~(1 << PB4);
    2c1e:	2c 98       	cbi	0x05, 4	; 5
#include<avr/io.h>

void spi_init(void);

static inline void spi_write(uint8_t byte) {
	SPDR = byte;
    2c20:	6e bd       	out	0x2e, r22	; 46
	while(!(SPSR & (1<<SPIF)));
    2c22:	0d b4       	in	r0, 0x2d	; 45
    2c24:	07 fe       	sbrs	r0, 7
    2c26:	fd cf       	rjmp	.-6      	; 0x2c22 <st7735_set_addr_win+0x7c>
}

static inline void spi_set_cs(void) {
	PORTB |= (1 << PB4);
    2c28:	2c 9a       	sbi	0x05, 4	; 5
    2c2a:	28 9a       	sbi	0x05, 0	; 5
}

static inline void spi_unset_cs(void) {
	PORTB &= ~(1 << PB4);
    2c2c:	2c 98       	cbi	0x05, 4	; 5
#include<avr/io.h>

void spi_init(void);

static inline void spi_write(uint8_t byte) {
	SPDR = byte;
    2c2e:	1e bc       	out	0x2e, r1	; 46
	while(!(SPSR & (1<<SPIF)));
    2c30:	0d b4       	in	r0, 0x2d	; 45
    2c32:	07 fe       	sbrs	r0, 7
    2c34:	fd cf       	rjmp	.-6      	; 0x2c30 <st7735_set_addr_win+0x8a>
}

static inline void spi_set_cs(void) {
	PORTB |= (1 << PB4);
    2c36:	2c 9a       	sbi	0x05, 4	; 5

	st7735_write_cmd(ST7735_RASET); // Row addr set
	st7735_write_data(0x00);
	st7735_write_data(y0 + st7735_row_start); // YSTART
	st7735_write_data(0x00);
	st7735_write_data(y1 + st7735_row_start); // YEND
    2c38:	82 0f       	add	r24, r18
uint8_t st7735_width = 0;
uint8_t st7735_height = 0;
enum ST7735_ORIENTATION st7735_orientation = ST7735_LANDSCAPE_INV;

static inline void st7735_set_rs(void) {
	PORTB |= (1 << PB0);
    2c3a:	28 9a       	sbi	0x05, 0	; 5
}

static inline void spi_unset_cs(void) {
	PORTB &= ~(1 << PB4);
    2c3c:	2c 98       	cbi	0x05, 4	; 5
#include<avr/io.h>

void spi_init(void);

static inline void spi_write(uint8_t byte) {
	SPDR = byte;
    2c3e:	8e bd       	out	0x2e, r24	; 46
	while(!(SPSR & (1<<SPIF)));
    2c40:	0d b4       	in	r0, 0x2d	; 45
    2c42:	07 fe       	sbrs	r0, 7
    2c44:	fd cf       	rjmp	.-6      	; 0x2c40 <st7735_set_addr_win+0x9a>
}

static inline void spi_set_cs(void) {
	PORTB |= (1 << PB4);
    2c46:	2c 9a       	sbi	0x05, 4	; 5
}

static inline void st7735_unset_rs(void) {
	PORTB &= ~(1 << PB0);
    2c48:	28 98       	cbi	0x05, 0	; 5
}

static inline void spi_unset_cs(void) {
	PORTB &= ~(1 << PB4);
    2c4a:	2c 98       	cbi	0x05, 4	; 5
#include<avr/io.h>

void spi_init(void);

static inline void spi_write(uint8_t byte) {
	SPDR = byte;
    2c4c:	8c e2       	ldi	r24, 0x2C	; 44
    2c4e:	8e bd       	out	0x2e, r24	; 46
	while(!(SPSR & (1<<SPIF)));
    2c50:	0d b4       	in	r0, 0x2d	; 45
    2c52:	07 fe       	sbrs	r0, 7
    2c54:	fd cf       	rjmp	.-6      	; 0x2c50 <st7735_set_addr_win+0xaa>
}

static inline void spi_set_cs(void) {
	PORTB |= (1 << PB4);
    2c56:	2c 9a       	sbi	0x05, 4	; 5
	st7735_write_data(y0 + st7735_row_start); // YSTART
	st7735_write_data(0x00);
	st7735_write_data(y1 + st7735_row_start); // YEND

	st7735_write_cmd(ST7735_RAMWR); // write to RAM
}
    2c58:	08 95       	ret

00002c5a <st7735_draw_pixel>:

void st7735_draw_pixel(int16_t x, int16_t y, uint16_t color) {
    2c5a:	0f 93       	push	r16
    2c5c:	1f 93       	push	r17
    2c5e:	fc 01       	movw	r30, r24
    2c60:	8a 01       	movw	r16, r20
	if(x < 0 || x >= st7735_width || y < 0 || y >= st7735_height){
    2c62:	97 fd       	sbrc	r25, 7
    2c64:	0e c0       	rjmp	.+28     	; 0x2c82 <st7735_draw_pixel+0x28>
    2c66:	80 91 17 07 	lds	r24, 0x0717
    2c6a:	90 e0       	ldi	r25, 0x00	; 0
    2c6c:	e8 17       	cp	r30, r24
    2c6e:	f9 07       	cpc	r31, r25
    2c70:	44 f4       	brge	.+16     	; 0x2c82 <st7735_draw_pixel+0x28>
    2c72:	77 fd       	sbrc	r23, 7
    2c74:	06 c0       	rjmp	.+12     	; 0x2c82 <st7735_draw_pixel+0x28>
    2c76:	80 91 18 07 	lds	r24, 0x0718
    2c7a:	90 e0       	ldi	r25, 0x00	; 0
    2c7c:	68 17       	cp	r22, r24
    2c7e:	79 07       	cpc	r23, r25
    2c80:	1c f0       	brlt	.+6      	; 0x2c88 <st7735_draw_pixel+0x2e>
  	spi_unset_cs();

	st7735_write_color(color);

  	spi_set_cs();
}
    2c82:	1f 91       	pop	r17
    2c84:	0f 91       	pop	r16
    2c86:	08 95       	ret
void st7735_draw_pixel(int16_t x, int16_t y, uint16_t color) {
	if(x < 0 || x >= st7735_width || y < 0 || y >= st7735_height){
		return;
	}

  	st7735_set_addr_win(x, y, x+1, y+1);
    2c88:	4e 2f       	mov	r20, r30
    2c8a:	4f 5f       	subi	r20, 0xFF	; 255
    2c8c:	26 2f       	mov	r18, r22
    2c8e:	2f 5f       	subi	r18, 0xFF	; 255
    2c90:	8e 2f       	mov	r24, r30
    2c92:	0e 94 d3 15 	call	0x2ba6	; 0x2ba6 <st7735_set_addr_win>
uint8_t st7735_width = 0;
uint8_t st7735_height = 0;
enum ST7735_ORIENTATION st7735_orientation = ST7735_LANDSCAPE_INV;

static inline void st7735_set_rs(void) {
	PORTB |= (1 << PB0);
    2c96:	28 9a       	sbi	0x05, 0	; 5
}

static inline void spi_unset_cs(void) {
	PORTB &= ~(1 << PB4);
    2c98:	2c 98       	cbi	0x05, 4	; 5
#include<avr/io.h>

void spi_init(void);

static inline void spi_write(uint8_t byte) {
	SPDR = byte;
    2c9a:	1e bd       	out	0x2e, r17	; 46
	while(!(SPSR & (1<<SPIF)));
    2c9c:	0d b4       	in	r0, 0x2d	; 45
    2c9e:	07 fe       	sbrs	r0, 7
    2ca0:	fd cf       	rjmp	.-6      	; 0x2c9c <st7735_draw_pixel+0x42>
#include<avr/io.h>

void spi_init(void);

static inline void spi_write(uint8_t byte) {
	SPDR = byte;
    2ca2:	0e bd       	out	0x2e, r16	; 46
	while(!(SPSR & (1<<SPIF)));
    2ca4:	0d b4       	in	r0, 0x2d	; 45
    2ca6:	07 fe       	sbrs	r0, 7
    2ca8:	fd cf       	rjmp	.-6      	; 0x2ca4 <st7735_draw_pixel+0x4a>
}

static inline void spi_set_cs(void) {
	PORTB |= (1 << PB4);
    2caa:	2c 9a       	sbi	0x05, 4	; 5
  	spi_unset_cs();

	st7735_write_color(color);

  	spi_set_cs();
}
    2cac:	1f 91       	pop	r17
    2cae:	0f 91       	pop	r16
    2cb0:	08 95       	ret

00002cb2 <st7735_fill_rect>:


void st7735_fill_rect(uint8_t x, uint8_t y, uint8_t w, uint8_t h, uint16_t color) {
    2cb2:	ef 92       	push	r14
    2cb4:	ff 92       	push	r15
    2cb6:	0f 93       	push	r16
    2cb8:	1f 93       	push	r17
    2cba:	78 2f       	mov	r23, r24
    2cbc:	f4 2e       	mov	r15, r20
    2cbe:	e2 2e       	mov	r14, r18
	if(x >= st7735_width || y >= st7735_height) {
    2cc0:	40 91 17 07 	lds	r20, 0x0717
    2cc4:	84 17       	cp	r24, r20
    2cc6:	b8 f5       	brcc	.+110    	; 0x2d36 <st7735_fill_rect+0x84>
    2cc8:	50 91 18 07 	lds	r21, 0x0718
    2ccc:	65 17       	cp	r22, r21
    2cce:	98 f5       	brcc	.+102    	; 0x2d36 <st7735_fill_rect+0x84>
		return;
	}

	if((x + w - 1) >= st7735_width) {
    2cd0:	90 e0       	ldi	r25, 0x00	; 0
    2cd2:	8f 0d       	add	r24, r15
    2cd4:	91 1d       	adc	r25, r1
    2cd6:	24 2f       	mov	r18, r20
    2cd8:	30 e0       	ldi	r19, 0x00	; 0
    2cda:	28 17       	cp	r18, r24
    2cdc:	39 07       	cpc	r19, r25
    2cde:	14 f4       	brge	.+4      	; 0x2ce4 <st7735_fill_rect+0x32>
		w = st7735_width  - x;
    2ce0:	f4 2e       	mov	r15, r20
    2ce2:	f7 1a       	sub	r15, r23
	}
	if((y + h - 1) >= st7735_height) {
    2ce4:	86 2f       	mov	r24, r22
    2ce6:	90 e0       	ldi	r25, 0x00	; 0
    2ce8:	8e 0d       	add	r24, r14
    2cea:	91 1d       	adc	r25, r1
    2cec:	25 2f       	mov	r18, r21
    2cee:	30 e0       	ldi	r19, 0x00	; 0
    2cf0:	28 17       	cp	r18, r24
    2cf2:	39 07       	cpc	r19, r25
    2cf4:	2c f1       	brlt	.+74     	; 0x2d40 <st7735_fill_rect+0x8e>
		h = st7735_height - y;
	}

	st7735_set_addr_win(x, y, x + w - 1, y + h - 1);
    2cf6:	47 2f       	mov	r20, r23
    2cf8:	41 50       	subi	r20, 0x01	; 1
    2cfa:	4f 0d       	add	r20, r15
    2cfc:	26 2f       	mov	r18, r22
    2cfe:	21 50       	subi	r18, 0x01	; 1
    2d00:	2e 0d       	add	r18, r14
    2d02:	87 2f       	mov	r24, r23
    2d04:	0e 94 d3 15 	call	0x2ba6	; 0x2ba6 <st7735_set_addr_win>
uint8_t st7735_width = 0;
uint8_t st7735_height = 0;
enum ST7735_ORIENTATION st7735_orientation = ST7735_LANDSCAPE_INV;

static inline void st7735_set_rs(void) {
	PORTB |= (1 << PB0);
    2d08:	28 9a       	sbi	0x05, 0	; 5
}

static inline void spi_unset_cs(void) {
	PORTB &= ~(1 << PB4);
    2d0a:	2c 98       	cbi	0x05, 4	; 5
	st7735_set_addr_win(x, y, x + w - 1, y + h - 1);

	st7735_set_rs();
	spi_unset_cs();

	for(uint8_t i = 0; i < h; i++) {
    2d0c:	ee 20       	and	r14, r14
    2d0e:	91 f0       	breq	.+36     	; 0x2d34 <st7735_fill_rect+0x82>
    2d10:	90 e0       	ldi	r25, 0x00	; 0
		for(uint8_t j = 0; j < w; j++) {
    2d12:	ff 20       	and	r15, r15
    2d14:	61 f0       	breq	.+24     	; 0x2d2e <st7735_fill_rect+0x7c>
    2d16:	80 e0       	ldi	r24, 0x00	; 0
#include<avr/io.h>

void spi_init(void);

static inline void spi_write(uint8_t byte) {
	SPDR = byte;
    2d18:	1e bd       	out	0x2e, r17	; 46
	while(!(SPSR & (1<<SPIF)));
    2d1a:	0d b4       	in	r0, 0x2d	; 45
    2d1c:	07 fe       	sbrs	r0, 7
    2d1e:	fd cf       	rjmp	.-6      	; 0x2d1a <st7735_fill_rect+0x68>
#include<avr/io.h>

void spi_init(void);

static inline void spi_write(uint8_t byte) {
	SPDR = byte;
    2d20:	0e bd       	out	0x2e, r16	; 46
	while(!(SPSR & (1<<SPIF)));
    2d22:	0d b4       	in	r0, 0x2d	; 45
    2d24:	07 fe       	sbrs	r0, 7
    2d26:	fd cf       	rjmp	.-6      	; 0x2d22 <st7735_fill_rect+0x70>
    2d28:	8f 5f       	subi	r24, 0xFF	; 255
    2d2a:	8f 15       	cp	r24, r15
    2d2c:	a8 f3       	brcs	.-22     	; 0x2d18 <st7735_fill_rect+0x66>
	st7735_set_addr_win(x, y, x + w - 1, y + h - 1);

	st7735_set_rs();
	spi_unset_cs();

	for(uint8_t i = 0; i < h; i++) {
    2d2e:	9f 5f       	subi	r25, 0xFF	; 255
    2d30:	9e 15       	cp	r25, r14
    2d32:	78 f3       	brcs	.-34     	; 0x2d12 <st7735_fill_rect+0x60>
}

static inline void spi_set_cs(void) {
	PORTB |= (1 << PB4);
    2d34:	2c 9a       	sbi	0x05, 4	; 5
			st7735_write_color(color);
		}
	}

	spi_set_cs();
}
    2d36:	1f 91       	pop	r17
    2d38:	0f 91       	pop	r16
    2d3a:	ff 90       	pop	r15
    2d3c:	ef 90       	pop	r14
    2d3e:	08 95       	ret

	if((x + w - 1) >= st7735_width) {
		w = st7735_width  - x;
	}
	if((y + h - 1) >= st7735_height) {
		h = st7735_height - y;
    2d40:	e5 2e       	mov	r14, r21
    2d42:	e6 1a       	sub	r14, r22
    2d44:	d8 cf       	rjmp	.-80     	; 0x2cf6 <st7735_fill_rect+0x44>

00002d46 <st7735_draw_bitmap>:

	spi_set_cs();
}


void st7735_draw_bitmap(uint8_t x, uint8_t y, PGM_P bitmap) {
    2d46:	ef 92       	push	r14
    2d48:	ff 92       	push	r15
    2d4a:	0f 93       	push	r16
    2d4c:	1f 93       	push	r17
    2d4e:	cf 93       	push	r28
    2d50:	df 93       	push	r29
    2d52:	78 2f       	mov	r23, r24
	if(x >= st7735_width || y >= st7735_height) {
    2d54:	20 91 17 07 	lds	r18, 0x0717
    2d58:	82 17       	cp	r24, r18
    2d5a:	08 f0       	brcs	.+2      	; 0x2d5e <st7735_draw_bitmap+0x18>
    2d5c:	52 c0       	rjmp	.+164    	; 0x2e02 <st7735_draw_bitmap+0xbc>
    2d5e:	a0 91 18 07 	lds	r26, 0x0718
    2d62:	6a 17       	cp	r22, r26
    2d64:	08 f0       	brcs	.+2      	; 0x2d68 <st7735_draw_bitmap+0x22>
    2d66:	4d c0       	rjmp	.+154    	; 0x2e02 <st7735_draw_bitmap+0xbc>
		return;
	}

	uint8_t w = pgm_read_word(bitmap);
    2d68:	fa 01       	movw	r30, r20
    2d6a:	85 91       	lpm	r24, Z+
    2d6c:	94 91       	lpm	r25, Z+
    2d6e:	18 2f       	mov	r17, r24
	bitmap += 2;
    2d70:	ea 01       	movw	r28, r20
    2d72:	22 96       	adiw	r28, 0x02	; 2
	uint8_t h = pgm_read_word(bitmap);
    2d74:	fe 01       	movw	r30, r28
    2d76:	e5 90       	lpm	r14, Z+
    2d78:	f4 90       	lpm	r15, Z+
	bitmap += 2;

	if((x + w - 1) >= st7735_width) {
    2d7a:	87 2f       	mov	r24, r23
    2d7c:	90 e0       	ldi	r25, 0x00	; 0
    2d7e:	81 0f       	add	r24, r17
    2d80:	91 1d       	adc	r25, r1
    2d82:	30 e0       	ldi	r19, 0x00	; 0
    2d84:	28 17       	cp	r18, r24
    2d86:	39 07       	cpc	r19, r25
    2d88:	0c f4       	brge	.+2      	; 0x2d8c <st7735_draw_bitmap+0x46>
    2d8a:	3b c0       	rjmp	.+118    	; 0x2e02 <st7735_draw_bitmap+0xbc>
		return;
	}

	uint8_t w = pgm_read_word(bitmap);
	bitmap += 2;
	uint8_t h = pgm_read_word(bitmap);
    2d8c:	0e 2d       	mov	r16, r14
	bitmap += 2;

	if((x + w - 1) >= st7735_width) {
		return;
	}
	if((y + h - 1) >= st7735_height) {
    2d8e:	86 2f       	mov	r24, r22
    2d90:	90 e0       	ldi	r25, 0x00	; 0
    2d92:	8e 0d       	add	r24, r14
    2d94:	91 1d       	adc	r25, r1
    2d96:	2a 2f       	mov	r18, r26
    2d98:	30 e0       	ldi	r19, 0x00	; 0
    2d9a:	28 17       	cp	r18, r24
    2d9c:	39 07       	cpc	r19, r25
    2d9e:	8c f1       	brlt	.+98     	; 0x2e02 <st7735_draw_bitmap+0xbc>
		return;
	}

	st7735_set_addr_win(x, y, x + w - 1, y + h - 1);
    2da0:	47 2f       	mov	r20, r23
    2da2:	41 50       	subi	r20, 0x01	; 1
    2da4:	41 0f       	add	r20, r17
    2da6:	26 2f       	mov	r18, r22
    2da8:	21 50       	subi	r18, 0x01	; 1
    2daa:	2e 0d       	add	r18, r14
    2dac:	87 2f       	mov	r24, r23
    2dae:	0e 94 d3 15 	call	0x2ba6	; 0x2ba6 <st7735_set_addr_win>
uint8_t st7735_width = 0;
uint8_t st7735_height = 0;
enum ST7735_ORIENTATION st7735_orientation = ST7735_LANDSCAPE_INV;

static inline void st7735_set_rs(void) {
	PORTB |= (1 << PB0);
    2db2:	28 9a       	sbi	0x05, 0	; 5
}

static inline void spi_unset_cs(void) {
	PORTB &= ~(1 << PB4);
    2db4:	2c 98       	cbi	0x05, 4	; 5
	st7735_set_addr_win(x, y, x + w - 1, y + h - 1);

	st7735_set_rs();
	spi_unset_cs();

	for(uint8_t i = 0; i < h; i++) {
    2db6:	ee 20       	and	r14, r14
    2db8:	19 f1       	breq	.+70     	; 0x2e00 <st7735_draw_bitmap+0xba>
	}

	uint8_t w = pgm_read_word(bitmap);
	bitmap += 2;
	uint8_t h = pgm_read_word(bitmap);
	bitmap += 2;
    2dba:	ae 01       	movw	r20, r28
    2dbc:	4e 5f       	subi	r20, 0xFE	; 254
    2dbe:	5f 4f       	sbci	r21, 0xFF	; 255
    2dc0:	60 e0       	ldi	r22, 0x00	; 0
    2dc2:	11 50       	subi	r17, 0x01	; 1

	st7735_set_rs();
	spi_unset_cs();

	for(uint8_t i = 0; i < h; i++) {
		for(uint8_t j = 0; j < w; j++) {
    2dc4:	a1 2f       	mov	r26, r17
    2dc6:	b0 e0       	ldi	r27, 0x00	; 0
    2dc8:	1f 5f       	subi	r17, 0xFF	; 255
    2dca:	11 96       	adiw	r26, 0x01	; 1
    2dcc:	aa 0f       	add	r26, r26
    2dce:	bb 1f       	adc	r27, r27
    2dd0:	11 23       	and	r17, r17
    2dd2:	99 f0       	breq	.+38     	; 0x2dfa <st7735_draw_bitmap+0xb4>
    2dd4:	9a 01       	movw	r18, r20
    2dd6:	2a 0f       	add	r18, r26
    2dd8:	3b 1f       	adc	r19, r27
			uint16_t color = pgm_read_word(bitmap);
    2dda:	fa 01       	movw	r30, r20
    2ddc:	85 91       	lpm	r24, Z+
    2dde:	94 91       	lpm	r25, Z+
#include<avr/io.h>

void spi_init(void);

static inline void spi_write(uint8_t byte) {
	SPDR = byte;
    2de0:	9e bd       	out	0x2e, r25	; 46
	while(!(SPSR & (1<<SPIF)));
    2de2:	0d b4       	in	r0, 0x2d	; 45
    2de4:	07 fe       	sbrs	r0, 7
    2de6:	fd cf       	rjmp	.-6      	; 0x2de2 <st7735_draw_bitmap+0x9c>
#include<avr/io.h>

void spi_init(void);

static inline void spi_write(uint8_t byte) {
	SPDR = byte;
    2de8:	8e bd       	out	0x2e, r24	; 46
	while(!(SPSR & (1<<SPIF)));
    2dea:	0d b4       	in	r0, 0x2d	; 45
    2dec:	07 fe       	sbrs	r0, 7
    2dee:	fd cf       	rjmp	.-6      	; 0x2dea <st7735_draw_bitmap+0xa4>
			st7735_write_color(color);
			bitmap += 2;
    2df0:	4e 5f       	subi	r20, 0xFE	; 254
    2df2:	5f 4f       	sbci	r21, 0xFF	; 255

	st7735_set_rs();
	spi_unset_cs();

	for(uint8_t i = 0; i < h; i++) {
		for(uint8_t j = 0; j < w; j++) {
    2df4:	42 17       	cp	r20, r18
    2df6:	53 07       	cpc	r21, r19
    2df8:	81 f7       	brne	.-32     	; 0x2dda <st7735_draw_bitmap+0x94>
	st7735_set_addr_win(x, y, x + w - 1, y + h - 1);

	st7735_set_rs();
	spi_unset_cs();

	for(uint8_t i = 0; i < h; i++) {
    2dfa:	6f 5f       	subi	r22, 0xFF	; 255
    2dfc:	60 17       	cp	r22, r16
    2dfe:	40 f3       	brcs	.-48     	; 0x2dd0 <st7735_draw_bitmap+0x8a>
}

static inline void spi_set_cs(void) {
	PORTB |= (1 << PB4);
    2e00:	2c 9a       	sbi	0x05, 4	; 5
			bitmap += 2;
		}
	}

	spi_set_cs();
}
    2e02:	df 91       	pop	r29
    2e04:	cf 91       	pop	r28
    2e06:	1f 91       	pop	r17
    2e08:	0f 91       	pop	r16
    2e0a:	ff 90       	pop	r15
    2e0c:	ef 90       	pop	r14
    2e0e:	08 95       	ret

00002e10 <st7735_draw_mono_bitmap>:

void st7735_draw_mono_bitmap(uint8_t x, uint8_t y, PGM_P bitmap, uint16_t color_set, uint16_t color_unset) {
    2e10:	bf 92       	push	r11
    2e12:	cf 92       	push	r12
    2e14:	df 92       	push	r13
    2e16:	ef 92       	push	r14
    2e18:	ff 92       	push	r15
    2e1a:	0f 93       	push	r16
    2e1c:	1f 93       	push	r17
    2e1e:	cf 93       	push	r28
    2e20:	df 93       	push	r29
    2e22:	78 2f       	mov	r23, r24
    2e24:	fa 01       	movw	r30, r20
    2e26:	c2 2e       	mov	r12, r18
    2e28:	b3 2e       	mov	r11, r19
    2e2a:	f0 2e       	mov	r15, r16
    2e2c:	e1 2e       	mov	r14, r17
	uint8_t w = pgm_read_byte(bitmap++);
    2e2e:	ea 01       	movw	r28, r20
    2e30:	21 96       	adiw	r28, 0x01	; 1
    2e32:	14 91       	lpm	r17, Z+
	uint8_t h = pgm_read_byte(bitmap++);
    2e34:	fe 01       	movw	r30, r28
    2e36:	d4 90       	lpm	r13, Z+

	if(x >= st7735_width || y >= st7735_height) {
    2e38:	20 91 17 07 	lds	r18, 0x0717
    2e3c:	82 17       	cp	r24, r18
    2e3e:	08 f0       	brcs	.+2      	; 0x2e42 <st7735_draw_mono_bitmap+0x32>
    2e40:	5a c0       	rjmp	.+180    	; 0x2ef6 <st7735_draw_mono_bitmap+0xe6>
    2e42:	40 91 18 07 	lds	r20, 0x0718
    2e46:	64 17       	cp	r22, r20
    2e48:	08 f0       	brcs	.+2      	; 0x2e4c <st7735_draw_mono_bitmap+0x3c>
    2e4a:	55 c0       	rjmp	.+170    	; 0x2ef6 <st7735_draw_mono_bitmap+0xe6>
		return;
	}

	if((x + w - 1) >= st7735_width) {
    2e4c:	90 e0       	ldi	r25, 0x00	; 0
    2e4e:	81 0f       	add	r24, r17
    2e50:	91 1d       	adc	r25, r1
    2e52:	30 e0       	ldi	r19, 0x00	; 0
    2e54:	28 17       	cp	r18, r24
    2e56:	39 07       	cpc	r19, r25
    2e58:	0c f4       	brge	.+2      	; 0x2e5c <st7735_draw_mono_bitmap+0x4c>
    2e5a:	4d c0       	rjmp	.+154    	; 0x2ef6 <st7735_draw_mono_bitmap+0xe6>
		return;
	}
	if((y + h - 1) >= st7735_height) {
    2e5c:	86 2f       	mov	r24, r22
    2e5e:	90 e0       	ldi	r25, 0x00	; 0
    2e60:	8d 0d       	add	r24, r13
    2e62:	91 1d       	adc	r25, r1
    2e64:	24 2f       	mov	r18, r20
    2e66:	30 e0       	ldi	r19, 0x00	; 0
    2e68:	28 17       	cp	r18, r24
    2e6a:	39 07       	cpc	r19, r25
    2e6c:	0c f4       	brge	.+2      	; 0x2e70 <st7735_draw_mono_bitmap+0x60>
    2e6e:	43 c0       	rjmp	.+134    	; 0x2ef6 <st7735_draw_mono_bitmap+0xe6>
		return;
	}

	st7735_set_addr_win(x, y, x + w - 1, y + h - 1);
    2e70:	47 2f       	mov	r20, r23
    2e72:	41 50       	subi	r20, 0x01	; 1
    2e74:	41 0f       	add	r20, r17
    2e76:	26 2f       	mov	r18, r22
    2e78:	21 50       	subi	r18, 0x01	; 1
    2e7a:	2d 0d       	add	r18, r13
    2e7c:	87 2f       	mov	r24, r23
    2e7e:	0e 94 d3 15 	call	0x2ba6	; 0x2ba6 <st7735_set_addr_win>
uint8_t st7735_width = 0;
uint8_t st7735_height = 0;
enum ST7735_ORIENTATION st7735_orientation = ST7735_LANDSCAPE_INV;

static inline void st7735_set_rs(void) {
	PORTB |= (1 << PB0);
    2e82:	28 9a       	sbi	0x05, 0	; 5
}

static inline void spi_unset_cs(void) {
	PORTB &= ~(1 << PB4);
    2e84:	2c 98       	cbi	0x05, 4	; 5
	st7735_set_rs();
	spi_unset_cs();

	uint16_t bit_pos = 0;
	uint8_t byte = 0;
	for(uint8_t i = 0; i < h; i++) {
    2e86:	dd 20       	and	r13, r13
    2e88:	a9 f1       	breq	.+106    	; 0x2ef4 <st7735_draw_mono_bitmap+0xe4>
	spi_set_cs();
}

void st7735_draw_mono_bitmap(uint8_t x, uint8_t y, PGM_P bitmap, uint16_t color_set, uint16_t color_unset) {
	uint8_t w = pgm_read_byte(bitmap++);
	uint8_t h = pgm_read_byte(bitmap++);
    2e8a:	be 01       	movw	r22, r28
    2e8c:	6f 5f       	subi	r22, 0xFF	; 255
    2e8e:	7f 4f       	sbci	r23, 0xFF	; 255
	spi_set_cs();
}


static inline void st7735_write_color(uint16_t color) {
	spi_write(color >> 8);
    2e90:	a0 e0       	ldi	r26, 0x00	; 0
    2e92:	b0 e0       	ldi	r27, 0x00	; 0
    2e94:	e0 e0       	ldi	r30, 0x00	; 0
    2e96:	00 e0       	ldi	r16, 0x00	; 0
	spi_unset_cs();

	uint16_t bit_pos = 0;
	uint8_t byte = 0;
	for(uint8_t i = 0; i < h; i++) {
		for(uint8_t j = 0; j < w; j++) {
    2e98:	11 50       	subi	r17, 0x01	; 1
    2e9a:	c1 2f       	mov	r28, r17
    2e9c:	d0 e0       	ldi	r29, 0x00	; 0
    2e9e:	1f 5f       	subi	r17, 0xFF	; 255
    2ea0:	21 96       	adiw	r28, 0x01	; 1
    2ea2:	11 23       	and	r17, r17
    2ea4:	21 f1       	breq	.+72     	; 0x2eee <st7735_draw_mono_bitmap+0xde>
	spi_set_cs();
}


static inline void st7735_write_color(uint16_t color) {
	spi_write(color >> 8);
    2ea6:	ad 01       	movw	r20, r26

	uint16_t bit_pos = 0;
	uint8_t byte = 0;
	for(uint8_t i = 0; i < h; i++) {
		for(uint8_t j = 0; j < w; j++) {
			if(bit_pos % 8 == 0) {
    2ea8:	9a 01       	movw	r18, r20
    2eaa:	27 70       	andi	r18, 0x07	; 7
    2eac:	30 70       	andi	r19, 0x00	; 0
    2eae:	21 15       	cp	r18, r1
    2eb0:	31 05       	cpc	r19, r1
    2eb2:	21 f4       	brne	.+8      	; 0x2ebc <st7735_draw_mono_bitmap+0xac>
				byte = pgm_read_byte(bitmap++);
    2eb4:	fb 01       	movw	r30, r22
    2eb6:	6f 5f       	subi	r22, 0xFF	; 255
    2eb8:	7f 4f       	sbci	r23, 0xFF	; 255
    2eba:	e4 91       	lpm	r30, Z+
			}

			if(byte & (1 << (bit_pos % 8))) {
    2ebc:	8e 2f       	mov	r24, r30
    2ebe:	90 e0       	ldi	r25, 0x00	; 0
    2ec0:	02 c0       	rjmp	.+4      	; 0x2ec6 <st7735_draw_mono_bitmap+0xb6>
    2ec2:	95 95       	asr	r25
    2ec4:	87 95       	ror	r24
    2ec6:	2a 95       	dec	r18
    2ec8:	e2 f7       	brpl	.-8      	; 0x2ec2 <st7735_draw_mono_bitmap+0xb2>
    2eca:	80 ff       	sbrs	r24, 0
    2ecc:	1e c0       	rjmp	.+60     	; 0x2f0a <st7735_draw_mono_bitmap+0xfa>
#include<avr/io.h>

void spi_init(void);

static inline void spi_write(uint8_t byte) {
	SPDR = byte;
    2ece:	be bc       	out	0x2e, r11	; 46
	while(!(SPSR & (1<<SPIF)));
    2ed0:	0d b4       	in	r0, 0x2d	; 45
    2ed2:	07 fe       	sbrs	r0, 7
    2ed4:	fd cf       	rjmp	.-6      	; 0x2ed0 <st7735_draw_mono_bitmap+0xc0>
#include<avr/io.h>

void spi_init(void);

static inline void spi_write(uint8_t byte) {
	SPDR = byte;
    2ed6:	ce bc       	out	0x2e, r12	; 46
	while(!(SPSR & (1<<SPIF)));
    2ed8:	0d b4       	in	r0, 0x2d	; 45
    2eda:	07 fe       	sbrs	r0, 7
    2edc:	fd cf       	rjmp	.-6      	; 0x2ed8 <st7735_draw_mono_bitmap+0xc8>
				st7735_write_color(color_set);
			}
			else {
				st7735_write_color(color_unset);
			}
			bit_pos++;
    2ede:	4f 5f       	subi	r20, 0xFF	; 255
    2ee0:	5f 4f       	sbci	r21, 0xFF	; 255
	spi_unset_cs();

	uint16_t bit_pos = 0;
	uint8_t byte = 0;
	for(uint8_t i = 0; i < h; i++) {
		for(uint8_t j = 0; j < w; j++) {
    2ee2:	84 2f       	mov	r24, r20
    2ee4:	8a 1b       	sub	r24, r26
    2ee6:	81 17       	cp	r24, r17
    2ee8:	f8 f2       	brcs	.-66     	; 0x2ea8 <st7735_draw_mono_bitmap+0x98>
    2eea:	ac 0f       	add	r26, r28
    2eec:	bd 1f       	adc	r27, r29
	st7735_set_rs();
	spi_unset_cs();

	uint16_t bit_pos = 0;
	uint8_t byte = 0;
	for(uint8_t i = 0; i < h; i++) {
    2eee:	0f 5f       	subi	r16, 0xFF	; 255
    2ef0:	0d 15       	cp	r16, r13
    2ef2:	b8 f2       	brcs	.-82     	; 0x2ea2 <st7735_draw_mono_bitmap+0x92>
}

static inline void spi_set_cs(void) {
	PORTB |= (1 << PB4);
    2ef4:	2c 9a       	sbi	0x05, 4	; 5
		}
	}

	spi_set_cs();

}
    2ef6:	df 91       	pop	r29
    2ef8:	cf 91       	pop	r28
    2efa:	1f 91       	pop	r17
    2efc:	0f 91       	pop	r16
    2efe:	ff 90       	pop	r15
    2f00:	ef 90       	pop	r14
    2f02:	df 90       	pop	r13
    2f04:	cf 90       	pop	r12
    2f06:	bf 90       	pop	r11
    2f08:	08 95       	ret
#include<avr/io.h>

void spi_init(void);

static inline void spi_write(uint8_t byte) {
	SPDR = byte;
    2f0a:	ee bc       	out	0x2e, r14	; 46
	while(!(SPSR & (1<<SPIF)));
    2f0c:	0d b4       	in	r0, 0x2d	; 45
    2f0e:	07 fe       	sbrs	r0, 7
    2f10:	fd cf       	rjmp	.-6      	; 0x2f0c <st7735_draw_mono_bitmap+0xfc>
#include<avr/io.h>

void spi_init(void);

static inline void spi_write(uint8_t byte) {
	SPDR = byte;
    2f12:	fe bc       	out	0x2e, r15	; 46
	while(!(SPSR & (1<<SPIF)));
    2f14:	0d b4       	in	r0, 0x2d	; 45
    2f16:	07 fe       	sbrs	r0, 7
    2f18:	fd cf       	rjmp	.-6      	; 0x2f14 <st7735_draw_mono_bitmap+0x104>
				st7735_write_color(color_set);
			}
			else {
				st7735_write_color(color_unset);
			}
			bit_pos++;
    2f1a:	4f 5f       	subi	r20, 0xFF	; 255
    2f1c:	5f 4f       	sbci	r21, 0xFF	; 255
	spi_unset_cs();

	uint16_t bit_pos = 0;
	uint8_t byte = 0;
	for(uint8_t i = 0; i < h; i++) {
		for(uint8_t j = 0; j < w; j++) {
    2f1e:	84 2f       	mov	r24, r20
    2f20:	8a 1b       	sub	r24, r26
    2f22:	81 17       	cp	r24, r17
    2f24:	08 f4       	brcc	.+2      	; 0x2f28 <st7735_draw_mono_bitmap+0x118>
    2f26:	c0 cf       	rjmp	.-128    	; 0x2ea8 <st7735_draw_mono_bitmap+0x98>
    2f28:	e0 cf       	rjmp	.-64     	; 0x2eea <st7735_draw_mono_bitmap+0xda>

00002f2a <st7735_set_orientation>:
	MADCTL_RGB = 0x00,
	MADCTL_BGR = 0x08,
	MADCTL_MH = 0x04 	// Horizontal scan oder
};

void st7735_set_orientation(enum ST7735_ORIENTATION orientation) {
    2f2a:	98 2f       	mov	r25, r24
static inline void st7735_set_rs(void) {
	PORTB |= (1 << PB0);
}

static inline void st7735_unset_rs(void) {
	PORTB &= ~(1 << PB0);
    2f2c:	28 98       	cbi	0x05, 0	; 5
static inline void spi_set_cs(void) {
	PORTB |= (1 << PB4);
}

static inline void spi_unset_cs(void) {
	PORTB &= ~(1 << PB4);
    2f2e:	2c 98       	cbi	0x05, 4	; 5
#include<avr/io.h>

void spi_init(void);

static inline void spi_write(uint8_t byte) {
	SPDR = byte;
    2f30:	86 e3       	ldi	r24, 0x36	; 54
    2f32:	8e bd       	out	0x2e, r24	; 46
	while(!(SPSR & (1<<SPIF)));
    2f34:	0d b4       	in	r0, 0x2d	; 45
    2f36:	07 fe       	sbrs	r0, 7
    2f38:	fd cf       	rjmp	.-6      	; 0x2f34 <st7735_set_orientation+0xa>
}

static inline void spi_set_cs(void) {
	PORTB |= (1 << PB4);
    2f3a:	2c 9a       	sbi	0x05, 4	; 5
};

void st7735_set_orientation(enum ST7735_ORIENTATION orientation) {
	st7735_write_cmd(ST7735_MADCTL);

  	switch (orientation) {
    2f3c:	91 30       	cpi	r25, 0x01	; 1
    2f3e:	21 f1       	breq	.+72     	; 0x2f88 <st7735_set_orientation+0x5e>
    2f40:	91 30       	cpi	r25, 0x01	; 1
    2f42:	78 f4       	brcc	.+30     	; 0x2f62 <st7735_set_orientation+0x38>
uint8_t st7735_width = 0;
uint8_t st7735_height = 0;
enum ST7735_ORIENTATION st7735_orientation = ST7735_LANDSCAPE_INV;

static inline void st7735_set_rs(void) {
	PORTB |= (1 << PB0);
    2f44:	28 9a       	sbi	0x05, 0	; 5
}

static inline void spi_unset_cs(void) {
	PORTB &= ~(1 << PB4);
    2f46:	2c 98       	cbi	0x05, 4	; 5
#include<avr/io.h>

void spi_init(void);

static inline void spi_write(uint8_t byte) {
	SPDR = byte;
    2f48:	80 ea       	ldi	r24, 0xA0	; 160
    2f4a:	8e bd       	out	0x2e, r24	; 46
	while(!(SPSR & (1<<SPIF)));
    2f4c:	0d b4       	in	r0, 0x2d	; 45
    2f4e:	07 fe       	sbrs	r0, 7
    2f50:	fd cf       	rjmp	.-6      	; 0x2f4c <st7735_set_orientation+0x22>
}

static inline void spi_set_cs(void) {
	PORTB |= (1 << PB4);
    2f52:	2c 9a       	sbi	0x05, 4	; 5

			if(st7735_type == ST7735_RED144_GREENTAB) {
				st7735_width = st7735_default_height_144;
			}
			else {
				st7735_width = st7735_default_height_18;
    2f54:	80 ea       	ldi	r24, 0xA0	; 160
    2f56:	80 93 17 07 	sts	0x0717, r24
			}

			st7735_height = st7735_default_width;
    2f5a:	80 e8       	ldi	r24, 0x80	; 128
    2f5c:	80 93 18 07 	sts	0x0718, r24
    2f60:	08 95       	ret
};

void st7735_set_orientation(enum ST7735_ORIENTATION orientation) {
	st7735_write_cmd(ST7735_MADCTL);

  	switch (orientation) {
    2f62:	92 30       	cpi	r25, 0x02	; 2
    2f64:	01 f1       	breq	.+64     	; 0x2fa6 <st7735_set_orientation+0x7c>
    2f66:	93 30       	cpi	r25, 0x03	; 3
    2f68:	09 f0       	breq	.+2      	; 0x2f6c <st7735_set_orientation+0x42>
    2f6a:	08 95       	ret
uint8_t st7735_width = 0;
uint8_t st7735_height = 0;
enum ST7735_ORIENTATION st7735_orientation = ST7735_LANDSCAPE_INV;

static inline void st7735_set_rs(void) {
	PORTB |= (1 << PB0);
    2f6c:	28 9a       	sbi	0x05, 0	; 5
}

static inline void spi_unset_cs(void) {
	PORTB &= ~(1 << PB4);
    2f6e:	2c 98       	cbi	0x05, 4	; 5
#include<avr/io.h>

void spi_init(void);

static inline void spi_write(uint8_t byte) {
	SPDR = byte;
    2f70:	1e bc       	out	0x2e, r1	; 46
	while(!(SPSR & (1<<SPIF)));
    2f72:	0d b4       	in	r0, 0x2d	; 45
    2f74:	07 fe       	sbrs	r0, 7
    2f76:	fd cf       	rjmp	.-6      	; 0x2f72 <st7735_set_orientation+0x48>
}

static inline void spi_set_cs(void) {
	PORTB |= (1 << PB4);
    2f78:	2c 9a       	sbi	0x05, 4	; 5
				st7735_write_data(MADCTL_RGB);
			} else {
				st7735_write_data(MADCTL_BGR);
			}

			st7735_width  = st7735_default_width;
    2f7a:	80 e8       	ldi	r24, 0x80	; 128
    2f7c:	80 93 17 07 	sts	0x0717, r24

			if(st7735_type == ST7735_RED144_GREENTAB) {
				st7735_height = st7735_default_height_144;
			} else {
				st7735_height = st7735_default_height_18;
    2f80:	80 ea       	ldi	r24, 0xA0	; 160
    2f82:	80 93 18 07 	sts	0x0718, r24
    2f86:	08 95       	ret
uint8_t st7735_width = 0;
uint8_t st7735_height = 0;
enum ST7735_ORIENTATION st7735_orientation = ST7735_LANDSCAPE_INV;

static inline void st7735_set_rs(void) {
	PORTB |= (1 << PB0);
    2f88:	28 9a       	sbi	0x05, 0	; 5
}

static inline void spi_unset_cs(void) {
	PORTB &= ~(1 << PB4);
    2f8a:	2c 98       	cbi	0x05, 4	; 5
#include<avr/io.h>

void spi_init(void);

static inline void spi_write(uint8_t byte) {
	SPDR = byte;
    2f8c:	80 ec       	ldi	r24, 0xC0	; 192
    2f8e:	8e bd       	out	0x2e, r24	; 46
	while(!(SPSR & (1<<SPIF)));
    2f90:	0d b4       	in	r0, 0x2d	; 45
    2f92:	07 fe       	sbrs	r0, 7
    2f94:	fd cf       	rjmp	.-6      	; 0x2f90 <st7735_set_orientation+0x66>
}

static inline void spi_set_cs(void) {
	PORTB |= (1 << PB4);
    2f96:	2c 9a       	sbi	0x05, 4	; 5
				st7735_write_data(MADCTL_RGB);
			} else {
				st7735_write_data(MADCTL_BGR);
			}

			st7735_width  = st7735_default_width;
    2f98:	80 e8       	ldi	r24, 0x80	; 128
    2f9a:	80 93 17 07 	sts	0x0717, r24

			if(st7735_type == ST7735_RED144_GREENTAB) {
				st7735_height = st7735_default_height_144;
			} else {
				st7735_height = st7735_default_height_18;
    2f9e:	80 ea       	ldi	r24, 0xA0	; 160
    2fa0:	80 93 18 07 	sts	0x0718, r24
    2fa4:	08 95       	ret
uint8_t st7735_width = 0;
uint8_t st7735_height = 0;
enum ST7735_ORIENTATION st7735_orientation = ST7735_LANDSCAPE_INV;

static inline void st7735_set_rs(void) {
	PORTB |= (1 << PB0);
    2fa6:	28 9a       	sbi	0x05, 0	; 5
}

static inline void spi_unset_cs(void) {
	PORTB &= ~(1 << PB4);
    2fa8:	2c 98       	cbi	0x05, 4	; 5
#include<avr/io.h>

void spi_init(void);

static inline void spi_write(uint8_t byte) {
	SPDR = byte;
    2faa:	80 e6       	ldi	r24, 0x60	; 96
    2fac:	8e bd       	out	0x2e, r24	; 46
	while(!(SPSR & (1<<SPIF)));
    2fae:	0d b4       	in	r0, 0x2d	; 45
    2fb0:	07 fe       	sbrs	r0, 7
    2fb2:	fd cf       	rjmp	.-6      	; 0x2fae <st7735_set_orientation+0x84>
}

static inline void spi_set_cs(void) {
	PORTB |= (1 << PB4);
    2fb4:	2c 9a       	sbi	0x05, 4	; 5
			}

			if (st7735_type == ST7735_RED144_GREENTAB) {
				st7735_width = st7735_default_height_144;
			} else {
				st7735_width = st7735_default_height_18;
    2fb6:	80 ea       	ldi	r24, 0xA0	; 160
    2fb8:	80 93 17 07 	sts	0x0717, r24
			}

			st7735_height = st7735_default_width;
    2fbc:	80 e8       	ldi	r24, 0x80	; 128
    2fbe:	80 93 18 07 	sts	0x0718, r24
    2fc2:	08 95       	ret

00002fc4 <st7735_draw_circle>:
	st7735_draw_fast_vline(x, y, h, color);
	st7735_draw_fast_vline(x + w - 1, y, h, color);
}


void st7735_draw_circle(uint8_t x0, uint8_t y0, uint8_t r, uint16_t color) {
    2fc4:	2f 92       	push	r2
    2fc6:	3f 92       	push	r3
    2fc8:	4f 92       	push	r4
    2fca:	5f 92       	push	r5
    2fcc:	6f 92       	push	r6
    2fce:	7f 92       	push	r7
    2fd0:	8f 92       	push	r8
    2fd2:	9f 92       	push	r9
    2fd4:	af 92       	push	r10
    2fd6:	bf 92       	push	r11
    2fd8:	cf 92       	push	r12
    2fda:	df 92       	push	r13
    2fdc:	ef 92       	push	r14
    2fde:	ff 92       	push	r15
    2fe0:	0f 93       	push	r16
    2fe2:	1f 93       	push	r17
    2fe4:	df 93       	push	r29
    2fe6:	cf 93       	push	r28
    2fe8:	cd b7       	in	r28, 0x3d	; 61
    2fea:	de b7       	in	r29, 0x3e	; 62
    2fec:	2c 97       	sbiw	r28, 0x0c	; 12
    2fee:	0f b6       	in	r0, 0x3f	; 63
    2ff0:	f8 94       	cli
    2ff2:	de bf       	out	0x3e, r29	; 62
    2ff4:	0f be       	out	0x3f, r0	; 63
    2ff6:	cd bf       	out	0x3d, r28	; 61
    2ff8:	69 01       	movw	r12, r18
	int16_t f = 1 - r;
    2ffa:	84 2e       	mov	r8, r20
    2ffc:	99 24       	eor	r9, r9
	int16_t ddF_x = 1;
	int16_t ddF_y = -2 * r;
	int16_t x = 0;
	int16_t y = r;

	st7735_draw_pixel(x0, y0 + r, color);
    2ffe:	48 2e       	mov	r4, r24
    3000:	55 24       	eor	r5, r5
    3002:	66 2e       	mov	r6, r22
    3004:	77 24       	eor	r7, r7
    3006:	94 01       	movw	r18, r8
    3008:	26 0d       	add	r18, r6
    300a:	37 1d       	adc	r19, r7
    300c:	3c 83       	std	Y+4, r19	; 0x04
    300e:	2b 83       	std	Y+3, r18	; 0x03
    3010:	c2 01       	movw	r24, r4
    3012:	b9 01       	movw	r22, r18
    3014:	a6 01       	movw	r20, r12
    3016:	0e 94 2d 16 	call	0x2c5a	; 0x2c5a <st7735_draw_pixel>
	st7735_draw_pixel(x0, y0 - r, color);
    301a:	c3 01       	movw	r24, r6
    301c:	88 19       	sub	r24, r8
    301e:	99 09       	sbc	r25, r9
    3020:	9e 83       	std	Y+6, r25	; 0x06
    3022:	8d 83       	std	Y+5, r24	; 0x05
    3024:	c2 01       	movw	r24, r4
    3026:	6d 81       	ldd	r22, Y+5	; 0x05
    3028:	7e 81       	ldd	r23, Y+6	; 0x06
    302a:	a6 01       	movw	r20, r12
    302c:	0e 94 2d 16 	call	0x2c5a	; 0x2c5a <st7735_draw_pixel>
	st7735_draw_pixel(x0 + r, y0, color);
    3030:	f4 01       	movw	r30, r8
    3032:	e4 0d       	add	r30, r4
    3034:	f5 1d       	adc	r31, r5
    3036:	f8 87       	std	Y+8, r31	; 0x08
    3038:	ef 83       	std	Y+7, r30	; 0x07
    303a:	cf 01       	movw	r24, r30
    303c:	b3 01       	movw	r22, r6
    303e:	a6 01       	movw	r20, r12
    3040:	0e 94 2d 16 	call	0x2c5a	; 0x2c5a <st7735_draw_pixel>
	st7735_draw_pixel(x0 - r, y0, color);
    3044:	92 01       	movw	r18, r4
    3046:	28 19       	sub	r18, r8
    3048:	39 09       	sbc	r19, r9
    304a:	3a 87       	std	Y+10, r19	; 0x0a
    304c:	29 87       	std	Y+9, r18	; 0x09
    304e:	c9 01       	movw	r24, r18
    3050:	b3 01       	movw	r22, r6
    3052:	a6 01       	movw	r20, r12
    3054:	0e 94 2d 16 	call	0x2c5a	; 0x2c5a <st7735_draw_pixel>

	while (x<y) {
    3058:	81 14       	cp	r8, r1
    305a:	91 04       	cpc	r9, r1
    305c:	09 f4       	brne	.+2      	; 0x3060 <st7735_draw_circle+0x9c>
    305e:	87 c0       	rjmp	.+270    	; 0x316e <st7735_draw_circle+0x1aa>
	st7735_draw_fast_vline(x + w - 1, y, h, color);
}


void st7735_draw_circle(uint8_t x0, uint8_t y0, uint8_t r, uint16_t color) {
	int16_t f = 1 - r;
    3060:	31 e0       	ldi	r19, 0x01	; 1
    3062:	a3 2e       	mov	r10, r19
    3064:	b1 2c       	mov	r11, r1
    3066:	a8 18       	sub	r10, r8
    3068:	b9 08       	sbc	r11, r9
	int16_t ddF_x = 1;
	int16_t ddF_y = -2 * r;
    306a:	c4 01       	movw	r24, r8
    306c:	88 0f       	add	r24, r24
    306e:	99 1f       	adc	r25, r25
    3070:	ee 27       	eor	r30, r30
    3072:	ff 27       	eor	r31, r31
    3074:	e8 1b       	sub	r30, r24
    3076:	f9 0b       	sbc	r31, r25
    3078:	fa 83       	std	Y+2, r31	; 0x02
    307a:	e9 83       	std	Y+1, r30	; 0x01
    307c:	81 e0       	ldi	r24, 0x01	; 1
    307e:	28 2e       	mov	r2, r24
    3080:	31 2c       	mov	r3, r1
    3082:	1c 86       	std	Y+12, r1	; 0x0c
    3084:	1b 86       	std	Y+11, r1	; 0x0b
    3086:	06 c0       	rjmp	.+12     	; 0x3094 <st7735_draw_circle+0xd0>
			ddF_y += 2;
			f += ddF_y;
		}

		x++;
		ddF_x += 2;
    3088:	22 e0       	ldi	r18, 0x02	; 2
    308a:	30 e0       	ldi	r19, 0x00	; 0
    308c:	22 0e       	add	r2, r18
    308e:	33 1e       	adc	r3, r19
		f += ddF_x;
    3090:	a2 0c       	add	r10, r2
    3092:	b3 1c       	adc	r11, r3
	st7735_draw_pixel(x0, y0 - r, color);
	st7735_draw_pixel(x0 + r, y0, color);
	st7735_draw_pixel(x0 - r, y0, color);

	while (x<y) {
		if (f >= 0) {
    3094:	b7 fc       	sbrc	r11, 7
    3096:	1f c0       	rjmp	.+62     	; 0x30d6 <st7735_draw_circle+0x112>
			y--;
    3098:	08 94       	sec
    309a:	81 08       	sbc	r8, r1
    309c:	91 08       	sbc	r9, r1
			ddF_y += 2;
    309e:	29 81       	ldd	r18, Y+1	; 0x01
    30a0:	3a 81       	ldd	r19, Y+2	; 0x02
    30a2:	2e 5f       	subi	r18, 0xFE	; 254
    30a4:	3f 4f       	sbci	r19, 0xFF	; 255
    30a6:	3a 83       	std	Y+2, r19	; 0x02
    30a8:	29 83       	std	Y+1, r18	; 0x01
			f += ddF_y;
    30aa:	a2 0e       	add	r10, r18
    30ac:	b3 1e       	adc	r11, r19
    30ae:	c4 01       	movw	r24, r8
    30b0:	86 0d       	add	r24, r6
    30b2:	97 1d       	adc	r25, r7
    30b4:	9c 83       	std	Y+4, r25	; 0x04
    30b6:	8b 83       	std	Y+3, r24	; 0x03
    30b8:	f3 01       	movw	r30, r6
    30ba:	e8 19       	sub	r30, r8
    30bc:	f9 09       	sbc	r31, r9
    30be:	fe 83       	std	Y+6, r31	; 0x06
    30c0:	ed 83       	std	Y+5, r30	; 0x05
    30c2:	94 01       	movw	r18, r8
    30c4:	24 0d       	add	r18, r4
    30c6:	35 1d       	adc	r19, r5
    30c8:	38 87       	std	Y+8, r19	; 0x08
    30ca:	2f 83       	std	Y+7, r18	; 0x07
    30cc:	c2 01       	movw	r24, r4
    30ce:	88 19       	sub	r24, r8
    30d0:	99 09       	sbc	r25, r9
    30d2:	9a 87       	std	Y+10, r25	; 0x0a
    30d4:	89 87       	std	Y+9, r24	; 0x09
		}

		x++;
    30d6:	eb 85       	ldd	r30, Y+11	; 0x0b
    30d8:	fc 85       	ldd	r31, Y+12	; 0x0c
    30da:	31 96       	adiw	r30, 0x01	; 1
    30dc:	fc 87       	std	Y+12, r31	; 0x0c
    30de:	eb 87       	std	Y+11, r30	; 0x0b
	st7735_draw_fast_vline(x, y, h, color);
	st7735_draw_fast_vline(x + w - 1, y, h, color);
}


void st7735_draw_circle(uint8_t x0, uint8_t y0, uint8_t r, uint16_t color) {
    30e0:	7f 01       	movw	r14, r30
    30e2:	e4 0c       	add	r14, r4
    30e4:	f5 1c       	adc	r15, r5

		x++;
		ddF_x += 2;
		f += ddF_x;

		st7735_draw_pixel(x0 + x, y0 + y, color);
    30e6:	c7 01       	movw	r24, r14
    30e8:	6b 81       	ldd	r22, Y+3	; 0x03
    30ea:	7c 81       	ldd	r23, Y+4	; 0x04
    30ec:	a6 01       	movw	r20, r12
    30ee:	0e 94 2d 16 	call	0x2c5a	; 0x2c5a <st7735_draw_pixel>
    30f2:	82 01       	movw	r16, r4
    30f4:	2b 85       	ldd	r18, Y+11	; 0x0b
    30f6:	3c 85       	ldd	r19, Y+12	; 0x0c
    30f8:	02 1b       	sub	r16, r18
    30fa:	13 0b       	sbc	r17, r19
		st7735_draw_pixel(x0 - x, y0 + y, color);
    30fc:	c8 01       	movw	r24, r16
    30fe:	6b 81       	ldd	r22, Y+3	; 0x03
    3100:	7c 81       	ldd	r23, Y+4	; 0x04
    3102:	a6 01       	movw	r20, r12
    3104:	0e 94 2d 16 	call	0x2c5a	; 0x2c5a <st7735_draw_pixel>
		st7735_draw_pixel(x0 + x, y0 - y, color);
    3108:	c7 01       	movw	r24, r14
    310a:	6d 81       	ldd	r22, Y+5	; 0x05
    310c:	7e 81       	ldd	r23, Y+6	; 0x06
    310e:	a6 01       	movw	r20, r12
    3110:	0e 94 2d 16 	call	0x2c5a	; 0x2c5a <st7735_draw_pixel>
		st7735_draw_pixel(x0 - x, y0 - y, color);
    3114:	c8 01       	movw	r24, r16
    3116:	6d 81       	ldd	r22, Y+5	; 0x05
    3118:	7e 81       	ldd	r23, Y+6	; 0x06
    311a:	a6 01       	movw	r20, r12
    311c:	0e 94 2d 16 	call	0x2c5a	; 0x2c5a <st7735_draw_pixel>
	st7735_draw_fast_vline(x, y, h, color);
	st7735_draw_fast_vline(x + w - 1, y, h, color);
}


void st7735_draw_circle(uint8_t x0, uint8_t y0, uint8_t r, uint16_t color) {
    3120:	0b 85       	ldd	r16, Y+11	; 0x0b
    3122:	1c 85       	ldd	r17, Y+12	; 0x0c
    3124:	06 0d       	add	r16, r6
    3126:	17 1d       	adc	r17, r7

		st7735_draw_pixel(x0 + x, y0 + y, color);
		st7735_draw_pixel(x0 - x, y0 + y, color);
		st7735_draw_pixel(x0 + x, y0 - y, color);
		st7735_draw_pixel(x0 - x, y0 - y, color);
		st7735_draw_pixel(x0 + y, y0 + x, color);
    3128:	8f 81       	ldd	r24, Y+7	; 0x07
    312a:	98 85       	ldd	r25, Y+8	; 0x08
    312c:	b8 01       	movw	r22, r16
    312e:	a6 01       	movw	r20, r12
    3130:	0e 94 2d 16 	call	0x2c5a	; 0x2c5a <st7735_draw_pixel>
		st7735_draw_pixel(x0 - y, y0 + x, color);
    3134:	89 85       	ldd	r24, Y+9	; 0x09
    3136:	9a 85       	ldd	r25, Y+10	; 0x0a
    3138:	b8 01       	movw	r22, r16
    313a:	a6 01       	movw	r20, r12
    313c:	0e 94 2d 16 	call	0x2c5a	; 0x2c5a <st7735_draw_pixel>
    3140:	83 01       	movw	r16, r6
    3142:	8b 85       	ldd	r24, Y+11	; 0x0b
    3144:	9c 85       	ldd	r25, Y+12	; 0x0c
    3146:	08 1b       	sub	r16, r24
    3148:	19 0b       	sbc	r17, r25
		st7735_draw_pixel(x0 + y, y0 - x, color);
    314a:	8f 81       	ldd	r24, Y+7	; 0x07
    314c:	98 85       	ldd	r25, Y+8	; 0x08
    314e:	b8 01       	movw	r22, r16
    3150:	a6 01       	movw	r20, r12
    3152:	0e 94 2d 16 	call	0x2c5a	; 0x2c5a <st7735_draw_pixel>
		st7735_draw_pixel(x0 - y, y0 - x, color);
    3156:	89 85       	ldd	r24, Y+9	; 0x09
    3158:	9a 85       	ldd	r25, Y+10	; 0x0a
    315a:	b8 01       	movw	r22, r16
    315c:	a6 01       	movw	r20, r12
    315e:	0e 94 2d 16 	call	0x2c5a	; 0x2c5a <st7735_draw_pixel>
	st7735_draw_pixel(x0, y0 + r, color);
	st7735_draw_pixel(x0, y0 - r, color);
	st7735_draw_pixel(x0 + r, y0, color);
	st7735_draw_pixel(x0 - r, y0, color);

	while (x<y) {
    3162:	eb 85       	ldd	r30, Y+11	; 0x0b
    3164:	fc 85       	ldd	r31, Y+12	; 0x0c
    3166:	e8 15       	cp	r30, r8
    3168:	f9 05       	cpc	r31, r9
    316a:	0c f4       	brge	.+2      	; 0x316e <st7735_draw_circle+0x1aa>
    316c:	8d cf       	rjmp	.-230    	; 0x3088 <st7735_draw_circle+0xc4>
		st7735_draw_pixel(x0 + y, y0 + x, color);
		st7735_draw_pixel(x0 - y, y0 + x, color);
		st7735_draw_pixel(x0 + y, y0 - x, color);
		st7735_draw_pixel(x0 - y, y0 - x, color);
	}
}
    316e:	2c 96       	adiw	r28, 0x0c	; 12
    3170:	0f b6       	in	r0, 0x3f	; 63
    3172:	f8 94       	cli
    3174:	de bf       	out	0x3e, r29	; 62
    3176:	0f be       	out	0x3f, r0	; 63
    3178:	cd bf       	out	0x3d, r28	; 61
    317a:	cf 91       	pop	r28
    317c:	df 91       	pop	r29
    317e:	1f 91       	pop	r17
    3180:	0f 91       	pop	r16
    3182:	ff 90       	pop	r15
    3184:	ef 90       	pop	r14
    3186:	df 90       	pop	r13
    3188:	cf 90       	pop	r12
    318a:	bf 90       	pop	r11
    318c:	af 90       	pop	r10
    318e:	9f 90       	pop	r9
    3190:	8f 90       	pop	r8
    3192:	7f 90       	pop	r7
    3194:	6f 90       	pop	r6
    3196:	5f 90       	pop	r5
    3198:	4f 90       	pop	r4
    319a:	3f 90       	pop	r3
    319c:	2f 90       	pop	r2
    319e:	08 95       	ret

000031a0 <st7735_draw_rect>:
		st7735_draw_fast_hline(seg, y0, cur_x - seg, color);
	}
}


void st7735_draw_rect(uint8_t x, uint8_t y, uint8_t w, uint8_t h, uint16_t color) {
    31a0:	cf 92       	push	r12
    31a2:	df 92       	push	r13
    31a4:	ef 92       	push	r14
    31a6:	ff 92       	push	r15
    31a8:	0f 93       	push	r16
    31aa:	1f 93       	push	r17
    31ac:	cf 93       	push	r28
    31ae:	df 93       	push	r29
    31b0:	d8 2e       	mov	r13, r24
    31b2:	c6 2e       	mov	r12, r22
    31b4:	f4 2e       	mov	r15, r20
    31b6:	e2 2e       	mov	r14, r18
	if(w < 1 || h < 1) {
    31b8:	44 23       	and	r20, r20
    31ba:	11 f0       	breq	.+4      	; 0x31c0 <st7735_draw_rect+0x20>
    31bc:	22 23       	and	r18, r18
    31be:	49 f4       	brne	.+18     	; 0x31d2 <st7735_draw_rect+0x32>

	st7735_draw_fast_hline(x, y, w, color);
	st7735_draw_fast_hline(x, y + h - 1, w, color);
	st7735_draw_fast_vline(x, y, h, color);
	st7735_draw_fast_vline(x + w - 1, y, h, color);
}
    31c0:	df 91       	pop	r29
    31c2:	cf 91       	pop	r28
    31c4:	1f 91       	pop	r17
    31c6:	0f 91       	pop	r16
    31c8:	ff 90       	pop	r15
    31ca:	ef 90       	pop	r14
    31cc:	df 90       	pop	r13
    31ce:	cf 90       	pop	r12
    31d0:	08 95       	ret
static inline void st7735_draw_fast_vline(uint8_t x, uint8_t y, uint8_t h, uint16_t color) {
	st7735_fill_rect(x, y, 1, h, color);
}

static inline void st7735_draw_fast_hline(uint8_t x, uint8_t y, uint8_t w, uint16_t color) {
	st7735_fill_rect(x, y, w, 1, color);
    31d2:	21 e0       	ldi	r18, 0x01	; 1
    31d4:	0e 94 59 16 	call	0x2cb2	; 0x2cb2 <st7735_fill_rect>

void st7735_draw_pixel(int16_t x, int16_t y, uint16_t color);
void st7735_fill_rect(uint8_t x, uint8_t y, uint8_t w, uint8_t h, uint16_t color);

static inline void st7735_draw_fast_vline(uint8_t x, uint8_t y, uint8_t h, uint16_t color) {
	st7735_fill_rect(x, y, 1, h, color);
    31d8:	6c 2d       	mov	r22, r12
    31da:	61 50       	subi	r22, 0x01	; 1
    31dc:	6e 0d       	add	r22, r14
    31de:	8d 2d       	mov	r24, r13
    31e0:	4f 2d       	mov	r20, r15
    31e2:	21 e0       	ldi	r18, 0x01	; 1
    31e4:	0e 94 59 16 	call	0x2cb2	; 0x2cb2 <st7735_fill_rect>
    31e8:	8d 2d       	mov	r24, r13
    31ea:	6c 2d       	mov	r22, r12
    31ec:	41 e0       	ldi	r20, 0x01	; 1
    31ee:	2e 2d       	mov	r18, r14
    31f0:	0e 94 59 16 	call	0x2cb2	; 0x2cb2 <st7735_fill_rect>

#include "st7735.h"

#define _swap_uint8_t(a, b) { uint8_t t = a; a = b; b = t; }

void st7735_draw_line(uint8_t x0, uint8_t y0, uint8_t x1, uint8_t y1, uint16_t color) {
    31f4:	da 94       	dec	r13
    31f6:	8d 2d       	mov	r24, r13
    31f8:	8f 0d       	add	r24, r15
    31fa:	6c 2d       	mov	r22, r12
    31fc:	41 e0       	ldi	r20, 0x01	; 1
    31fe:	2e 2d       	mov	r18, r14
    3200:	0e 94 59 16 	call	0x2cb2	; 0x2cb2 <st7735_fill_rect>
    3204:	dd cf       	rjmp	.-70     	; 0x31c0 <st7735_draw_rect+0x20>

00003206 <st7735_draw_line>:
    3206:	3f 92       	push	r3
    3208:	4f 92       	push	r4
    320a:	5f 92       	push	r5
    320c:	6f 92       	push	r6
    320e:	7f 92       	push	r7
    3210:	8f 92       	push	r8
    3212:	9f 92       	push	r9
    3214:	af 92       	push	r10
    3216:	bf 92       	push	r11
    3218:	cf 92       	push	r12
    321a:	df 92       	push	r13
    321c:	ef 92       	push	r14
    321e:	ff 92       	push	r15
    3220:	0f 93       	push	r16
    3222:	1f 93       	push	r17
    3224:	cf 93       	push	r28
    3226:	df 93       	push	r29
    3228:	88 2e       	mov	r8, r24
    322a:	96 2e       	mov	r9, r22
    322c:	e4 2e       	mov	r14, r20
    322e:	f2 2e       	mov	r15, r18
    3230:	28 01       	movw	r4, r16
	uint8_t steep_dir = abs(y1 - y0) > abs(x1 - x0);
    3232:	62 2f       	mov	r22, r18
    3234:	70 e0       	ldi	r23, 0x00	; 0
    3236:	49 2d       	mov	r20, r9
    3238:	50 e0       	ldi	r21, 0x00	; 0
    323a:	ae 2d       	mov	r26, r14
    323c:	b0 e0       	ldi	r27, 0x00	; 0
    323e:	e8 2f       	mov	r30, r24
    3240:	f0 e0       	ldi	r31, 0x00	; 0
    3242:	33 24       	eor	r3, r3
    3244:	9b 01       	movw	r18, r22
    3246:	24 1b       	sub	r18, r20
    3248:	35 0b       	sbc	r19, r21
    324a:	37 fd       	sbrc	r19, 7
    324c:	92 c0       	rjmp	.+292    	; 0x3372 <st7735_draw_line+0x16c>
    324e:	cd 01       	movw	r24, r26
    3250:	8e 1b       	sub	r24, r30
    3252:	9f 0b       	sbc	r25, r31
    3254:	97 fd       	sbrc	r25, 7
    3256:	89 c0       	rjmp	.+274    	; 0x336a <st7735_draw_line+0x164>
    3258:	82 17       	cp	r24, r18
    325a:	93 07       	cpc	r25, r19
    325c:	74 f4       	brge	.+28     	; 0x327a <st7735_draw_line+0x74>
    325e:	33 24       	eor	r3, r3
    3260:	33 94       	inc	r3
	if (steep_dir) {
    3262:	89 2d       	mov	r24, r9
    3264:	98 2c       	mov	r9, r8
    3266:	88 2e       	mov	r8, r24
    3268:	8f 2d       	mov	r24, r15
    326a:	fe 2c       	mov	r15, r14
    326c:	e8 2e       	mov	r14, r24
    326e:	ca 01       	movw	r24, r20
    3270:	af 01       	movw	r20, r30
    3272:	fc 01       	movw	r30, r24
    3274:	cb 01       	movw	r24, r22
    3276:	bd 01       	movw	r22, r26
    3278:	dc 01       	movw	r26, r24
		_swap_uint8_t(x0, y0);
		_swap_uint8_t(x1, y1);
	}

	if (x0 > x1) {
    327a:	e8 14       	cp	r14, r8
    327c:	60 f4       	brcc	.+24     	; 0x3296 <st7735_draw_line+0x90>
    327e:	8e 2d       	mov	r24, r14
    3280:	e8 2c       	mov	r14, r8
    3282:	88 2e       	mov	r8, r24
    3284:	8f 2d       	mov	r24, r15
    3286:	f9 2c       	mov	r15, r9
    3288:	98 2e       	mov	r9, r24
    328a:	cf 01       	movw	r24, r30
    328c:	fd 01       	movw	r30, r26
    328e:	dc 01       	movw	r26, r24
    3290:	ca 01       	movw	r24, r20
    3292:	ab 01       	movw	r20, r22
    3294:	bc 01       	movw	r22, r24
		_swap_uint8_t(y0, y1);
	}

  	int16_t dx, dy;
  	dx = x1 - x0;
  	dy = abs(y1 - y0);
    3296:	6b 01       	movw	r12, r22
    3298:	c4 1a       	sub	r12, r20
    329a:	d5 0a       	sbc	r13, r21
    329c:	d7 fc       	sbrc	r13, 7
    329e:	60 c0       	rjmp	.+192    	; 0x3360 <st7735_draw_line+0x15a>

	int16_t err = dx / 2;
	int16_t y_step;

	if (y0 < y1) {
    32a0:	9f 14       	cp	r9, r15
    32a2:	08 f4       	brcc	.+2      	; 0x32a6 <st7735_draw_line+0xa0>
    32a4:	53 c0       	rjmp	.+166    	; 0x334c <st7735_draw_line+0x146>
    32a6:	66 24       	eor	r6, r6
    32a8:	6a 94       	dec	r6
    32aa:	76 2c       	mov	r7, r6
		y_step = -1;
	}

	uint8_t seg = x0;
	uint8_t cur_x;
	for(cur_x = x0; cur_x <= x1; cur_x++) {
    32ac:	e8 14       	cp	r14, r8
    32ae:	08 f4       	brcc	.+2      	; 0x32b2 <st7735_draw_line+0xac>
    32b0:	66 c0       	rjmp	.+204    	; 0x337e <st7735_draw_line+0x178>
		_swap_uint8_t(x0, x1);
		_swap_uint8_t(y0, y1);
	}

  	int16_t dx, dy;
  	dx = x1 - x0;
    32b2:	5d 01       	movw	r10, r26
    32b4:	ae 1a       	sub	r10, r30
    32b6:	bf 0a       	sbc	r11, r31
  	dy = abs(y1 - y0);

	int16_t err = dx / 2;
    32b8:	c5 01       	movw	r24, r10
    32ba:	b7 fc       	sbrc	r11, 7
    32bc:	5e c0       	rjmp	.+188    	; 0x337a <st7735_draw_line+0x174>
    32be:	ec 01       	movw	r28, r24
    32c0:	d5 95       	asr	r29
    32c2:	c7 95       	ror	r28
    32c4:	f8 2c       	mov	r15, r8
    32c6:	f3 94       	inc	r15
    32c8:	68 2d       	mov	r22, r8
    32ca:	05 c0       	rjmp	.+10     	; 0x32d6 <st7735_draw_line+0xd0>
				st7735_draw_fast_vline(y0, seg, cur_x - seg + 1, color);
			} else {
				st7735_draw_fast_hline(seg, y0, cur_x - seg +1, color);
			}
			y0 += y_step;
			err += dx;
    32cc:	8f 2d       	mov	r24, r15
    32ce:	8f 5f       	subi	r24, 0xFF	; 255
		y_step = -1;
	}

	uint8_t seg = x0;
	uint8_t cur_x;
	for(cur_x = x0; cur_x <= x1; cur_x++) {
    32d0:	ef 14       	cp	r14, r15
    32d2:	b0 f0       	brcs	.+44     	; 0x3300 <st7735_draw_line+0xfa>
    32d4:	f8 2e       	mov	r15, r24
		err -= dy;
    32d6:	cc 19       	sub	r28, r12
    32d8:	dd 09       	sbc	r29, r13
		if (err < 0) {
    32da:	d7 ff       	sbrs	r29, 7
    32dc:	f7 cf       	rjmp	.-18     	; 0x32cc <st7735_draw_line+0xc6>
			if (steep_dir) {
    32de:	33 20       	and	r3, r3
    32e0:	61 f1       	breq	.+88     	; 0x333a <st7735_draw_line+0x134>
    32e2:	2f 2d       	mov	r18, r15
    32e4:	26 1b       	sub	r18, r22
    32e6:	89 2d       	mov	r24, r9
    32e8:	41 e0       	ldi	r20, 0x01	; 1
    32ea:	82 01       	movw	r16, r4
    32ec:	0e 94 59 16 	call	0x2cb2	; 0x2cb2 <st7735_fill_rect>
				st7735_draw_fast_vline(y0, seg, cur_x - seg + 1, color);
			} else {
				st7735_draw_fast_hline(seg, y0, cur_x - seg +1, color);
			}
			y0 += y_step;
    32f0:	96 0c       	add	r9, r6
			err += dx;
    32f2:	ca 0d       	add	r28, r10
    32f4:	db 1d       	adc	r29, r11
    32f6:	6f 2d       	mov	r22, r15
    32f8:	8f 2d       	mov	r24, r15
    32fa:	8f 5f       	subi	r24, 0xFF	; 255
		y_step = -1;
	}

	uint8_t seg = x0;
	uint8_t cur_x;
	for(cur_x = x0; cur_x <= x1; cur_x++) {
    32fc:	ef 14       	cp	r14, r15
    32fe:	50 f7       	brcc	.-44     	; 0x32d4 <st7735_draw_line+0xce>
    3300:	2f 2d       	mov	r18, r15
    3302:	26 1b       	sub	r18, r22
			seg = cur_x + 1;
		}
	}

	// x0 incremented
	if (steep_dir) {
    3304:	33 20       	and	r3, r3
    3306:	31 f5       	brne	.+76     	; 0x3354 <st7735_draw_line+0x14e>
}

static inline void st7735_draw_fast_hline(uint8_t x, uint8_t y, uint8_t w, uint16_t color) {
	st7735_fill_rect(x, y, w, 1, color);
    3308:	86 2f       	mov	r24, r22
    330a:	69 2d       	mov	r22, r9
    330c:	42 2f       	mov	r20, r18
    330e:	21 e0       	ldi	r18, 0x01	; 1
    3310:	82 01       	movw	r16, r4
    3312:	0e 94 59 16 	call	0x2cb2	; 0x2cb2 <st7735_fill_rect>
		st7735_draw_fast_vline(y0, seg, cur_x - seg, color);
	} else {
		st7735_draw_fast_hline(seg, y0, cur_x - seg, color);
	}
}
    3316:	df 91       	pop	r29
    3318:	cf 91       	pop	r28
    331a:	1f 91       	pop	r17
    331c:	0f 91       	pop	r16
    331e:	ff 90       	pop	r15
    3320:	ef 90       	pop	r14
    3322:	df 90       	pop	r13
    3324:	cf 90       	pop	r12
    3326:	bf 90       	pop	r11
    3328:	af 90       	pop	r10
    332a:	9f 90       	pop	r9
    332c:	8f 90       	pop	r8
    332e:	7f 90       	pop	r7
    3330:	6f 90       	pop	r6
    3332:	5f 90       	pop	r5
    3334:	4f 90       	pop	r4
    3336:	3f 90       	pop	r3
    3338:	08 95       	ret
    333a:	4f 2d       	mov	r20, r15
    333c:	46 1b       	sub	r20, r22
    333e:	86 2f       	mov	r24, r22
    3340:	69 2d       	mov	r22, r9
    3342:	21 e0       	ldi	r18, 0x01	; 1
    3344:	82 01       	movw	r16, r4
    3346:	0e 94 59 16 	call	0x2cb2	; 0x2cb2 <st7735_fill_rect>
    334a:	d2 cf       	rjmp	.-92     	; 0x32f0 <st7735_draw_line+0xea>
  	dy = abs(y1 - y0);

	int16_t err = dx / 2;
	int16_t y_step;

	if (y0 < y1) {
    334c:	51 e0       	ldi	r21, 0x01	; 1
    334e:	65 2e       	mov	r6, r21
    3350:	71 2c       	mov	r7, r1
    3352:	ac cf       	rjmp	.-168    	; 0x32ac <st7735_draw_line+0xa6>

void st7735_draw_pixel(int16_t x, int16_t y, uint16_t color);
void st7735_fill_rect(uint8_t x, uint8_t y, uint8_t w, uint8_t h, uint16_t color);

static inline void st7735_draw_fast_vline(uint8_t x, uint8_t y, uint8_t h, uint16_t color) {
	st7735_fill_rect(x, y, 1, h, color);
    3354:	89 2d       	mov	r24, r9
    3356:	41 e0       	ldi	r20, 0x01	; 1
    3358:	82 01       	movw	r16, r4
    335a:	0e 94 59 16 	call	0x2cb2	; 0x2cb2 <st7735_fill_rect>
    335e:	db cf       	rjmp	.-74     	; 0x3316 <st7735_draw_line+0x110>
		_swap_uint8_t(y0, y1);
	}

  	int16_t dx, dy;
  	dx = x1 - x0;
  	dy = abs(y1 - y0);
    3360:	d0 94       	com	r13
    3362:	c1 94       	neg	r12
    3364:	d1 08       	sbc	r13, r1
    3366:	d3 94       	inc	r13
    3368:	9b cf       	rjmp	.-202    	; 0x32a0 <st7735_draw_line+0x9a>
#include "st7735.h"

#define _swap_uint8_t(a, b) { uint8_t t = a; a = b; b = t; }

void st7735_draw_line(uint8_t x0, uint8_t y0, uint8_t x1, uint8_t y1, uint16_t color) {
	uint8_t steep_dir = abs(y1 - y0) > abs(x1 - x0);
    336a:	90 95       	com	r25
    336c:	81 95       	neg	r24
    336e:	9f 4f       	sbci	r25, 0xFF	; 255
    3370:	73 cf       	rjmp	.-282    	; 0x3258 <st7735_draw_line+0x52>
    3372:	30 95       	com	r19
    3374:	21 95       	neg	r18
    3376:	3f 4f       	sbci	r19, 0xFF	; 255
    3378:	6a cf       	rjmp	.-300    	; 0x324e <st7735_draw_line+0x48>

  	int16_t dx, dy;
  	dx = x1 - x0;
  	dy = abs(y1 - y0);

	int16_t err = dx / 2;
    337a:	01 96       	adiw	r24, 0x01	; 1
    337c:	a0 cf       	rjmp	.-192    	; 0x32be <st7735_draw_line+0xb8>
		y_step = -1;
	}

	uint8_t seg = x0;
	uint8_t cur_x;
	for(cur_x = x0; cur_x <= x1; cur_x++) {
    337e:	68 2d       	mov	r22, r8
    3380:	20 e0       	ldi	r18, 0x00	; 0
    3382:	c0 cf       	rjmp	.-128    	; 0x3304 <st7735_draw_line+0xfe>

00003384 <st7735_setCursor>:
    }
}


void st7735_setCursor(int16_t x, int16_t y) {
    cursor_x = x;
    3384:	90 93 8b 09 	sts	0x098B, r25
    3388:	80 93 8a 09 	sts	0x098A, r24
    cursor_y = y;
    338c:	70 93 84 09 	sts	0x0984, r23
    3390:	60 93 83 09 	sts	0x0983, r22
}
    3394:	08 95       	ret

00003396 <st7735_setTextSize>:


void st7735_setTextSize(uint8_t s) {
    textsize = (s > 0) ? s : 1;
    3396:	88 23       	and	r24, r24
    3398:	09 f4       	brne	.+2      	; 0x339c <st7735_setTextSize+0x6>
    339a:	81 e0       	ldi	r24, 0x01	; 1
    339c:	80 93 8d 09 	sts	0x098D, r24
}
    33a0:	08 95       	ret

000033a2 <st7735_setTextColor>:


void st7735_setTextColor(uint16_t c, uint16_t b) {
    textcolor = c;
    33a2:	90 93 91 09 	sts	0x0991, r25
    33a6:	80 93 90 09 	sts	0x0990, r24
    textbgcolor = b;
    33aa:	70 93 8f 09 	sts	0x098F, r23
    33ae:	60 93 8e 09 	sts	0x098E, r22
}
    33b2:	08 95       	ret

000033b4 <st7735_setTextWrap>:

void st7735_setTextWrap(uint8_t w) {
    wrap = w;
    33b4:	80 93 8c 09 	sts	0x098C, r24
}
    33b8:	08 95       	ret

000033ba <st7735_drawChar>:
  0x00, 0x00, 0x00, 0x00, 0x00,
};

// draw a character
void st7735_drawChar(int16_t x, int16_t y, unsigned char c,
              uint16_t color, uint16_t bg, uint8_t size) {
    33ba:	2f 92       	push	r2
    33bc:	3f 92       	push	r3
    33be:	4f 92       	push	r4
    33c0:	5f 92       	push	r5
    33c2:	6f 92       	push	r6
    33c4:	7f 92       	push	r7
    33c6:	8f 92       	push	r8
    33c8:	9f 92       	push	r9
    33ca:	af 92       	push	r10
    33cc:	bf 92       	push	r11
    33ce:	cf 92       	push	r12
    33d0:	df 92       	push	r13
    33d2:	ef 92       	push	r14
    33d4:	ff 92       	push	r15
    33d6:	0f 93       	push	r16
    33d8:	1f 93       	push	r17
    33da:	df 93       	push	r29
    33dc:	cf 93       	push	r28
    33de:	cd b7       	in	r28, 0x3d	; 61
    33e0:	de b7       	in	r29, 0x3e	; 62
    33e2:	2e 97       	sbiw	r28, 0x0e	; 14
    33e4:	0f b6       	in	r0, 0x3f	; 63
    33e6:	f8 94       	cli
    33e8:	de bf       	out	0x3e, r29	; 62
    33ea:	0f be       	out	0x3f, r0	; 63
    33ec:	cd bf       	out	0x3d, r28	; 61
    33ee:	98 87       	std	Y+8, r25	; 0x08
    33f0:	8f 83       	std	Y+7, r24	; 0x07
    33f2:	7a 87       	std	Y+10, r23	; 0x0a
    33f4:	69 87       	std	Y+9, r22	; 0x09
    33f6:	59 01       	movw	r10, r18
    33f8:	48 01       	movw	r8, r16
    33fa:	de 2c       	mov	r13, r14

    if((x >= st7735_width)            || // Clip right
    33fc:	80 91 17 07 	lds	r24, 0x0717
    3400:	90 e0       	ldi	r25, 0x00	; 0
    3402:	2f 81       	ldd	r18, Y+7	; 0x07
    3404:	38 85       	ldd	r19, Y+8	; 0x08
    3406:	28 17       	cp	r18, r24
    3408:	39 07       	cpc	r19, r25
    340a:	0c f0       	brlt	.+2      	; 0x340e <st7735_drawChar+0x54>
    340c:	91 c0       	rjmp	.+290    	; 0x3530 <st7735_drawChar+0x176>
    340e:	80 91 18 07 	lds	r24, 0x0718
    3412:	90 e0       	ldi	r25, 0x00	; 0
    3414:	68 17       	cp	r22, r24
    3416:	79 07       	cpc	r23, r25
    3418:	0c f0       	brlt	.+2      	; 0x341c <st7735_drawChar+0x62>
    341a:	8a c0       	rjmp	.+276    	; 0x3530 <st7735_drawChar+0x176>
    341c:	8e 2d       	mov	r24, r14
    341e:	90 e0       	ldi	r25, 0x00	; 0
    3420:	9e 83       	std	Y+6, r25	; 0x06
    3422:	8d 83       	std	Y+5, r24	; 0x05
    3424:	88 0f       	add	r24, r24
    3426:	99 1f       	adc	r25, r25
    3428:	88 0f       	add	r24, r24
    342a:	99 1f       	adc	r25, r25
    342c:	ad 81       	ldd	r26, Y+5	; 0x05
    342e:	be 81       	ldd	r27, Y+6	; 0x06
    3430:	8a 0f       	add	r24, r26
    3432:	9b 1f       	adc	r25, r27
    3434:	82 0f       	add	r24, r18
    3436:	93 1f       	adc	r25, r19
    3438:	18 16       	cp	r1, r24
    343a:	19 06       	cpc	r1, r25
    343c:	0c f0       	brlt	.+2      	; 0x3440 <st7735_drawChar+0x86>
    343e:	78 c0       	rjmp	.+240    	; 0x3530 <st7735_drawChar+0x176>
    3440:	cd 01       	movw	r24, r26
    3442:	88 0f       	add	r24, r24
    3444:	99 1f       	adc	r25, r25
    3446:	88 0f       	add	r24, r24
    3448:	99 1f       	adc	r25, r25
    344a:	88 0f       	add	r24, r24
    344c:	99 1f       	adc	r25, r25
    344e:	86 0f       	add	r24, r22
    3450:	97 1f       	adc	r25, r23
    3452:	18 16       	cp	r1, r24
    3454:	19 06       	cpc	r1, r25
    3456:	0c f0       	brlt	.+2      	; 0x345a <st7735_drawChar+0xa0>
    3458:	6b c0       	rjmp	.+214    	; 0x3530 <st7735_drawChar+0x176>
    345a:	cd 80       	ldd	r12, Y+5	; 0x05
    345c:	19 01       	movw	r2, r18
    345e:	2c 83       	std	Y+4, r18	; 0x04
    3460:	85 e0       	ldi	r24, 0x05	; 5
    3462:	48 9f       	mul	r20, r24
    3464:	f0 01       	movw	r30, r0
    3466:	11 24       	eor	r1, r1
    3468:	e4 5d       	subi	r30, 0xD4	; 212
    346a:	fe 4f       	sbci	r31, 0xFE	; 254
    346c:	fb 83       	std	Y+3, r31	; 0x03
    346e:	ea 83       	std	Y+2, r30	; 0x02
    3470:	66 24       	eor	r6, r6
    3472:	77 24       	eor	r7, r7
    3474:	19 82       	std	Y+1, r1	; 0x01
    3476:	2b 01       	movw	r4, r22
    3478:	28 e0       	ldi	r18, 0x08	; 8
    347a:	30 e0       	ldi	r19, 0x00	; 0
    347c:	42 0e       	add	r4, r18
    347e:	53 1e       	adc	r5, r19
                    }
                else {  // big size
                    if(rotation % 2 != 0) {
                        st7735_fill_rect(y+(j*size),st7735_width-x-(i*size)-size, size, size, color);
                    } else {
                        st7735_fill_rect(x+(i*size), y+(j*size), size, size, color);
    3480:	3f 81       	ldd	r19, Y+7	; 0x07
    3482:	3b 87       	std	Y+11, r19	; 0x0b
    3484:	89 85       	ldd	r24, Y+9	; 0x09
    3486:	8c 87       	std	Y+12, r24	; 0x0c
            ((y + 8 * size - 1) < 0))   // Clip top
        return;

    for (int8_t i=0; i<6; i++ ) {
        uint8_t line;
        if (i == 5)
    3488:	95 e0       	ldi	r25, 0x05	; 5
    348a:	69 16       	cp	r6, r25
    348c:	09 f4       	brne	.+2      	; 0x3490 <st7735_drawChar+0xd6>
    348e:	96 c0       	rjmp	.+300    	; 0x35bc <st7735_drawChar+0x202>
            line = 0x0;
        else
            line = pgm_read_byte(font+(c*5)+i);	
    3490:	ea 81       	ldd	r30, Y+2	; 0x02
    3492:	fb 81       	ldd	r31, Y+3	; 0x03
    3494:	e4 90       	lpm	r14, Z+
                    }
                else {  // big size
                    if(rotation % 2 != 0) {
                        st7735_fill_rect(y+(j*size),st7735_width-x-(i*size)-size, size, size, color);
                    } else {
                        st7735_fill_rect(x+(i*size), y+(j*size), size, size, color);
    3496:	fc 84       	ldd	r15, Y+12	; 0x0c
    3498:	29 85       	ldd	r18, Y+9	; 0x09
    349a:	3a 85       	ldd	r19, Y+10	; 0x0a
    349c:	3e 87       	std	Y+14, r19	; 0x0e
    349e:	2d 87       	std	Y+13, r18	; 0x0d
    34a0:	20 c0       	rjmp	.+64     	; 0x34e2 <st7735_drawChar+0x128>
            line = 0x0;
        else
            line = pgm_read_byte(font+(c*5)+i);	
        for (int8_t j = 0; j<8; j++) {
            if (line & 0x1) {
                if (size == 1) // default size
    34a2:	31 e0       	ldi	r19, 0x01	; 1
    34a4:	d3 16       	cp	r13, r19
    34a6:	09 f4       	brne	.+2      	; 0x34aa <st7735_drawChar+0xf0>
    34a8:	64 c0       	rjmp	.+200    	; 0x3572 <st7735_drawChar+0x1b8>
                        st7735_draw_pixel(y+j,st7735_width-x-i-size, color);
                    } else {
                        st7735_draw_pixel(x+i, y+j, color);
                    }
                else {  // big size
                    if(rotation % 2 != 0) {
    34aa:	80 91 87 09 	lds	r24, 0x0987
    34ae:	80 ff       	sbrs	r24, 0
    34b0:	58 c0       	rjmp	.+176    	; 0x3562 <st7735_drawChar+0x1a8>
                        st7735_fill_rect(y+(j*size),st7735_width-x-(i*size)-size, size, size, color);
    34b2:	60 91 17 07 	lds	r22, 0x0717
    34b6:	bb 85       	ldd	r27, Y+11	; 0x0b
    34b8:	6b 1b       	sub	r22, r27
    34ba:	e9 81       	ldd	r30, Y+1	; 0x01
    34bc:	6e 1b       	sub	r22, r30
    34be:	6d 19       	sub	r22, r13
    34c0:	8f 2d       	mov	r24, r15
    34c2:	4d 2d       	mov	r20, r13
    34c4:	2d 2d       	mov	r18, r13
    34c6:	85 01       	movw	r16, r10
    34c8:	0e 94 59 16 	call	0x2cb2	; 0x2cb2 <st7735_fill_rect>
                }
            } else if (bg != color) {
                if (size == 1) // default size
                    st7735_draw_pixel(x+i, y+j, bg);
                else {  // big size
                    st7735_fill_rect(x+i*size, y+j*size, size, size, bg);
    34cc:	fc 0c       	add	r15, r12
    34ce:	2d 85       	ldd	r18, Y+13	; 0x0d
    34d0:	3e 85       	ldd	r19, Y+14	; 0x0e
    34d2:	2f 5f       	subi	r18, 0xFF	; 255
    34d4:	3f 4f       	sbci	r19, 0xFF	; 255
    34d6:	3e 87       	std	Y+14, r19	; 0x0e
    34d8:	2d 87       	std	Y+13, r18	; 0x0d
        uint8_t line;
        if (i == 5)
            line = 0x0;
        else
            line = pgm_read_byte(font+(c*5)+i);	
        for (int8_t j = 0; j<8; j++) {
    34da:	24 15       	cp	r18, r4
    34dc:	35 05       	cpc	r19, r5
    34de:	91 f0       	breq	.+36     	; 0x3504 <st7735_drawChar+0x14a>
                    st7735_draw_pixel(x+i, y+j, bg);
                else {  // big size
                    st7735_fill_rect(x+i*size, y+j*size, size, size, bg);
                }
            }
            line >>= 1;
    34e0:	e6 94       	lsr	r14
        if (i == 5)
            line = 0x0;
        else
            line = pgm_read_byte(font+(c*5)+i);	
        for (int8_t j = 0; j<8; j++) {
            if (line & 0x1) {
    34e2:	e0 fc       	sbrc	r14, 0
    34e4:	de cf       	rjmp	.-68     	; 0x34a2 <st7735_drawChar+0xe8>
                        st7735_fill_rect(y+(j*size),st7735_width-x-(i*size)-size, size, size, color);
                    } else {
                        st7735_fill_rect(x+(i*size), y+(j*size), size, size, color);
                    }
                }
            } else if (bg != color) {
    34e6:	8a 14       	cp	r8, r10
    34e8:	9b 04       	cpc	r9, r11
    34ea:	81 f3       	breq	.-32     	; 0x34cc <st7735_drawChar+0x112>
                if (size == 1) // default size
    34ec:	f1 e0       	ldi	r31, 0x01	; 1
    34ee:	df 16       	cp	r13, r31
    34f0:	09 f4       	brne	.+2      	; 0x34f4 <st7735_drawChar+0x13a>
    34f2:	56 c0       	rjmp	.+172    	; 0x35a0 <st7735_drawChar+0x1e6>
                    st7735_draw_pixel(x+i, y+j, bg);
                else {  // big size
                    st7735_fill_rect(x+i*size, y+j*size, size, size, bg);
    34f4:	8c 81       	ldd	r24, Y+4	; 0x04
    34f6:	6f 2d       	mov	r22, r15
    34f8:	4d 2d       	mov	r20, r13
    34fa:	2d 2d       	mov	r18, r13
    34fc:	84 01       	movw	r16, r8
    34fe:	0e 94 59 16 	call	0x2cb2	; 0x2cb2 <st7735_fill_rect>
    3502:	e4 cf       	rjmp	.-56     	; 0x34cc <st7735_drawChar+0x112>
                }
            }
            line >>= 1;
    3504:	08 94       	sec
    3506:	61 1c       	adc	r6, r1
    3508:	71 1c       	adc	r7, r1
    350a:	39 81       	ldd	r19, Y+1	; 0x01
    350c:	3c 0d       	add	r19, r12
    350e:	39 83       	std	Y+1, r19	; 0x01
    3510:	08 94       	sec
    3512:	21 1c       	adc	r2, r1
    3514:	31 1c       	adc	r3, r1
    3516:	8c 81       	ldd	r24, Y+4	; 0x04
    3518:	8c 0d       	add	r24, r12
    351a:	8c 83       	std	Y+4, r24	; 0x04
    351c:	aa 81       	ldd	r26, Y+2	; 0x02
    351e:	bb 81       	ldd	r27, Y+3	; 0x03
    3520:	11 96       	adiw	r26, 0x01	; 1
    3522:	bb 83       	std	Y+3, r27	; 0x03
    3524:	aa 83       	std	Y+2, r26	; 0x02
            (y >= st7735_height)           || // Clip bottom
            ((x + 5 * size - 1) < 0) || // Clip left
            ((y + 8 * size - 1) < 0))   // Clip top
        return;

    for (int8_t i=0; i<6; i++ ) {
    3526:	b6 e0       	ldi	r27, 0x06	; 6
    3528:	6b 16       	cp	r6, r27
    352a:	71 04       	cpc	r7, r1
    352c:	09 f0       	breq	.+2      	; 0x3530 <st7735_drawChar+0x176>
    352e:	ac cf       	rjmp	.-168    	; 0x3488 <st7735_drawChar+0xce>
                }
            }
            line >>= 1;
        }
    }
}
    3530:	2e 96       	adiw	r28, 0x0e	; 14
    3532:	0f b6       	in	r0, 0x3f	; 63
    3534:	f8 94       	cli
    3536:	de bf       	out	0x3e, r29	; 62
    3538:	0f be       	out	0x3f, r0	; 63
    353a:	cd bf       	out	0x3d, r28	; 61
    353c:	cf 91       	pop	r28
    353e:	df 91       	pop	r29
    3540:	1f 91       	pop	r17
    3542:	0f 91       	pop	r16
    3544:	ff 90       	pop	r15
    3546:	ef 90       	pop	r14
    3548:	df 90       	pop	r13
    354a:	cf 90       	pop	r12
    354c:	bf 90       	pop	r11
    354e:	af 90       	pop	r10
    3550:	9f 90       	pop	r9
    3552:	8f 90       	pop	r8
    3554:	7f 90       	pop	r7
    3556:	6f 90       	pop	r6
    3558:	5f 90       	pop	r5
    355a:	4f 90       	pop	r4
    355c:	3f 90       	pop	r3
    355e:	2f 90       	pop	r2
    3560:	08 95       	ret
                    }
                else {  // big size
                    if(rotation % 2 != 0) {
                        st7735_fill_rect(y+(j*size),st7735_width-x-(i*size)-size, size, size, color);
                    } else {
                        st7735_fill_rect(x+(i*size), y+(j*size), size, size, color);
    3562:	8c 81       	ldd	r24, Y+4	; 0x04
    3564:	6f 2d       	mov	r22, r15
    3566:	4d 2d       	mov	r20, r13
    3568:	2d 2d       	mov	r18, r13
    356a:	85 01       	movw	r16, r10
    356c:	0e 94 59 16 	call	0x2cb2	; 0x2cb2 <st7735_fill_rect>
    3570:	ad cf       	rjmp	.-166    	; 0x34cc <st7735_drawChar+0x112>
        else
            line = pgm_read_byte(font+(c*5)+i);	
        for (int8_t j = 0; j<8; j++) {
            if (line & 0x1) {
                if (size == 1) // default size
                    if(rotation % 2 != 0) {
    3572:	80 91 87 09 	lds	r24, 0x0987
    3576:	80 ff       	sbrs	r24, 0
    3578:	1a c0       	rjmp	.+52     	; 0x35ae <st7735_drawChar+0x1f4>
                        st7735_draw_pixel(y+j,st7735_width-x-i-size, color);
    357a:	60 91 17 07 	lds	r22, 0x0717
    357e:	70 e0       	ldi	r23, 0x00	; 0
    3580:	8f 81       	ldd	r24, Y+7	; 0x07
    3582:	98 85       	ldd	r25, Y+8	; 0x08
    3584:	68 1b       	sub	r22, r24
    3586:	79 0b       	sbc	r23, r25
    3588:	66 19       	sub	r22, r6
    358a:	77 09       	sbc	r23, r7
    358c:	ad 81       	ldd	r26, Y+5	; 0x05
    358e:	be 81       	ldd	r27, Y+6	; 0x06
    3590:	6a 1b       	sub	r22, r26
    3592:	7b 0b       	sbc	r23, r27
    3594:	8d 85       	ldd	r24, Y+13	; 0x0d
    3596:	9e 85       	ldd	r25, Y+14	; 0x0e
    3598:	a5 01       	movw	r20, r10
    359a:	0e 94 2d 16 	call	0x2c5a	; 0x2c5a <st7735_draw_pixel>
    359e:	96 cf       	rjmp	.-212    	; 0x34cc <st7735_drawChar+0x112>
                        st7735_fill_rect(x+(i*size), y+(j*size), size, size, color);
                    }
                }
            } else if (bg != color) {
                if (size == 1) // default size
                    st7735_draw_pixel(x+i, y+j, bg);
    35a0:	c1 01       	movw	r24, r2
    35a2:	6d 85       	ldd	r22, Y+13	; 0x0d
    35a4:	7e 85       	ldd	r23, Y+14	; 0x0e
    35a6:	a4 01       	movw	r20, r8
    35a8:	0e 94 2d 16 	call	0x2c5a	; 0x2c5a <st7735_draw_pixel>
    35ac:	8f cf       	rjmp	.-226    	; 0x34cc <st7735_drawChar+0x112>
            if (line & 0x1) {
                if (size == 1) // default size
                    if(rotation % 2 != 0) {
                        st7735_draw_pixel(y+j,st7735_width-x-i-size, color);
                    } else {
                        st7735_draw_pixel(x+i, y+j, color);
    35ae:	c1 01       	movw	r24, r2
    35b0:	6d 85       	ldd	r22, Y+13	; 0x0d
    35b2:	7e 85       	ldd	r23, Y+14	; 0x0e
    35b4:	a5 01       	movw	r20, r10
    35b6:	0e 94 2d 16 	call	0x2c5a	; 0x2c5a <st7735_draw_pixel>
    35ba:	88 cf       	rjmp	.-240    	; 0x34cc <st7735_drawChar+0x112>
            ((y + 8 * size - 1) < 0))   // Clip top
        return;

    for (int8_t i=0; i<6; i++ ) {
        uint8_t line;
        if (i == 5)
    35bc:	ee 24       	eor	r14, r14
    35be:	6b cf       	rjmp	.-298    	; 0x3496 <st7735_drawChar+0xdc>

000035c0 <st7735_write>:
        }
    }
}


void st7735_write(char c) { //use char c to avoid "initialization from incompatible pointer type"
    35c0:	ef 92       	push	r14
    35c2:	0f 93       	push	r16
    35c4:	1f 93       	push	r17
    35c6:	48 2f       	mov	r20, r24
    if (c == '\n') {
    35c8:	8a 30       	cpi	r24, 0x0A	; 10
    35ca:	09 f4       	brne	.+2      	; 0x35ce <st7735_write+0xe>
    35cc:	50 c0       	rjmp	.+160    	; 0x366e <st7735_write+0xae>
        cursor_y += textsize*8;
        cursor_x = 0;
    } else if (c == '\r') {
    35ce:	8d 30       	cpi	r24, 0x0D	; 13
    35d0:	09 f4       	brne	.+2      	; 0x35d4 <st7735_write+0x14>
    35d2:	49 c0       	rjmp	.+146    	; 0x3666 <st7735_write+0xa6>
        // skip em
    } else {
        st7735_drawChar(cursor_x, cursor_y, c, textcolor, textbgcolor, textsize);
    35d4:	60 91 83 09 	lds	r22, 0x0983
    35d8:	70 91 84 09 	lds	r23, 0x0984
    35dc:	20 91 90 09 	lds	r18, 0x0990
    35e0:	30 91 91 09 	lds	r19, 0x0991
    35e4:	00 91 8e 09 	lds	r16, 0x098E
    35e8:	10 91 8f 09 	lds	r17, 0x098F
    35ec:	80 91 8a 09 	lds	r24, 0x098A
    35f0:	90 91 8b 09 	lds	r25, 0x098B
    35f4:	e0 90 8d 09 	lds	r14, 0x098D
    35f8:	0e 94 dd 19 	call	0x33ba	; 0x33ba <st7735_drawChar>
        cursor_x += textsize*6;
    35fc:	80 91 8d 09 	lds	r24, 0x098D
    3600:	68 2f       	mov	r22, r24
    3602:	70 e0       	ldi	r23, 0x00	; 0
    3604:	9b 01       	movw	r18, r22
    3606:	22 0f       	add	r18, r18
    3608:	33 1f       	adc	r19, r19
    360a:	26 0f       	add	r18, r22
    360c:	37 1f       	adc	r19, r23
    360e:	22 0f       	add	r18, r18
    3610:	33 1f       	adc	r19, r19
    3612:	40 91 8a 09 	lds	r20, 0x098A
    3616:	50 91 8b 09 	lds	r21, 0x098B
    361a:	42 0f       	add	r20, r18
    361c:	53 1f       	adc	r21, r19
    361e:	50 93 8b 09 	sts	0x098B, r21
    3622:	40 93 8a 09 	sts	0x098A, r20
        if (wrap && (cursor_x > (st7735_width - textsize*6))) {
    3626:	80 91 8c 09 	lds	r24, 0x098C
    362a:	88 23       	and	r24, r24
    362c:	e1 f0       	breq	.+56     	; 0x3666 <st7735_write+0xa6>
    362e:	80 91 17 07 	lds	r24, 0x0717
    3632:	90 e0       	ldi	r25, 0x00	; 0
    3634:	82 1b       	sub	r24, r18
    3636:	93 0b       	sbc	r25, r19
    3638:	84 17       	cp	r24, r20
    363a:	95 07       	cpc	r25, r21
    363c:	a4 f4       	brge	.+40     	; 0x3666 <st7735_write+0xa6>
            cursor_y += textsize*8;
    363e:	66 0f       	add	r22, r22
    3640:	77 1f       	adc	r23, r23
    3642:	66 0f       	add	r22, r22
    3644:	77 1f       	adc	r23, r23
    3646:	66 0f       	add	r22, r22
    3648:	77 1f       	adc	r23, r23
    364a:	80 91 83 09 	lds	r24, 0x0983
    364e:	90 91 84 09 	lds	r25, 0x0984
    3652:	86 0f       	add	r24, r22
    3654:	97 1f       	adc	r25, r23
    3656:	90 93 84 09 	sts	0x0984, r25
    365a:	80 93 83 09 	sts	0x0983, r24
            cursor_x = 0;
    365e:	10 92 8b 09 	sts	0x098B, r1
    3662:	10 92 8a 09 	sts	0x098A, r1
        }
    }
}
    3666:	1f 91       	pop	r17
    3668:	0f 91       	pop	r16
    366a:	ef 90       	pop	r14
    366c:	08 95       	ret
}


void st7735_write(char c) { //use char c to avoid "initialization from incompatible pointer type"
    if (c == '\n') {
        cursor_y += textsize*8;
    366e:	20 91 8d 09 	lds	r18, 0x098D
    3672:	30 e0       	ldi	r19, 0x00	; 0
    3674:	22 0f       	add	r18, r18
    3676:	33 1f       	adc	r19, r19
    3678:	22 0f       	add	r18, r18
    367a:	33 1f       	adc	r19, r19
    367c:	22 0f       	add	r18, r18
    367e:	33 1f       	adc	r19, r19
    3680:	80 91 83 09 	lds	r24, 0x0983
    3684:	90 91 84 09 	lds	r25, 0x0984
    3688:	82 0f       	add	r24, r18
    368a:	93 1f       	adc	r25, r19
    368c:	90 93 84 09 	sts	0x0984, r25
    3690:	80 93 83 09 	sts	0x0983, r24
        cursor_x = 0;
    3694:	10 92 8b 09 	sts	0x098B, r1
    3698:	10 92 8a 09 	sts	0x098A, r1
        if (wrap && (cursor_x > (st7735_width - textsize*6))) {
            cursor_y += textsize*8;
            cursor_x = 0;
        }
    }
}
    369c:	1f 91       	pop	r17
    369e:	0f 91       	pop	r16
    36a0:	ef 90       	pop	r14
    36a2:	08 95       	ret

000036a4 <st7735_printf>:
    wrap = w;
}

// this function is called by printf as a stream handler
int st7735_printf(char var, FILE *stream) {
	st7735_write(var);
    36a4:	0e 94 e0 1a 	call	0x35c0	; 0x35c0 <st7735_write>
	return 0;
    36a8:	80 e0       	ldi	r24, 0x00	; 0
    36aa:	90 e0       	ldi	r25, 0x00	; 0
    36ac:	08 95       	ret

000036ae <st7735_print>:
        }
    }
}


void st7735_print(const char str[]) {
    36ae:	cf 93       	push	r28
    36b0:	df 93       	push	r29
    36b2:	fc 01       	movw	r30, r24
    int x=0;
    while(str[x]) {
    36b4:	80 81       	ld	r24, Z
    36b6:	88 23       	and	r24, r24
    36b8:	39 f0       	breq	.+14     	; 0x36c8 <st7735_print+0x1a>
    36ba:	ef 01       	movw	r28, r30
        st7735_write(str[x]);
    36bc:	0e 94 e0 1a 	call	0x35c0	; 0x35c0 <st7735_write>
}


void st7735_print(const char str[]) {
    int x=0;
    while(str[x]) {
    36c0:	89 81       	ldd	r24, Y+1	; 0x01
    36c2:	21 96       	adiw	r28, 0x01	; 1
    36c4:	88 23       	and	r24, r24
    36c6:	d1 f7       	brne	.-12     	; 0x36bc <st7735_print+0xe>
        st7735_write(str[x]);
        x++;
    }
}
    36c8:	df 91       	pop	r29
    36ca:	cf 91       	pop	r28
    36cc:	08 95       	ret

000036ce <xputc>:

void xputc (char c)
{
	if (_CR_CRLF && c == '\n') xputc('\r');		/* CR -> CRLF */

	if (outptr) {
    36ce:	e0 91 19 07 	lds	r30, 0x0719
    36d2:	f0 91 1a 07 	lds	r31, 0x071A
    36d6:	30 97       	sbiw	r30, 0x00	; 0
    36d8:	31 f0       	breq	.+12     	; 0x36e6 <xputc+0x18>
		*outptr++ = (unsigned char)c;
    36da:	81 93       	st	Z+, r24
    36dc:	f0 93 1a 07 	sts	0x071A, r31
    36e0:	e0 93 19 07 	sts	0x0719, r30
    36e4:	08 95       	ret
		return;
	}

	if (xfunc_out) xfunc_out((unsigned char)c);
    36e6:	e0 91 92 09 	lds	r30, 0x0992
    36ea:	f0 91 93 09 	lds	r31, 0x0993
    36ee:	30 97       	sbiw	r30, 0x00	; 0
    36f0:	09 f0       	breq	.+2      	; 0x36f4 <xputc+0x26>
    36f2:	09 95       	icall
    36f4:	08 95       	ret

000036f6 <xputs>:
/*----------------------------------------------*/

void xputs (					/* Put a string to the default device */
	const char* str				/* Pointer to the string */
)
{
    36f6:	cf 93       	push	r28
    36f8:	df 93       	push	r29
    36fa:	ec 01       	movw	r28, r24
	while (*str)
    36fc:	88 81       	ld	r24, Y
    36fe:	88 23       	and	r24, r24
    3700:	31 f0       	breq	.+12     	; 0x370e <xputs+0x18>
		xputc(*str++);
    3702:	21 96       	adiw	r28, 0x01	; 1
    3704:	0e 94 67 1b 	call	0x36ce	; 0x36ce <xputc>

void xputs (					/* Put a string to the default device */
	const char* str				/* Pointer to the string */
)
{
	while (*str)
    3708:	88 81       	ld	r24, Y
    370a:	88 23       	and	r24, r24
    370c:	d1 f7       	brne	.-12     	; 0x3702 <xputs+0xc>
		xputc(*str++);
}
    370e:	df 91       	pop	r29
    3710:	cf 91       	pop	r28
    3712:	08 95       	ret

00003714 <xfputs>:

void xfputs (					/* Put a string to the specified device */
	void(*func)(unsigned char),	/* Pointer to the output function */
	const char*	str				/* Pointer to the string */
)
{
    3714:	0f 93       	push	r16
    3716:	1f 93       	push	r17
    3718:	cf 93       	push	r28
    371a:	df 93       	push	r29
    371c:	eb 01       	movw	r28, r22
	void (*pf)(unsigned char);


	pf = xfunc_out;		/* Save current output device */
    371e:	00 91 92 09 	lds	r16, 0x0992
    3722:	10 91 93 09 	lds	r17, 0x0993
	xfunc_out = func;	/* Switch output to specified device */
    3726:	90 93 93 09 	sts	0x0993, r25
    372a:	80 93 92 09 	sts	0x0992, r24
	while (*str)		/* Put the string */
    372e:	88 81       	ld	r24, Y
    3730:	88 23       	and	r24, r24
    3732:	31 f0       	breq	.+12     	; 0x3740 <xfputs+0x2c>
		xputc(*str++);
    3734:	21 96       	adiw	r28, 0x01	; 1
    3736:	0e 94 67 1b 	call	0x36ce	; 0x36ce <xputc>
	void (*pf)(unsigned char);


	pf = xfunc_out;		/* Save current output device */
	xfunc_out = func;	/* Switch output to specified device */
	while (*str)		/* Put the string */
    373a:	88 81       	ld	r24, Y
    373c:	88 23       	and	r24, r24
    373e:	d1 f7       	brne	.-12     	; 0x3734 <xfputs+0x20>
		xputc(*str++);
	xfunc_out = pf;		/* Restore output device */
    3740:	10 93 93 09 	sts	0x0993, r17
    3744:	00 93 92 09 	sts	0x0992, r16
}
    3748:	df 91       	pop	r29
    374a:	cf 91       	pop	r28
    374c:	1f 91       	pop	r17
    374e:	0f 91       	pop	r16
    3750:	08 95       	ret

00003752 <xvprintf>:
static
void xvprintf (
	const char*	fmt,	/* Pointer to the format string */
	va_list arp			/* Pointer to arguments */
)
{
    3752:	2f 92       	push	r2
    3754:	3f 92       	push	r3
    3756:	4f 92       	push	r4
    3758:	5f 92       	push	r5
    375a:	6f 92       	push	r6
    375c:	7f 92       	push	r7
    375e:	8f 92       	push	r8
    3760:	9f 92       	push	r9
    3762:	af 92       	push	r10
    3764:	bf 92       	push	r11
    3766:	cf 92       	push	r12
    3768:	df 92       	push	r13
    376a:	ef 92       	push	r14
    376c:	ff 92       	push	r15
    376e:	0f 93       	push	r16
    3770:	1f 93       	push	r17
    3772:	df 93       	push	r29
    3774:	cf 93       	push	r28
    3776:	cd b7       	in	r28, 0x3d	; 61
    3778:	de b7       	in	r29, 0x3e	; 62
    377a:	64 97       	sbiw	r28, 0x14	; 20
    377c:	0f b6       	in	r0, 0x3f	; 63
    377e:	f8 94       	cli
    3780:	de bf       	out	0x3e, r29	; 62
    3782:	0f be       	out	0x3f, r0	; 63
    3784:	cd bf       	out	0x3d, r28	; 61
    3786:	1c 01       	movw	r2, r24
    3788:	8b 01       	movw	r16, r22
	unsigned long v;
	char s[16], c, d, *p;


	for (;;) {
		c = *fmt++;					/* Get a char */
    378a:	d1 01       	movw	r26, r2
    378c:	8c 91       	ld	r24, X
		if (!c) break;				/* End of format? */
    378e:	88 23       	and	r24, r24
    3790:	09 f4       	brne	.+2      	; 0x3794 <xvprintf+0x42>
    3792:	56 c0       	rjmp	.+172    	; 0x3840 <xvprintf+0xee>
	unsigned long v;
	char s[16], c, d, *p;


	for (;;) {
		c = *fmt++;					/* Get a char */
    3794:	08 94       	sec
    3796:	21 1c       	adc	r2, r1
    3798:	31 1c       	adc	r3, r1
		if (!c) break;				/* End of format? */
		if (c != '%') {				/* Pass through it if not a % sequense */
    379a:	85 32       	cpi	r24, 0x25	; 37
    379c:	09 f0       	breq	.+2      	; 0x37a0 <xvprintf+0x4e>
    379e:	45 c0       	rjmp	.+138    	; 0x382a <xvprintf+0xd8>
			xputc(c); continue;
		}
		f = 0;
		c = *fmt++;					/* Get first char of the sequense */
    37a0:	f1 01       	movw	r30, r2
    37a2:	21 91       	ld	r18, Z+
		if (c == '0') {				/* Flag: '0' padded */
    37a4:	20 33       	cpi	r18, 0x30	; 48
    37a6:	09 f4       	brne	.+2      	; 0x37aa <xvprintf+0x58>
    37a8:	67 c1       	rjmp	.+718    	; 0x3a78 <xvprintf+0x326>
			f = 1; c = *fmt++;
		} else {
			if (c == '-') {			/* Flag: left justified */
    37aa:	2d 32       	cpi	r18, 0x2D	; 45
    37ac:	09 f4       	brne	.+2      	; 0x37b0 <xvprintf+0x5e>
    37ae:	7d c1       	rjmp	.+762    	; 0x3aaa <xvprintf+0x358>
    37b0:	1c 8a       	std	Y+20, r1	; 0x14
    37b2:	1b 8a       	std	Y+19, r1	; 0x13
				f = 2; c = *fmt++;
			}
		}
		for (w = 0; c >= '0' && c <= '9'; c = *fmt++)	/* Minimum width */
    37b4:	82 2f       	mov	r24, r18
    37b6:	80 53       	subi	r24, 0x30	; 48
    37b8:	8a 30       	cpi	r24, 0x0A	; 10
    37ba:	08 f0       	brcs	.+2      	; 0x37be <xvprintf+0x6c>
    37bc:	6a c1       	rjmp	.+724    	; 0x3a92 <xvprintf+0x340>
    37be:	cc 24       	eor	r12, r12
    37c0:	dd 24       	eor	r13, r13
			w = w * 10 + c - '0';
    37c2:	c6 01       	movw	r24, r12
    37c4:	88 0f       	add	r24, r24
    37c6:	99 1f       	adc	r25, r25
    37c8:	88 0f       	add	r24, r24
    37ca:	99 1f       	adc	r25, r25
    37cc:	88 0f       	add	r24, r24
    37ce:	99 1f       	adc	r25, r25
    37d0:	cc 0c       	add	r12, r12
    37d2:	dd 1c       	adc	r13, r13
    37d4:	c8 0e       	add	r12, r24
    37d6:	d9 1e       	adc	r13, r25
    37d8:	c2 0e       	add	r12, r18
    37da:	d1 1c       	adc	r13, r1
    37dc:	20 ed       	ldi	r18, 0xD0	; 208
    37de:	3f ef       	ldi	r19, 0xFF	; 255
    37e0:	c2 0e       	add	r12, r18
    37e2:	d3 1e       	adc	r13, r19
		} else {
			if (c == '-') {			/* Flag: left justified */
				f = 2; c = *fmt++;
			}
		}
		for (w = 0; c >= '0' && c <= '9'; c = *fmt++)	/* Minimum width */
    37e4:	21 91       	ld	r18, Z+
    37e6:	82 2f       	mov	r24, r18
    37e8:	80 53       	subi	r24, 0x30	; 48
    37ea:	8a 30       	cpi	r24, 0x0A	; 10
    37ec:	50 f3       	brcs	.-44     	; 0x37c2 <xvprintf+0x70>
    37ee:	a2 2e       	mov	r10, r18
    37f0:	1f 01       	movw	r2, r30
			w = w * 10 + c - '0';
		if (c == 'l' || c == 'L') {	/* Prefix: Size is long int */
    37f2:	2c 36       	cpi	r18, 0x6C	; 108
    37f4:	09 f4       	brne	.+2      	; 0x37f8 <xvprintf+0xa6>
    37f6:	d3 c0       	rjmp	.+422    	; 0x399e <xvprintf+0x24c>
    37f8:	2c 34       	cpi	r18, 0x4C	; 76
    37fa:	09 f4       	brne	.+2      	; 0x37fe <xvprintf+0xac>
    37fc:	d0 c0       	rjmp	.+416    	; 0x399e <xvprintf+0x24c>
			f |= 4; c = *fmt++;
		}
		if (!c) break;				/* End of format? */
    37fe:	aa 20       	and	r10, r10
    3800:	f9 f0       	breq	.+62     	; 0x3840 <xvprintf+0xee>
		d = c;
		if (d >= 'a') d -= 0x20;
    3802:	b0 e6       	ldi	r27, 0x60	; 96
    3804:	ba 15       	cp	r27, r10
    3806:	08 f4       	brcc	.+2      	; 0x380a <xvprintf+0xb8>
    3808:	d3 c0       	rjmp	.+422    	; 0x39b0 <xvprintf+0x25e>
    380a:	8a 2d       	mov	r24, r10
		switch (d) {				/* Type is... */
    380c:	8f 34       	cpi	r24, 0x4F	; 79
    380e:	09 f4       	brne	.+2      	; 0x3812 <xvprintf+0xc0>
    3810:	d4 c0       	rjmp	.+424    	; 0x39ba <xvprintf+0x268>
    3812:	80 35       	cpi	r24, 0x50	; 80
    3814:	08 f0       	brcs	.+2      	; 0x3818 <xvprintf+0xc6>
    3816:	e7 c0       	rjmp	.+462    	; 0x39e6 <xvprintf+0x294>
    3818:	83 34       	cpi	r24, 0x43	; 67
    381a:	09 f4       	brne	.+2      	; 0x381e <xvprintf+0xcc>
    381c:	74 c1       	rjmp	.+744    	; 0x3b06 <xvprintf+0x3b4>
    381e:	84 34       	cpi	r24, 0x44	; 68
    3820:	09 f4       	brne	.+2      	; 0x3824 <xvprintf+0xd2>
    3822:	6b c1       	rjmp	.+726    	; 0x3afa <xvprintf+0x3a8>
    3824:	82 34       	cpi	r24, 0x42	; 66
    3826:	29 f1       	breq	.+74     	; 0x3872 <xvprintf+0x120>
		case 'U' :					/* Unsigned decimal */
			r = 10; break;
		case 'X' :					/* Hexdecimal */
			r = 16; break;
		default:					/* Unknown type (passthrough) */
			xputc(c); continue;
    3828:	8a 2d       	mov	r24, r10
    382a:	0e 94 67 1b 	call	0x36ce	; 0x36ce <xputc>
    382e:	1a 8b       	std	Y+18, r17	; 0x12
    3830:	09 8b       	std	Y+17, r16	; 0x11
static
void xvprintf (
	const char*	fmt,	/* Pointer to the format string */
	va_list arp			/* Pointer to arguments */
)
{
    3832:	09 89       	ldd	r16, Y+17	; 0x11
    3834:	1a 89       	ldd	r17, Y+18	; 0x12
	unsigned long v;
	char s[16], c, d, *p;


	for (;;) {
		c = *fmt++;					/* Get a char */
    3836:	d1 01       	movw	r26, r2
    3838:	8c 91       	ld	r24, X
		if (!c) break;				/* End of format? */
    383a:	88 23       	and	r24, r24
    383c:	09 f0       	breq	.+2      	; 0x3840 <xvprintf+0xee>
    383e:	aa cf       	rjmp	.-172    	; 0x3794 <xvprintf+0x42>
		j = i; d = (f & 1) ? '0' : ' ';
		while (!(f & 2) && j++ < w) xputc(d);
		do xputc(s[--i]); while(i);
		while (j++ < w) xputc(' ');
	}
}
    3840:	64 96       	adiw	r28, 0x14	; 20
    3842:	0f b6       	in	r0, 0x3f	; 63
    3844:	f8 94       	cli
    3846:	de bf       	out	0x3e, r29	; 62
    3848:	0f be       	out	0x3f, r0	; 63
    384a:	cd bf       	out	0x3d, r28	; 61
    384c:	cf 91       	pop	r28
    384e:	df 91       	pop	r29
    3850:	1f 91       	pop	r17
    3852:	0f 91       	pop	r16
    3854:	ff 90       	pop	r15
    3856:	ef 90       	pop	r14
    3858:	df 90       	pop	r13
    385a:	cf 90       	pop	r12
    385c:	bf 90       	pop	r11
    385e:	af 90       	pop	r10
    3860:	9f 90       	pop	r9
    3862:	8f 90       	pop	r8
    3864:	7f 90       	pop	r7
    3866:	6f 90       	pop	r6
    3868:	5f 90       	pop	r5
    386a:	4f 90       	pop	r4
    386c:	3f 90       	pop	r3
    386e:	2f 90       	pop	r2
    3870:	08 95       	ret
		case 'U' :					/* Unsigned decimal */
			r = 10; break;
		case 'X' :					/* Hexdecimal */
			r = 16; break;
		default:					/* Unknown type (passthrough) */
			xputc(c); continue;
    3872:	22 e0       	ldi	r18, 0x02	; 2
    3874:	42 2e       	mov	r4, r18
    3876:	51 2c       	mov	r5, r1
    3878:	61 2c       	mov	r6, r1
    387a:	71 2c       	mov	r7, r1
		}

		/* Get an argument and put it in numeral */
		v = (f & 4) ? va_arg(arp, long) : ((d == 'D') ? (long)va_arg(arp, int) : (long)va_arg(arp, unsigned int));
    387c:	bb 89       	ldd	r27, Y+19	; 0x13
    387e:	b2 ff       	sbrs	r27, 2
    3880:	a4 c0       	rjmp	.+328    	; 0x39ca <xvprintf+0x278>
    3882:	f8 01       	movw	r30, r16
    3884:	34 96       	adiw	r30, 0x04	; 4
    3886:	fa 8b       	std	Y+18, r31	; 0x12
    3888:	e9 8b       	std	Y+17, r30	; 0x11
    388a:	d8 01       	movw	r26, r16
    388c:	ed 90       	ld	r14, X+
    388e:	fd 90       	ld	r15, X+
    3890:	0d 91       	ld	r16, X+
    3892:	1c 91       	ld	r17, X
		if (d == 'D' && (v & 0x80000000)) {
    3894:	84 34       	cpi	r24, 0x44	; 68
    3896:	09 f4       	brne	.+2      	; 0x389a <xvprintf+0x148>
    3898:	1a c1       	rjmp	.+564    	; 0x3ace <xvprintf+0x37c>
			v = 0 - v;
			f |= 8;
    389a:	88 24       	eor	r8, r8
    389c:	99 24       	eor	r9, r9
		}
		i = 0;
		do {
			d = (char)(v % r); v /= r;
    389e:	c8 01       	movw	r24, r16
    38a0:	b7 01       	movw	r22, r14
    38a2:	a3 01       	movw	r20, r6
    38a4:	92 01       	movw	r18, r4
    38a6:	0e 94 0d 80 	call	0x1001a	; 0x1001a <__udivmodsi4>
    38aa:	b6 2e       	mov	r11, r22
    38ac:	c8 01       	movw	r24, r16
    38ae:	b7 01       	movw	r22, r14
    38b0:	a3 01       	movw	r20, r6
    38b2:	92 01       	movw	r18, r4
    38b4:	0e 94 0d 80 	call	0x1001a	; 0x1001a <__udivmodsi4>
    38b8:	c9 01       	movw	r24, r18
    38ba:	da 01       	movw	r26, r20
    38bc:	7c 01       	movw	r14, r24
    38be:	8d 01       	movw	r16, r26
			if (d > 9) d += (c == 'x') ? 0x27 : 0x07;
    38c0:	f9 e0       	ldi	r31, 0x09	; 9
    38c2:	fb 15       	cp	r31, r11
    38c4:	30 f4       	brcc	.+12     	; 0x38d2 <xvprintf+0x180>
    38c6:	28 e7       	ldi	r18, 0x78	; 120
    38c8:	a2 16       	cp	r10, r18
    38ca:	09 f4       	brne	.+2      	; 0x38ce <xvprintf+0x17c>
    38cc:	66 c0       	rjmp	.+204    	; 0x399a <xvprintf+0x248>
    38ce:	27 e0       	ldi	r18, 0x07	; 7
    38d0:	b2 0e       	add	r11, r18
			s[i++] = d + '0';
    38d2:	e1 e0       	ldi	r30, 0x01	; 1
    38d4:	f0 e0       	ldi	r31, 0x00	; 0
    38d6:	ec 0f       	add	r30, r28
    38d8:	fd 1f       	adc	r31, r29
    38da:	e8 0d       	add	r30, r8
    38dc:	f9 1d       	adc	r31, r9
    38de:	30 e3       	ldi	r19, 0x30	; 48
    38e0:	b3 0e       	add	r11, r19
    38e2:	b0 82       	st	Z, r11
    38e4:	08 94       	sec
    38e6:	81 1c       	adc	r8, r1
    38e8:	91 1c       	adc	r9, r1
		} while (v && i < sizeof(s));
    38ea:	00 97       	sbiw	r24, 0x00	; 0
    38ec:	a1 05       	cpc	r26, r1
    38ee:	b1 05       	cpc	r27, r1
    38f0:	21 f0       	breq	.+8      	; 0x38fa <xvprintf+0x1a8>
    38f2:	80 e1       	ldi	r24, 0x10	; 16
    38f4:	88 16       	cp	r8, r24
    38f6:	91 04       	cpc	r9, r1
    38f8:	91 f6       	brne	.-92     	; 0x389e <xvprintf+0x14c>
		if (f & 8) s[i++] = '-';
    38fa:	9b 89       	ldd	r25, Y+19	; 0x13
    38fc:	93 ff       	sbrs	r25, 3
    38fe:	0b c0       	rjmp	.+22     	; 0x3916 <xvprintf+0x1c4>
    3900:	e1 e0       	ldi	r30, 0x01	; 1
    3902:	f0 e0       	ldi	r31, 0x00	; 0
    3904:	ec 0f       	add	r30, r28
    3906:	fd 1f       	adc	r31, r29
    3908:	e8 0d       	add	r30, r8
    390a:	f9 1d       	adc	r31, r9
    390c:	ad e2       	ldi	r26, 0x2D	; 45
    390e:	a0 83       	st	Z, r26
    3910:	08 94       	sec
    3912:	81 1c       	adc	r8, r1
    3914:	91 1c       	adc	r9, r1
		j = i; d = (f & 1) ? '0' : ' ';
    3916:	bb 89       	ldd	r27, Y+19	; 0x13
    3918:	b0 fd       	sbrc	r27, 0
    391a:	c0 c0       	rjmp	.+384    	; 0x3a9c <xvprintf+0x34a>
    391c:	90 e2       	ldi	r25, 0x20	; 32
    391e:	f9 2e       	mov	r15, r25
		while (!(f & 2) && j++ < w) xputc(d);
    3920:	eb 89       	ldd	r30, Y+19	; 0x13
    3922:	e1 fd       	sbrc	r30, 1
    3924:	c0 c0       	rjmp	.+384    	; 0x3aa6 <xvprintf+0x354>
    3926:	54 01       	movw	r10, r8
    3928:	08 94       	sec
    392a:	a1 1c       	adc	r10, r1
    392c:	b1 1c       	adc	r11, r1
    392e:	8c 14       	cp	r8, r12
    3930:	9d 04       	cpc	r9, r13
    3932:	70 f4       	brcc	.+28     	; 0x3950 <xvprintf+0x1fe>
    3934:	84 01       	movw	r16, r8
    3936:	8f 2d       	mov	r24, r15
    3938:	0e 94 67 1b 	call	0x36ce	; 0x36ce <xputc>
    393c:	0f 5f       	subi	r16, 0xFF	; 255
    393e:	1f 4f       	sbci	r17, 0xFF	; 255
    3940:	0c 15       	cp	r16, r12
    3942:	1d 05       	cpc	r17, r13
    3944:	c0 f3       	brcs	.-16     	; 0x3936 <xvprintf+0x1e4>
    3946:	c6 01       	movw	r24, r12
    3948:	88 19       	sub	r24, r8
    394a:	99 09       	sbc	r25, r9
    394c:	a8 0e       	add	r10, r24
    394e:	b9 1e       	adc	r11, r25
    3950:	74 01       	movw	r14, r8
    3952:	08 94       	sec
    3954:	e1 08       	sbc	r14, r1
    3956:	f1 08       	sbc	r15, r1
    3958:	01 e0       	ldi	r16, 0x01	; 1
    395a:	10 e0       	ldi	r17, 0x00	; 0
    395c:	0c 0f       	add	r16, r28
    395e:	1d 1f       	adc	r17, r29
    3960:	0e 0d       	add	r16, r14
    3962:	1f 1d       	adc	r17, r15
    3964:	03 c0       	rjmp	.+6      	; 0x396c <xvprintf+0x21a>
    3966:	08 94       	sec
    3968:	e1 08       	sbc	r14, r1
    396a:	f1 08       	sbc	r15, r1
		do xputc(s[--i]); while(i);
    396c:	d8 01       	movw	r26, r16
    396e:	8c 91       	ld	r24, X
    3970:	0e 94 67 1b 	call	0x36ce	; 0x36ce <xputc>
    3974:	01 50       	subi	r16, 0x01	; 1
    3976:	10 40       	sbci	r17, 0x00	; 0
    3978:	e1 14       	cp	r14, r1
    397a:	f1 04       	cpc	r15, r1
    397c:	a1 f7       	brne	.-24     	; 0x3966 <xvprintf+0x214>
		while (j++ < w) xputc(' ');
    397e:	ac 14       	cp	r10, r12
    3980:	bd 04       	cpc	r11, r13
    3982:	08 f0       	brcs	.+2      	; 0x3986 <xvprintf+0x234>
    3984:	56 cf       	rjmp	.-340    	; 0x3832 <xvprintf+0xe0>
    3986:	80 e2       	ldi	r24, 0x20	; 32
    3988:	0e 94 67 1b 	call	0x36ce	; 0x36ce <xputc>
    398c:	08 94       	sec
    398e:	a1 1c       	adc	r10, r1
    3990:	b1 1c       	adc	r11, r1
    3992:	ac 14       	cp	r10, r12
    3994:	bd 04       	cpc	r11, r13
    3996:	b8 f3       	brcs	.-18     	; 0x3986 <xvprintf+0x234>
    3998:	4c cf       	rjmp	.-360    	; 0x3832 <xvprintf+0xe0>
			f |= 8;
		}
		i = 0;
		do {
			d = (char)(v % r); v /= r;
			if (d > 9) d += (c == 'x') ? 0x27 : 0x07;
    399a:	27 e2       	ldi	r18, 0x27	; 39
    399c:	99 cf       	rjmp	.-206    	; 0x38d0 <xvprintf+0x17e>
			}
		}
		for (w = 0; c >= '0' && c <= '9'; c = *fmt++)	/* Minimum width */
			w = w * 10 + c - '0';
		if (c == 'l' || c == 'L') {	/* Prefix: Size is long int */
			f |= 4; c = *fmt++;
    399e:	8b 89       	ldd	r24, Y+19	; 0x13
    39a0:	9c 89       	ldd	r25, Y+20	; 0x14
    39a2:	84 60       	ori	r24, 0x04	; 4
    39a4:	9c 8b       	std	Y+20, r25	; 0x14
    39a6:	8b 8b       	std	Y+19, r24	; 0x13
    39a8:	df 01       	movw	r26, r30
    39aa:	ad 90       	ld	r10, X+
    39ac:	1d 01       	movw	r2, r26
    39ae:	27 cf       	rjmp	.-434    	; 0x37fe <xvprintf+0xac>
		}
		if (!c) break;				/* End of format? */
		d = c;
		if (d >= 'a') d -= 0x20;
    39b0:	8a 2d       	mov	r24, r10
    39b2:	80 52       	subi	r24, 0x20	; 32
		switch (d) {				/* Type is... */
    39b4:	8f 34       	cpi	r24, 0x4F	; 79
    39b6:	09 f0       	breq	.+2      	; 0x39ba <xvprintf+0x268>
    39b8:	2c cf       	rjmp	.-424    	; 0x3812 <xvprintf+0xc0>
    39ba:	58 e0       	ldi	r21, 0x08	; 8
    39bc:	45 2e       	mov	r4, r21
    39be:	51 2c       	mov	r5, r1
    39c0:	61 2c       	mov	r6, r1
    39c2:	71 2c       	mov	r7, r1
		default:					/* Unknown type (passthrough) */
			xputc(c); continue;
		}

		/* Get an argument and put it in numeral */
		v = (f & 4) ? va_arg(arp, long) : ((d == 'D') ? (long)va_arg(arp, int) : (long)va_arg(arp, unsigned int));
    39c4:	bb 89       	ldd	r27, Y+19	; 0x13
    39c6:	b2 fd       	sbrc	r27, 2
    39c8:	5c cf       	rjmp	.-328    	; 0x3882 <xvprintf+0x130>
    39ca:	84 34       	cpi	r24, 0x44	; 68
    39cc:	09 f4       	brne	.+2      	; 0x39d0 <xvprintf+0x27e>
    39ce:	73 c0       	rjmp	.+230    	; 0x3ab6 <xvprintf+0x364>
    39d0:	f8 01       	movw	r30, r16
    39d2:	32 96       	adiw	r30, 0x02	; 2
    39d4:	fa 8b       	std	Y+18, r31	; 0x12
    39d6:	e9 8b       	std	Y+17, r30	; 0x11
    39d8:	d8 01       	movw	r26, r16
    39da:	8d 91       	ld	r24, X+
    39dc:	9c 91       	ld	r25, X
    39de:	7c 01       	movw	r14, r24
    39e0:	00 e0       	ldi	r16, 0x00	; 0
    39e2:	10 e0       	ldi	r17, 0x00	; 0
    39e4:	5a cf       	rjmp	.-332    	; 0x389a <xvprintf+0x148>
			f |= 4; c = *fmt++;
		}
		if (!c) break;				/* End of format? */
		d = c;
		if (d >= 'a') d -= 0x20;
		switch (d) {				/* Type is... */
    39e6:	85 35       	cpi	r24, 0x55	; 85
    39e8:	09 f4       	brne	.+2      	; 0x39ec <xvprintf+0x29a>
    39ea:	87 c0       	rjmp	.+270    	; 0x3afa <xvprintf+0x3a8>
    39ec:	88 35       	cpi	r24, 0x58	; 88
    39ee:	09 f4       	brne	.+2      	; 0x39f2 <xvprintf+0x2a0>
    39f0:	7e c0       	rjmp	.+252    	; 0x3aee <xvprintf+0x39c>
    39f2:	83 35       	cpi	r24, 0x53	; 83
    39f4:	09 f0       	breq	.+2      	; 0x39f8 <xvprintf+0x2a6>
    39f6:	18 cf       	rjmp	.-464    	; 0x3828 <xvprintf+0xd6>
		case 'S' :					/* String */
			p = va_arg(arp, char*);
    39f8:	f8 01       	movw	r30, r16
    39fa:	32 96       	adiw	r30, 0x02	; 2
    39fc:	fa 8b       	std	Y+18, r31	; 0x12
    39fe:	e9 8b       	std	Y+17, r30	; 0x11
    3a00:	d8 01       	movw	r26, r16
    3a02:	ad 90       	ld	r10, X+
    3a04:	bc 90       	ld	r11, X
			for (j = 0; p[j]; j++) ;
    3a06:	f5 01       	movw	r30, r10
    3a08:	80 81       	ld	r24, Z
    3a0a:	88 23       	and	r24, r24
    3a0c:	09 f4       	brne	.+2      	; 0x3a10 <xvprintf+0x2be>
    3a0e:	85 c0       	rjmp	.+266    	; 0x3b1a <xvprintf+0x3c8>
    3a10:	20 e0       	ldi	r18, 0x00	; 0
    3a12:	30 e0       	ldi	r19, 0x00	; 0
    3a14:	2f 5f       	subi	r18, 0xFF	; 255
    3a16:	3f 4f       	sbci	r19, 0xFF	; 255
    3a18:	f5 01       	movw	r30, r10
    3a1a:	e2 0f       	add	r30, r18
    3a1c:	f3 1f       	adc	r31, r19
    3a1e:	80 81       	ld	r24, Z
    3a20:	88 23       	and	r24, r24
    3a22:	c1 f7       	brne	.-16     	; 0x3a14 <xvprintf+0x2c2>
    3a24:	89 01       	movw	r16, r18
    3a26:	0f 5f       	subi	r16, 0xFF	; 255
    3a28:	1f 4f       	sbci	r17, 0xFF	; 255
			while (!(f & 2) && j++ < w) xputc(' ');
    3a2a:	fb 89       	ldd	r31, Y+19	; 0x13
    3a2c:	f1 fd       	sbrc	r31, 1
    3a2e:	7a c0       	rjmp	.+244    	; 0x3b24 <xvprintf+0x3d2>
    3a30:	2c 15       	cp	r18, r12
    3a32:	3d 05       	cpc	r19, r13
    3a34:	50 f4       	brcc	.+20     	; 0x3a4a <xvprintf+0x2f8>
    3a36:	80 e2       	ldi	r24, 0x20	; 32
    3a38:	0e 94 67 1b 	call	0x36ce	; 0x36ce <xputc>
    3a3c:	0f 5f       	subi	r16, 0xFF	; 255
    3a3e:	1f 4f       	sbci	r17, 0xFF	; 255
    3a40:	c8 01       	movw	r24, r16
    3a42:	01 97       	sbiw	r24, 0x01	; 1
    3a44:	8c 15       	cp	r24, r12
    3a46:	9d 05       	cpc	r25, r13
    3a48:	b0 f3       	brcs	.-20     	; 0x3a36 <xvprintf+0x2e4>
    3a4a:	78 01       	movw	r14, r16
    3a4c:	08 94       	sec
    3a4e:	e1 1c       	adc	r14, r1
    3a50:	f1 1c       	adc	r15, r1
			xputs(p);
    3a52:	c5 01       	movw	r24, r10
    3a54:	0e 94 7b 1b 	call	0x36f6	; 0x36f6 <xputs>
			while (j++ < w) xputc(' ');
    3a58:	0c 15       	cp	r16, r12
    3a5a:	1d 05       	cpc	r17, r13
    3a5c:	08 f0       	brcs	.+2      	; 0x3a60 <xvprintf+0x30e>
    3a5e:	e9 ce       	rjmp	.-558    	; 0x3832 <xvprintf+0xe0>
    3a60:	80 e2       	ldi	r24, 0x20	; 32
    3a62:	0e 94 67 1b 	call	0x36ce	; 0x36ce <xputc>
    3a66:	08 94       	sec
    3a68:	e1 1c       	adc	r14, r1
    3a6a:	f1 1c       	adc	r15, r1
    3a6c:	c7 01       	movw	r24, r14
    3a6e:	01 97       	sbiw	r24, 0x01	; 1
    3a70:	8c 15       	cp	r24, r12
    3a72:	9d 05       	cpc	r25, r13
    3a74:	a8 f3       	brcs	.-22     	; 0x3a60 <xvprintf+0x30e>
    3a76:	dd ce       	rjmp	.-582    	; 0x3832 <xvprintf+0xe0>
			xputc(c); continue;
		}
		f = 0;
		c = *fmt++;					/* Get first char of the sequense */
		if (c == '0') {				/* Flag: '0' padded */
			f = 1; c = *fmt++;
    3a78:	d1 01       	movw	r26, r2
    3a7a:	11 96       	adiw	r26, 0x01	; 1
    3a7c:	2c 91       	ld	r18, X
    3a7e:	31 96       	adiw	r30, 0x01	; 1
    3a80:	81 e0       	ldi	r24, 0x01	; 1
    3a82:	90 e0       	ldi	r25, 0x00	; 0
    3a84:	9c 8b       	std	Y+20, r25	; 0x14
    3a86:	8b 8b       	std	Y+19, r24	; 0x13
		} else {
			if (c == '-') {			/* Flag: left justified */
				f = 2; c = *fmt++;
			}
		}
		for (w = 0; c >= '0' && c <= '9'; c = *fmt++)	/* Minimum width */
    3a88:	82 2f       	mov	r24, r18
    3a8a:	80 53       	subi	r24, 0x30	; 48
    3a8c:	8a 30       	cpi	r24, 0x0A	; 10
    3a8e:	08 f4       	brcc	.+2      	; 0x3a92 <xvprintf+0x340>
    3a90:	96 ce       	rjmp	.-724    	; 0x37be <xvprintf+0x6c>
    3a92:	a2 2e       	mov	r10, r18
    3a94:	1f 01       	movw	r2, r30
    3a96:	cc 24       	eor	r12, r12
    3a98:	dd 24       	eor	r13, r13
    3a9a:	ab ce       	rjmp	.-682    	; 0x37f2 <xvprintf+0xa0>
			d = (char)(v % r); v /= r;
			if (d > 9) d += (c == 'x') ? 0x27 : 0x07;
			s[i++] = d + '0';
		} while (v && i < sizeof(s));
		if (f & 8) s[i++] = '-';
		j = i; d = (f & 1) ? '0' : ' ';
    3a9c:	80 e3       	ldi	r24, 0x30	; 48
    3a9e:	f8 2e       	mov	r15, r24
		while (!(f & 2) && j++ < w) xputc(d);
    3aa0:	eb 89       	ldd	r30, Y+19	; 0x13
    3aa2:	e1 ff       	sbrs	r30, 1
    3aa4:	40 cf       	rjmp	.-384    	; 0x3926 <xvprintf+0x1d4>
    3aa6:	54 01       	movw	r10, r8
    3aa8:	53 cf       	rjmp	.-346    	; 0x3950 <xvprintf+0x1fe>
		c = *fmt++;					/* Get first char of the sequense */
		if (c == '0') {				/* Flag: '0' padded */
			f = 1; c = *fmt++;
		} else {
			if (c == '-') {			/* Flag: left justified */
				f = 2; c = *fmt++;
    3aaa:	21 91       	ld	r18, Z+
    3aac:	a2 e0       	ldi	r26, 0x02	; 2
    3aae:	b0 e0       	ldi	r27, 0x00	; 0
    3ab0:	bc 8b       	std	Y+20, r27	; 0x14
    3ab2:	ab 8b       	std	Y+19, r26	; 0x13
    3ab4:	7f ce       	rjmp	.-770    	; 0x37b4 <xvprintf+0x62>
		default:					/* Unknown type (passthrough) */
			xputc(c); continue;
		}

		/* Get an argument and put it in numeral */
		v = (f & 4) ? va_arg(arp, long) : ((d == 'D') ? (long)va_arg(arp, int) : (long)va_arg(arp, unsigned int));
    3ab6:	f8 01       	movw	r30, r16
    3ab8:	32 96       	adiw	r30, 0x02	; 2
    3aba:	fa 8b       	std	Y+18, r31	; 0x12
    3abc:	e9 8b       	std	Y+17, r30	; 0x11
    3abe:	d8 01       	movw	r26, r16
    3ac0:	8d 91       	ld	r24, X+
    3ac2:	9c 91       	ld	r25, X
    3ac4:	7c 01       	movw	r14, r24
    3ac6:	00 27       	eor	r16, r16
    3ac8:	f7 fc       	sbrc	r15, 7
    3aca:	00 95       	com	r16
    3acc:	10 2f       	mov	r17, r16
		if (d == 'D' && (v & 0x80000000)) {
    3ace:	17 ff       	sbrs	r17, 7
    3ad0:	e4 ce       	rjmp	.-568    	; 0x389a <xvprintf+0x148>
			v = 0 - v;
    3ad2:	10 95       	com	r17
    3ad4:	00 95       	com	r16
    3ad6:	f0 94       	com	r15
    3ad8:	e0 94       	com	r14
    3ada:	e1 1c       	adc	r14, r1
    3adc:	f1 1c       	adc	r15, r1
    3ade:	01 1d       	adc	r16, r1
    3ae0:	11 1d       	adc	r17, r1
			f |= 8;
    3ae2:	eb 89       	ldd	r30, Y+19	; 0x13
    3ae4:	fc 89       	ldd	r31, Y+20	; 0x14
    3ae6:	e8 60       	ori	r30, 0x08	; 8
    3ae8:	fc 8b       	std	Y+20, r31	; 0x14
    3aea:	eb 8b       	std	Y+19, r30	; 0x13
    3aec:	d6 ce       	rjmp	.-596    	; 0x389a <xvprintf+0x148>
			while (!(f & 2) && j++ < w) xputc(' ');
			xputs(p);
			while (j++ < w) xputc(' ');
			continue;
		case 'C' :					/* Character */
			xputc((char)va_arg(arp, int)); continue;
    3aee:	30 e1       	ldi	r19, 0x10	; 16
    3af0:	43 2e       	mov	r4, r19
    3af2:	51 2c       	mov	r5, r1
    3af4:	61 2c       	mov	r6, r1
    3af6:	71 2c       	mov	r7, r1
    3af8:	c1 ce       	rjmp	.-638    	; 0x387c <xvprintf+0x12a>
			f |= 4; c = *fmt++;
		}
		if (!c) break;				/* End of format? */
		d = c;
		if (d >= 'a') d -= 0x20;
		switch (d) {				/* Type is... */
    3afa:	4a e0       	ldi	r20, 0x0A	; 10
    3afc:	44 2e       	mov	r4, r20
    3afe:	51 2c       	mov	r5, r1
    3b00:	61 2c       	mov	r6, r1
    3b02:	71 2c       	mov	r7, r1
    3b04:	bb ce       	rjmp	.-650    	; 0x387c <xvprintf+0x12a>
			while (!(f & 2) && j++ < w) xputc(' ');
			xputs(p);
			while (j++ < w) xputc(' ');
			continue;
		case 'C' :					/* Character */
			xputc((char)va_arg(arp, int)); continue;
    3b06:	98 01       	movw	r18, r16
    3b08:	2e 5f       	subi	r18, 0xFE	; 254
    3b0a:	3f 4f       	sbci	r19, 0xFF	; 255
    3b0c:	3a 8b       	std	Y+18, r19	; 0x12
    3b0e:	29 8b       	std	Y+17, r18	; 0x11
    3b10:	d8 01       	movw	r26, r16
    3b12:	8c 91       	ld	r24, X
    3b14:	0e 94 67 1b 	call	0x36ce	; 0x36ce <xputc>
    3b18:	8c ce       	rjmp	.-744    	; 0x3832 <xvprintf+0xe0>
		d = c;
		if (d >= 'a') d -= 0x20;
		switch (d) {				/* Type is... */
		case 'S' :					/* String */
			p = va_arg(arp, char*);
			for (j = 0; p[j]; j++) ;
    3b1a:	20 e0       	ldi	r18, 0x00	; 0
    3b1c:	30 e0       	ldi	r19, 0x00	; 0
    3b1e:	01 e0       	ldi	r16, 0x01	; 1
    3b20:	10 e0       	ldi	r17, 0x00	; 0
    3b22:	83 cf       	rjmp	.-250    	; 0x3a2a <xvprintf+0x2d8>
			while (!(f & 2) && j++ < w) xputc(' ');
    3b24:	78 01       	movw	r14, r16
    3b26:	89 01       	movw	r16, r18
    3b28:	94 cf       	rjmp	.-216    	; 0x3a52 <xvprintf+0x300>

00003b2a <xvprintf_P>:
static
void xvprintf_P (
	const char*	fmt,	/* Pointer to the format string */
	va_list arp			/* Pointer to arguments */
)
{
    3b2a:	2f 92       	push	r2
    3b2c:	3f 92       	push	r3
    3b2e:	4f 92       	push	r4
    3b30:	5f 92       	push	r5
    3b32:	6f 92       	push	r6
    3b34:	7f 92       	push	r7
    3b36:	8f 92       	push	r8
    3b38:	9f 92       	push	r9
    3b3a:	af 92       	push	r10
    3b3c:	bf 92       	push	r11
    3b3e:	cf 92       	push	r12
    3b40:	df 92       	push	r13
    3b42:	ef 92       	push	r14
    3b44:	ff 92       	push	r15
    3b46:	0f 93       	push	r16
    3b48:	1f 93       	push	r17
    3b4a:	df 93       	push	r29
    3b4c:	cf 93       	push	r28
    3b4e:	cd b7       	in	r28, 0x3d	; 61
    3b50:	de b7       	in	r29, 0x3e	; 62
    3b52:	64 97       	sbiw	r28, 0x14	; 20
    3b54:	0f b6       	in	r0, 0x3f	; 63
    3b56:	f8 94       	cli
    3b58:	de bf       	out	0x3e, r29	; 62
    3b5a:	0f be       	out	0x3f, r0	; 63
    3b5c:	cd bf       	out	0x3d, r28	; 61
    3b5e:	1c 01       	movw	r2, r24
    3b60:	8b 01       	movw	r16, r22
	unsigned long v;
	char s[16], c, d, *p;


	for (;;) {
		c = PB(*fmt++);					/* Get a char */
    3b62:	f1 01       	movw	r30, r2
    3b64:	84 91       	lpm	r24, Z+
		if (!c) break;				/* End of format? */
    3b66:	88 23       	and	r24, r24
    3b68:	09 f4       	brne	.+2      	; 0x3b6c <xvprintf_P+0x42>
    3b6a:	5d c0       	rjmp	.+186    	; 0x3c26 <xvprintf_P+0xfc>
	unsigned long v;
	char s[16], c, d, *p;


	for (;;) {
		c = PB(*fmt++);					/* Get a char */
    3b6c:	08 94       	sec
    3b6e:	21 1c       	adc	r2, r1
    3b70:	31 1c       	adc	r3, r1
		if (!c) break;				/* End of format? */
		if (c != '%') {				/* Pass through it if not a % sequense */
    3b72:	85 32       	cpi	r24, 0x25	; 37
    3b74:	09 f0       	breq	.+2      	; 0x3b78 <xvprintf_P+0x4e>
    3b76:	4c c0       	rjmp	.+152    	; 0x3c10 <xvprintf_P+0xe6>
			xputc(c); continue;
		}
		f = 0;
		c = PB(*fmt++);					/* Get first char of the sequense */
    3b78:	91 01       	movw	r18, r2
    3b7a:	2f 5f       	subi	r18, 0xFF	; 255
    3b7c:	3f 4f       	sbci	r19, 0xFF	; 255
    3b7e:	f1 01       	movw	r30, r2
    3b80:	84 91       	lpm	r24, Z+
		if (c == '0') {				/* Flag: '0' padded */
    3b82:	80 33       	cpi	r24, 0x30	; 48
    3b84:	09 f4       	brne	.+2      	; 0x3b88 <xvprintf_P+0x5e>
    3b86:	71 c1       	rjmp	.+738    	; 0x3e6a <xvprintf_P+0x340>
			f = 1; c = PB(*fmt++);
		} else {
			if (c == '-') {			/* Flag: left justified */
    3b88:	8d 32       	cpi	r24, 0x2D	; 45
    3b8a:	09 f4       	brne	.+2      	; 0x3b8e <xvprintf_P+0x64>
    3b8c:	87 c1       	rjmp	.+782    	; 0x3e9c <xvprintf_P+0x372>
    3b8e:	48 2f       	mov	r20, r24
    3b90:	1c 8a       	std	Y+20, r1	; 0x14
    3b92:	1b 8a       	std	Y+19, r1	; 0x13
				f = 2; c = PB(*fmt++);
			}
		}
		for (w = 0; c >= '0' && c <= '9'; c = PB(*fmt++))	/* Minimum width */
    3b94:	84 2f       	mov	r24, r20
    3b96:	80 53       	subi	r24, 0x30	; 48
    3b98:	8a 30       	cpi	r24, 0x0A	; 10
    3b9a:	08 f0       	brcs	.+2      	; 0x3b9e <xvprintf_P+0x74>
    3b9c:	73 c1       	rjmp	.+742    	; 0x3e84 <xvprintf_P+0x35a>
    3b9e:	cc 24       	eor	r12, r12
    3ba0:	dd 24       	eor	r13, r13
			w = w * 10 + c - '0';
    3ba2:	c6 01       	movw	r24, r12
    3ba4:	88 0f       	add	r24, r24
    3ba6:	99 1f       	adc	r25, r25
    3ba8:	88 0f       	add	r24, r24
    3baa:	99 1f       	adc	r25, r25
    3bac:	88 0f       	add	r24, r24
    3bae:	99 1f       	adc	r25, r25
    3bb0:	cc 0c       	add	r12, r12
    3bb2:	dd 1c       	adc	r13, r13
    3bb4:	c8 0e       	add	r12, r24
    3bb6:	d9 1e       	adc	r13, r25
    3bb8:	c4 0e       	add	r12, r20
    3bba:	d1 1c       	adc	r13, r1
    3bbc:	80 ed       	ldi	r24, 0xD0	; 208
    3bbe:	9f ef       	ldi	r25, 0xFF	; 255
    3bc0:	c8 0e       	add	r12, r24
    3bc2:	d9 1e       	adc	r13, r25
    3bc4:	f9 01       	movw	r30, r18
		} else {
			if (c == '-') {			/* Flag: left justified */
				f = 2; c = PB(*fmt++);
			}
		}
		for (w = 0; c >= '0' && c <= '9'; c = PB(*fmt++))	/* Minimum width */
    3bc6:	2f 5f       	subi	r18, 0xFF	; 255
    3bc8:	3f 4f       	sbci	r19, 0xFF	; 255
    3bca:	44 91       	lpm	r20, Z+
    3bcc:	84 2f       	mov	r24, r20
    3bce:	80 53       	subi	r24, 0x30	; 48
    3bd0:	8a 30       	cpi	r24, 0x0A	; 10
    3bd2:	38 f3       	brcs	.-50     	; 0x3ba2 <xvprintf_P+0x78>
    3bd4:	19 01       	movw	r2, r18
    3bd6:	a4 2e       	mov	r10, r20
			w = w * 10 + c - '0';
		if (c == 'l' || c == 'L') {	/* Prefix: Size is long int */
    3bd8:	4c 36       	cpi	r20, 0x6C	; 108
    3bda:	09 f4       	brne	.+2      	; 0x3bde <xvprintf_P+0xb4>
    3bdc:	d4 c0       	rjmp	.+424    	; 0x3d86 <xvprintf_P+0x25c>
    3bde:	4c 34       	cpi	r20, 0x4C	; 76
    3be0:	09 f4       	brne	.+2      	; 0x3be4 <xvprintf_P+0xba>
    3be2:	d1 c0       	rjmp	.+418    	; 0x3d86 <xvprintf_P+0x25c>
			f |= 4; c = PB(*fmt++);
		}
		if (!c) break;				/* End of format? */
    3be4:	aa 20       	and	r10, r10
    3be6:	f9 f0       	breq	.+62     	; 0x3c26 <xvprintf_P+0xfc>
		d = c;
		if (d >= 'a') d -= 0x20;
    3be8:	f0 e6       	ldi	r31, 0x60	; 96
    3bea:	fa 15       	cp	r31, r10
    3bec:	08 f4       	brcc	.+2      	; 0x3bf0 <xvprintf_P+0xc6>
    3bee:	d7 c0       	rjmp	.+430    	; 0x3d9e <xvprintf_P+0x274>
    3bf0:	8a 2d       	mov	r24, r10
		switch (d) {				/* Type is... */
    3bf2:	8f 34       	cpi	r24, 0x4F	; 79
    3bf4:	09 f4       	brne	.+2      	; 0x3bf8 <xvprintf_P+0xce>
    3bf6:	d8 c0       	rjmp	.+432    	; 0x3da8 <xvprintf_P+0x27e>
    3bf8:	80 35       	cpi	r24, 0x50	; 80
    3bfa:	08 f0       	brcs	.+2      	; 0x3bfe <xvprintf_P+0xd4>
    3bfc:	ec c0       	rjmp	.+472    	; 0x3dd6 <xvprintf_P+0x2ac>
    3bfe:	83 34       	cpi	r24, 0x43	; 67
    3c00:	09 f4       	brne	.+2      	; 0x3c04 <xvprintf_P+0xda>
    3c02:	7e c1       	rjmp	.+764    	; 0x3f00 <xvprintf_P+0x3d6>
    3c04:	84 34       	cpi	r24, 0x44	; 68
    3c06:	09 f4       	brne	.+2      	; 0x3c0a <xvprintf_P+0xe0>
    3c08:	75 c1       	rjmp	.+746    	; 0x3ef4 <xvprintf_P+0x3ca>
    3c0a:	82 34       	cpi	r24, 0x42	; 66
    3c0c:	29 f1       	breq	.+74     	; 0x3c58 <xvprintf_P+0x12e>
		case 'U' :					/* Unsigned decimal */
			r = 10; break;
		case 'X' :					/* Hexdecimal */
			r = 16; break;
		default:					/* Unknown type (passthrough) */
			xputc(c); continue;
    3c0e:	8a 2d       	mov	r24, r10
    3c10:	0e 94 67 1b 	call	0x36ce	; 0x36ce <xputc>
    3c14:	1a 8b       	std	Y+18, r17	; 0x12
    3c16:	09 8b       	std	Y+17, r16	; 0x11
static
void xvprintf_P (
	const char*	fmt,	/* Pointer to the format string */
	va_list arp			/* Pointer to arguments */
)
{
    3c18:	09 89       	ldd	r16, Y+17	; 0x11
    3c1a:	1a 89       	ldd	r17, Y+18	; 0x12
	unsigned long v;
	char s[16], c, d, *p;


	for (;;) {
		c = PB(*fmt++);					/* Get a char */
    3c1c:	f1 01       	movw	r30, r2
    3c1e:	84 91       	lpm	r24, Z+
		if (!c) break;				/* End of format? */
    3c20:	88 23       	and	r24, r24
    3c22:	09 f0       	breq	.+2      	; 0x3c26 <xvprintf_P+0xfc>
    3c24:	a3 cf       	rjmp	.-186    	; 0x3b6c <xvprintf_P+0x42>
		j = i; d = (f & 1) ? '0' : ' ';
		while (!(f & 2) && j++ < w) xputc(d);
		do xputc(s[--i]); while(i);
		while (j++ < w) xputc(' ');
	}
}
    3c26:	64 96       	adiw	r28, 0x14	; 20
    3c28:	0f b6       	in	r0, 0x3f	; 63
    3c2a:	f8 94       	cli
    3c2c:	de bf       	out	0x3e, r29	; 62
    3c2e:	0f be       	out	0x3f, r0	; 63
    3c30:	cd bf       	out	0x3d, r28	; 61
    3c32:	cf 91       	pop	r28
    3c34:	df 91       	pop	r29
    3c36:	1f 91       	pop	r17
    3c38:	0f 91       	pop	r16
    3c3a:	ff 90       	pop	r15
    3c3c:	ef 90       	pop	r14
    3c3e:	df 90       	pop	r13
    3c40:	cf 90       	pop	r12
    3c42:	bf 90       	pop	r11
    3c44:	af 90       	pop	r10
    3c46:	9f 90       	pop	r9
    3c48:	8f 90       	pop	r8
    3c4a:	7f 90       	pop	r7
    3c4c:	6f 90       	pop	r6
    3c4e:	5f 90       	pop	r5
    3c50:	4f 90       	pop	r4
    3c52:	3f 90       	pop	r3
    3c54:	2f 90       	pop	r2
    3c56:	08 95       	ret
		case 'U' :					/* Unsigned decimal */
			r = 10; break;
		case 'X' :					/* Hexdecimal */
			r = 16; break;
		default:					/* Unknown type (passthrough) */
			xputc(c); continue;
    3c58:	a2 e0       	ldi	r26, 0x02	; 2
    3c5a:	4a 2e       	mov	r4, r26
    3c5c:	51 2c       	mov	r5, r1
    3c5e:	61 2c       	mov	r6, r1
    3c60:	71 2c       	mov	r7, r1
		}

		/* Get an argument and put it in numeral */
		v = (f & 4) ? va_arg(arp, long) : ((d == 'D') ? (long)va_arg(arp, int) : (long)va_arg(arp, unsigned int));
    3c62:	fb 89       	ldd	r31, Y+19	; 0x13
    3c64:	f2 ff       	sbrs	r31, 2
    3c66:	a8 c0       	rjmp	.+336    	; 0x3db8 <xvprintf_P+0x28e>
    3c68:	98 01       	movw	r18, r16
    3c6a:	2c 5f       	subi	r18, 0xFC	; 252
    3c6c:	3f 4f       	sbci	r19, 0xFF	; 255
    3c6e:	3a 8b       	std	Y+18, r19	; 0x12
    3c70:	29 8b       	std	Y+17, r18	; 0x11
    3c72:	f8 01       	movw	r30, r16
    3c74:	e0 80       	ld	r14, Z
    3c76:	f1 80       	ldd	r15, Z+1	; 0x01
    3c78:	02 81       	ldd	r16, Z+2	; 0x02
    3c7a:	13 81       	ldd	r17, Z+3	; 0x03
		if (d == 'D' && (v & 0x80000000)) {
    3c7c:	84 34       	cpi	r24, 0x44	; 68
    3c7e:	09 f4       	brne	.+2      	; 0x3c82 <xvprintf_P+0x158>
    3c80:	23 c1       	rjmp	.+582    	; 0x3ec8 <xvprintf_P+0x39e>
			v = 0 - v;
			f |= 8;
    3c82:	88 24       	eor	r8, r8
    3c84:	99 24       	eor	r9, r9
		}
		i = 0;
		do {
			d = (char)(v % r); v /= r;
    3c86:	c8 01       	movw	r24, r16
    3c88:	b7 01       	movw	r22, r14
    3c8a:	a3 01       	movw	r20, r6
    3c8c:	92 01       	movw	r18, r4
    3c8e:	0e 94 0d 80 	call	0x1001a	; 0x1001a <__udivmodsi4>
    3c92:	b6 2e       	mov	r11, r22
    3c94:	c8 01       	movw	r24, r16
    3c96:	b7 01       	movw	r22, r14
    3c98:	a3 01       	movw	r20, r6
    3c9a:	92 01       	movw	r18, r4
    3c9c:	0e 94 0d 80 	call	0x1001a	; 0x1001a <__udivmodsi4>
    3ca0:	c9 01       	movw	r24, r18
    3ca2:	da 01       	movw	r26, r20
    3ca4:	7c 01       	movw	r14, r24
    3ca6:	8d 01       	movw	r16, r26
			if (d > 9) d += (c == 'x') ? 0x27 : 0x07;
    3ca8:	39 e0       	ldi	r19, 0x09	; 9
    3caa:	3b 15       	cp	r19, r11
    3cac:	30 f4       	brcc	.+12     	; 0x3cba <xvprintf_P+0x190>
    3cae:	e8 e7       	ldi	r30, 0x78	; 120
    3cb0:	ae 16       	cp	r10, r30
    3cb2:	09 f4       	brne	.+2      	; 0x3cb6 <xvprintf_P+0x18c>
    3cb4:	66 c0       	rjmp	.+204    	; 0x3d82 <xvprintf_P+0x258>
    3cb6:	27 e0       	ldi	r18, 0x07	; 7
    3cb8:	b2 0e       	add	r11, r18
			s[i++] = d + '0';
    3cba:	e1 e0       	ldi	r30, 0x01	; 1
    3cbc:	f0 e0       	ldi	r31, 0x00	; 0
    3cbe:	ec 0f       	add	r30, r28
    3cc0:	fd 1f       	adc	r31, r29
    3cc2:	e8 0d       	add	r30, r8
    3cc4:	f9 1d       	adc	r31, r9
    3cc6:	20 e3       	ldi	r18, 0x30	; 48
    3cc8:	b2 0e       	add	r11, r18
    3cca:	b0 82       	st	Z, r11
    3ccc:	08 94       	sec
    3cce:	81 1c       	adc	r8, r1
    3cd0:	91 1c       	adc	r9, r1
		} while (v && i < sizeof(s));
    3cd2:	00 97       	sbiw	r24, 0x00	; 0
    3cd4:	a1 05       	cpc	r26, r1
    3cd6:	b1 05       	cpc	r27, r1
    3cd8:	21 f0       	breq	.+8      	; 0x3ce2 <xvprintf_P+0x1b8>
    3cda:	30 e1       	ldi	r19, 0x10	; 16
    3cdc:	83 16       	cp	r8, r19
    3cde:	91 04       	cpc	r9, r1
    3ce0:	91 f6       	brne	.-92     	; 0x3c86 <xvprintf_P+0x15c>
		if (f & 8) s[i++] = '-';
    3ce2:	8b 89       	ldd	r24, Y+19	; 0x13
    3ce4:	83 ff       	sbrs	r24, 3
    3ce6:	0b c0       	rjmp	.+22     	; 0x3cfe <xvprintf_P+0x1d4>
    3ce8:	e1 e0       	ldi	r30, 0x01	; 1
    3cea:	f0 e0       	ldi	r31, 0x00	; 0
    3cec:	ec 0f       	add	r30, r28
    3cee:	fd 1f       	adc	r31, r29
    3cf0:	e8 0d       	add	r30, r8
    3cf2:	f9 1d       	adc	r31, r9
    3cf4:	9d e2       	ldi	r25, 0x2D	; 45
    3cf6:	90 83       	st	Z, r25
    3cf8:	08 94       	sec
    3cfa:	81 1c       	adc	r8, r1
    3cfc:	91 1c       	adc	r9, r1
		j = i; d = (f & 1) ? '0' : ' ';
    3cfe:	eb 89       	ldd	r30, Y+19	; 0x13
    3d00:	e0 fd       	sbrc	r30, 0
    3d02:	c5 c0       	rjmp	.+394    	; 0x3e8e <xvprintf_P+0x364>
    3d04:	f0 e2       	ldi	r31, 0x20	; 32
    3d06:	ff 2e       	mov	r15, r31
		while (!(f & 2) && j++ < w) xputc(d);
    3d08:	fb 89       	ldd	r31, Y+19	; 0x13
    3d0a:	f1 fd       	sbrc	r31, 1
    3d0c:	c5 c0       	rjmp	.+394    	; 0x3e98 <xvprintf_P+0x36e>
    3d0e:	54 01       	movw	r10, r8
    3d10:	08 94       	sec
    3d12:	a1 1c       	adc	r10, r1
    3d14:	b1 1c       	adc	r11, r1
    3d16:	8c 14       	cp	r8, r12
    3d18:	9d 04       	cpc	r9, r13
    3d1a:	70 f4       	brcc	.+28     	; 0x3d38 <xvprintf_P+0x20e>
    3d1c:	84 01       	movw	r16, r8
    3d1e:	8f 2d       	mov	r24, r15
    3d20:	0e 94 67 1b 	call	0x36ce	; 0x36ce <xputc>
    3d24:	0f 5f       	subi	r16, 0xFF	; 255
    3d26:	1f 4f       	sbci	r17, 0xFF	; 255
    3d28:	0c 15       	cp	r16, r12
    3d2a:	1d 05       	cpc	r17, r13
    3d2c:	c0 f3       	brcs	.-16     	; 0x3d1e <xvprintf_P+0x1f4>
    3d2e:	c6 01       	movw	r24, r12
    3d30:	88 19       	sub	r24, r8
    3d32:	99 09       	sbc	r25, r9
    3d34:	a8 0e       	add	r10, r24
    3d36:	b9 1e       	adc	r11, r25
    3d38:	74 01       	movw	r14, r8
    3d3a:	08 94       	sec
    3d3c:	e1 08       	sbc	r14, r1
    3d3e:	f1 08       	sbc	r15, r1
    3d40:	01 e0       	ldi	r16, 0x01	; 1
    3d42:	10 e0       	ldi	r17, 0x00	; 0
    3d44:	0c 0f       	add	r16, r28
    3d46:	1d 1f       	adc	r17, r29
    3d48:	0e 0d       	add	r16, r14
    3d4a:	1f 1d       	adc	r17, r15
    3d4c:	03 c0       	rjmp	.+6      	; 0x3d54 <xvprintf_P+0x22a>
    3d4e:	08 94       	sec
    3d50:	e1 08       	sbc	r14, r1
    3d52:	f1 08       	sbc	r15, r1
		do xputc(s[--i]); while(i);
    3d54:	f8 01       	movw	r30, r16
    3d56:	80 81       	ld	r24, Z
    3d58:	0e 94 67 1b 	call	0x36ce	; 0x36ce <xputc>
    3d5c:	01 50       	subi	r16, 0x01	; 1
    3d5e:	10 40       	sbci	r17, 0x00	; 0
    3d60:	e1 14       	cp	r14, r1
    3d62:	f1 04       	cpc	r15, r1
    3d64:	a1 f7       	brne	.-24     	; 0x3d4e <xvprintf_P+0x224>
		while (j++ < w) xputc(' ');
    3d66:	ac 14       	cp	r10, r12
    3d68:	bd 04       	cpc	r11, r13
    3d6a:	08 f0       	brcs	.+2      	; 0x3d6e <xvprintf_P+0x244>
    3d6c:	55 cf       	rjmp	.-342    	; 0x3c18 <xvprintf_P+0xee>
    3d6e:	80 e2       	ldi	r24, 0x20	; 32
    3d70:	0e 94 67 1b 	call	0x36ce	; 0x36ce <xputc>
    3d74:	08 94       	sec
    3d76:	a1 1c       	adc	r10, r1
    3d78:	b1 1c       	adc	r11, r1
    3d7a:	ac 14       	cp	r10, r12
    3d7c:	bd 04       	cpc	r11, r13
    3d7e:	b8 f3       	brcs	.-18     	; 0x3d6e <xvprintf_P+0x244>
    3d80:	4b cf       	rjmp	.-362    	; 0x3c18 <xvprintf_P+0xee>
			f |= 8;
		}
		i = 0;
		do {
			d = (char)(v % r); v /= r;
			if (d > 9) d += (c == 'x') ? 0x27 : 0x07;
    3d82:	27 e2       	ldi	r18, 0x27	; 39
    3d84:	99 cf       	rjmp	.-206    	; 0x3cb8 <xvprintf_P+0x18e>
			}
		}
		for (w = 0; c >= '0' && c <= '9'; c = PB(*fmt++))	/* Minimum width */
			w = w * 10 + c - '0';
		if (c == 'l' || c == 'L') {	/* Prefix: Size is long int */
			f |= 4; c = PB(*fmt++);
    3d86:	eb 89       	ldd	r30, Y+19	; 0x13
    3d88:	fc 89       	ldd	r31, Y+20	; 0x14
    3d8a:	e4 60       	ori	r30, 0x04	; 4
    3d8c:	fc 8b       	std	Y+20, r31	; 0x14
    3d8e:	eb 8b       	std	Y+19, r30	; 0x13
    3d90:	19 01       	movw	r2, r18
    3d92:	08 94       	sec
    3d94:	21 1c       	adc	r2, r1
    3d96:	31 1c       	adc	r3, r1
    3d98:	f9 01       	movw	r30, r18
    3d9a:	a4 90       	lpm	r10, Z+
    3d9c:	23 cf       	rjmp	.-442    	; 0x3be4 <xvprintf_P+0xba>
		}
		if (!c) break;				/* End of format? */
		d = c;
		if (d >= 'a') d -= 0x20;
    3d9e:	8a 2d       	mov	r24, r10
    3da0:	80 52       	subi	r24, 0x20	; 32
		switch (d) {				/* Type is... */
    3da2:	8f 34       	cpi	r24, 0x4F	; 79
    3da4:	09 f0       	breq	.+2      	; 0x3da8 <xvprintf_P+0x27e>
    3da6:	28 cf       	rjmp	.-432    	; 0x3bf8 <xvprintf_P+0xce>
    3da8:	28 e0       	ldi	r18, 0x08	; 8
    3daa:	42 2e       	mov	r4, r18
    3dac:	51 2c       	mov	r5, r1
    3dae:	61 2c       	mov	r6, r1
    3db0:	71 2c       	mov	r7, r1
		default:					/* Unknown type (passthrough) */
			xputc(c); continue;
		}

		/* Get an argument and put it in numeral */
		v = (f & 4) ? va_arg(arp, long) : ((d == 'D') ? (long)va_arg(arp, int) : (long)va_arg(arp, unsigned int));
    3db2:	fb 89       	ldd	r31, Y+19	; 0x13
    3db4:	f2 fd       	sbrc	r31, 2
    3db6:	58 cf       	rjmp	.-336    	; 0x3c68 <xvprintf_P+0x13e>
    3db8:	84 34       	cpi	r24, 0x44	; 68
    3dba:	09 f4       	brne	.+2      	; 0x3dbe <xvprintf_P+0x294>
    3dbc:	78 c0       	rjmp	.+240    	; 0x3eae <xvprintf_P+0x384>
    3dbe:	98 01       	movw	r18, r16
    3dc0:	2e 5f       	subi	r18, 0xFE	; 254
    3dc2:	3f 4f       	sbci	r19, 0xFF	; 255
    3dc4:	3a 8b       	std	Y+18, r19	; 0x12
    3dc6:	29 8b       	std	Y+17, r18	; 0x11
    3dc8:	f8 01       	movw	r30, r16
    3dca:	80 81       	ld	r24, Z
    3dcc:	91 81       	ldd	r25, Z+1	; 0x01
    3dce:	7c 01       	movw	r14, r24
    3dd0:	00 e0       	ldi	r16, 0x00	; 0
    3dd2:	10 e0       	ldi	r17, 0x00	; 0
    3dd4:	56 cf       	rjmp	.-340    	; 0x3c82 <xvprintf_P+0x158>
			f |= 4; c = PB(*fmt++);
		}
		if (!c) break;				/* End of format? */
		d = c;
		if (d >= 'a') d -= 0x20;
		switch (d) {				/* Type is... */
    3dd6:	85 35       	cpi	r24, 0x55	; 85
    3dd8:	09 f4       	brne	.+2      	; 0x3ddc <xvprintf_P+0x2b2>
    3dda:	8c c0       	rjmp	.+280    	; 0x3ef4 <xvprintf_P+0x3ca>
    3ddc:	88 35       	cpi	r24, 0x58	; 88
    3dde:	09 f4       	brne	.+2      	; 0x3de2 <xvprintf_P+0x2b8>
    3de0:	83 c0       	rjmp	.+262    	; 0x3ee8 <xvprintf_P+0x3be>
    3de2:	83 35       	cpi	r24, 0x53	; 83
    3de4:	09 f0       	breq	.+2      	; 0x3de8 <xvprintf_P+0x2be>
    3de6:	13 cf       	rjmp	.-474    	; 0x3c0e <xvprintf_P+0xe4>
		case 'S' :					/* String */
			p = va_arg(arp, char*);
    3de8:	98 01       	movw	r18, r16
    3dea:	2e 5f       	subi	r18, 0xFE	; 254
    3dec:	3f 4f       	sbci	r19, 0xFF	; 255
    3dee:	3a 8b       	std	Y+18, r19	; 0x12
    3df0:	29 8b       	std	Y+17, r18	; 0x11
    3df2:	f8 01       	movw	r30, r16
    3df4:	a0 80       	ld	r10, Z
    3df6:	b1 80       	ldd	r11, Z+1	; 0x01
			for (j = 0; p[j]; j++) ;
    3df8:	f5 01       	movw	r30, r10
    3dfa:	80 81       	ld	r24, Z
    3dfc:	88 23       	and	r24, r24
    3dfe:	09 f4       	brne	.+2      	; 0x3e02 <xvprintf_P+0x2d8>
    3e00:	89 c0       	rjmp	.+274    	; 0x3f14 <xvprintf_P+0x3ea>
    3e02:	20 e0       	ldi	r18, 0x00	; 0
    3e04:	30 e0       	ldi	r19, 0x00	; 0
    3e06:	2f 5f       	subi	r18, 0xFF	; 255
    3e08:	3f 4f       	sbci	r19, 0xFF	; 255
    3e0a:	f5 01       	movw	r30, r10
    3e0c:	e2 0f       	add	r30, r18
    3e0e:	f3 1f       	adc	r31, r19
    3e10:	80 81       	ld	r24, Z
    3e12:	88 23       	and	r24, r24
    3e14:	c1 f7       	brne	.-16     	; 0x3e06 <xvprintf_P+0x2dc>
    3e16:	89 01       	movw	r16, r18
    3e18:	0f 5f       	subi	r16, 0xFF	; 255
    3e1a:	1f 4f       	sbci	r17, 0xFF	; 255
			while (!(f & 2) && j++ < w) xputc(' ');
    3e1c:	fb 89       	ldd	r31, Y+19	; 0x13
    3e1e:	f1 fd       	sbrc	r31, 1
    3e20:	7e c0       	rjmp	.+252    	; 0x3f1e <xvprintf_P+0x3f4>
    3e22:	2c 15       	cp	r18, r12
    3e24:	3d 05       	cpc	r19, r13
    3e26:	50 f4       	brcc	.+20     	; 0x3e3c <xvprintf_P+0x312>
    3e28:	80 e2       	ldi	r24, 0x20	; 32
    3e2a:	0e 94 67 1b 	call	0x36ce	; 0x36ce <xputc>
    3e2e:	0f 5f       	subi	r16, 0xFF	; 255
    3e30:	1f 4f       	sbci	r17, 0xFF	; 255
    3e32:	c8 01       	movw	r24, r16
    3e34:	01 97       	sbiw	r24, 0x01	; 1
    3e36:	8c 15       	cp	r24, r12
    3e38:	9d 05       	cpc	r25, r13
    3e3a:	b0 f3       	brcs	.-20     	; 0x3e28 <xvprintf_P+0x2fe>
    3e3c:	78 01       	movw	r14, r16
    3e3e:	08 94       	sec
    3e40:	e1 1c       	adc	r14, r1
    3e42:	f1 1c       	adc	r15, r1
			xputs(p);
    3e44:	c5 01       	movw	r24, r10
    3e46:	0e 94 7b 1b 	call	0x36f6	; 0x36f6 <xputs>
			while (j++ < w) xputc(' ');
    3e4a:	0c 15       	cp	r16, r12
    3e4c:	1d 05       	cpc	r17, r13
    3e4e:	08 f0       	brcs	.+2      	; 0x3e52 <xvprintf_P+0x328>
    3e50:	e3 ce       	rjmp	.-570    	; 0x3c18 <xvprintf_P+0xee>
    3e52:	80 e2       	ldi	r24, 0x20	; 32
    3e54:	0e 94 67 1b 	call	0x36ce	; 0x36ce <xputc>
    3e58:	08 94       	sec
    3e5a:	e1 1c       	adc	r14, r1
    3e5c:	f1 1c       	adc	r15, r1
    3e5e:	c7 01       	movw	r24, r14
    3e60:	01 97       	sbiw	r24, 0x01	; 1
    3e62:	8c 15       	cp	r24, r12
    3e64:	9d 05       	cpc	r25, r13
    3e66:	a8 f3       	brcs	.-22     	; 0x3e52 <xvprintf_P+0x328>
    3e68:	d7 ce       	rjmp	.-594    	; 0x3c18 <xvprintf_P+0xee>
			xputc(c); continue;
		}
		f = 0;
		c = PB(*fmt++);					/* Get first char of the sequense */
		if (c == '0') {				/* Flag: '0' padded */
			f = 1; c = PB(*fmt++);
    3e6a:	f9 01       	movw	r30, r18
    3e6c:	2f 5f       	subi	r18, 0xFF	; 255
    3e6e:	3f 4f       	sbci	r19, 0xFF	; 255
    3e70:	44 91       	lpm	r20, Z+
    3e72:	81 e0       	ldi	r24, 0x01	; 1
    3e74:	90 e0       	ldi	r25, 0x00	; 0
    3e76:	9c 8b       	std	Y+20, r25	; 0x14
    3e78:	8b 8b       	std	Y+19, r24	; 0x13
		} else {
			if (c == '-') {			/* Flag: left justified */
				f = 2; c = PB(*fmt++);
			}
		}
		for (w = 0; c >= '0' && c <= '9'; c = PB(*fmt++))	/* Minimum width */
    3e7a:	84 2f       	mov	r24, r20
    3e7c:	80 53       	subi	r24, 0x30	; 48
    3e7e:	8a 30       	cpi	r24, 0x0A	; 10
    3e80:	08 f4       	brcc	.+2      	; 0x3e84 <xvprintf_P+0x35a>
    3e82:	8d ce       	rjmp	.-742    	; 0x3b9e <xvprintf_P+0x74>
    3e84:	19 01       	movw	r2, r18
    3e86:	a4 2e       	mov	r10, r20
    3e88:	cc 24       	eor	r12, r12
    3e8a:	dd 24       	eor	r13, r13
    3e8c:	a5 ce       	rjmp	.-694    	; 0x3bd8 <xvprintf_P+0xae>
			d = (char)(v % r); v /= r;
			if (d > 9) d += (c == 'x') ? 0x27 : 0x07;
			s[i++] = d + '0';
		} while (v && i < sizeof(s));
		if (f & 8) s[i++] = '-';
		j = i; d = (f & 1) ? '0' : ' ';
    3e8e:	e0 e3       	ldi	r30, 0x30	; 48
    3e90:	fe 2e       	mov	r15, r30
		while (!(f & 2) && j++ < w) xputc(d);
    3e92:	fb 89       	ldd	r31, Y+19	; 0x13
    3e94:	f1 ff       	sbrs	r31, 1
    3e96:	3b cf       	rjmp	.-394    	; 0x3d0e <xvprintf_P+0x1e4>
    3e98:	54 01       	movw	r10, r8
    3e9a:	4e cf       	rjmp	.-356    	; 0x3d38 <xvprintf_P+0x20e>
		c = PB(*fmt++);					/* Get first char of the sequense */
		if (c == '0') {				/* Flag: '0' padded */
			f = 1; c = PB(*fmt++);
		} else {
			if (c == '-') {			/* Flag: left justified */
				f = 2; c = PB(*fmt++);
    3e9c:	f9 01       	movw	r30, r18
    3e9e:	2f 5f       	subi	r18, 0xFF	; 255
    3ea0:	3f 4f       	sbci	r19, 0xFF	; 255
    3ea2:	44 91       	lpm	r20, Z+
    3ea4:	e2 e0       	ldi	r30, 0x02	; 2
    3ea6:	f0 e0       	ldi	r31, 0x00	; 0
    3ea8:	fc 8b       	std	Y+20, r31	; 0x14
    3eaa:	eb 8b       	std	Y+19, r30	; 0x13
    3eac:	73 ce       	rjmp	.-794    	; 0x3b94 <xvprintf_P+0x6a>
		default:					/* Unknown type (passthrough) */
			xputc(c); continue;
		}

		/* Get an argument and put it in numeral */
		v = (f & 4) ? va_arg(arp, long) : ((d == 'D') ? (long)va_arg(arp, int) : (long)va_arg(arp, unsigned int));
    3eae:	98 01       	movw	r18, r16
    3eb0:	2e 5f       	subi	r18, 0xFE	; 254
    3eb2:	3f 4f       	sbci	r19, 0xFF	; 255
    3eb4:	3a 8b       	std	Y+18, r19	; 0x12
    3eb6:	29 8b       	std	Y+17, r18	; 0x11
    3eb8:	f8 01       	movw	r30, r16
    3eba:	80 81       	ld	r24, Z
    3ebc:	91 81       	ldd	r25, Z+1	; 0x01
    3ebe:	7c 01       	movw	r14, r24
    3ec0:	00 27       	eor	r16, r16
    3ec2:	f7 fc       	sbrc	r15, 7
    3ec4:	00 95       	com	r16
    3ec6:	10 2f       	mov	r17, r16
		if (d == 'D' && (v & 0x80000000)) {
    3ec8:	17 ff       	sbrs	r17, 7
    3eca:	db ce       	rjmp	.-586    	; 0x3c82 <xvprintf_P+0x158>
			v = 0 - v;
    3ecc:	10 95       	com	r17
    3ece:	00 95       	com	r16
    3ed0:	f0 94       	com	r15
    3ed2:	e0 94       	com	r14
    3ed4:	e1 1c       	adc	r14, r1
    3ed6:	f1 1c       	adc	r15, r1
    3ed8:	01 1d       	adc	r16, r1
    3eda:	11 1d       	adc	r17, r1
			f |= 8;
    3edc:	2b 89       	ldd	r18, Y+19	; 0x13
    3ede:	3c 89       	ldd	r19, Y+20	; 0x14
    3ee0:	28 60       	ori	r18, 0x08	; 8
    3ee2:	3c 8b       	std	Y+20, r19	; 0x14
    3ee4:	2b 8b       	std	Y+19, r18	; 0x13
    3ee6:	cd ce       	rjmp	.-614    	; 0x3c82 <xvprintf_P+0x158>
			while (!(f & 2) && j++ < w) xputc(' ');
			xputs(p);
			while (j++ < w) xputc(' ');
			continue;
		case 'C' :					/* Character */
			xputc((char)va_arg(arp, int)); continue;
    3ee8:	b0 e1       	ldi	r27, 0x10	; 16
    3eea:	4b 2e       	mov	r4, r27
    3eec:	51 2c       	mov	r5, r1
    3eee:	61 2c       	mov	r6, r1
    3ef0:	71 2c       	mov	r7, r1
    3ef2:	b7 ce       	rjmp	.-658    	; 0x3c62 <xvprintf_P+0x138>
			f |= 4; c = PB(*fmt++);
		}
		if (!c) break;				/* End of format? */
		d = c;
		if (d >= 'a') d -= 0x20;
		switch (d) {				/* Type is... */
    3ef4:	9a e0       	ldi	r25, 0x0A	; 10
    3ef6:	49 2e       	mov	r4, r25
    3ef8:	51 2c       	mov	r5, r1
    3efa:	61 2c       	mov	r6, r1
    3efc:	71 2c       	mov	r7, r1
    3efe:	b1 ce       	rjmp	.-670    	; 0x3c62 <xvprintf_P+0x138>
			while (!(f & 2) && j++ < w) xputc(' ');
			xputs(p);
			while (j++ < w) xputc(' ');
			continue;
		case 'C' :					/* Character */
			xputc((char)va_arg(arp, int)); continue;
    3f00:	98 01       	movw	r18, r16
    3f02:	2e 5f       	subi	r18, 0xFE	; 254
    3f04:	3f 4f       	sbci	r19, 0xFF	; 255
    3f06:	3a 8b       	std	Y+18, r19	; 0x12
    3f08:	29 8b       	std	Y+17, r18	; 0x11
    3f0a:	f8 01       	movw	r30, r16
    3f0c:	80 81       	ld	r24, Z
    3f0e:	0e 94 67 1b 	call	0x36ce	; 0x36ce <xputc>
    3f12:	82 ce       	rjmp	.-764    	; 0x3c18 <xvprintf_P+0xee>
		d = c;
		if (d >= 'a') d -= 0x20;
		switch (d) {				/* Type is... */
		case 'S' :					/* String */
			p = va_arg(arp, char*);
			for (j = 0; p[j]; j++) ;
    3f14:	20 e0       	ldi	r18, 0x00	; 0
    3f16:	30 e0       	ldi	r19, 0x00	; 0
    3f18:	01 e0       	ldi	r16, 0x01	; 1
    3f1a:	10 e0       	ldi	r17, 0x00	; 0
    3f1c:	7f cf       	rjmp	.-258    	; 0x3e1c <xvprintf_P+0x2f2>
			while (!(f & 2) && j++ < w) xputc(' ');
    3f1e:	78 01       	movw	r14, r16
    3f20:	89 01       	movw	r16, r18
    3f22:	90 cf       	rjmp	.-224    	; 0x3e44 <xvprintf_P+0x31a>

00003f24 <xfprintf_P>:
void xfprintf_P (					/* Put a formatted string to the specified device */
	void(*func)(unsigned char),	/* Pointer to the output function */
	const char*	fmt,			/* Pointer to the format string */
	...							/* Optional arguments */
)
{
    3f24:	0f 93       	push	r16
    3f26:	1f 93       	push	r17
    3f28:	df 93       	push	r29
    3f2a:	cf 93       	push	r28
    3f2c:	cd b7       	in	r28, 0x3d	; 61
    3f2e:	de b7       	in	r29, 0x3e	; 62
	va_list arp;
	void (*pf)(unsigned char);


	pf = xfunc_out;		/* Save current output device */
    3f30:	00 91 92 09 	lds	r16, 0x0992
    3f34:	10 91 93 09 	lds	r17, 0x0993
	xfunc_out = func;	/* Switch output to specified device */
    3f38:	8f 81       	ldd	r24, Y+7	; 0x07
    3f3a:	98 85       	ldd	r25, Y+8	; 0x08
    3f3c:	90 93 93 09 	sts	0x0993, r25
    3f40:	80 93 92 09 	sts	0x0992, r24
void xfprintf_P (					/* Put a formatted string to the specified device */
	void(*func)(unsigned char),	/* Pointer to the output function */
	const char*	fmt,			/* Pointer to the format string */
	...							/* Optional arguments */
)
{
    3f44:	9e 01       	movw	r18, r28
    3f46:	25 5f       	subi	r18, 0xF5	; 245
    3f48:	3f 4f       	sbci	r19, 0xFF	; 255

	pf = xfunc_out;		/* Save current output device */
	xfunc_out = func;	/* Switch output to specified device */

	va_start(arp, fmt);
	xvprintf_P(fmt, arp);
    3f4a:	89 85       	ldd	r24, Y+9	; 0x09
    3f4c:	9a 85       	ldd	r25, Y+10	; 0x0a
    3f4e:	b9 01       	movw	r22, r18
    3f50:	0e 94 95 1d 	call	0x3b2a	; 0x3b2a <xvprintf_P>
	va_end(arp);

	xfunc_out = pf;		/* Restore output device */
    3f54:	10 93 93 09 	sts	0x0993, r17
    3f58:	00 93 92 09 	sts	0x0992, r16
}
    3f5c:	cf 91       	pop	r28
    3f5e:	df 91       	pop	r29
    3f60:	1f 91       	pop	r17
    3f62:	0f 91       	pop	r16
    3f64:	08 95       	ret

00003f66 <xsprintf_P>:
void xsprintf_P (			/* Put a formatted string to the memory */
	char* buff,			/* Pointer to the output buffer */
	const char*	fmt,	/* Pointer to the format string */
	...					/* Optional arguments */
)
{
    3f66:	df 93       	push	r29
    3f68:	cf 93       	push	r28
    3f6a:	cd b7       	in	r28, 0x3d	; 61
    3f6c:	de b7       	in	r29, 0x3e	; 62
	va_list arp;


	outptr = buff;		/* Switch destination for memory */
    3f6e:	8d 81       	ldd	r24, Y+5	; 0x05
    3f70:	9e 81       	ldd	r25, Y+6	; 0x06
    3f72:	90 93 1a 07 	sts	0x071A, r25
    3f76:	80 93 19 07 	sts	0x0719, r24
void xsprintf_P (			/* Put a formatted string to the memory */
	char* buff,			/* Pointer to the output buffer */
	const char*	fmt,	/* Pointer to the format string */
	...					/* Optional arguments */
)
{
    3f7a:	9e 01       	movw	r18, r28
    3f7c:	27 5f       	subi	r18, 0xF7	; 247
    3f7e:	3f 4f       	sbci	r19, 0xFF	; 255


	outptr = buff;		/* Switch destination for memory */

	va_start(arp, fmt);
	xvprintf_P(fmt, arp);
    3f80:	8f 81       	ldd	r24, Y+7	; 0x07
    3f82:	98 85       	ldd	r25, Y+8	; 0x08
    3f84:	b9 01       	movw	r22, r18
    3f86:	0e 94 95 1d 	call	0x3b2a	; 0x3b2a <xvprintf_P>
	va_end(arp);

	*outptr = 0;		/* Terminate output string with a \0 */
    3f8a:	e0 91 19 07 	lds	r30, 0x0719
    3f8e:	f0 91 1a 07 	lds	r31, 0x071A
    3f92:	10 82       	st	Z, r1
	outptr = 0;			/* Switch destination for device */
    3f94:	10 92 1a 07 	sts	0x071A, r1
    3f98:	10 92 19 07 	sts	0x0719, r1
}
    3f9c:	cf 91       	pop	r28
    3f9e:	df 91       	pop	r29
    3fa0:	08 95       	ret

00003fa2 <xprintf_P>:

void xprintf_P (			/* Put a formatted string to the default device */
	const char*	fmt,	/* Pointer to the format string */
	...					/* Optional arguments */
)
{
    3fa2:	df 93       	push	r29
    3fa4:	cf 93       	push	r28
    3fa6:	cd b7       	in	r28, 0x3d	; 61
    3fa8:	de b7       	in	r29, 0x3e	; 62
    3faa:	fe 01       	movw	r30, r28
    3fac:	35 96       	adiw	r30, 0x05	; 5
	va_list arp;


	va_start(arp, fmt);
	xvprintf_P(fmt, arp);
    3fae:	81 91       	ld	r24, Z+
    3fb0:	91 91       	ld	r25, Z+
    3fb2:	bf 01       	movw	r22, r30
    3fb4:	0e 94 95 1d 	call	0x3b2a	; 0x3b2a <xvprintf_P>
	va_end(arp);
}
    3fb8:	cf 91       	pop	r28
    3fba:	df 91       	pop	r29
    3fbc:	08 95       	ret

00003fbe <xfprintf>:
void xfprintf (					/* Put a formatted string to the specified device */
	void(*func)(unsigned char),	/* Pointer to the output function */
	const char*	fmt,			/* Pointer to the format string */
	...							/* Optional arguments */
)
{
    3fbe:	0f 93       	push	r16
    3fc0:	1f 93       	push	r17
    3fc2:	df 93       	push	r29
    3fc4:	cf 93       	push	r28
    3fc6:	cd b7       	in	r28, 0x3d	; 61
    3fc8:	de b7       	in	r29, 0x3e	; 62
	va_list arp;
	void (*pf)(unsigned char);


	pf = xfunc_out;		/* Save current output device */
    3fca:	00 91 92 09 	lds	r16, 0x0992
    3fce:	10 91 93 09 	lds	r17, 0x0993
	xfunc_out = func;	/* Switch output to specified device */
    3fd2:	8f 81       	ldd	r24, Y+7	; 0x07
    3fd4:	98 85       	ldd	r25, Y+8	; 0x08
    3fd6:	90 93 93 09 	sts	0x0993, r25
    3fda:	80 93 92 09 	sts	0x0992, r24
void xfprintf (					/* Put a formatted string to the specified device */
	void(*func)(unsigned char),	/* Pointer to the output function */
	const char*	fmt,			/* Pointer to the format string */
	...							/* Optional arguments */
)
{
    3fde:	9e 01       	movw	r18, r28
    3fe0:	25 5f       	subi	r18, 0xF5	; 245
    3fe2:	3f 4f       	sbci	r19, 0xFF	; 255

	pf = xfunc_out;		/* Save current output device */
	xfunc_out = func;	/* Switch output to specified device */

	va_start(arp, fmt);
	xvprintf(fmt, arp);
    3fe4:	89 85       	ldd	r24, Y+9	; 0x09
    3fe6:	9a 85       	ldd	r25, Y+10	; 0x0a
    3fe8:	b9 01       	movw	r22, r18
    3fea:	0e 94 a9 1b 	call	0x3752	; 0x3752 <xvprintf>
	va_end(arp);

	xfunc_out = pf;		/* Restore output device */
    3fee:	10 93 93 09 	sts	0x0993, r17
    3ff2:	00 93 92 09 	sts	0x0992, r16
}
    3ff6:	cf 91       	pop	r28
    3ff8:	df 91       	pop	r29
    3ffa:	1f 91       	pop	r17
    3ffc:	0f 91       	pop	r16
    3ffe:	08 95       	ret

00004000 <xsprintf>:
void xsprintf (			/* Put a formatted string to the memory */
	char* buff,			/* Pointer to the output buffer */
	const char*	fmt,	/* Pointer to the format string */
	...					/* Optional arguments */
)
{
    4000:	df 93       	push	r29
    4002:	cf 93       	push	r28
    4004:	cd b7       	in	r28, 0x3d	; 61
    4006:	de b7       	in	r29, 0x3e	; 62
	va_list arp;


	outptr = buff;		/* Switch destination for memory */
    4008:	8d 81       	ldd	r24, Y+5	; 0x05
    400a:	9e 81       	ldd	r25, Y+6	; 0x06
    400c:	90 93 1a 07 	sts	0x071A, r25
    4010:	80 93 19 07 	sts	0x0719, r24
void xsprintf (			/* Put a formatted string to the memory */
	char* buff,			/* Pointer to the output buffer */
	const char*	fmt,	/* Pointer to the format string */
	...					/* Optional arguments */
)
{
    4014:	9e 01       	movw	r18, r28
    4016:	27 5f       	subi	r18, 0xF7	; 247
    4018:	3f 4f       	sbci	r19, 0xFF	; 255


	outptr = buff;		/* Switch destination for memory */

	va_start(arp, fmt);
	xvprintf(fmt, arp);
    401a:	8f 81       	ldd	r24, Y+7	; 0x07
    401c:	98 85       	ldd	r25, Y+8	; 0x08
    401e:	b9 01       	movw	r22, r18
    4020:	0e 94 a9 1b 	call	0x3752	; 0x3752 <xvprintf>
	va_end(arp);

	*outptr = 0;		/* Terminate output string with a \0 */
    4024:	e0 91 19 07 	lds	r30, 0x0719
    4028:	f0 91 1a 07 	lds	r31, 0x071A
    402c:	10 82       	st	Z, r1
	outptr = 0;			/* Switch destination for device */
    402e:	10 92 1a 07 	sts	0x071A, r1
    4032:	10 92 19 07 	sts	0x0719, r1
}
    4036:	cf 91       	pop	r28
    4038:	df 91       	pop	r29
    403a:	08 95       	ret

0000403c <xprintf>:

void xprintf (			/* Put a formatted string to the default device */
	const char*	fmt,	/* Pointer to the format string */
	...					/* Optional arguments */
)
{
    403c:	df 93       	push	r29
    403e:	cf 93       	push	r28
    4040:	cd b7       	in	r28, 0x3d	; 61
    4042:	de b7       	in	r29, 0x3e	; 62
    4044:	fe 01       	movw	r30, r28
    4046:	35 96       	adiw	r30, 0x05	; 5
	va_list arp;


	va_start(arp, fmt);
	xvprintf(fmt, arp);
    4048:	81 91       	ld	r24, Z+
    404a:	91 91       	ld	r25, Z+
    404c:	bf 01       	movw	r22, r30
    404e:	0e 94 a9 1b 	call	0x3752	; 0x3752 <xvprintf>
	va_end(arp);
}
    4052:	cf 91       	pop	r28
    4054:	df 91       	pop	r29
    4056:	08 95       	ret

00004058 <put_dump>:
	const void* buff,		/* Pointer to the array to be dumped */
	unsigned long addr,		/* Heading address value */
	int len,				/* Number of items to be dumped */
	int width				/* Size of the items (DF_CHAR, DF_SHORT, DF_LONG) */
)
{
    4058:	cf 92       	push	r12
    405a:	df 92       	push	r13
    405c:	ef 92       	push	r14
    405e:	ff 92       	push	r15
    4060:	0f 93       	push	r16
    4062:	1f 93       	push	r17
    4064:	cf 93       	push	r28
    4066:	df 93       	push	r29
    4068:	6c 01       	movw	r12, r24
    406a:	79 01       	movw	r14, r18
	const unsigned char *bp;
	const unsigned short *sp;
	const unsigned long *lp;


	xprintf("%08lX ", addr);		/* address */
    406c:	00 d0       	rcall	.+0      	; 0x406e <put_dump+0x16>
    406e:	00 d0       	rcall	.+0      	; 0x4070 <put_dump+0x18>
    4070:	00 d0       	rcall	.+0      	; 0x4072 <put_dump+0x1a>
    4072:	8c ea       	ldi	r24, 0xAC	; 172
    4074:	93 e0       	ldi	r25, 0x03	; 3
    4076:	ad b7       	in	r26, 0x3d	; 61
    4078:	be b7       	in	r27, 0x3e	; 62
    407a:	12 96       	adiw	r26, 0x02	; 2
    407c:	9c 93       	st	X, r25
    407e:	8e 93       	st	-X, r24
    4080:	11 97       	sbiw	r26, 0x01	; 1
    4082:	ed b7       	in	r30, 0x3d	; 61
    4084:	fe b7       	in	r31, 0x3e	; 62
    4086:	43 83       	std	Z+3, r20	; 0x03
    4088:	54 83       	std	Z+4, r21	; 0x04
    408a:	65 83       	std	Z+5, r22	; 0x05
    408c:	76 83       	std	Z+6, r23	; 0x06
    408e:	0e 94 1e 20 	call	0x403c	; 0x403c <xprintf>

	switch (width) {
    4092:	8d b7       	in	r24, 0x3d	; 61
    4094:	9e b7       	in	r25, 0x3e	; 62
    4096:	06 96       	adiw	r24, 0x06	; 6
    4098:	0f b6       	in	r0, 0x3f	; 63
    409a:	f8 94       	cli
    409c:	9e bf       	out	0x3e, r25	; 62
    409e:	0f be       	out	0x3f, r0	; 63
    40a0:	8d bf       	out	0x3d, r24	; 61
    40a2:	02 30       	cpi	r16, 0x02	; 2
    40a4:	11 05       	cpc	r17, r1
    40a6:	09 f4       	brne	.+2      	; 0x40aa <put_dump+0x52>
    40a8:	6e c0       	rjmp	.+220    	; 0x4186 <__stack+0x87>
    40aa:	04 30       	cpi	r16, 0x04	; 4
    40ac:	11 05       	cpc	r17, r1
    40ae:	09 f4       	brne	.+2      	; 0x40b2 <put_dump+0x5a>
    40b0:	47 c0       	rjmp	.+142    	; 0x4140 <__stack+0x41>
    40b2:	01 30       	cpi	r16, 0x01	; 1
    40b4:	11 05       	cpc	r17, r1
    40b6:	61 f0       	breq	.+24     	; 0x40d0 <put_dump+0x78>
			xprintf(" %08LX", *lp++);
		while (--len);
		break;
	}

	xputc('\n');
    40b8:	8a e0       	ldi	r24, 0x0A	; 10
    40ba:	0e 94 67 1b 	call	0x36ce	; 0x36ce <xputc>
}
    40be:	df 91       	pop	r29
    40c0:	cf 91       	pop	r28
    40c2:	1f 91       	pop	r17
    40c4:	0f 91       	pop	r16
    40c6:	ff 90       	pop	r15
    40c8:	ef 90       	pop	r14
    40ca:	df 90       	pop	r13
    40cc:	cf 90       	pop	r12
    40ce:	08 95       	ret
	xprintf("%08lX ", addr);		/* address */

	switch (width) {
	case DW_CHAR:
		bp = buff;
		for (i = 0; i < len; i++)		/* Hexdecimal dump */
    40d0:	1e 14       	cp	r1, r14
    40d2:	1f 04       	cpc	r1, r15
    40d4:	0c f0       	brlt	.+2      	; 0x40d8 <put_dump+0x80>
    40d6:	71 c0       	rjmp	.+226    	; 0x41ba <__stack+0xbb>
    40d8:	c0 e0       	ldi	r28, 0x00	; 0
    40da:	d0 e0       	ldi	r29, 0x00	; 0
    40dc:	03 eb       	ldi	r16, 0xB3	; 179
    40de:	13 e0       	ldi	r17, 0x03	; 3
			xprintf(" %02X", bp[i]);
    40e0:	00 d0       	rcall	.+0      	; 0x40e2 <put_dump+0x8a>
    40e2:	00 d0       	rcall	.+0      	; 0x40e4 <put_dump+0x8c>
    40e4:	ed b7       	in	r30, 0x3d	; 61
    40e6:	fe b7       	in	r31, 0x3e	; 62
    40e8:	31 96       	adiw	r30, 0x01	; 1
    40ea:	ad b7       	in	r26, 0x3d	; 61
    40ec:	be b7       	in	r27, 0x3e	; 62
    40ee:	12 96       	adiw	r26, 0x02	; 2
    40f0:	1c 93       	st	X, r17
    40f2:	0e 93       	st	-X, r16
    40f4:	11 97       	sbiw	r26, 0x01	; 1
    40f6:	d6 01       	movw	r26, r12
    40f8:	ac 0f       	add	r26, r28
    40fa:	bd 1f       	adc	r27, r29
    40fc:	8c 91       	ld	r24, X
    40fe:	82 83       	std	Z+2, r24	; 0x02
    4100:	13 82       	std	Z+3, r1	; 0x03
    4102:	0e 94 1e 20 	call	0x403c	; 0x403c <xprintf>
	xprintf("%08lX ", addr);		/* address */

	switch (width) {
	case DW_CHAR:
		bp = buff;
		for (i = 0; i < len; i++)		/* Hexdecimal dump */
    4106:	21 96       	adiw	r28, 0x01	; 1
    4108:	0f 90       	pop	r0
    410a:	0f 90       	pop	r0
    410c:	0f 90       	pop	r0
    410e:	0f 90       	pop	r0
    4110:	ce 15       	cp	r28, r14
    4112:	df 05       	cpc	r29, r15
    4114:	2c f3       	brlt	.-54     	; 0x40e0 <put_dump+0x88>
			xprintf(" %02X", bp[i]);
		xputc(' ');
    4116:	80 e2       	ldi	r24, 0x20	; 32
    4118:	0e 94 67 1b 	call	0x36ce	; 0x36ce <xputc>
    411c:	e6 01       	movw	r28, r12
    411e:	86 01       	movw	r16, r12
    4120:	0e 0d       	add	r16, r14
    4122:	1f 1d       	adc	r17, r15
		for (i = 0; i < len; i++)		/* ASCII dump */
			xputc((bp[i] >= ' ' && bp[i] <= '~') ? bp[i] : '.');
    4124:	98 81       	ld	r25, Y
    4126:	89 2f       	mov	r24, r25
    4128:	80 52       	subi	r24, 0x20	; 32
    412a:	8f 35       	cpi	r24, 0x5F	; 95
    412c:	08 f0       	brcs	.+2      	; 0x4130 <__stack+0x31>
    412e:	9e e2       	ldi	r25, 0x2E	; 46
    4130:	89 2f       	mov	r24, r25
    4132:	0e 94 67 1b 	call	0x36ce	; 0x36ce <xputc>
    4136:	21 96       	adiw	r28, 0x01	; 1
	case DW_CHAR:
		bp = buff;
		for (i = 0; i < len; i++)		/* Hexdecimal dump */
			xprintf(" %02X", bp[i]);
		xputc(' ');
		for (i = 0; i < len; i++)		/* ASCII dump */
    4138:	c0 17       	cp	r28, r16
    413a:	d1 07       	cpc	r29, r17
    413c:	99 f7       	brne	.-26     	; 0x4124 <__stack+0x25>
    413e:	bc cf       	rjmp	.-136    	; 0x40b8 <put_dump+0x60>
		do								/* Hexdecimal dump */
			xprintf(" %04X", *sp++);
		while (--len);
		break;
	case DW_LONG:
		lp = buff;
    4140:	e6 01       	movw	r28, r12
    4142:	0f eb       	ldi	r16, 0xBF	; 191
    4144:	13 e0       	ldi	r17, 0x03	; 3
		do								/* Hexdecimal dump */
			xprintf(" %08LX", *lp++);
    4146:	89 91       	ld	r24, Y+
    4148:	99 91       	ld	r25, Y+
    414a:	a9 91       	ld	r26, Y+
    414c:	b9 91       	ld	r27, Y+
    414e:	00 d0       	rcall	.+0      	; 0x4150 <__stack+0x51>
    4150:	00 d0       	rcall	.+0      	; 0x4152 <__stack+0x53>
    4152:	00 d0       	rcall	.+0      	; 0x4154 <__stack+0x55>
    4154:	ed b7       	in	r30, 0x3d	; 61
    4156:	fe b7       	in	r31, 0x3e	; 62
    4158:	12 83       	std	Z+2, r17	; 0x02
    415a:	01 83       	std	Z+1, r16	; 0x01
    415c:	83 83       	std	Z+3, r24	; 0x03
    415e:	94 83       	std	Z+4, r25	; 0x04
    4160:	a5 83       	std	Z+5, r26	; 0x05
    4162:	b6 83       	std	Z+6, r27	; 0x06
    4164:	0e 94 1e 20 	call	0x403c	; 0x403c <xprintf>
		while (--len);
    4168:	08 94       	sec
    416a:	e1 08       	sbc	r14, r1
    416c:	f1 08       	sbc	r15, r1
    416e:	8d b7       	in	r24, 0x3d	; 61
    4170:	9e b7       	in	r25, 0x3e	; 62
    4172:	06 96       	adiw	r24, 0x06	; 6
    4174:	0f b6       	in	r0, 0x3f	; 63
    4176:	f8 94       	cli
    4178:	9e bf       	out	0x3e, r25	; 62
    417a:	0f be       	out	0x3f, r0	; 63
    417c:	8d bf       	out	0x3d, r24	; 61
    417e:	e1 14       	cp	r14, r1
    4180:	f1 04       	cpc	r15, r1
    4182:	09 f7       	brne	.-62     	; 0x4146 <__stack+0x47>
    4184:	99 cf       	rjmp	.-206    	; 0x40b8 <put_dump+0x60>
		xputc(' ');
		for (i = 0; i < len; i++)		/* ASCII dump */
			xputc((bp[i] >= ' ' && bp[i] <= '~') ? bp[i] : '.');
		break;
	case DW_SHORT:
		sp = buff;
    4186:	e6 01       	movw	r28, r12
    4188:	09 eb       	ldi	r16, 0xB9	; 185
    418a:	13 e0       	ldi	r17, 0x03	; 3
		do								/* Hexdecimal dump */
			xprintf(" %04X", *sp++);
    418c:	89 91       	ld	r24, Y+
    418e:	99 91       	ld	r25, Y+
    4190:	00 d0       	rcall	.+0      	; 0x4192 <__stack+0x93>
    4192:	00 d0       	rcall	.+0      	; 0x4194 <__stack+0x95>
    4194:	ed b7       	in	r30, 0x3d	; 61
    4196:	fe b7       	in	r31, 0x3e	; 62
    4198:	12 83       	std	Z+2, r17	; 0x02
    419a:	01 83       	std	Z+1, r16	; 0x01
    419c:	94 83       	std	Z+4, r25	; 0x04
    419e:	83 83       	std	Z+3, r24	; 0x03
    41a0:	0e 94 1e 20 	call	0x403c	; 0x403c <xprintf>
		while (--len);
    41a4:	08 94       	sec
    41a6:	e1 08       	sbc	r14, r1
    41a8:	f1 08       	sbc	r15, r1
    41aa:	0f 90       	pop	r0
    41ac:	0f 90       	pop	r0
    41ae:	0f 90       	pop	r0
    41b0:	0f 90       	pop	r0
    41b2:	e1 14       	cp	r14, r1
    41b4:	f1 04       	cpc	r15, r1
    41b6:	51 f7       	brne	.-44     	; 0x418c <__stack+0x8d>
    41b8:	7f cf       	rjmp	.-258    	; 0x40b8 <put_dump+0x60>
	switch (width) {
	case DW_CHAR:
		bp = buff;
		for (i = 0; i < len; i++)		/* Hexdecimal dump */
			xprintf(" %02X", bp[i]);
		xputc(' ');
    41ba:	80 e2       	ldi	r24, 0x20	; 32
    41bc:	0e 94 67 1b 	call	0x36ce	; 0x36ce <xputc>
    41c0:	7b cf       	rjmp	.-266    	; 0x40b8 <put_dump+0x60>

000041c2 <usart_init>:
                                usart Related
********************************************************************************/

void usart_init( uint16_t ubrr) {
	// Set baud rate
	UBRR0H = (uint8_t)(ubrr>>8);
    41c2:	90 93 c5 00 	sts	0x00C5, r25
	UBRR0L = (uint8_t)ubrr;
    41c6:	80 93 c4 00 	sts	0x00C4, r24
	// Enable receiver and transmitter
	UCSR0B = (1<<RXEN0)|(1<<TXEN0);
    41ca:	88 e1       	ldi	r24, 0x18	; 24
    41cc:	80 93 c1 00 	sts	0x00C1, r24
	// Set frame format: 8data, 1stop bit, no parity
	UCSR0C = (1<<UCSZ01)|(1<<UCSZ00);
    41d0:	86 e0       	ldi	r24, 0x06	; 6
    41d2:	80 93 c2 00 	sts	0x00C2, r24
}
    41d6:	08 95       	ret

000041d8 <usart_putchar>:


void usart_putchar(char data) { 
    41d8:	98 2f       	mov	r25, r24
	// Wait for empty transmit buffer
	while ( !(UCSR0A & (_BV(UDRE0))) );
    41da:	80 91 c0 00 	lds	r24, 0x00C0
    41de:	85 ff       	sbrs	r24, 5
    41e0:	fc cf       	rjmp	.-8      	; 0x41da <usart_putchar+0x2>
	// Start transmission
	UDR0 = data; 
    41e2:	90 93 c6 00 	sts	0x00C6, r25
}
    41e6:	08 95       	ret

000041e8 <usart_getchar>:

char usart_getchar(void) { 
	// Wait for incomming data
	while ( !(UCSR0A & (_BV(RXC0))) );
    41e8:	80 91 c0 00 	lds	r24, 0x00C0
    41ec:	87 ff       	sbrs	r24, 7
    41ee:	fc cf       	rjmp	.-8      	; 0x41e8 <usart_getchar>
	// Return the data
	return UDR0;
    41f0:	80 91 c6 00 	lds	r24, 0x00C6
} 
    41f4:	08 95       	ret

000041f6 <usart_pstr>:

void usart_pstr(char *s) {
    41f6:	fc 01       	movw	r30, r24
    // loop through entire string
	while (*s) {  
    41f8:	90 81       	ld	r25, Z
    41fa:	99 23       	and	r25, r25
    41fc:	51 f0       	breq	.+20     	; 0x4212 <usart_pstr+0x1c>
}


void usart_putchar(char data) { 
	// Wait for empty transmit buffer
	while ( !(UCSR0A & (_BV(UDRE0))) );
    41fe:	80 91 c0 00 	lds	r24, 0x00C0
    4202:	85 ff       	sbrs	r24, 5
    4204:	fc cf       	rjmp	.-8      	; 0x41fe <usart_pstr+0x8>
	// Start transmission
	UDR0 = data; 
    4206:	90 93 c6 00 	sts	0x00C6, r25

void usart_pstr(char *s) {
    // loop through entire string
	while (*s) {  
        usart_putchar(*s);
        s++;
    420a:	31 96       	adiw	r30, 0x01	; 1
	return UDR0;
} 

void usart_pstr(char *s) {
    // loop through entire string
	while (*s) {  
    420c:	90 81       	ld	r25, Z
    420e:	99 23       	and	r25, r25
    4210:	b1 f7       	brne	.-20     	; 0x41fe <usart_pstr+0x8>
    4212:	08 95       	ret

00004214 <usart_kbhit>:

unsigned char usart_kbhit(void) {
	//return nonzero if char waiting  polled version
	unsigned char b;
	b=0;
	if(UCSR0A & (1<<RXC0)) b=1;
    4214:	80 91 c0 00 	lds	r24, 0x00C0
	return b;
}
    4218:	88 1f       	adc	r24, r24
    421a:	88 27       	eor	r24, r24
    421c:	88 1f       	adc	r24, r24
    421e:	08 95       	ret

00004220 <usart_putchar_printf>:

// this function is called by printf as a stream handler
int usart_putchar_printf(char var, FILE *stream) {
    4220:	98 2f       	mov	r25, r24
}


void usart_putchar(char data) { 
	// Wait for empty transmit buffer
	while ( !(UCSR0A & (_BV(UDRE0))) );
    4222:	80 91 c0 00 	lds	r24, 0x00C0
    4226:	85 ff       	sbrs	r24, 5
    4228:	fc cf       	rjmp	.-8      	; 0x4222 <usart_putchar_printf+0x2>
	// Start transmission
	UDR0 = data; 
    422a:	90 93 c6 00 	sts	0x00C6, r25

// this function is called by printf as a stream handler
int usart_putchar_printf(char var, FILE *stream) {
	usart_putchar(var);
	return 0;
}
    422e:	80 e0       	ldi	r24, 0x00	; 0
    4230:	90 e0       	ldi	r25, 0x00	; 0
    4232:	08 95       	ret

00004234 <TimeInit>:
	OCR0A=count; //set count number 
	TIMSK0=0x02; //enable ISR on compare match. 
	TCNT0 =0x00;
	cnt_timer = 0;
	*/
	System_time = chVTGetSystemTimeX();	 
    4234:	80 91 d2 07 	lds	r24, 0x07D2
    4238:	90 91 d3 07 	lds	r25, 0x07D3
    423c:	a0 91 d4 07 	lds	r26, 0x07D4
    4240:	b0 91 d5 07 	lds	r27, 0x07D5
    4244:	80 93 9c 09 	sts	0x099C, r24
    4248:	90 93 9d 09 	sts	0x099D, r25
    424c:	a0 93 9e 09 	sts	0x099E, r26
    4250:	b0 93 9f 09 	sts	0x099F, r27

}
    4254:	08 95       	ret

00004256 <GetTime>:
  }
}


void GetTime(TIME *ptr)
{
    4256:	fc 01       	movw	r30, r24
    4258:	f8 94       	cli
	//disable the Timer ISR 	
	//TIMSK0=TIMSK0 & ~(1<<OCIE0A); //Timer0 compare A interrupt OFF
	chSysLock(); 
	//set the time
	ptr->milliseconds_time=MilliSeconds;
    425a:	80 91 1f 07 	lds	r24, 0x071F
    425e:	90 91 20 07 	lds	r25, 0x0720
    4262:	95 83       	std	Z+5, r25	; 0x05
    4264:	84 83       	std	Z+4, r24	; 0x04
	ptr->seconds_time=Seconds;
    4266:	80 91 1b 07 	lds	r24, 0x071B
    426a:	90 91 1c 07 	lds	r25, 0x071C
    426e:	a0 91 1d 07 	lds	r26, 0x071D
    4272:	b0 91 1e 07 	lds	r27, 0x071E
    4276:	80 83       	st	Z, r24
    4278:	91 83       	std	Z+1, r25	; 0x01
    427a:	a2 83       	std	Z+2, r26	; 0x02
    427c:	b3 83       	std	Z+3, r27	; 0x03
    427e:	78 94       	sei
	
	//enable ISR
	//TIMSK0=TIMSK0 | (1<<OCIE0A); //Timer0 compare A interrupt ON
	chSysUnlock(); 

}
    4280:	08 95       	ret

00004282 <Get_elapsed_ms>:

uint32_t Get_elapsed_ms(TIME *pStart)
{
    4282:	cf 92       	push	r12
    4284:	df 92       	push	r13
    4286:	ef 92       	push	r14
    4288:	ff 92       	push	r15
    428a:	0f 93       	push	r16
    428c:	1f 93       	push	r17
    428e:	6c 01       	movw	r12, r24
    4290:	f8 94       	cli
{
	//disable the Timer ISR 	
	//TIMSK0=TIMSK0 & ~(1<<OCIE0A); //Timer0 compare A interrupt OFF
	chSysLock(); 
	//set the time
	ptr->milliseconds_time=MilliSeconds;
    4292:	e0 90 1f 07 	lds	r14, 0x071F
    4296:	f0 90 20 07 	lds	r15, 0x0720
	ptr->seconds_time=Seconds;
    429a:	60 91 1b 07 	lds	r22, 0x071B
    429e:	70 91 1c 07 	lds	r23, 0x071C
    42a2:	80 91 1d 07 	lds	r24, 0x071D
    42a6:	90 91 1e 07 	lds	r25, 0x071E
    42aa:	78 94       	sei
{
	uint32_t temp;
	TIME t;
	GetTime(&t);

	temp=(t.seconds_time-pStart->seconds_time)*1000;
    42ac:	f6 01       	movw	r30, r12
    42ae:	20 81       	ld	r18, Z
    42b0:	31 81       	ldd	r19, Z+1	; 0x01
    42b2:	42 81       	ldd	r20, Z+2	; 0x02
    42b4:	53 81       	ldd	r21, Z+3	; 0x03
    42b6:	62 1b       	sub	r22, r18
    42b8:	73 0b       	sbc	r23, r19
    42ba:	84 0b       	sbc	r24, r20
    42bc:	95 0b       	sbc	r25, r21
    42be:	28 ee       	ldi	r18, 0xE8	; 232
    42c0:	33 e0       	ldi	r19, 0x03	; 3
    42c2:	40 e0       	ldi	r20, 0x00	; 0
    42c4:	50 e0       	ldi	r21, 0x00	; 0
    42c6:	0e 94 bb 7f 	call	0xff76	; 0xff76 <__mulsi3>
    42ca:	9b 01       	movw	r18, r22
    42cc:	ac 01       	movw	r20, r24
  	temp=temp + t.milliseconds_time;
    42ce:	f6 01       	movw	r30, r12
    42d0:	84 81       	ldd	r24, Z+4	; 0x04
    42d2:	95 81       	ldd	r25, Z+5	; 0x05
    42d4:	a0 e0       	ldi	r26, 0x00	; 0
    42d6:	b0 e0       	ldi	r27, 0x00	; 0
    42d8:	28 1b       	sub	r18, r24
    42da:	39 0b       	sbc	r19, r25
    42dc:	4a 0b       	sbc	r20, r26
    42de:	5b 0b       	sbc	r21, r27
    42e0:	00 e0       	ldi	r16, 0x00	; 0
    42e2:	10 e0       	ldi	r17, 0x00	; 0
    42e4:	2e 0d       	add	r18, r14
    42e6:	3f 1d       	adc	r19, r15
    42e8:	40 1f       	adc	r20, r16
    42ea:	51 1f       	adc	r21, r17
  	temp=temp-pStart->milliseconds_time;
	return temp;
}
    42ec:	b9 01       	movw	r22, r18
    42ee:	ca 01       	movw	r24, r20
    42f0:	1f 91       	pop	r17
    42f2:	0f 91       	pop	r16
    42f4:	ff 90       	pop	r15
    42f6:	ef 90       	pop	r14
    42f8:	df 90       	pop	r13
    42fa:	cf 90       	pop	r12
    42fc:	08 95       	ret

000042fe <Get_elapsed_s>:

uint32_t Get_elapsed_s(TIME *pStart)
{
    42fe:	fc 01       	movw	r30, r24
    4300:	f8 94       	cli
{
	//disable the Timer ISR 	
	//TIMSK0=TIMSK0 & ~(1<<OCIE0A); //Timer0 compare A interrupt OFF
	chSysLock(); 
	//set the time
	ptr->milliseconds_time=MilliSeconds;
    4302:	80 91 1f 07 	lds	r24, 0x071F
    4306:	90 91 20 07 	lds	r25, 0x0720
	ptr->seconds_time=Seconds;
    430a:	20 91 1b 07 	lds	r18, 0x071B
    430e:	30 91 1c 07 	lds	r19, 0x071C
    4312:	40 91 1d 07 	lds	r20, 0x071D
    4316:	50 91 1e 07 	lds	r21, 0x071E
    431a:	78 94       	sei
    431c:	80 81       	ld	r24, Z
    431e:	91 81       	ldd	r25, Z+1	; 0x01
    4320:	a2 81       	ldd	r26, Z+2	; 0x02
    4322:	b3 81       	ldd	r27, Z+3	; 0x03
    4324:	28 1b       	sub	r18, r24
    4326:	39 0b       	sbc	r19, r25
    4328:	4a 0b       	sbc	r20, r26
    432a:	5b 0b       	sbc	r21, r27
	uint32_t temp;
	TIME t;
	GetTime(&t);
	temp=(t.seconds_time-pStart->seconds_time);
 	return temp;
}
    432c:	b9 01       	movw	r22, r18
    432e:	ca 01       	movw	r24, r20
    4330:	08 95       	ret

00004332 <getSeconds>:
    4332:	f8 94       	cli
{
	uint32_t temp;
	//TIMSK0=TIMSK0 & ~(1<<OCIE0A); //Timer0 compare A interrupt OFF
	chSysLock(); 
	//set the time variables
	temp=Seconds;
    4334:	20 91 1b 07 	lds	r18, 0x071B
    4338:	30 91 1c 07 	lds	r19, 0x071C
    433c:	40 91 1d 07 	lds	r20, 0x071D
    4340:	50 91 1e 07 	lds	r21, 0x071E
    4344:	78 94       	sei
	//turn ISR back on
	//TIMSK0=TIMSK0 | (1<<OCIE0A); //Timer0 compare A interrupt ON
	chSysUnlock();
	return temp;
}
    4346:	b9 01       	movw	r22, r18
    4348:	ca 01       	movw	r24, r20
    434a:	08 95       	ret

0000434c <Reset_timer>:
    434c:	f8 94       	cli
{

	//TIMSK0=TIMSK0 & ~(1<<OCIE0A); //Timer0 compare A interrupt OFF
	chSysLock(); 
	//set the time variables
	Seconds = 0;
    434e:	10 92 1b 07 	sts	0x071B, r1
    4352:	10 92 1c 07 	sts	0x071C, r1
    4356:	10 92 1d 07 	sts	0x071D, r1
    435a:	10 92 1e 07 	sts	0x071E, r1
    435e:	78 94       	sei
	//turn ISR back on
	//TIMSK0=TIMSK0 | (1<<OCIE0A); //Timer0 compare A interrupt ON
	chSysUnlock(); 

}
    4360:	08 95       	ret

00004362 <timer>:
	OCR0A=count; //set count number 
	TIMSK0=0x02; //enable ISR on compare match. 
	TCNT0 =0x00;
	cnt_timer = 0;
	*/
	System_time = chVTGetSystemTimeX();	 
    4362:	80 91 d2 07 	lds	r24, 0x07D2
    4366:	90 91 d3 07 	lds	r25, 0x07D3
    436a:	a0 91 d4 07 	lds	r26, 0x07D4
    436e:	b0 91 d5 07 	lds	r27, 0x07D5
    4372:	80 93 9c 09 	sts	0x099C, r24
    4376:	90 93 9d 09 	sts	0x099D, r25
    437a:	a0 93 9e 09 	sts	0x099E, r26
    437e:	b0 93 9f 09 	sts	0x099F, r27
    4382:	f8 94       	cli
  TimeInit();

  /* Waiting for button push and activation of the test suite.*/
  while (true) {
  chSysLock(); 
  System_delta = chVTTimeElapsedSinceX(System_time);	
    4384:	20 91 d2 07 	lds	r18, 0x07D2
    4388:	30 91 d3 07 	lds	r19, 0x07D3
    438c:	40 91 d4 07 	lds	r20, 0x07D4
    4390:	50 91 d5 07 	lds	r21, 0x07D5
    4394:	80 91 9c 09 	lds	r24, 0x099C
    4398:	90 91 9d 09 	lds	r25, 0x099D
    439c:	a0 91 9e 09 	lds	r26, 0x099E
    43a0:	b0 91 9f 09 	lds	r27, 0x099F
    43a4:	79 01       	movw	r14, r18
    43a6:	8a 01       	movw	r16, r20
    43a8:	e8 1a       	sub	r14, r24
    43aa:	f9 0a       	sbc	r15, r25
    43ac:	0a 0b       	sbc	r16, r26
    43ae:	1b 0b       	sbc	r17, r27
    43b0:	e0 92 98 09 	sts	0x0998, r14
    43b4:	f0 92 99 09 	sts	0x0999, r15
    43b8:	00 93 9a 09 	sts	0x099A, r16
    43bc:	10 93 9b 09 	sts	0x099B, r17
  System_time = chVTGetSystemTimeX();	 
    43c0:	20 93 9c 09 	sts	0x099C, r18
    43c4:	30 93 9d 09 	sts	0x099D, r19
    43c8:	40 93 9e 09 	sts	0x099E, r20
    43cc:	50 93 9f 09 	sts	0x099F, r21
    43d0:	78 94       	sei
  chSysUnlock(); 

  MilliSeconds+=ST2MS(System_delta);
    43d2:	60 91 98 09 	lds	r22, 0x0998
    43d6:	70 91 99 09 	lds	r23, 0x0999
    43da:	80 91 9a 09 	lds	r24, 0x099A
    43de:	90 91 9b 09 	lds	r25, 0x099B
    43e2:	00 91 1f 07 	lds	r16, 0x071F
    43e6:	10 91 20 07 	lds	r17, 0x0720
    43ea:	0f 5f       	subi	r16, 0xFF	; 255
    43ec:	1f 4f       	sbci	r17, 0xFF	; 255
    43ee:	61 50       	subi	r22, 0x01	; 1
    43f0:	70 40       	sbci	r23, 0x00	; 0
    43f2:	80 40       	sbci	r24, 0x00	; 0
    43f4:	90 40       	sbci	r25, 0x00	; 0
    43f6:	24 e1       	ldi	r18, 0x14	; 20
    43f8:	30 e0       	ldi	r19, 0x00	; 0
    43fa:	40 e0       	ldi	r20, 0x00	; 0
    43fc:	50 e0       	ldi	r21, 0x00	; 0
    43fe:	0e 94 0d 80 	call	0x1001a	; 0x1001a <__udivmodsi4>
    4402:	02 0f       	add	r16, r18
    4404:	13 1f       	adc	r17, r19
    4406:	10 93 20 07 	sts	0x0720, r17
    440a:	00 93 1f 07 	sts	0x071F, r16
	if (MilliSeconds>=1000)
    440e:	80 91 1f 07 	lds	r24, 0x071F
    4412:	90 91 20 07 	lds	r25, 0x0720
    4416:	88 5e       	subi	r24, 0xE8	; 232
    4418:	93 40       	sbci	r25, 0x03	; 3
    441a:	78 f1       	brcs	.+94     	; 0x447a <timer+0x118>
	{
		Seconds++;
    441c:	80 91 1b 07 	lds	r24, 0x071B
    4420:	90 91 1c 07 	lds	r25, 0x071C
    4424:	a0 91 1d 07 	lds	r26, 0x071D
    4428:	b0 91 1e 07 	lds	r27, 0x071E
    442c:	01 96       	adiw	r24, 0x01	; 1
    442e:	a1 1d       	adc	r26, r1
    4430:	b1 1d       	adc	r27, r1
    4432:	80 93 1b 07 	sts	0x071B, r24
    4436:	90 93 1c 07 	sts	0x071C, r25
    443a:	a0 93 1d 07 	sts	0x071D, r26
    443e:	b0 93 1e 07 	sts	0x071E, r27
		//cnt_timer++;
		MilliSeconds=0;
    4442:	10 92 20 07 	sts	0x0720, r1
    4446:	10 92 1f 07 	sts	0x071F, r1
		minute_counter = (double) Seconds/60.0;
    444a:	60 91 1b 07 	lds	r22, 0x071B
    444e:	70 91 1c 07 	lds	r23, 0x071C
    4452:	80 91 1d 07 	lds	r24, 0x071D
    4456:	90 91 1e 07 	lds	r25, 0x071E
    445a:	0e 94 e2 7d 	call	0xfbc4	; 0xfbc4 <__floatunsisf>
    445e:	20 e0       	ldi	r18, 0x00	; 0
    4460:	30 e0       	ldi	r19, 0x00	; 0
    4462:	40 e7       	ldi	r20, 0x70	; 112
    4464:	52 e4       	ldi	r21, 0x42	; 66
    4466:	0e 94 4e 7d 	call	0xfa9c	; 0xfa9c <__divsf3>
    446a:	60 93 01 0e 	sts	0x0E01, r22
    446e:	70 93 02 0e 	sts	0x0E02, r23
    4472:	80 93 03 0e 	sts	0x0E03, r24
    4476:	90 93 04 0e 	sts	0x0E04, r25
	}
	chThdSleepMilliseconds(1); // lowest priority so thread doesn't need to sleep
    447a:	64 e1       	ldi	r22, 0x14	; 20
    447c:	70 e0       	ldi	r23, 0x00	; 0
    447e:	80 e0       	ldi	r24, 0x00	; 0
    4480:	90 e0       	ldi	r25, 0x00	; 0
    4482:	0e 94 f4 08 	call	0x11e8	; 0x11e8 <chThdSleep>
    4486:	7d cf       	rjmp	.-262    	; 0x4382 <timer+0x20>

00004488 <wait_ready>:
/* Wait for card ready                                                   */
/*-----------------------------------------------------------------------*/

static
int wait_ready (void)	/* 1:OK, 0:Timeout */
{
    4488:	28 e8       	ldi	r18, 0x88	; 136
    448a:	33 e1       	ldi	r19, 0x13	; 19

//receive an SPI byte
static
BYTE rcv_spi(void)
{
	SPDR = 0xff;
    448c:	4f ef       	ldi	r20, 0xFF	; 255
    448e:	4e bd       	out	0x2e, r20	; 46
	while(!(SPSR & _BV(SPIF)));
    4490:	0d b4       	in	r0, 0x2d	; 45
    4492:	07 fe       	sbrs	r0, 7
    4494:	fd cf       	rjmp	.-6      	; 0x4490 <wait_ready+0x8>
	return SPDR;
    4496:	8e b5       	in	r24, 0x2e	; 46
	UINT tmr;


	for (tmr = 5000; tmr; tmr--) {	/* Wait for ready in timeout of 500ms */
		d = rcv_spi();
		if (d == 0xFF) return 1;
    4498:	8f 3f       	cpi	r24, 0xFF	; 255
    449a:	79 f0       	breq	.+30     	; 0x44ba <wait_ready+0x32>
    449c:	84 e6       	ldi	r24, 0x64	; 100
    449e:	90 e0       	ldi	r25, 0x00	; 0


static void dly_us (UINT n)
{
	do {	/* 9 clocks per loop on avr-gcc -Os */
		PINB; PINB; PINB; PINB; PINB;
    44a0:	53 b1       	in	r21, 0x03	; 3
    44a2:	53 b1       	in	r21, 0x03	; 3
    44a4:	53 b1       	in	r21, 0x03	; 3
    44a6:	53 b1       	in	r21, 0x03	; 3
    44a8:	53 b1       	in	r21, 0x03	; 3
	} while (--n);
    44aa:	01 97       	sbiw	r24, 0x01	; 1
    44ac:	c9 f7       	brne	.-14     	; 0x44a0 <wait_ready+0x18>
{
	BYTE d;
	UINT tmr;


	for (tmr = 5000; tmr; tmr--) {	/* Wait for ready in timeout of 500ms */
    44ae:	21 50       	subi	r18, 0x01	; 1
    44b0:	30 40       	sbci	r19, 0x00	; 0
    44b2:	69 f7       	brne	.-38     	; 0x448e <wait_ready+0x6>
    44b4:	20 e0       	ldi	r18, 0x00	; 0
    44b6:	30 e0       	ldi	r19, 0x00	; 0
    44b8:	02 c0       	rjmp	.+4      	; 0x44be <wait_ready+0x36>
		d = rcv_spi();
		if (d == 0xFF) return 1;
    44ba:	21 e0       	ldi	r18, 0x01	; 1
    44bc:	30 e0       	ldi	r19, 0x00	; 0
		dly_us (100);
	}

	return 0;
}
    44be:	c9 01       	movw	r24, r18
    44c0:	08 95       	ret

000044c2 <select>:
/*-----------------------------------------------------------------------*/

static
int select (void)	/* 1:OK, 0:Timeout */
{
SELECT();
    44c2:	2a 98       	cbi	0x05, 2	; 5
if (!wait_ready()) {
    44c4:	0e 94 44 22 	call	0x4488	; 0x4488 <wait_ready>
    44c8:	89 2b       	or	r24, r25
    44ca:	59 f4       	brne	.+22     	; 0x44e2 <select+0x20>
static
void deselect (void)
{
 BYTE d;
 
 DESELECT();
    44cc:	2a 9a       	sbi	0x05, 2	; 5

//receive an SPI byte
static
BYTE rcv_spi(void)
{
	SPDR = 0xff;
    44ce:	8f ef       	ldi	r24, 0xFF	; 255
    44d0:	8e bd       	out	0x2e, r24	; 46
	while(!(SPSR & _BV(SPIF)));
    44d2:	0d b4       	in	r0, 0x2d	; 45
    44d4:	07 fe       	sbrs	r0, 7
    44d6:	fd cf       	rjmp	.-6      	; 0x44d2 <select+0x10>
	return SPDR;
    44d8:	8e b5       	in	r24, 0x2e	; 46
    44da:	20 e0       	ldi	r18, 0x00	; 0
    44dc:	30 e0       	ldi	r19, 0x00	; 0
if (!wait_ready()) {
		deselect();
		return 0;
	}
	return 1;
}
    44de:	c9 01       	movw	r24, r18
    44e0:	08 95       	ret

static
int select (void)	/* 1:OK, 0:Timeout */
{
SELECT();
if (!wait_ready()) {
    44e2:	21 e0       	ldi	r18, 0x01	; 1
    44e4:	30 e0       	ldi	r19, 0x00	; 0
		deselect();
		return 0;
	}
	return 1;
}
    44e6:	c9 01       	movw	r24, r18
    44e8:	08 95       	ret

000044ea <rcvr_datablock>:
static
int rcvr_datablock (	/* 1:OK, 0:Failed */
	BYTE *buff,			/* Data buffer to store received data */
	UINT btr			/* Byte count */
)
{
    44ea:	fc 01       	movw	r30, r24
    44ec:	28 ee       	ldi	r18, 0xE8	; 232
    44ee:	33 e0       	ldi	r19, 0x03	; 3

//receive an SPI byte
static
BYTE rcv_spi(void)
{
	SPDR = 0xff;
    44f0:	4f ef       	ldi	r20, 0xFF	; 255
    44f2:	4e bd       	out	0x2e, r20	; 46
	while(!(SPSR & _BV(SPIF)));
    44f4:	0d b4       	in	r0, 0x2d	; 45
    44f6:	07 fe       	sbrs	r0, 7
    44f8:	fd cf       	rjmp	.-6      	; 0x44f4 <rcvr_datablock+0xa>
	return SPDR;
    44fa:	8e b5       	in	r24, 0x2e	; 46
	UINT tmr;


for (tmr = 1000; tmr; tmr--) {	/* Wait for data packet in timeout of 100ms */
		token = rcv_spi();
		if (token != 0xFF) break;
    44fc:	8f 3f       	cpi	r24, 0xFF	; 255
    44fe:	81 f4       	brne	.+32     	; 0x4520 <rcvr_datablock+0x36>
    4500:	84 e6       	ldi	r24, 0x64	; 100
    4502:	90 e0       	ldi	r25, 0x00	; 0


static void dly_us (UINT n)
{
	do {	/* 9 clocks per loop on avr-gcc -Os */
		PINB; PINB; PINB; PINB; PINB;
    4504:	53 b1       	in	r21, 0x03	; 3
    4506:	53 b1       	in	r21, 0x03	; 3
    4508:	53 b1       	in	r21, 0x03	; 3
    450a:	53 b1       	in	r21, 0x03	; 3
    450c:	53 b1       	in	r21, 0x03	; 3
	} while (--n);
    450e:	01 97       	sbiw	r24, 0x01	; 1
    4510:	c9 f7       	brne	.-14     	; 0x4504 <rcvr_datablock+0x1a>
{
	BYTE token;
	UINT tmr;


for (tmr = 1000; tmr; tmr--) {	/* Wait for data packet in timeout of 100ms */
    4512:	21 50       	subi	r18, 0x01	; 1
    4514:	30 40       	sbci	r19, 0x00	; 0
    4516:	69 f7       	brne	.-38     	; 0x44f2 <rcvr_datablock+0x8>
		rcvr_spi_m(buff++);
	} while (btr -= 4);
	rcv_spi();						/* Discard CRC */
	rcv_spi();

	return 1;						/* Return with success */
    4518:	20 e0       	ldi	r18, 0x00	; 0
    451a:	30 e0       	ldi	r19, 0x00	; 0
}
    451c:	c9 01       	movw	r24, r18
    451e:	08 95       	ret
for (tmr = 1000; tmr; tmr--) {	/* Wait for data packet in timeout of 100ms */
		token = rcv_spi();
		if (token != 0xFF) break;
		DLY_US(100);
	}
	if (token != 0xFE) return 0;		/* If not valid data token, retutn with error */
    4520:	8e 3f       	cpi	r24, 0xFE	; 254
    4522:	d1 f7       	brne	.-12     	; 0x4518 <rcvr_datablock+0x2e>


	do {							/* Receive the data block into buffer */
		rcvr_spi_m(buff++);
    4524:	9f ef       	ldi	r25, 0xFF	; 255
    4526:	9e bd       	out	0x2e, r25	; 46
    4528:	0d b4       	in	r0, 0x2d	; 45
    452a:	07 fe       	sbrs	r0, 7
    452c:	fd cf       	rjmp	.-6      	; 0x4528 <rcvr_datablock+0x3e>
    452e:	8e b5       	in	r24, 0x2e	; 46
    4530:	80 83       	st	Z, r24
		rcvr_spi_m(buff++);
    4532:	9e bd       	out	0x2e, r25	; 46
    4534:	0d b4       	in	r0, 0x2d	; 45
    4536:	07 fe       	sbrs	r0, 7
    4538:	fd cf       	rjmp	.-6      	; 0x4534 <rcvr_datablock+0x4a>
    453a:	8e b5       	in	r24, 0x2e	; 46
    453c:	81 83       	std	Z+1, r24	; 0x01
		rcvr_spi_m(buff++);
    453e:	9e bd       	out	0x2e, r25	; 46
    4540:	0d b4       	in	r0, 0x2d	; 45
    4542:	07 fe       	sbrs	r0, 7
    4544:	fd cf       	rjmp	.-6      	; 0x4540 <rcvr_datablock+0x56>
    4546:	8e b5       	in	r24, 0x2e	; 46
    4548:	82 83       	std	Z+2, r24	; 0x02
		rcvr_spi_m(buff++);
    454a:	9e bd       	out	0x2e, r25	; 46
    454c:	0d b4       	in	r0, 0x2d	; 45
    454e:	07 fe       	sbrs	r0, 7
    4550:	fd cf       	rjmp	.-6      	; 0x454c <rcvr_datablock+0x62>
    4552:	8e b5       	in	r24, 0x2e	; 46
    4554:	83 83       	std	Z+3, r24	; 0x03
	} while (btr -= 4);
    4556:	64 50       	subi	r22, 0x04	; 4
    4558:	70 40       	sbci	r23, 0x00	; 0
    455a:	11 f0       	breq	.+4      	; 0x4560 <rcvr_datablock+0x76>
static
int rcvr_datablock (	/* 1:OK, 0:Failed */
	BYTE *buff,			/* Data buffer to store received data */
	UINT btr			/* Byte count */
)
{
    455c:	34 96       	adiw	r30, 0x04	; 4
    455e:	e3 cf       	rjmp	.-58     	; 0x4526 <rcvr_datablock+0x3c>

//receive an SPI byte
static
BYTE rcv_spi(void)
{
	SPDR = 0xff;
    4560:	8f ef       	ldi	r24, 0xFF	; 255
    4562:	8e bd       	out	0x2e, r24	; 46
	while(!(SPSR & _BV(SPIF)));
    4564:	0d b4       	in	r0, 0x2d	; 45
    4566:	07 fe       	sbrs	r0, 7
    4568:	fd cf       	rjmp	.-6      	; 0x4564 <rcvr_datablock+0x7a>
	return SPDR;
    456a:	8e b5       	in	r24, 0x2e	; 46

//receive an SPI byte
static
BYTE rcv_spi(void)
{
	SPDR = 0xff;
    456c:	8f ef       	ldi	r24, 0xFF	; 255
    456e:	8e bd       	out	0x2e, r24	; 46
	while(!(SPSR & _BV(SPIF)));
    4570:	0d b4       	in	r0, 0x2d	; 45
    4572:	07 fe       	sbrs	r0, 7
    4574:	fd cf       	rjmp	.-6      	; 0x4570 <rcvr_datablock+0x86>
	return SPDR;
    4576:	8e b5       	in	r24, 0x2e	; 46
    4578:	21 e0       	ldi	r18, 0x01	; 1
    457a:	30 e0       	ldi	r19, 0x00	; 0
    457c:	cf cf       	rjmp	.-98     	; 0x451c <rcvr_datablock+0x32>

0000457e <xmit_datablock>:
static
int xmit_datablock (	/* 1:OK, 0:Failed */
	const BYTE *buff,	/* 512 byte data block to be transmitted */
	BYTE token			/* Data/Stop token */
)
{
    457e:	1f 93       	push	r17
    4580:	cf 93       	push	r28
    4582:	df 93       	push	r29
    4584:	ec 01       	movw	r28, r24
    4586:	16 2f       	mov	r17, r22
	BYTE resp, wc;


	if (!wait_ready()) return 0;
    4588:	0e 94 44 22 	call	0x4488	; 0x4488 <wait_ready>
    458c:	89 2b       	or	r24, r25
    458e:	c1 f0       	breq	.+48     	; 0x45c0 <xmit_datablock+0x42>

//send an SPI byte
static
BYTE xmit_spi(BYTE val)
{
	SPDR = val;
    4590:	1e bd       	out	0x2e, r17	; 46
	while(!(SPSR & _BV(SPIF)));
    4592:	0d b4       	in	r0, 0x2d	; 45
    4594:	07 fe       	sbrs	r0, 7
    4596:	fd cf       	rjmp	.-6      	; 0x4592 <xmit_datablock+0x14>
	return SPDR;
    4598:	8e b5       	in	r24, 0x2e	; 46


	if (!wait_ready()) return 0;

	xmit_spi(token);					/* Xmit data token */
	if (token != 0xFD) {	/* Is data token */
    459a:	1d 3f       	cpi	r17, 0xFD	; 253
    459c:	c1 f1       	breq	.+112    	; 0x460e <xmit_datablock+0x90>
    459e:	90 e0       	ldi	r25, 0x00	; 0
		wc = 0;
		do {							/* Xmit the 512 byte data block to MMC */
			xmit_spi(*buff++);
    45a0:	88 81       	ld	r24, Y

//send an SPI byte
static
BYTE xmit_spi(BYTE val)
{
	SPDR = val;
    45a2:	8e bd       	out	0x2e, r24	; 46
	while(!(SPSR & _BV(SPIF)));
    45a4:	0d b4       	in	r0, 0x2d	; 45
    45a6:	07 fe       	sbrs	r0, 7
    45a8:	fd cf       	rjmp	.-6      	; 0x45a4 <xmit_datablock+0x26>
	return SPDR;
    45aa:	8e b5       	in	r24, 0x2e	; 46
	xmit_spi(token);					/* Xmit data token */
	if (token != 0xFD) {	/* Is data token */
		wc = 0;
		do {							/* Xmit the 512 byte data block to MMC */
			xmit_spi(*buff++);
			xmit_spi(*buff++);
    45ac:	89 81       	ldd	r24, Y+1	; 0x01

//send an SPI byte
static
BYTE xmit_spi(BYTE val)
{
	SPDR = val;
    45ae:	8e bd       	out	0x2e, r24	; 46
	while(!(SPSR & _BV(SPIF)));
    45b0:	0d b4       	in	r0, 0x2d	; 45
    45b2:	07 fe       	sbrs	r0, 7
    45b4:	fd cf       	rjmp	.-6      	; 0x45b0 <xmit_datablock+0x32>
	return SPDR;
    45b6:	8e b5       	in	r24, 0x2e	; 46
	if (token != 0xFD) {	/* Is data token */
		wc = 0;
		do {							/* Xmit the 512 byte data block to MMC */
			xmit_spi(*buff++);
			xmit_spi(*buff++);
		} while (--wc);
    45b8:	91 50       	subi	r25, 0x01	; 1
    45ba:	49 f0       	breq	.+18     	; 0x45ce <xmit_datablock+0x50>
static
int xmit_datablock (	/* 1:OK, 0:Failed */
	const BYTE *buff,	/* 512 byte data block to be transmitted */
	BYTE token			/* Data/Stop token */
)
{
    45bc:	22 96       	adiw	r28, 0x02	; 2
    45be:	f0 cf       	rjmp	.-32     	; 0x45a0 <xmit_datablock+0x22>
	BYTE resp, wc;


	if (!wait_ready()) return 0;
    45c0:	20 e0       	ldi	r18, 0x00	; 0
    45c2:	30 e0       	ldi	r19, 0x00	; 0
		if ((resp & 0x1F) != 0x05)		/* If not accepted, return with error */
			return 0;
	}

	return 1;
}
    45c4:	c9 01       	movw	r24, r18
    45c6:	df 91       	pop	r29
    45c8:	cf 91       	pop	r28
    45ca:	1f 91       	pop	r17
    45cc:	08 95       	ret

//send an SPI byte
static
BYTE xmit_spi(BYTE val)
{
	SPDR = val;
    45ce:	8f ef       	ldi	r24, 0xFF	; 255
    45d0:	8e bd       	out	0x2e, r24	; 46
	while(!(SPSR & _BV(SPIF)));
    45d2:	0d b4       	in	r0, 0x2d	; 45
    45d4:	07 fe       	sbrs	r0, 7
    45d6:	fd cf       	rjmp	.-6      	; 0x45d2 <xmit_datablock+0x54>
	return SPDR;
    45d8:	8e b5       	in	r24, 0x2e	; 46

//send an SPI byte
static
BYTE xmit_spi(BYTE val)
{
	SPDR = val;
    45da:	8f ef       	ldi	r24, 0xFF	; 255
    45dc:	8e bd       	out	0x2e, r24	; 46
	while(!(SPSR & _BV(SPIF)));
    45de:	0d b4       	in	r0, 0x2d	; 45
    45e0:	07 fe       	sbrs	r0, 7
    45e2:	fd cf       	rjmp	.-6      	; 0x45de <xmit_datablock+0x60>
	return SPDR;
    45e4:	8e b5       	in	r24, 0x2e	; 46

//receive an SPI byte
static
BYTE rcv_spi(void)
{
	SPDR = 0xff;
    45e6:	8f ef       	ldi	r24, 0xFF	; 255
    45e8:	8e bd       	out	0x2e, r24	; 46
	while(!(SPSR & _BV(SPIF)));
    45ea:	0d b4       	in	r0, 0x2d	; 45
    45ec:	07 fe       	sbrs	r0, 7
    45ee:	fd cf       	rjmp	.-6      	; 0x45ea <xmit_datablock+0x6c>
	return SPDR;
    45f0:	8e b5       	in	r24, 0x2e	; 46
    45f2:	90 e0       	ldi	r25, 0x00	; 0
    45f4:	8f 71       	andi	r24, 0x1F	; 31
    45f6:	85 30       	cpi	r24, 0x05	; 5
    45f8:	09 f0       	breq	.+2      	; 0x45fc <xmit_datablock+0x7e>
    45fa:	91 e0       	ldi	r25, 0x01	; 1
    45fc:	81 e0       	ldi	r24, 0x01	; 1
    45fe:	98 27       	eor	r25, r24
    4600:	29 2f       	mov	r18, r25
    4602:	30 e0       	ldi	r19, 0x00	; 0
		if ((resp & 0x1F) != 0x05)		/* If not accepted, return with error */
			return 0;
	}

	return 1;
}
    4604:	c9 01       	movw	r24, r18
    4606:	df 91       	pop	r29
    4608:	cf 91       	pop	r28
    460a:	1f 91       	pop	r17
    460c:	08 95       	ret


	if (!wait_ready()) return 0;

	xmit_spi(token);					/* Xmit data token */
	if (token != 0xFD) {	/* Is data token */
    460e:	21 e0       	ldi	r18, 0x01	; 1
    4610:	30 e0       	ldi	r19, 0x00	; 0
		if ((resp & 0x1F) != 0x05)		/* If not accepted, return with error */
			return 0;
	}

	return 1;
}
    4612:	c9 01       	movw	r24, r18
    4614:	df 91       	pop	r29
    4616:	cf 91       	pop	r28
    4618:	1f 91       	pop	r17
    461a:	08 95       	ret

0000461c <send_cmd>:
static
BYTE send_cmd (		/* Returns command response (bit7==1:Send failed)*/
	BYTE cmd,		/* Command byte */
	DWORD arg		/* Argument */
)
{
    461c:	df 92       	push	r13
    461e:	ef 92       	push	r14
    4620:	ff 92       	push	r15
    4622:	0f 93       	push	r16
    4624:	1f 93       	push	r17
    4626:	d8 2e       	mov	r13, r24
    4628:	7a 01       	movw	r14, r20
    462a:	8b 01       	movw	r16, r22
	BYTE n, res;


	if (cmd & 0x80) {	/* ACMD<n> is the command sequense of CMD55-CMD<n> */
    462c:	87 fd       	sbrc	r24, 7
    462e:	63 c0       	rjmp	.+198    	; 0x46f6 <send_cmd+0xda>
static
void deselect (void)
{
 BYTE d;
 
 DESELECT();
    4630:	2a 9a       	sbi	0x05, 2	; 5

//receive an SPI byte
static
BYTE rcv_spi(void)
{
	SPDR = 0xff;
    4632:	8f ef       	ldi	r24, 0xFF	; 255
    4634:	8e bd       	out	0x2e, r24	; 46
	while(!(SPSR & _BV(SPIF)));
    4636:	0d b4       	in	r0, 0x2d	; 45
    4638:	07 fe       	sbrs	r0, 7
    463a:	fd cf       	rjmp	.-6      	; 0x4636 <send_cmd+0x1a>
	return SPDR;
    463c:	8e b5       	in	r24, 0x2e	; 46
		if (res > 1) return res;
	}

	/* Select the card and wait for ready */
	deselect();
	if (!select()) return 0xFF;
    463e:	0e 94 61 22 	call	0x44c2	; 0x44c2 <select>
    4642:	89 2b       	or	r24, r25
    4644:	09 f4       	brne	.+2      	; 0x4648 <send_cmd+0x2c>
    4646:	47 c0       	rjmp	.+142    	; 0x46d6 <send_cmd+0xba>

	/* Send command packet */
	xmit_spi(0x40 | cmd);				/* Start + Command index */
    4648:	8d 2d       	mov	r24, r13
    464a:	80 64       	ori	r24, 0x40	; 64

//send an SPI byte
static
BYTE xmit_spi(BYTE val)
{
	SPDR = val;
    464c:	8e bd       	out	0x2e, r24	; 46
	while(!(SPSR & _BV(SPIF)));
    464e:	0d b4       	in	r0, 0x2d	; 45
    4650:	07 fe       	sbrs	r0, 7
    4652:	fd cf       	rjmp	.-6      	; 0x464e <send_cmd+0x32>
	return SPDR;
    4654:	8e b5       	in	r24, 0x2e	; 46
	deselect();
	if (!select()) return 0xFF;

	/* Send command packet */
	xmit_spi(0x40 | cmd);				/* Start + Command index */
	xmit_spi((BYTE)(arg >> 24));		/* Argument[31..24] */
    4656:	81 2f       	mov	r24, r17
    4658:	99 27       	eor	r25, r25
    465a:	aa 27       	eor	r26, r26
    465c:	bb 27       	eor	r27, r27

//send an SPI byte
static
BYTE xmit_spi(BYTE val)
{
	SPDR = val;
    465e:	8e bd       	out	0x2e, r24	; 46
	while(!(SPSR & _BV(SPIF)));
    4660:	0d b4       	in	r0, 0x2d	; 45
    4662:	07 fe       	sbrs	r0, 7
    4664:	fd cf       	rjmp	.-6      	; 0x4660 <send_cmd+0x44>
	return SPDR;
    4666:	8e b5       	in	r24, 0x2e	; 46
	if (!select()) return 0xFF;

	/* Send command packet */
	xmit_spi(0x40 | cmd);				/* Start + Command index */
	xmit_spi((BYTE)(arg >> 24));		/* Argument[31..24] */
	xmit_spi((BYTE)(arg >> 16));		/* Argument[23..16] */
    4668:	c8 01       	movw	r24, r16
    466a:	aa 27       	eor	r26, r26
    466c:	bb 27       	eor	r27, r27

//send an SPI byte
static
BYTE xmit_spi(BYTE val)
{
	SPDR = val;
    466e:	8e bd       	out	0x2e, r24	; 46
	while(!(SPSR & _BV(SPIF)));
    4670:	0d b4       	in	r0, 0x2d	; 45
    4672:	07 fe       	sbrs	r0, 7
    4674:	fd cf       	rjmp	.-6      	; 0x4670 <send_cmd+0x54>
	return SPDR;
    4676:	8e b5       	in	r24, 0x2e	; 46

	/* Send command packet */
	xmit_spi(0x40 | cmd);				/* Start + Command index */
	xmit_spi((BYTE)(arg >> 24));		/* Argument[31..24] */
	xmit_spi((BYTE)(arg >> 16));		/* Argument[23..16] */
	xmit_spi((BYTE)(arg >> 8));			/* Argument[15..8] */
    4678:	bb 27       	eor	r27, r27
    467a:	a1 2f       	mov	r26, r17
    467c:	90 2f       	mov	r25, r16
    467e:	8f 2d       	mov	r24, r15

//send an SPI byte
static
BYTE xmit_spi(BYTE val)
{
	SPDR = val;
    4680:	8e bd       	out	0x2e, r24	; 46
	while(!(SPSR & _BV(SPIF)));
    4682:	0d b4       	in	r0, 0x2d	; 45
    4684:	07 fe       	sbrs	r0, 7
    4686:	fd cf       	rjmp	.-6      	; 0x4682 <send_cmd+0x66>
	return SPDR;
    4688:	8e b5       	in	r24, 0x2e	; 46

//send an SPI byte
static
BYTE xmit_spi(BYTE val)
{
	SPDR = val;
    468a:	ee bc       	out	0x2e, r14	; 46
	while(!(SPSR & _BV(SPIF)));
    468c:	0d b4       	in	r0, 0x2d	; 45
    468e:	07 fe       	sbrs	r0, 7
    4690:	fd cf       	rjmp	.-6      	; 0x468c <send_cmd+0x70>
	return SPDR;
    4692:	8e b5       	in	r24, 0x2e	; 46
	xmit_spi((BYTE)(arg >> 24));		/* Argument[31..24] */
	xmit_spi((BYTE)(arg >> 16));		/* Argument[23..16] */
	xmit_spi((BYTE)(arg >> 8));			/* Argument[15..8] */
	xmit_spi((BYTE)arg);				/* Argument[7..0] */
	n = 0x01;							/* Dummy CRC + Stop */
	if (cmd == CMD0) n = 0x95;			/* Valid CRC for CMD0(0) */
    4694:	dd 20       	and	r13, r13
    4696:	d1 f4       	brne	.+52     	; 0x46cc <send_cmd+0xb0>
    4698:	85 e9       	ldi	r24, 0x95	; 149

//send an SPI byte
static
BYTE xmit_spi(BYTE val)
{
	SPDR = val;
    469a:	8e bd       	out	0x2e, r24	; 46
	while(!(SPSR & _BV(SPIF)));
    469c:	0d b4       	in	r0, 0x2d	; 45
    469e:	07 fe       	sbrs	r0, 7
    46a0:	fd cf       	rjmp	.-6      	; 0x469c <send_cmd+0x80>
	return SPDR;
    46a2:	8e b5       	in	r24, 0x2e	; 46
	if (cmd == CMD0) n = 0x95;			/* Valid CRC for CMD0(0) */
	if (cmd == CMD8) n = 0x87;			/* Valid CRC for CMD8(0x1AA) */
	xmit_spi(n);

	/* Receive command response */
	if (cmd == CMD12) rcv_spi();		/* Skip a stuff byte when stop reading */
    46a4:	8c e0       	ldi	r24, 0x0C	; 12
    46a6:	d8 16       	cp	r13, r24
    46a8:	f9 f0       	breq	.+62     	; 0x46e8 <send_cmd+0xcc>
static
BYTE rcv_spi(void)
{
	SPDR = 0xff;
	while(!(SPSR & _BV(SPIF)));
	return SPDR;
    46aa:	9a e0       	ldi	r25, 0x0A	; 10

//receive an SPI byte
static
BYTE rcv_spi(void)
{
	SPDR = 0xff;
    46ac:	2f ef       	ldi	r18, 0xFF	; 255
    46ae:	2e bd       	out	0x2e, r18	; 46
	while(!(SPSR & _BV(SPIF)));
    46b0:	0d b4       	in	r0, 0x2d	; 45
    46b2:	07 fe       	sbrs	r0, 7
    46b4:	fd cf       	rjmp	.-6      	; 0x46b0 <send_cmd+0x94>
	return SPDR;
    46b6:	8e b5       	in	r24, 0x2e	; 46
	/* Receive command response */
	if (cmd == CMD12) rcv_spi();		/* Skip a stuff byte when stop reading */
	n = 10;								/* Wait for a valid response in timeout of 10 attempts */
	do
		res = rcv_spi();
	while ((res & 0x80) && --n);
    46b8:	87 ff       	sbrs	r24, 7
    46ba:	02 c0       	rjmp	.+4      	; 0x46c0 <send_cmd+0xa4>
    46bc:	91 50       	subi	r25, 0x01	; 1
    46be:	b9 f7       	brne	.-18     	; 0x46ae <send_cmd+0x92>

	return res;			/* Return with the response value */
}
    46c0:	1f 91       	pop	r17
    46c2:	0f 91       	pop	r16
    46c4:	ff 90       	pop	r15
    46c6:	ef 90       	pop	r14
    46c8:	df 90       	pop	r13
    46ca:	08 95       	ret
	xmit_spi((BYTE)(arg >> 16));		/* Argument[23..16] */
	xmit_spi((BYTE)(arg >> 8));			/* Argument[15..8] */
	xmit_spi((BYTE)arg);				/* Argument[7..0] */
	n = 0x01;							/* Dummy CRC + Stop */
	if (cmd == CMD0) n = 0x95;			/* Valid CRC for CMD0(0) */
	if (cmd == CMD8) n = 0x87;			/* Valid CRC for CMD8(0x1AA) */
    46cc:	88 e0       	ldi	r24, 0x08	; 8
    46ce:	d8 16       	cp	r13, r24
    46d0:	49 f4       	brne	.+18     	; 0x46e4 <send_cmd+0xc8>
    46d2:	87 e8       	ldi	r24, 0x87	; 135
    46d4:	e2 cf       	rjmp	.-60     	; 0x469a <send_cmd+0x7e>
		if (res > 1) return res;
	}

	/* Select the card and wait for ready */
	deselect();
	if (!select()) return 0xFF;
    46d6:	8f ef       	ldi	r24, 0xFF	; 255
	do
		res = rcv_spi();
	while ((res & 0x80) && --n);

	return res;			/* Return with the response value */
}
    46d8:	1f 91       	pop	r17
    46da:	0f 91       	pop	r16
    46dc:	ff 90       	pop	r15
    46de:	ef 90       	pop	r14
    46e0:	df 90       	pop	r13
    46e2:	08 95       	ret
	xmit_spi((BYTE)(arg >> 16));		/* Argument[23..16] */
	xmit_spi((BYTE)(arg >> 8));			/* Argument[15..8] */
	xmit_spi((BYTE)arg);				/* Argument[7..0] */
	n = 0x01;							/* Dummy CRC + Stop */
	if (cmd == CMD0) n = 0x95;			/* Valid CRC for CMD0(0) */
	if (cmd == CMD8) n = 0x87;			/* Valid CRC for CMD8(0x1AA) */
    46e4:	81 e0       	ldi	r24, 0x01	; 1
    46e6:	d9 cf       	rjmp	.-78     	; 0x469a <send_cmd+0x7e>

//receive an SPI byte
static
BYTE rcv_spi(void)
{
	SPDR = 0xff;
    46e8:	8f ef       	ldi	r24, 0xFF	; 255
    46ea:	8e bd       	out	0x2e, r24	; 46
	while(!(SPSR & _BV(SPIF)));
    46ec:	0d b4       	in	r0, 0x2d	; 45
    46ee:	07 fe       	sbrs	r0, 7
    46f0:	fd cf       	rjmp	.-6      	; 0x46ec <send_cmd+0xd0>
	return SPDR;
    46f2:	8e b5       	in	r24, 0x2e	; 46
    46f4:	da cf       	rjmp	.-76     	; 0x46aa <send_cmd+0x8e>
	BYTE n, res;


	if (cmd & 0x80) {	/* ACMD<n> is the command sequense of CMD55-CMD<n> */
		cmd &= 0x7F;
		res = send_cmd(CMD55, 0);
    46f6:	87 e3       	ldi	r24, 0x37	; 55
    46f8:	40 e0       	ldi	r20, 0x00	; 0
    46fa:	50 e0       	ldi	r21, 0x00	; 0
    46fc:	60 e0       	ldi	r22, 0x00	; 0
    46fe:	70 e0       	ldi	r23, 0x00	; 0
    4700:	0e 94 0e 23 	call	0x461c	; 0x461c <send_cmd>
		if (res > 1) return res;
    4704:	82 30       	cpi	r24, 0x02	; 2
    4706:	e0 f6       	brcc	.-72     	; 0x46c0 <send_cmd+0xa4>
{
	BYTE n, res;


	if (cmd & 0x80) {	/* ACMD<n> is the command sequense of CMD55-CMD<n> */
		cmd &= 0x7F;
    4708:	8f e7       	ldi	r24, 0x7F	; 127
    470a:	d8 22       	and	r13, r24
    470c:	91 cf       	rjmp	.-222    	; 0x4630 <send_cmd+0x14>

0000470e <disk_status>:

DSTATUS disk_status (
	BYTE drv			/* Drive number (0) */
)
{
	DSTATUS s = Stat;
    470e:	90 91 c6 03 	lds	r25, 0x03C6


	if (drv || !INS) {
    4712:	88 23       	and	r24, r24
    4714:	29 f4       	brne	.+10     	; 0x4720 <disk_status+0x12>
	} else {
		s &= ~STA_NODISK;
		if (WP)
			s |= STA_PROTECT;
		else
			s &= ~STA_PROTECT;
    4716:	89 2f       	mov	r24, r25
    4718:	89 7f       	andi	r24, 0xF9	; 249
	}
	Stat = s;
    471a:	80 93 c6 03 	sts	0x03C6, r24

	return s;
}
    471e:	08 95       	ret
)
{
	DSTATUS s = Stat;


	if (drv || !INS) {
    4720:	83 e0       	ldi	r24, 0x03	; 3
		if (WP)
			s |= STA_PROTECT;
		else
			s &= ~STA_PROTECT;
	}
	Stat = s;
    4722:	80 93 c6 03 	sts	0x03C6, r24

	return s;
}
    4726:	08 95       	ret

00004728 <disk_initialize>:
/*-----------------------------------------------------------------------*/

DSTATUS disk_initialize (
	BYTE drv		/* Physical drive nmuber (0) */
)
{
    4728:	af 92       	push	r10
    472a:	bf 92       	push	r11
    472c:	cf 92       	push	r12
    472e:	df 92       	push	r13
    4730:	ff 92       	push	r15
    4732:	0f 93       	push	r16
    4734:	1f 93       	push	r17
    4736:	df 93       	push	r29
    4738:	cf 93       	push	r28
    473a:	00 d0       	rcall	.+0      	; 0x473c <disk_initialize+0x14>
    473c:	00 d0       	rcall	.+0      	; 0x473e <disk_initialize+0x16>
    473e:	cd b7       	in	r28, 0x3d	; 61
    4740:	de b7       	in	r29, 0x3e	; 62

DSTATUS disk_status (
	BYTE drv			/* Drive number (0) */
)
{
	DSTATUS s = Stat;
    4742:	90 91 c6 03 	lds	r25, 0x03C6


	if (drv || !INS) {
    4746:	88 23       	and	r24, r24
    4748:	c9 f5       	brne	.+114    	; 0x47bc <disk_initialize+0x94>
	} else {
		s &= ~STA_NODISK;
		if (WP)
			s |= STA_PROTECT;
		else
			s &= ~STA_PROTECT;
    474a:	e9 ef       	ldi	r30, 0xF9	; 249
    474c:	fe 2e       	mov	r15, r30
    474e:	f9 22       	and	r15, r25
	}
	Stat = s;
    4750:	f0 92 c6 03 	sts	0x03C6, r15
#define rcvr_spi_m(dst)	SPDR=0xFF; loop_until_bit_is_set(SPSR,SPIF); *(dst)=SPDR

static
void init_spi(void)
{
	DDR_INI();
    4754:	84 b1       	in	r24, 0x04	; 4
    4756:	84 6a       	ori	r24, 0xA4	; 164
    4758:	84 b9       	out	0x04, r24	; 4

//spi low speed for initialization
static
void SPI_Low_Speed(void)
{
	SPCR =   _BV(SPE)|_BV(MSTR)|_BV(SPR1)|_BV(SPR0);
    475a:	83 e5       	ldi	r24, 0x53	; 83
    475c:	8c bd       	out	0x2c, r24	; 44
	SPSR &= ~_BV(SPI2X);
    475e:	8d b5       	in	r24, 0x2d	; 45
    4760:	8e 7f       	andi	r24, 0xFE	; 254
    4762:	8d bd       	out	0x2d, r24	; 45
static
void init_spi(void)
{
	DDR_INI();
	SPI_Low_Speed();
	SD_Deassert();
    4764:	2a 9a       	sbi	0x05, 2	; 5
static
void deselect (void)
{
 BYTE d;
 
 DESELECT();
    4766:	2a 9a       	sbi	0x05, 2	; 5

//receive an SPI byte
static
BYTE rcv_spi(void)
{
	SPDR = 0xff;
    4768:	8f ef       	ldi	r24, 0xFF	; 255
    476a:	8e bd       	out	0x2e, r24	; 46
	while(!(SPSR & _BV(SPIF)));
    476c:	0d b4       	in	r0, 0x2d	; 45
    476e:	07 fe       	sbrs	r0, 7
    4770:	fd cf       	rjmp	.-6      	; 0x476c <disk_initialize+0x44>
	return SPDR;
    4772:	8e b5       	in	r24, 0x2e	; 46
    4774:	8a e0       	ldi	r24, 0x0A	; 10

//receive an SPI byte
static
BYTE rcv_spi(void)
{
	SPDR = 0xff;
    4776:	9f ef       	ldi	r25, 0xFF	; 255
    4778:	9e bd       	out	0x2e, r25	; 46
	while(!(SPSR & _BV(SPIF)));
    477a:	0d b4       	in	r0, 0x2d	; 45
    477c:	07 fe       	sbrs	r0, 7
    477e:	fd cf       	rjmp	.-6      	; 0x477a <disk_initialize+0x52>
	return SPDR;
    4780:	2e b5       	in	r18, 0x2e	; 46
	s = disk_status(drv);		/* Check if card is in the socket */
	if (s & STA_NODISK) return s;
	
	init_spi();		/* Initialize ports to control MMC */
	deselect();
	for (n = 10; n; n--) rcv_spi();	/* 80 dummy clocks with CS=H */
    4782:	81 50       	subi	r24, 0x01	; 1
    4784:	c9 f7       	brne	.-14     	; 0x4778 <disk_initialize+0x50>

	ty = 0;
	if (send_cmd(CMD0, 0) == 1) {			/* Enter Idle state */
    4786:	40 e0       	ldi	r20, 0x00	; 0
    4788:	50 e0       	ldi	r21, 0x00	; 0
    478a:	60 e0       	ldi	r22, 0x00	; 0
    478c:	70 e0       	ldi	r23, 0x00	; 0
    478e:	0e 94 0e 23 	call	0x461c	; 0x461c <send_cmd>
    4792:	81 30       	cpi	r24, 0x01	; 1
    4794:	39 f1       	breq	.+78     	; 0x47e4 <disk_initialize+0xbc>

//spi full speed
static
void SPI_High_Speed(void)
{
	SPCR =  _BV(SPE)|_BV(MSTR);
    4796:	80 e5       	ldi	r24, 0x50	; 80
    4798:	8c bd       	out	0x2c, r24	; 44
	SPSR |= _BV(SPI2X);
    479a:	8d b5       	in	r24, 0x2d	; 45
    479c:	81 60       	ori	r24, 0x01	; 1
    479e:	8d bd       	out	0x2d, r24	; 45
			if (!tmr || send_cmd(CMD16, 512) != 0)	/* Set R/W block length to 512 */
				ty = 0;
		}
	}
	SPI_High_Speed();
	CardType = ty;
    47a0:	10 92 21 07 	sts	0x0721, r1
	if (ty)		/* Initialization succeded */
		s &= ~STA_NOINIT;
	else		/* Initialization failed */
		s |= STA_NOINIT;
    47a4:	f1 e0       	ldi	r31, 0x01	; 1
    47a6:	ff 2a       	or	r15, r31
	Stat = s;
    47a8:	f0 92 c6 03 	sts	0x03C6, r15
static
void deselect (void)
{
 BYTE d;
 
 DESELECT();
    47ac:	2a 9a       	sbi	0x05, 2	; 5

//receive an SPI byte
static
BYTE rcv_spi(void)
{
	SPDR = 0xff;
    47ae:	8f ef       	ldi	r24, 0xFF	; 255
    47b0:	8e bd       	out	0x2e, r24	; 46
	while(!(SPSR & _BV(SPIF)));
    47b2:	0d b4       	in	r0, 0x2d	; 45
    47b4:	07 fe       	sbrs	r0, 7
    47b6:	fd cf       	rjmp	.-6      	; 0x47b2 <disk_initialize+0x8a>
	return SPDR;
    47b8:	8e b5       	in	r24, 0x2e	; 46
    47ba:	05 c0       	rjmp	.+10     	; 0x47c6 <disk_initialize+0x9e>
		if (WP)
			s |= STA_PROTECT;
		else
			s &= ~STA_PROTECT;
	}
	Stat = s;
    47bc:	83 e0       	ldi	r24, 0x03	; 3
    47be:	80 93 c6 03 	sts	0x03C6, r24
    47c2:	43 e0       	ldi	r20, 0x03	; 3
    47c4:	f4 2e       	mov	r15, r20
	Stat = s;

	deselect();

	return s;
}
    47c6:	8f 2d       	mov	r24, r15
    47c8:	0f 90       	pop	r0
    47ca:	0f 90       	pop	r0
    47cc:	0f 90       	pop	r0
    47ce:	0f 90       	pop	r0
    47d0:	cf 91       	pop	r28
    47d2:	df 91       	pop	r29
    47d4:	1f 91       	pop	r17
    47d6:	0f 91       	pop	r16
    47d8:	ff 90       	pop	r15
    47da:	df 90       	pop	r13
    47dc:	cf 90       	pop	r12
    47de:	bf 90       	pop	r11
    47e0:	af 90       	pop	r10
    47e2:	08 95       	ret
	deselect();
	for (n = 10; n; n--) rcv_spi();	/* 80 dummy clocks with CS=H */

	ty = 0;
	if (send_cmd(CMD0, 0) == 1) {			/* Enter Idle state */
		if (send_cmd(CMD8, 0x1AA) == 1) {	/* SDv2? */
    47e4:	88 e0       	ldi	r24, 0x08	; 8
    47e6:	4a ea       	ldi	r20, 0xAA	; 170
    47e8:	51 e0       	ldi	r21, 0x01	; 1
    47ea:	60 e0       	ldi	r22, 0x00	; 0
    47ec:	70 e0       	ldi	r23, 0x00	; 0
    47ee:	0e 94 0e 23 	call	0x461c	; 0x461c <send_cmd>
    47f2:	81 30       	cpi	r24, 0x01	; 1
    47f4:	a9 f5       	brne	.+106    	; 0x4860 <disk_initialize+0x138>
    47f6:	6e 01       	movw	r12, r28
    47f8:	08 94       	sec
    47fa:	c1 1c       	adc	r12, r1
    47fc:	d1 1c       	adc	r13, r1
    47fe:	f6 01       	movw	r30, r12
    4800:	75 e0       	ldi	r23, 0x05	; 5
    4802:	a7 2e       	mov	r10, r23
    4804:	b1 2c       	mov	r11, r1
    4806:	ac 0e       	add	r10, r28
    4808:	bd 1e       	adc	r11, r29

//receive an SPI byte
static
BYTE rcv_spi(void)
{
	SPDR = 0xff;
    480a:	9f ef       	ldi	r25, 0xFF	; 255
    480c:	9e bd       	out	0x2e, r25	; 46
	while(!(SPSR & _BV(SPIF)));
    480e:	0d b4       	in	r0, 0x2d	; 45
    4810:	07 fe       	sbrs	r0, 7
    4812:	fd cf       	rjmp	.-6      	; 0x480e <disk_initialize+0xe6>
	return SPDR;
    4814:	8e b5       	in	r24, 0x2e	; 46
	for (n = 10; n; n--) rcv_spi();	/* 80 dummy clocks with CS=H */

	ty = 0;
	if (send_cmd(CMD0, 0) == 1) {			/* Enter Idle state */
		if (send_cmd(CMD8, 0x1AA) == 1) {	/* SDv2? */
			for (n = 0; n < 4; n++) buf[n] = rcv_spi();		/* Get trailing return value of R7 resp */
    4816:	81 93       	st	Z+, r24
    4818:	ea 15       	cp	r30, r10
    481a:	fb 05       	cpc	r31, r11
    481c:	b9 f7       	brne	.-18     	; 0x480c <disk_initialize+0xe4>
			if (buf[2] == 0x01 && buf[3] == 0xAA) {		/* The card can work at vdd range of 2.7-3.6V */
    481e:	8b 81       	ldd	r24, Y+3	; 0x03
    4820:	81 30       	cpi	r24, 0x01	; 1
    4822:	09 f0       	breq	.+2      	; 0x4826 <disk_initialize+0xfe>
    4824:	b8 cf       	rjmp	.-144    	; 0x4796 <disk_initialize+0x6e>
    4826:	8c 81       	ldd	r24, Y+4	; 0x04
    4828:	8a 3a       	cpi	r24, 0xAA	; 170
    482a:	09 f0       	breq	.+2      	; 0x482e <disk_initialize+0x106>
    482c:	b4 cf       	rjmp	.-152    	; 0x4796 <disk_initialize+0x6e>
    482e:	08 ee       	ldi	r16, 0xE8	; 232
    4830:	13 e0       	ldi	r17, 0x03	; 3
				for (tmr = 1000; tmr; tmr--) {			/* Wait for leaving idle state (ACMD41 with HCS bit) */
					if (send_cmd(ACMD41, 1UL << 30) == 0) break;
    4832:	89 ea       	ldi	r24, 0xA9	; 169
    4834:	40 e0       	ldi	r20, 0x00	; 0
    4836:	50 e0       	ldi	r21, 0x00	; 0
    4838:	60 e0       	ldi	r22, 0x00	; 0
    483a:	70 e4       	ldi	r23, 0x40	; 64
    483c:	0e 94 0e 23 	call	0x461c	; 0x461c <send_cmd>
    4840:	88 23       	and	r24, r24
    4842:	09 f4       	brne	.+2      	; 0x4846 <disk_initialize+0x11e>
    4844:	47 c0       	rjmp	.+142    	; 0x48d4 <disk_initialize+0x1ac>
    4846:	88 ee       	ldi	r24, 0xE8	; 232
    4848:	93 e0       	ldi	r25, 0x03	; 3


static void dly_us (UINT n)
{
	do {	/* 9 clocks per loop on avr-gcc -Os */
		PINB; PINB; PINB; PINB; PINB;
    484a:	23 b1       	in	r18, 0x03	; 3
    484c:	23 b1       	in	r18, 0x03	; 3
    484e:	23 b1       	in	r18, 0x03	; 3
    4850:	23 b1       	in	r18, 0x03	; 3
    4852:	23 b1       	in	r18, 0x03	; 3
	} while (--n);
    4854:	01 97       	sbiw	r24, 0x01	; 1
    4856:	c9 f7       	brne	.-14     	; 0x484a <disk_initialize+0x122>
	ty = 0;
	if (send_cmd(CMD0, 0) == 1) {			/* Enter Idle state */
		if (send_cmd(CMD8, 0x1AA) == 1) {	/* SDv2? */
			for (n = 0; n < 4; n++) buf[n] = rcv_spi();		/* Get trailing return value of R7 resp */
			if (buf[2] == 0x01 && buf[3] == 0xAA) {		/* The card can work at vdd range of 2.7-3.6V */
				for (tmr = 1000; tmr; tmr--) {			/* Wait for leaving idle state (ACMD41 with HCS bit) */
    4858:	01 50       	subi	r16, 0x01	; 1
    485a:	10 40       	sbci	r17, 0x00	; 0
    485c:	51 f7       	brne	.-44     	; 0x4832 <disk_initialize+0x10a>
    485e:	9b cf       	rjmp	.-202    	; 0x4796 <disk_initialize+0x6e>
					for (n = 0; n < 4; n++) buf[n] = rcv_spi();
					ty = (buf[0] & 0x40) ? CT_SD2 | CT_BLOCK : CT_SD2;	/* SDv2 */
				}
			}
		} else {							/* SDv1 or MMCv3 */
			if (send_cmd(ACMD41, 0) <= 1) 	{
    4860:	89 ea       	ldi	r24, 0xA9	; 169
    4862:	40 e0       	ldi	r20, 0x00	; 0
    4864:	50 e0       	ldi	r21, 0x00	; 0
    4866:	60 e0       	ldi	r22, 0x00	; 0
    4868:	70 e0       	ldi	r23, 0x00	; 0
    486a:	0e 94 0e 23 	call	0x461c	; 0x461c <send_cmd>
    486e:	82 30       	cpi	r24, 0x02	; 2
    4870:	d0 f0       	brcs	.+52     	; 0x48a6 <disk_initialize+0x17e>
    4872:	dd 24       	eor	r13, r13
    4874:	d3 94       	inc	r13
    4876:	08 ee       	ldi	r16, 0xE8	; 232
    4878:	13 e0       	ldi	r17, 0x03	; 3
				ty = CT_SD1; cmd = ACMD41;	/* SDv1 */
			} else {
				ty = CT_MMC; cmd = CMD1;	/* MMCv3 */
			}
			for (tmr = 1000; tmr; tmr--) {			/* Wait for leaving idle state */
				if (send_cmd(ACMD41, 0) == 0) break;
    487a:	89 ea       	ldi	r24, 0xA9	; 169
    487c:	40 e0       	ldi	r20, 0x00	; 0
    487e:	50 e0       	ldi	r21, 0x00	; 0
    4880:	60 e0       	ldi	r22, 0x00	; 0
    4882:	70 e0       	ldi	r23, 0x00	; 0
    4884:	0e 94 0e 23 	call	0x461c	; 0x461c <send_cmd>
    4888:	88 23       	and	r24, r24
    488a:	81 f0       	breq	.+32     	; 0x48ac <disk_initialize+0x184>
    488c:	88 ee       	ldi	r24, 0xE8	; 232
    488e:	93 e0       	ldi	r25, 0x03	; 3


static void dly_us (UINT n)
{
	do {	/* 9 clocks per loop on avr-gcc -Os */
		PINB; PINB; PINB; PINB; PINB;
    4890:	23 b1       	in	r18, 0x03	; 3
    4892:	23 b1       	in	r18, 0x03	; 3
    4894:	23 b1       	in	r18, 0x03	; 3
    4896:	23 b1       	in	r18, 0x03	; 3
    4898:	23 b1       	in	r18, 0x03	; 3
	} while (--n);
    489a:	01 97       	sbiw	r24, 0x01	; 1
    489c:	c9 f7       	brne	.-14     	; 0x4890 <disk_initialize+0x168>
			if (send_cmd(ACMD41, 0) <= 1) 	{
				ty = CT_SD1; cmd = ACMD41;	/* SDv1 */
			} else {
				ty = CT_MMC; cmd = CMD1;	/* MMCv3 */
			}
			for (tmr = 1000; tmr; tmr--) {			/* Wait for leaving idle state */
    489e:	01 50       	subi	r16, 0x01	; 1
    48a0:	10 40       	sbci	r17, 0x00	; 0
    48a2:	59 f7       	brne	.-42     	; 0x487a <disk_initialize+0x152>
    48a4:	78 cf       	rjmp	.-272    	; 0x4796 <disk_initialize+0x6e>
					for (n = 0; n < 4; n++) buf[n] = rcv_spi();
					ty = (buf[0] & 0x40) ? CT_SD2 | CT_BLOCK : CT_SD2;	/* SDv2 */
				}
			}
		} else {							/* SDv1 or MMCv3 */
			if (send_cmd(ACMD41, 0) <= 1) 	{
    48a6:	52 e0       	ldi	r21, 0x02	; 2
    48a8:	d5 2e       	mov	r13, r21
    48aa:	e5 cf       	rjmp	.-54     	; 0x4876 <disk_initialize+0x14e>
			}
			for (tmr = 1000; tmr; tmr--) {			/* Wait for leaving idle state */
				if (send_cmd(ACMD41, 0) == 0) break;
				DLY_US(1000);
			}
			if (!tmr || send_cmd(CMD16, 512) != 0)	/* Set R/W block length to 512 */
    48ac:	80 e1       	ldi	r24, 0x10	; 16
    48ae:	40 e0       	ldi	r20, 0x00	; 0
    48b0:	52 e0       	ldi	r21, 0x02	; 2
    48b2:	60 e0       	ldi	r22, 0x00	; 0
    48b4:	70 e0       	ldi	r23, 0x00	; 0
    48b6:	0e 94 0e 23 	call	0x461c	; 0x461c <send_cmd>
    48ba:	88 23       	and	r24, r24
    48bc:	09 f0       	breq	.+2      	; 0x48c0 <disk_initialize+0x198>
    48be:	6b cf       	rjmp	.-298    	; 0x4796 <disk_initialize+0x6e>

//spi full speed
static
void SPI_High_Speed(void)
{
	SPCR =  _BV(SPE)|_BV(MSTR);
    48c0:	80 e5       	ldi	r24, 0x50	; 80
    48c2:	8c bd       	out	0x2c, r24	; 44
	SPSR |= _BV(SPI2X);
    48c4:	8d b5       	in	r24, 0x2d	; 45
    48c6:	81 60       	ori	r24, 0x01	; 1
    48c8:	8d bd       	out	0x2d, r24	; 45
			if (!tmr || send_cmd(CMD16, 512) != 0)	/* Set R/W block length to 512 */
				ty = 0;
		}
	}
	SPI_High_Speed();
	CardType = ty;
    48ca:	d0 92 21 07 	sts	0x0721, r13
	if (ty)		/* Initialization succeded */
		s &= ~STA_NOINIT;
    48ce:	8e ef       	ldi	r24, 0xFE	; 254
    48d0:	f8 22       	and	r15, r24
    48d2:	6a cf       	rjmp	.-300    	; 0x47a8 <disk_initialize+0x80>
			if (buf[2] == 0x01 && buf[3] == 0xAA) {		/* The card can work at vdd range of 2.7-3.6V */
				for (tmr = 1000; tmr; tmr--) {			/* Wait for leaving idle state (ACMD41 with HCS bit) */
					if (send_cmd(ACMD41, 1UL << 30) == 0) break;
					DLY_US(1000);
				}
				if (tmr && send_cmd(CMD58, 0) == 0) {	/* Check CCS bit in the OCR */
    48d4:	8a e3       	ldi	r24, 0x3A	; 58
    48d6:	40 e0       	ldi	r20, 0x00	; 0
    48d8:	50 e0       	ldi	r21, 0x00	; 0
    48da:	60 e0       	ldi	r22, 0x00	; 0
    48dc:	70 e0       	ldi	r23, 0x00	; 0
    48de:	0e 94 0e 23 	call	0x461c	; 0x461c <send_cmd>
    48e2:	88 23       	and	r24, r24
    48e4:	09 f0       	breq	.+2      	; 0x48e8 <disk_initialize+0x1c0>
    48e6:	57 cf       	rjmp	.-338    	; 0x4796 <disk_initialize+0x6e>

//receive an SPI byte
static
BYTE rcv_spi(void)
{
	SPDR = 0xff;
    48e8:	9f ef       	ldi	r25, 0xFF	; 255
    48ea:	9e bd       	out	0x2e, r25	; 46
	while(!(SPSR & _BV(SPIF)));
    48ec:	0d b4       	in	r0, 0x2d	; 45
    48ee:	07 fe       	sbrs	r0, 7
    48f0:	fd cf       	rjmp	.-6      	; 0x48ec <disk_initialize+0x1c4>
	return SPDR;
    48f2:	8e b5       	in	r24, 0x2e	; 46
				for (tmr = 1000; tmr; tmr--) {			/* Wait for leaving idle state (ACMD41 with HCS bit) */
					if (send_cmd(ACMD41, 1UL << 30) == 0) break;
					DLY_US(1000);
				}
				if (tmr && send_cmd(CMD58, 0) == 0) {	/* Check CCS bit in the OCR */
					for (n = 0; n < 4; n++) buf[n] = rcv_spi();
    48f4:	f6 01       	movw	r30, r12
    48f6:	81 93       	st	Z+, r24
    48f8:	6f 01       	movw	r12, r30
    48fa:	ea 15       	cp	r30, r10
    48fc:	fb 05       	cpc	r31, r11
    48fe:	a9 f7       	brne	.-22     	; 0x48ea <disk_initialize+0x1c2>
					ty = (buf[0] & 0x40) ? CT_SD2 | CT_BLOCK : CT_SD2;	/* SDv2 */
    4900:	89 81       	ldd	r24, Y+1	; 0x01
    4902:	86 fd       	sbrc	r24, 6
    4904:	03 c0       	rjmp	.+6      	; 0x490c <disk_initialize+0x1e4>
    4906:	64 e0       	ldi	r22, 0x04	; 4
    4908:	d6 2e       	mov	r13, r22
    490a:	da cf       	rjmp	.-76     	; 0x48c0 <disk_initialize+0x198>
		if (WP)
			s |= STA_PROTECT;
		else
			s &= ~STA_PROTECT;
	}
	Stat = s;
    490c:	3c e0       	ldi	r19, 0x0C	; 12
    490e:	d3 2e       	mov	r13, r19
    4910:	d7 cf       	rjmp	.-82     	; 0x48c0 <disk_initialize+0x198>

00004912 <disk_read>:
	BYTE drv,			/* Physical drive nmuber (0) */
	BYTE *buff,			/* Pointer to the data buffer to store read data */
	DWORD sector,		/* Start sector number (LBA) */
	BYTE count			/* Sector count (1..128) */
)
{
    4912:	0f 93       	push	r16
    4914:	cf 93       	push	r28
    4916:	df 93       	push	r29
    4918:	eb 01       	movw	r28, r22

DSTATUS disk_status (
	BYTE drv			/* Drive number (0) */
)
{
	DSTATUS s = Stat;
    491a:	90 91 c6 03 	lds	r25, 0x03C6


	if (drv || !INS) {
    491e:	88 23       	and	r24, r24
    4920:	29 f5       	brne	.+74     	; 0x496c <disk_read+0x5a>
	} else {
		s &= ~STA_NODISK;
		if (WP)
			s |= STA_PROTECT;
		else
			s &= ~STA_PROTECT;
    4922:	89 2f       	mov	r24, r25
    4924:	89 7f       	andi	r24, 0xF9	; 249
	}
	Stat = s;
    4926:	80 93 c6 03 	sts	0x03C6, r24
{
	DSTATUS s;


	s = disk_status(drv);
	if (s & STA_NOINIT) return RES_NOTRDY;
    492a:	80 fd       	sbrc	r24, 0
    492c:	22 c0       	rjmp	.+68     	; 0x4972 <disk_read+0x60>
	if (!count) return RES_PARERR;
    492e:	00 23       	and	r16, r16
    4930:	31 f1       	breq	.+76     	; 0x497e <disk_read+0x6c>
	if (!(CardType & CT_BLOCK)) sector *= 512;	/* Convert LBA to byte address if needed */
    4932:	80 91 21 07 	lds	r24, 0x0721
    4936:	83 ff       	sbrs	r24, 3
    4938:	3b c0       	rjmp	.+118    	; 0x49b0 <disk_read+0x9e>

	if (count == 1) {	/* Single block read */
    493a:	01 30       	cpi	r16, 0x01	; 1
    493c:	09 f4       	brne	.+2      	; 0x4940 <disk_read+0x2e>
    493e:	42 c0       	rjmp	.+132    	; 0x49c4 <disk_read+0xb2>
		if ((send_cmd(CMD17, sector) == 0)	/* READ_SINGLE_BLOCK */
			&& rcvr_datablock(buff, 512))
			count = 0;
	}
	else {				/* Multiple block read */
		if (send_cmd(CMD18, sector) == 0) {	/* READ_MULTIPLE_BLOCK */
    4940:	82 e1       	ldi	r24, 0x12	; 18
    4942:	ba 01       	movw	r22, r20
    4944:	a9 01       	movw	r20, r18
    4946:	0e 94 0e 23 	call	0x461c	; 0x461c <send_cmd>
    494a:	88 23       	and	r24, r24
    494c:	01 f1       	breq	.+64     	; 0x498e <disk_read+0x7c>
static
void deselect (void)
{
 BYTE d;
 
 DESELECT();
    494e:	2a 9a       	sbi	0x05, 2	; 5

//receive an SPI byte
static
BYTE rcv_spi(void)
{
	SPDR = 0xff;
    4950:	8f ef       	ldi	r24, 0xFF	; 255
    4952:	8e bd       	out	0x2e, r24	; 46
	while(!(SPSR & _BV(SPIF)));
    4954:	0d b4       	in	r0, 0x2d	; 45
    4956:	07 fe       	sbrs	r0, 7
    4958:	fd cf       	rjmp	.-6      	; 0x4954 <disk_read+0x42>
	return SPDR;
    495a:	8e b5       	in	r24, 0x2e	; 46
			send_cmd(CMD12, 0);				/* STOP_TRANSMISSION */
		}
	}
	deselect();

	return count ? RES_ERROR : RES_OK;
    495c:	00 23       	and	r16, r16
    495e:	51 f0       	breq	.+20     	; 0x4974 <disk_read+0x62>
    4960:	01 e0       	ldi	r16, 0x01	; 1
}
    4962:	80 2f       	mov	r24, r16
    4964:	df 91       	pop	r29
    4966:	cf 91       	pop	r28
    4968:	0f 91       	pop	r16
    496a:	08 95       	ret
		if (WP)
			s |= STA_PROTECT;
		else
			s &= ~STA_PROTECT;
	}
	Stat = s;
    496c:	83 e0       	ldi	r24, 0x03	; 3
    496e:	80 93 c6 03 	sts	0x03C6, r24
    4972:	03 e0       	ldi	r16, 0x03	; 3
		}
	}
	deselect();

	return count ? RES_ERROR : RES_OK;
}
    4974:	80 2f       	mov	r24, r16
    4976:	df 91       	pop	r29
    4978:	cf 91       	pop	r28
    497a:	0f 91       	pop	r16
    497c:	08 95       	ret
	DSTATUS s;


	s = disk_status(drv);
	if (s & STA_NOINIT) return RES_NOTRDY;
	if (!count) return RES_PARERR;
    497e:	04 e0       	ldi	r16, 0x04	; 4
		}
	}
	deselect();

	return count ? RES_ERROR : RES_OK;
}
    4980:	80 2f       	mov	r24, r16
    4982:	df 91       	pop	r29
    4984:	cf 91       	pop	r28
    4986:	0f 91       	pop	r16
    4988:	08 95       	ret
	}
	else {				/* Multiple block read */
		if (send_cmd(CMD18, sector) == 0) {	/* READ_MULTIPLE_BLOCK */
			do {
				if (!rcvr_datablock(buff, 512)) break;
				buff += 512;
    498a:	c0 50       	subi	r28, 0x00	; 0
    498c:	de 4f       	sbci	r29, 0xFE	; 254
			count = 0;
	}
	else {				/* Multiple block read */
		if (send_cmd(CMD18, sector) == 0) {	/* READ_MULTIPLE_BLOCK */
			do {
				if (!rcvr_datablock(buff, 512)) break;
    498e:	ce 01       	movw	r24, r28
    4990:	60 e0       	ldi	r22, 0x00	; 0
    4992:	72 e0       	ldi	r23, 0x02	; 2
    4994:	0e 94 75 22 	call	0x44ea	; 0x44ea <rcvr_datablock>
    4998:	89 2b       	or	r24, r25
    499a:	11 f0       	breq	.+4      	; 0x49a0 <disk_read+0x8e>
				buff += 512;
			} while (--count);
    499c:	01 50       	subi	r16, 0x01	; 1
    499e:	a9 f7       	brne	.-22     	; 0x498a <disk_read+0x78>
			send_cmd(CMD12, 0);				/* STOP_TRANSMISSION */
    49a0:	8c e0       	ldi	r24, 0x0C	; 12
    49a2:	40 e0       	ldi	r20, 0x00	; 0
    49a4:	50 e0       	ldi	r21, 0x00	; 0
    49a6:	60 e0       	ldi	r22, 0x00	; 0
    49a8:	70 e0       	ldi	r23, 0x00	; 0
    49aa:	0e 94 0e 23 	call	0x461c	; 0x461c <send_cmd>
    49ae:	cf cf       	rjmp	.-98     	; 0x494e <disk_read+0x3c>


	s = disk_status(drv);
	if (s & STA_NOINIT) return RES_NOTRDY;
	if (!count) return RES_PARERR;
	if (!(CardType & CT_BLOCK)) sector *= 512;	/* Convert LBA to byte address if needed */
    49b0:	f9 e0       	ldi	r31, 0x09	; 9
    49b2:	22 0f       	add	r18, r18
    49b4:	33 1f       	adc	r19, r19
    49b6:	44 1f       	adc	r20, r20
    49b8:	55 1f       	adc	r21, r21
    49ba:	fa 95       	dec	r31
    49bc:	d1 f7       	brne	.-12     	; 0x49b2 <disk_read+0xa0>

	if (count == 1) {	/* Single block read */
    49be:	01 30       	cpi	r16, 0x01	; 1
    49c0:	09 f0       	breq	.+2      	; 0x49c4 <disk_read+0xb2>
    49c2:	be cf       	rjmp	.-132    	; 0x4940 <disk_read+0x2e>
		if ((send_cmd(CMD17, sector) == 0)	/* READ_SINGLE_BLOCK */
    49c4:	81 e1       	ldi	r24, 0x11	; 17
    49c6:	ba 01       	movw	r22, r20
    49c8:	a9 01       	movw	r20, r18
    49ca:	0e 94 0e 23 	call	0x461c	; 0x461c <send_cmd>
    49ce:	88 23       	and	r24, r24
    49d0:	09 f0       	breq	.+2      	; 0x49d4 <disk_read+0xc2>
    49d2:	bd cf       	rjmp	.-134    	; 0x494e <disk_read+0x3c>
    49d4:	ce 01       	movw	r24, r28
    49d6:	60 e0       	ldi	r22, 0x00	; 0
    49d8:	72 e0       	ldi	r23, 0x02	; 2
    49da:	0e 94 75 22 	call	0x44ea	; 0x44ea <rcvr_datablock>
    49de:	00 e0       	ldi	r16, 0x00	; 0
    49e0:	89 2b       	or	r24, r25
    49e2:	09 f0       	breq	.+2      	; 0x49e6 <disk_read+0xd4>
    49e4:	b4 cf       	rjmp	.-152    	; 0x494e <disk_read+0x3c>
    49e6:	01 e0       	ldi	r16, 0x01	; 1
    49e8:	b2 cf       	rjmp	.-156    	; 0x494e <disk_read+0x3c>

000049ea <disk_write>:
	BYTE drv,			/* Physical drive nmuber (0) */
	const BYTE *buff,	/* Pointer to the data to be written */
	DWORD sector,		/* Start sector number (LBA) */
	BYTE count			/* Sector count (1..128) */
)
{
    49ea:	cf 92       	push	r12
    49ec:	df 92       	push	r13
    49ee:	ef 92       	push	r14
    49f0:	ff 92       	push	r15
    49f2:	0f 93       	push	r16
    49f4:	cf 93       	push	r28
    49f6:	df 93       	push	r29
    49f8:	eb 01       	movw	r28, r22
    49fa:	69 01       	movw	r12, r18
    49fc:	7a 01       	movw	r14, r20

DSTATUS disk_status (
	BYTE drv			/* Drive number (0) */
)
{
	DSTATUS s = Stat;
    49fe:	90 91 c6 03 	lds	r25, 0x03C6


	if (drv || !INS) {
    4a02:	88 23       	and	r24, r24
    4a04:	31 f5       	brne	.+76     	; 0x4a52 <disk_write+0x68>
	} else {
		s &= ~STA_NODISK;
		if (WP)
			s |= STA_PROTECT;
		else
			s &= ~STA_PROTECT;
    4a06:	89 2f       	mov	r24, r25
    4a08:	89 7f       	andi	r24, 0xF9	; 249
	}
	Stat = s;
    4a0a:	80 93 c6 03 	sts	0x03C6, r24
{
	DSTATUS s;


	s = disk_status(drv);
	if (s & STA_NOINIT) return RES_NOTRDY;
    4a0e:	80 fd       	sbrc	r24, 0
    4a10:	23 c0       	rjmp	.+70     	; 0x4a58 <disk_write+0x6e>
	if (s & STA_PROTECT) return RES_WRPRT;
	if (!count) return RES_PARERR;
    4a12:	00 23       	and	r16, r16
    4a14:	59 f1       	breq	.+86     	; 0x4a6c <disk_write+0x82>
	if (!(CardType & CT_BLOCK)) sector *= 512;	/* Convert LBA to byte address if needed */
    4a16:	80 91 21 07 	lds	r24, 0x0721
    4a1a:	90 e0       	ldi	r25, 0x00	; 0
    4a1c:	83 ff       	sbrs	r24, 3
    4a1e:	3b c0       	rjmp	.+118    	; 0x4a96 <disk_write+0xac>

	if (count == 1) {	/* Single block write */
    4a20:	01 30       	cpi	r16, 0x01	; 1
    4a22:	09 f4       	brne	.+2      	; 0x4a26 <disk_write+0x3c>
    4a24:	48 c0       	rjmp	.+144    	; 0x4ab6 <disk_write+0xcc>
		if ((send_cmd(CMD24, sector) == 0)	/* WRITE_BLOCK */
			&& xmit_datablock(buff, 0xFE))
			count = 0;
	}
	else {				/* Multiple block write */
		if (CardType & CT_SDC) send_cmd(ACMD23, count);
    4a26:	86 70       	andi	r24, 0x06	; 6
    4a28:	90 70       	andi	r25, 0x00	; 0
    4a2a:	89 2b       	or	r24, r25
    4a2c:	e1 f5       	brne	.+120    	; 0x4aa6 <disk_write+0xbc>
		if (send_cmd(CMD25, sector) == 0) {	/* WRITE_MULTIPLE_BLOCK */
    4a2e:	89 e1       	ldi	r24, 0x19	; 25
    4a30:	b7 01       	movw	r22, r14
    4a32:	a6 01       	movw	r20, r12
    4a34:	0e 94 0e 23 	call	0x461c	; 0x461c <send_cmd>
    4a38:	88 23       	and	r24, r24
    4a3a:	e1 f0       	breq	.+56     	; 0x4a74 <disk_write+0x8a>
static
void deselect (void)
{
 BYTE d;
 
 DESELECT();
    4a3c:	2a 9a       	sbi	0x05, 2	; 5

//receive an SPI byte
static
BYTE rcv_spi(void)
{
	SPDR = 0xff;
    4a3e:	8f ef       	ldi	r24, 0xFF	; 255
    4a40:	8e bd       	out	0x2e, r24	; 46
	while(!(SPSR & _BV(SPIF)));
    4a42:	0d b4       	in	r0, 0x2d	; 45
    4a44:	07 fe       	sbrs	r0, 7
    4a46:	fd cf       	rjmp	.-6      	; 0x4a42 <disk_write+0x58>
	return SPDR;
    4a48:	8e b5       	in	r24, 0x2e	; 46
				count = 1;
		}
	}
	deselect();

	return count ? RES_ERROR : RES_OK;
    4a4a:	00 23       	and	r16, r16
    4a4c:	31 f0       	breq	.+12     	; 0x4a5a <disk_write+0x70>
    4a4e:	01 e0       	ldi	r16, 0x01	; 1
    4a50:	04 c0       	rjmp	.+8      	; 0x4a5a <disk_write+0x70>
		if (WP)
			s |= STA_PROTECT;
		else
			s &= ~STA_PROTECT;
	}
	Stat = s;
    4a52:	83 e0       	ldi	r24, 0x03	; 3
    4a54:	80 93 c6 03 	sts	0x03C6, r24
    4a58:	03 e0       	ldi	r16, 0x03	; 3
		}
	}
	deselect();

	return count ? RES_ERROR : RES_OK;
}
    4a5a:	80 2f       	mov	r24, r16
    4a5c:	df 91       	pop	r29
    4a5e:	cf 91       	pop	r28
    4a60:	0f 91       	pop	r16
    4a62:	ff 90       	pop	r15
    4a64:	ef 90       	pop	r14
    4a66:	df 90       	pop	r13
    4a68:	cf 90       	pop	r12
    4a6a:	08 95       	ret


	s = disk_status(drv);
	if (s & STA_NOINIT) return RES_NOTRDY;
	if (s & STA_PROTECT) return RES_WRPRT;
	if (!count) return RES_PARERR;
    4a6c:	04 e0       	ldi	r16, 0x04	; 4
    4a6e:	f5 cf       	rjmp	.-22     	; 0x4a5a <disk_write+0x70>
	else {				/* Multiple block write */
		if (CardType & CT_SDC) send_cmd(ACMD23, count);
		if (send_cmd(CMD25, sector) == 0) {	/* WRITE_MULTIPLE_BLOCK */
			do {
				if (!xmit_datablock(buff, 0xFC)) break;
				buff += 512;
    4a70:	c0 50       	subi	r28, 0x00	; 0
    4a72:	de 4f       	sbci	r29, 0xFE	; 254
	}
	else {				/* Multiple block write */
		if (CardType & CT_SDC) send_cmd(ACMD23, count);
		if (send_cmd(CMD25, sector) == 0) {	/* WRITE_MULTIPLE_BLOCK */
			do {
				if (!xmit_datablock(buff, 0xFC)) break;
    4a74:	ce 01       	movw	r24, r28
    4a76:	6c ef       	ldi	r22, 0xFC	; 252
    4a78:	0e 94 bf 22 	call	0x457e	; 0x457e <xmit_datablock>
    4a7c:	89 2b       	or	r24, r25
    4a7e:	11 f0       	breq	.+4      	; 0x4a84 <disk_write+0x9a>
				buff += 512;
			} while (--count);
    4a80:	01 50       	subi	r16, 0x01	; 1
    4a82:	b1 f7       	brne	.-20     	; 0x4a70 <disk_write+0x86>
			if (!xmit_datablock(0, 0xFD))	/* STOP_TRAN token */
    4a84:	80 e0       	ldi	r24, 0x00	; 0
    4a86:	90 e0       	ldi	r25, 0x00	; 0
    4a88:	6d ef       	ldi	r22, 0xFD	; 253
    4a8a:	0e 94 bf 22 	call	0x457e	; 0x457e <xmit_datablock>
    4a8e:	89 2b       	or	r24, r25
    4a90:	a9 f6       	brne	.-86     	; 0x4a3c <disk_write+0x52>
    4a92:	01 e0       	ldi	r16, 0x01	; 1
    4a94:	d3 cf       	rjmp	.-90     	; 0x4a3c <disk_write+0x52>

	s = disk_status(drv);
	if (s & STA_NOINIT) return RES_NOTRDY;
	if (s & STA_PROTECT) return RES_WRPRT;
	if (!count) return RES_PARERR;
	if (!(CardType & CT_BLOCK)) sector *= 512;	/* Convert LBA to byte address if needed */
    4a96:	a9 e0       	ldi	r26, 0x09	; 9
    4a98:	cc 0c       	add	r12, r12
    4a9a:	dd 1c       	adc	r13, r13
    4a9c:	ee 1c       	adc	r14, r14
    4a9e:	ff 1c       	adc	r15, r15
    4aa0:	aa 95       	dec	r26
    4aa2:	d1 f7       	brne	.-12     	; 0x4a98 <disk_write+0xae>
    4aa4:	bd cf       	rjmp	.-134    	; 0x4a20 <disk_write+0x36>
		if ((send_cmd(CMD24, sector) == 0)	/* WRITE_BLOCK */
			&& xmit_datablock(buff, 0xFE))
			count = 0;
	}
	else {				/* Multiple block write */
		if (CardType & CT_SDC) send_cmd(ACMD23, count);
    4aa6:	40 2f       	mov	r20, r16
    4aa8:	50 e0       	ldi	r21, 0x00	; 0
    4aaa:	60 e0       	ldi	r22, 0x00	; 0
    4aac:	70 e0       	ldi	r23, 0x00	; 0
    4aae:	87 e9       	ldi	r24, 0x97	; 151
    4ab0:	0e 94 0e 23 	call	0x461c	; 0x461c <send_cmd>
    4ab4:	bc cf       	rjmp	.-136    	; 0x4a2e <disk_write+0x44>
	if (s & STA_PROTECT) return RES_WRPRT;
	if (!count) return RES_PARERR;
	if (!(CardType & CT_BLOCK)) sector *= 512;	/* Convert LBA to byte address if needed */

	if (count == 1) {	/* Single block write */
		if ((send_cmd(CMD24, sector) == 0)	/* WRITE_BLOCK */
    4ab6:	88 e1       	ldi	r24, 0x18	; 24
    4ab8:	b7 01       	movw	r22, r14
    4aba:	a6 01       	movw	r20, r12
    4abc:	0e 94 0e 23 	call	0x461c	; 0x461c <send_cmd>
    4ac0:	88 23       	and	r24, r24
    4ac2:	09 f0       	breq	.+2      	; 0x4ac6 <disk_write+0xdc>
    4ac4:	bb cf       	rjmp	.-138    	; 0x4a3c <disk_write+0x52>
    4ac6:	ce 01       	movw	r24, r28
    4ac8:	6e ef       	ldi	r22, 0xFE	; 254
    4aca:	0e 94 bf 22 	call	0x457e	; 0x457e <xmit_datablock>
    4ace:	00 e0       	ldi	r16, 0x00	; 0
    4ad0:	89 2b       	or	r24, r25
    4ad2:	09 f0       	breq	.+2      	; 0x4ad6 <disk_write+0xec>
    4ad4:	b3 cf       	rjmp	.-154    	; 0x4a3c <disk_write+0x52>
		if (send_cmd(CMD25, sector) == 0) {	/* WRITE_MULTIPLE_BLOCK */
			do {
				if (!xmit_datablock(buff, 0xFC)) break;
				buff += 512;
			} while (--count);
			if (!xmit_datablock(0, 0xFD))	/* STOP_TRAN token */
    4ad6:	01 e0       	ldi	r16, 0x01	; 1
    4ad8:	b1 cf       	rjmp	.-158    	; 0x4a3c <disk_write+0x52>

00004ada <disk_ioctl>:
DRESULT disk_ioctl (
	BYTE drv,		/* Physical drive nmuber (0) */
	BYTE ctrl,		/* Control code */
	void *buff		/* Buffer to send/receive control data */
)
{
    4ada:	0f 93       	push	r16
    4adc:	1f 93       	push	r17
    4ade:	df 93       	push	r29
    4ae0:	cf 93       	push	r28
    4ae2:	cd b7       	in	r28, 0x3d	; 61
    4ae4:	de b7       	in	r29, 0x3e	; 62
    4ae6:	60 97       	sbiw	r28, 0x10	; 16
    4ae8:	0f b6       	in	r0, 0x3f	; 63
    4aea:	f8 94       	cli
    4aec:	de bf       	out	0x3e, r29	; 62
    4aee:	0f be       	out	0x3f, r0	; 63
    4af0:	cd bf       	out	0x3d, r28	; 61
    4af2:	8a 01       	movw	r16, r20

DSTATUS disk_status (
	BYTE drv			/* Drive number (0) */
)
{
	DSTATUS s = Stat;
    4af4:	90 91 c6 03 	lds	r25, 0x03C6


	if (drv || !INS) {
    4af8:	88 23       	and	r24, r24
    4afa:	a9 f4       	brne	.+42     	; 0x4b26 <disk_ioctl+0x4c>
	} else {
		s &= ~STA_NODISK;
		if (WP)
			s |= STA_PROTECT;
		else
			s &= ~STA_PROTECT;
    4afc:	89 2f       	mov	r24, r25
    4afe:	89 7f       	andi	r24, 0xF9	; 249
	}
	Stat = s;
    4b00:	80 93 c6 03 	sts	0x03C6, r24
	DRESULT res;
	BYTE n, csd[16];
	WORD cs;


	if (disk_status(drv) & STA_NOINIT)					/* Check if card is in the socket */
    4b04:	80 fd       	sbrc	r24, 0
    4b06:	12 c0       	rjmp	.+36     	; 0x4b2c <disk_ioctl+0x52>
		return RES_NOTRDY;

	res = RES_ERROR;
	switch (ctrl) {
    4b08:	61 30       	cpi	r22, 0x01	; 1
    4b0a:	51 f1       	breq	.+84     	; 0x4b60 <disk_ioctl+0x86>
    4b0c:	61 30       	cpi	r22, 0x01	; 1
    4b0e:	d8 f0       	brcs	.+54     	; 0x4b46 <disk_ioctl+0x6c>
    4b10:	63 30       	cpi	r22, 0x03	; 3
    4b12:	89 f1       	breq	.+98     	; 0x4b76 <disk_ioctl+0x9c>
    4b14:	94 e0       	ldi	r25, 0x04	; 4
static
void deselect (void)
{
 BYTE d;
 
 DESELECT();
    4b16:	2a 9a       	sbi	0x05, 2	; 5

//receive an SPI byte
static
BYTE rcv_spi(void)
{
	SPDR = 0xff;
    4b18:	8f ef       	ldi	r24, 0xFF	; 255
    4b1a:	8e bd       	out	0x2e, r24	; 46
	while(!(SPSR & _BV(SPIF)));
    4b1c:	0d b4       	in	r0, 0x2d	; 45
    4b1e:	07 fe       	sbrs	r0, 7
    4b20:	fd cf       	rjmp	.-6      	; 0x4b1c <disk_ioctl+0x42>
	return SPDR;
    4b22:	8e b5       	in	r24, 0x2e	; 46
    4b24:	04 c0       	rjmp	.+8      	; 0x4b2e <disk_ioctl+0x54>
		if (WP)
			s |= STA_PROTECT;
		else
			s &= ~STA_PROTECT;
	}
	Stat = s;
    4b26:	83 e0       	ldi	r24, 0x03	; 3
    4b28:	80 93 c6 03 	sts	0x03C6, r24
    4b2c:	93 e0       	ldi	r25, 0x03	; 3
	}

	deselect();

	return res;
}
    4b2e:	89 2f       	mov	r24, r25
    4b30:	60 96       	adiw	r28, 0x10	; 16
    4b32:	0f b6       	in	r0, 0x3f	; 63
    4b34:	f8 94       	cli
    4b36:	de bf       	out	0x3e, r29	; 62
    4b38:	0f be       	out	0x3f, r0	; 63
    4b3a:	cd bf       	out	0x3d, r28	; 61
    4b3c:	cf 91       	pop	r28
    4b3e:	df 91       	pop	r29
    4b40:	1f 91       	pop	r17
    4b42:	0f 91       	pop	r16
    4b44:	08 95       	ret
		return RES_NOTRDY;

	res = RES_ERROR;
	switch (ctrl) {
		case CTRL_SYNC :		/* Make sure that no pending write process */
			if (select()) {
    4b46:	0e 94 61 22 	call	0x44c2	; 0x44c2 <select>
    4b4a:	89 2b       	or	r24, r25
    4b4c:	91 f0       	breq	.+36     	; 0x4b72 <disk_ioctl+0x98>
static
void deselect (void)
{
 BYTE d;
 
 DESELECT();
    4b4e:	2a 9a       	sbi	0x05, 2	; 5

//receive an SPI byte
static
BYTE rcv_spi(void)
{
	SPDR = 0xff;
    4b50:	8f ef       	ldi	r24, 0xFF	; 255
    4b52:	8e bd       	out	0x2e, r24	; 46
	while(!(SPSR & _BV(SPIF)));
    4b54:	0d b4       	in	r0, 0x2d	; 45
    4b56:	07 fe       	sbrs	r0, 7
    4b58:	fd cf       	rjmp	.-6      	; 0x4b54 <disk_ioctl+0x7a>
	return SPDR;
    4b5a:	8e b5       	in	r24, 0x2e	; 46
    4b5c:	90 e0       	ldi	r25, 0x00	; 0
    4b5e:	db cf       	rjmp	.-74     	; 0x4b16 <disk_ioctl+0x3c>
				res = RES_OK;
			}
			break;

		case GET_SECTOR_COUNT :	/* Get number of sectors on the disk (DWORD) */
			if ((send_cmd(CMD9, 0) == 0) && rcvr_datablock(csd, 16)) {
    4b60:	89 e0       	ldi	r24, 0x09	; 9
    4b62:	40 e0       	ldi	r20, 0x00	; 0
    4b64:	50 e0       	ldi	r21, 0x00	; 0
    4b66:	60 e0       	ldi	r22, 0x00	; 0
    4b68:	70 e0       	ldi	r23, 0x00	; 0
    4b6a:	0e 94 0e 23 	call	0x461c	; 0x461c <send_cmd>
    4b6e:	88 23       	and	r24, r24
    4b70:	69 f0       	breq	.+26     	; 0x4b8c <disk_ioctl+0xb2>
			break;

		case GET_BLOCK_SIZE :	/* Get erase block size in unit of sector (DWORD) */
			*(DWORD*)buff = 128;
			res = RES_OK;
			break;
    4b72:	91 e0       	ldi	r25, 0x01	; 1
    4b74:	d0 cf       	rjmp	.-96     	; 0x4b16 <disk_ioctl+0x3c>
				res = RES_OK;
			}
			break;

		case GET_BLOCK_SIZE :	/* Get erase block size in unit of sector (DWORD) */
			*(DWORD*)buff = 128;
    4b76:	80 e8       	ldi	r24, 0x80	; 128
    4b78:	90 e0       	ldi	r25, 0x00	; 0
    4b7a:	a0 e0       	ldi	r26, 0x00	; 0
    4b7c:	b0 e0       	ldi	r27, 0x00	; 0
    4b7e:	fa 01       	movw	r30, r20
    4b80:	80 83       	st	Z, r24
    4b82:	91 83       	std	Z+1, r25	; 0x01
    4b84:	a2 83       	std	Z+2, r26	; 0x02
    4b86:	b3 83       	std	Z+3, r27	; 0x03
    4b88:	90 e0       	ldi	r25, 0x00	; 0
    4b8a:	c5 cf       	rjmp	.-118    	; 0x4b16 <disk_ioctl+0x3c>
				res = RES_OK;
			}
			break;

		case GET_SECTOR_COUNT :	/* Get number of sectors on the disk (DWORD) */
			if ((send_cmd(CMD9, 0) == 0) && rcvr_datablock(csd, 16)) {
    4b8c:	ce 01       	movw	r24, r28
    4b8e:	01 96       	adiw	r24, 0x01	; 1
    4b90:	60 e1       	ldi	r22, 0x10	; 16
    4b92:	70 e0       	ldi	r23, 0x00	; 0
    4b94:	0e 94 75 22 	call	0x44ea	; 0x44ea <rcvr_datablock>
    4b98:	89 2b       	or	r24, r25
    4b9a:	59 f3       	breq	.-42     	; 0x4b72 <disk_ioctl+0x98>
				if ((csd[0] >> 6) == 1) {	/* SDC ver 2.00 */
    4b9c:	89 81       	ldd	r24, Y+1	; 0x01
    4b9e:	82 95       	swap	r24
    4ba0:	86 95       	lsr	r24
    4ba2:	86 95       	lsr	r24
    4ba4:	83 70       	andi	r24, 0x03	; 3
    4ba6:	81 30       	cpi	r24, 0x01	; 1
    4ba8:	b9 f1       	breq	.+110    	; 0x4c18 <disk_ioctl+0x13e>
					cs= csd[9] + ((WORD)csd[8] << 8) + 1;
					*(DWORD*)buff = (DWORD)cs << 10;
				} else {					/* SDC ver 1.XX or MMC */
					n = (csd[5] & 15) + ((csd[10] & 128) >> 7) + ((csd[9] & 3) << 1) + 2;
					cs = (csd[8] >> 6) + ((WORD)csd[7] << 2) + ((WORD)(csd[6] & 3) << 10) + 1;
					*(DWORD*)buff = (DWORD)cs << (n - 9);
    4baa:	89 85       	ldd	r24, Y+9	; 0x09
    4bac:	82 95       	swap	r24
    4bae:	86 95       	lsr	r24
    4bb0:	86 95       	lsr	r24
    4bb2:	83 70       	andi	r24, 0x03	; 3
    4bb4:	28 85       	ldd	r18, Y+8	; 0x08
    4bb6:	30 e0       	ldi	r19, 0x00	; 0
    4bb8:	22 0f       	add	r18, r18
    4bba:	33 1f       	adc	r19, r19
    4bbc:	22 0f       	add	r18, r18
    4bbe:	33 1f       	adc	r19, r19
    4bc0:	28 0f       	add	r18, r24
    4bc2:	31 1d       	adc	r19, r1
    4bc4:	2f 5f       	subi	r18, 0xFF	; 255
    4bc6:	3f 4f       	sbci	r19, 0xFF	; 255
    4bc8:	8f 81       	ldd	r24, Y+7	; 0x07
    4bca:	90 e0       	ldi	r25, 0x00	; 0
    4bcc:	83 70       	andi	r24, 0x03	; 3
    4bce:	90 70       	andi	r25, 0x00	; 0
    4bd0:	98 2f       	mov	r25, r24
    4bd2:	88 27       	eor	r24, r24
    4bd4:	99 0f       	add	r25, r25
    4bd6:	99 0f       	add	r25, r25
    4bd8:	28 0f       	add	r18, r24
    4bda:	39 1f       	adc	r19, r25
    4bdc:	40 e0       	ldi	r20, 0x00	; 0
    4bde:	50 e0       	ldi	r21, 0x00	; 0
    4be0:	8e 81       	ldd	r24, Y+6	; 0x06
    4be2:	8f 70       	andi	r24, 0x0F	; 15
    4be4:	6b 85       	ldd	r22, Y+11	; 0x0b
    4be6:	66 1f       	adc	r22, r22
    4be8:	66 27       	eor	r22, r22
    4bea:	66 1f       	adc	r22, r22
    4bec:	86 0f       	add	r24, r22
    4bee:	8e 5f       	subi	r24, 0xFE	; 254
    4bf0:	6a 85       	ldd	r22, Y+10	; 0x0a
    4bf2:	63 70       	andi	r22, 0x03	; 3
    4bf4:	66 0f       	add	r22, r22
    4bf6:	86 0f       	add	r24, r22
    4bf8:	90 e0       	ldi	r25, 0x00	; 0
    4bfa:	09 97       	sbiw	r24, 0x09	; 9
    4bfc:	04 c0       	rjmp	.+8      	; 0x4c06 <disk_ioctl+0x12c>
    4bfe:	22 0f       	add	r18, r18
    4c00:	33 1f       	adc	r19, r19
    4c02:	44 1f       	adc	r20, r20
    4c04:	55 1f       	adc	r21, r21
    4c06:	8a 95       	dec	r24
    4c08:	d2 f7       	brpl	.-12     	; 0x4bfe <disk_ioctl+0x124>
    4c0a:	f8 01       	movw	r30, r16
    4c0c:	20 83       	st	Z, r18
    4c0e:	31 83       	std	Z+1, r19	; 0x01
    4c10:	42 83       	std	Z+2, r20	; 0x02
    4c12:	53 83       	std	Z+3, r21	; 0x03
    4c14:	90 e0       	ldi	r25, 0x00	; 0
    4c16:	7f cf       	rjmp	.-258    	; 0x4b16 <disk_ioctl+0x3c>

		case GET_SECTOR_COUNT :	/* Get number of sectors on the disk (DWORD) */
			if ((send_cmd(CMD9, 0) == 0) && rcvr_datablock(csd, 16)) {
				if ((csd[0] >> 6) == 1) {	/* SDC ver 2.00 */
					cs= csd[9] + ((WORD)csd[8] << 8) + 1;
					*(DWORD*)buff = (DWORD)cs << 10;
    4c18:	8a 85       	ldd	r24, Y+10	; 0x0a
    4c1a:	90 e0       	ldi	r25, 0x00	; 0
    4c1c:	01 96       	adiw	r24, 0x01	; 1
    4c1e:	39 85       	ldd	r19, Y+9	; 0x09
    4c20:	20 e0       	ldi	r18, 0x00	; 0
    4c22:	82 0f       	add	r24, r18
    4c24:	93 1f       	adc	r25, r19
    4c26:	a0 e0       	ldi	r26, 0x00	; 0
    4c28:	b0 e0       	ldi	r27, 0x00	; 0
    4c2a:	2a e0       	ldi	r18, 0x0A	; 10
    4c2c:	88 0f       	add	r24, r24
    4c2e:	99 1f       	adc	r25, r25
    4c30:	aa 1f       	adc	r26, r26
    4c32:	bb 1f       	adc	r27, r27
    4c34:	2a 95       	dec	r18
    4c36:	d1 f7       	brne	.-12     	; 0x4c2c <disk_ioctl+0x152>
    4c38:	f8 01       	movw	r30, r16
    4c3a:	80 83       	st	Z, r24
    4c3c:	91 83       	std	Z+1, r25	; 0x01
    4c3e:	a2 83       	std	Z+2, r26	; 0x02
    4c40:	b3 83       	std	Z+3, r27	; 0x03
    4c42:	90 e0       	ldi	r25, 0x00	; 0
    4c44:	68 cf       	rjmp	.-304    	; 0x4b16 <disk_ioctl+0x3c>

00004c46 <clust2sect>:

DWORD clust2sect (	/* !=0: Sector number, 0: Failed - invalid cluster# */
	FATFS *fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
    4c46:	ef 92       	push	r14
    4c48:	ff 92       	push	r15
    4c4a:	0f 93       	push	r16
    4c4c:	1f 93       	push	r17
    4c4e:	cf 93       	push	r28
    4c50:	df 93       	push	r29
    4c52:	ec 01       	movw	r28, r24
    4c54:	7a 01       	movw	r14, r20
    4c56:	8b 01       	movw	r16, r22
	clst -= 2;
    4c58:	8e ef       	ldi	r24, 0xFE	; 254
    4c5a:	9f ef       	ldi	r25, 0xFF	; 255
    4c5c:	af ef       	ldi	r26, 0xFF	; 255
    4c5e:	bf ef       	ldi	r27, 0xFF	; 255
    4c60:	e8 0e       	add	r14, r24
    4c62:	f9 1e       	adc	r15, r25
    4c64:	0a 1f       	adc	r16, r26
    4c66:	1b 1f       	adc	r17, r27
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
    4c68:	8e 89       	ldd	r24, Y+22	; 0x16
    4c6a:	9f 89       	ldd	r25, Y+23	; 0x17
    4c6c:	a8 8d       	ldd	r26, Y+24	; 0x18
    4c6e:	b9 8d       	ldd	r27, Y+25	; 0x19
    4c70:	02 97       	sbiw	r24, 0x02	; 2
    4c72:	a1 09       	sbc	r26, r1
    4c74:	b1 09       	sbc	r27, r1
    4c76:	e8 16       	cp	r14, r24
    4c78:	f9 06       	cpc	r15, r25
    4c7a:	0a 07       	cpc	r16, r26
    4c7c:	1b 07       	cpc	r17, r27
    4c7e:	d8 f4       	brcc	.+54     	; 0x4cb6 <clust2sect+0x70>
	return clst * fs->csize + fs->database;
    4c80:	2a 81       	ldd	r18, Y+2	; 0x02
    4c82:	30 e0       	ldi	r19, 0x00	; 0
    4c84:	40 e0       	ldi	r20, 0x00	; 0
    4c86:	50 e0       	ldi	r21, 0x00	; 0
    4c88:	c8 01       	movw	r24, r16
    4c8a:	b7 01       	movw	r22, r14
    4c8c:	0e 94 bb 7f 	call	0xff76	; 0xff76 <__mulsi3>
    4c90:	9b 01       	movw	r18, r22
    4c92:	ac 01       	movw	r20, r24
    4c94:	8e a1       	ldd	r24, Y+38	; 0x26
    4c96:	9f a1       	ldd	r25, Y+39	; 0x27
    4c98:	a8 a5       	ldd	r26, Y+40	; 0x28
    4c9a:	b9 a5       	ldd	r27, Y+41	; 0x29
    4c9c:	28 0f       	add	r18, r24
    4c9e:	39 1f       	adc	r19, r25
    4ca0:	4a 1f       	adc	r20, r26
    4ca2:	5b 1f       	adc	r21, r27
}
    4ca4:	b9 01       	movw	r22, r18
    4ca6:	ca 01       	movw	r24, r20
    4ca8:	df 91       	pop	r29
    4caa:	cf 91       	pop	r28
    4cac:	1f 91       	pop	r17
    4cae:	0f 91       	pop	r16
    4cb0:	ff 90       	pop	r15
    4cb2:	ef 90       	pop	r14
    4cb4:	08 95       	ret
	FATFS *fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
    4cb6:	20 e0       	ldi	r18, 0x00	; 0
    4cb8:	30 e0       	ldi	r19, 0x00	; 0
    4cba:	40 e0       	ldi	r20, 0x00	; 0
    4cbc:	50 e0       	ldi	r21, 0x00	; 0
    4cbe:	f2 cf       	rjmp	.-28     	; 0x4ca4 <clust2sect+0x5e>

00004cc0 <f_mount>:

FRESULT f_mount (
	BYTE vol,		/* Logical drive number to be mounted/unmounted */
	FATFS *fs		/* Pointer to new file system object (NULL for unmount)*/
)
{
    4cc0:	fb 01       	movw	r30, r22
	FATFS *rfs;


	if (vol >= _VOLUMES)			/* Check if the drive number is valid */
    4cc2:	88 23       	and	r24, r24
    4cc4:	81 f4       	brne	.+32     	; 0x4ce6 <f_mount+0x26>
		return FR_INVALID_DRIVE;
	rfs = FatFs[vol];				/* Get current fs object */
    4cc6:	a0 91 22 07 	lds	r26, 0x0722
    4cca:	b0 91 23 07 	lds	r27, 0x0723

	if (rfs) {
    4cce:	10 97       	sbiw	r26, 0x00	; 0
    4cd0:	09 f0       	breq	.+2      	; 0x4cd4 <f_mount+0x14>
		clear_lock(rfs);
#endif
#if _FS_REENTRANT					/* Discard sync object of the current volume */
		if (!ff_del_syncobj(rfs->sobj)) return FR_INT_ERR;
#endif
		rfs->fs_type = 0;			/* Clear old fs object */
    4cd2:	1c 92       	st	X, r1
	}

	if (fs) {
    4cd4:	30 97       	sbiw	r30, 0x00	; 0
    4cd6:	09 f0       	breq	.+2      	; 0x4cda <f_mount+0x1a>
		fs->fs_type = 0;			/* Clear new fs object */
    4cd8:	10 82       	st	Z, r1
#if _FS_REENTRANT					/* Create sync object for the new volume */
		if (!ff_cre_syncobj(vol, &fs->sobj)) return FR_INT_ERR;
#endif
	}
	FatFs[vol] = fs;				/* Register new fs object */
    4cda:	f0 93 23 07 	sts	0x0723, r31
    4cde:	e0 93 22 07 	sts	0x0722, r30
    4ce2:	80 e0       	ldi	r24, 0x00	; 0

	return FR_OK;
}
    4ce4:	08 95       	ret
)
{
	FATFS *rfs;


	if (vol >= _VOLUMES)			/* Check if the drive number is valid */
    4ce6:	8b e0       	ldi	r24, 0x0B	; 11
    4ce8:	08 95       	ret

00004cea <validate>:
static
FRESULT validate (	/* FR_OK(0): The object is valid, !=0: Invalid */
	FATFS *fs,		/* Pointer to the file system object */
	WORD id			/* Member id of the target object to be checked */
)
{
    4cea:	fc 01       	movw	r30, r24
	if (!fs || !fs->fs_type || fs->id != id)
    4cec:	00 97       	sbiw	r24, 0x00	; 0
    4cee:	41 f0       	breq	.+16     	; 0x4d00 <validate+0x16>
    4cf0:	80 81       	ld	r24, Z
    4cf2:	88 23       	and	r24, r24
    4cf4:	29 f0       	breq	.+10     	; 0x4d00 <validate+0x16>
    4cf6:	86 81       	ldd	r24, Z+6	; 0x06
    4cf8:	97 81       	ldd	r25, Z+7	; 0x07
    4cfa:	86 17       	cp	r24, r22
    4cfc:	97 07       	cpc	r25, r23
    4cfe:	11 f0       	breq	.+4      	; 0x4d04 <validate+0x1a>
		return FR_INVALID_OBJECT;

	ENTER_FF(fs);		/* Lock file system */

	if (disk_status(fs->drv) & STA_NOINIT)
    4d00:	89 e0       	ldi	r24, 0x09	; 9
		return FR_NOT_READY;

	return FR_OK;
}
    4d02:	08 95       	ret
	if (!fs || !fs->fs_type || fs->id != id)
		return FR_INVALID_OBJECT;

	ENTER_FF(fs);		/* Lock file system */

	if (disk_status(fs->drv) & STA_NOINIT)
    4d04:	81 81       	ldd	r24, Z+1	; 0x01
    4d06:	0e 94 87 23 	call	0x470e	; 0x470e <disk_status>
    4d0a:	80 fd       	sbrc	r24, 0
    4d0c:	02 c0       	rjmp	.+4      	; 0x4d12 <validate+0x28>
    4d0e:	80 e0       	ldi	r24, 0x00	; 0
    4d10:	08 95       	ret
    4d12:	83 e0       	ldi	r24, 0x03	; 3
    4d14:	08 95       	ret

00004d16 <move_window>:
static
FRESULT move_window (
	FATFS *fs,		/* File system object */
	DWORD sector	/* Sector number to make appearance in the fs->win[] */
)					/* Move to zero only writes back dirty window */
{
    4d16:	6f 92       	push	r6
    4d18:	7f 92       	push	r7
    4d1a:	8f 92       	push	r8
    4d1c:	9f 92       	push	r9
    4d1e:	af 92       	push	r10
    4d20:	bf 92       	push	r11
    4d22:	cf 92       	push	r12
    4d24:	df 92       	push	r13
    4d26:	ef 92       	push	r14
    4d28:	ff 92       	push	r15
    4d2a:	0f 93       	push	r16
    4d2c:	1f 93       	push	r17
    4d2e:	cf 93       	push	r28
    4d30:	df 93       	push	r29
    4d32:	ec 01       	movw	r28, r24
    4d34:	4a 01       	movw	r8, r20
    4d36:	5b 01       	movw	r10, r22
	DWORD wsect;


	wsect = fs->winsect;
    4d38:	ca a4       	ldd	r12, Y+42	; 0x2a
    4d3a:	db a4       	ldd	r13, Y+43	; 0x2b
    4d3c:	ec a4       	ldd	r14, Y+44	; 0x2c
    4d3e:	fd a4       	ldd	r15, Y+45	; 0x2d
	if (wsect != sector) {	/* Changed current window */
    4d40:	c4 16       	cp	r12, r20
    4d42:	d5 06       	cpc	r13, r21
    4d44:	e6 06       	cpc	r14, r22
    4d46:	f7 06       	cpc	r15, r23
    4d48:	49 f0       	breq	.+18     	; 0x4d5c <move_window+0x46>
#if !_FS_READONLY
		if (fs->wflag) {	/* Write back dirty window if needed */
    4d4a:	8c 81       	ldd	r24, Y+4	; 0x04
    4d4c:	88 23       	and	r24, r24
    4d4e:	b1 f4       	brne	.+44     	; 0x4d7c <move_window+0x66>
					disk_write(fs->drv, fs->win, wsect, 1);
				}
			}
		}
#endif
		if (sector) {
    4d50:	81 14       	cp	r8, r1
    4d52:	91 04       	cpc	r9, r1
    4d54:	a1 04       	cpc	r10, r1
    4d56:	b1 04       	cpc	r11, r1
    4d58:	09 f0       	breq	.+2      	; 0x4d5c <move_window+0x46>
    4d5a:	47 c0       	rjmp	.+142    	; 0x4dea <move_window+0xd4>
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK)
				return FR_DISK_ERR;
			fs->winsect = sector;
    4d5c:	80 e0       	ldi	r24, 0x00	; 0
		}
	}

	return FR_OK;
}
    4d5e:	df 91       	pop	r29
    4d60:	cf 91       	pop	r28
    4d62:	1f 91       	pop	r17
    4d64:	0f 91       	pop	r16
    4d66:	ff 90       	pop	r15
    4d68:	ef 90       	pop	r14
    4d6a:	df 90       	pop	r13
    4d6c:	cf 90       	pop	r12
    4d6e:	bf 90       	pop	r11
    4d70:	af 90       	pop	r10
    4d72:	9f 90       	pop	r9
    4d74:	8f 90       	pop	r8
    4d76:	7f 90       	pop	r7
    4d78:	6f 90       	pop	r6
    4d7a:	08 95       	ret

	wsect = fs->winsect;
	if (wsect != sector) {	/* Changed current window */
#if !_FS_READONLY
		if (fs->wflag) {	/* Write back dirty window if needed */
			if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
    4d7c:	8e e2       	ldi	r24, 0x2E	; 46
    4d7e:	68 2e       	mov	r6, r24
    4d80:	71 2c       	mov	r7, r1
    4d82:	6c 0e       	add	r6, r28
    4d84:	7d 1e       	adc	r7, r29
    4d86:	89 81       	ldd	r24, Y+1	; 0x01
    4d88:	b3 01       	movw	r22, r6
    4d8a:	a7 01       	movw	r20, r14
    4d8c:	96 01       	movw	r18, r12
    4d8e:	01 e0       	ldi	r16, 0x01	; 1
    4d90:	0e 94 f5 24 	call	0x49ea	; 0x49ea <disk_write>
    4d94:	88 23       	and	r24, r24
    4d96:	c9 f5       	brne	.+114    	; 0x4e0a <move_window+0xf4>
				return FR_DISK_ERR;
			fs->wflag = 0;
    4d98:	1c 82       	std	Y+4, r1	; 0x04
			if (wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area */
    4d9a:	2a 8d       	ldd	r18, Y+26	; 0x1a
    4d9c:	3b 8d       	ldd	r19, Y+27	; 0x1b
    4d9e:	4c 8d       	ldd	r20, Y+28	; 0x1c
    4da0:	5d 8d       	ldd	r21, Y+29	; 0x1d
    4da2:	8e 8d       	ldd	r24, Y+30	; 0x1e
    4da4:	9f 8d       	ldd	r25, Y+31	; 0x1f
    4da6:	a8 a1       	ldd	r26, Y+32	; 0x20
    4da8:	b9 a1       	ldd	r27, Y+33	; 0x21
    4daa:	82 0f       	add	r24, r18
    4dac:	93 1f       	adc	r25, r19
    4dae:	a4 1f       	adc	r26, r20
    4db0:	b5 1f       	adc	r27, r21
    4db2:	c8 16       	cp	r12, r24
    4db4:	d9 06       	cpc	r13, r25
    4db6:	ea 06       	cpc	r14, r26
    4db8:	fb 06       	cpc	r15, r27
    4dba:	50 f6       	brcc	.-108    	; 0x4d50 <move_window+0x3a>
				BYTE nf;
				for (nf = fs->n_fats; nf > 1; nf--) {	/* Reflect the change to all FAT copies */
    4dbc:	1b 81       	ldd	r17, Y+3	; 0x03
    4dbe:	12 30       	cpi	r17, 0x02	; 2
    4dc0:	28 f4       	brcc	.+10     	; 0x4dcc <move_window+0xb6>
    4dc2:	c6 cf       	rjmp	.-116    	; 0x4d50 <move_window+0x3a>
    4dc4:	2a 8d       	ldd	r18, Y+26	; 0x1a
    4dc6:	3b 8d       	ldd	r19, Y+27	; 0x1b
    4dc8:	4c 8d       	ldd	r20, Y+28	; 0x1c
    4dca:	5d 8d       	ldd	r21, Y+29	; 0x1d
					wsect += fs->fsize;
    4dcc:	c2 0e       	add	r12, r18
    4dce:	d3 1e       	adc	r13, r19
    4dd0:	e4 1e       	adc	r14, r20
    4dd2:	f5 1e       	adc	r15, r21
					disk_write(fs->drv, fs->win, wsect, 1);
    4dd4:	89 81       	ldd	r24, Y+1	; 0x01
    4dd6:	b3 01       	movw	r22, r6
    4dd8:	a7 01       	movw	r20, r14
    4dda:	96 01       	movw	r18, r12
    4ddc:	01 e0       	ldi	r16, 0x01	; 1
    4dde:	0e 94 f5 24 	call	0x49ea	; 0x49ea <disk_write>
			if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
				return FR_DISK_ERR;
			fs->wflag = 0;
			if (wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area */
				BYTE nf;
				for (nf = fs->n_fats; nf > 1; nf--) {	/* Reflect the change to all FAT copies */
    4de2:	11 50       	subi	r17, 0x01	; 1
    4de4:	12 30       	cpi	r17, 0x02	; 2
    4de6:	70 f7       	brcc	.-36     	; 0x4dc4 <move_window+0xae>
    4de8:	b3 cf       	rjmp	.-154    	; 0x4d50 <move_window+0x3a>
				}
			}
		}
#endif
		if (sector) {
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK)
    4dea:	be 01       	movw	r22, r28
    4dec:	62 5d       	subi	r22, 0xD2	; 210
    4dee:	7f 4f       	sbci	r23, 0xFF	; 255
    4df0:	89 81       	ldd	r24, Y+1	; 0x01
    4df2:	a5 01       	movw	r20, r10
    4df4:	94 01       	movw	r18, r8
    4df6:	01 e0       	ldi	r16, 0x01	; 1
    4df8:	0e 94 89 24 	call	0x4912	; 0x4912 <disk_read>
    4dfc:	88 23       	and	r24, r24
    4dfe:	29 f4       	brne	.+10     	; 0x4e0a <move_window+0xf4>
				return FR_DISK_ERR;
			fs->winsect = sector;
    4e00:	8a a6       	std	Y+42, r8	; 0x2a
    4e02:	9b a6       	std	Y+43, r9	; 0x2b
    4e04:	ac a6       	std	Y+44, r10	; 0x2c
    4e06:	bd a6       	std	Y+45, r11	; 0x2d
    4e08:	aa cf       	rjmp	.-172    	; 0x4d5e <move_window+0x48>
    4e0a:	81 e0       	ldi	r24, 0x01	; 1
    4e0c:	a8 cf       	rjmp	.-176    	; 0x4d5e <move_window+0x48>

00004e0e <put_fat>:
FRESULT put_fat (
	FATFS *fs,	/* File system object */
	DWORD clst,	/* Cluster# to be changed in range of 2 to fs->n_fatent - 1 */
	DWORD val	/* New value to mark the cluster */
)
{
    4e0e:	6f 92       	push	r6
    4e10:	7f 92       	push	r7
    4e12:	8f 92       	push	r8
    4e14:	9f 92       	push	r9
    4e16:	af 92       	push	r10
    4e18:	bf 92       	push	r11
    4e1a:	cf 92       	push	r12
    4e1c:	df 92       	push	r13
    4e1e:	ef 92       	push	r14
    4e20:	ff 92       	push	r15
    4e22:	0f 93       	push	r16
    4e24:	1f 93       	push	r17
    4e26:	cf 93       	push	r28
    4e28:	df 93       	push	r29
    4e2a:	ec 01       	movw	r28, r24
    4e2c:	6a 01       	movw	r12, r20
    4e2e:	7b 01       	movw	r14, r22
    4e30:	48 01       	movw	r8, r16
    4e32:	59 01       	movw	r10, r18
	UINT bc;
	BYTE *p;
	FRESULT res;


	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
    4e34:	42 30       	cpi	r20, 0x02	; 2
    4e36:	51 05       	cpc	r21, r1
    4e38:	61 05       	cpc	r22, r1
    4e3a:	71 05       	cpc	r23, r1
    4e3c:	b0 f0       	brcs	.+44     	; 0x4e6a <put_fat+0x5c>
    4e3e:	8e 89       	ldd	r24, Y+22	; 0x16
    4e40:	9f 89       	ldd	r25, Y+23	; 0x17
    4e42:	a8 8d       	ldd	r26, Y+24	; 0x18
    4e44:	b9 8d       	ldd	r27, Y+25	; 0x19
    4e46:	48 17       	cp	r20, r24
    4e48:	59 07       	cpc	r21, r25
    4e4a:	6a 07       	cpc	r22, r26
    4e4c:	7b 07       	cpc	r23, r27
    4e4e:	68 f4       	brcc	.+26     	; 0x4e6a <put_fat+0x5c>
		res = FR_INT_ERR;

	} else {
		switch (fs->fs_type) {
    4e50:	88 81       	ld	r24, Y
    4e52:	82 30       	cpi	r24, 0x02	; 2
    4e54:	09 f4       	brne	.+2      	; 0x4e58 <put_fat+0x4a>
    4e56:	b6 c0       	rjmp	.+364    	; 0x4fc4 <put_fat+0x1b6>
    4e58:	83 30       	cpi	r24, 0x03	; 3
    4e5a:	09 f4       	brne	.+2      	; 0x4e5e <put_fat+0x50>
    4e5c:	6b c0       	rjmp	.+214    	; 0x4f34 <put_fat+0x126>
    4e5e:	81 30       	cpi	r24, 0x01	; 1
    4e60:	a9 f0       	breq	.+42     	; 0x4e8c <put_fat+0x7e>
    4e62:	12 e0       	ldi	r17, 0x02	; 2
			break;

		default :
			res = FR_INT_ERR;
		}
		fs->wflag = 1;
    4e64:	81 e0       	ldi	r24, 0x01	; 1
    4e66:	8c 83       	std	Y+4, r24	; 0x04
    4e68:	01 c0       	rjmp	.+2      	; 0x4e6c <put_fat+0x5e>
    4e6a:	12 e0       	ldi	r17, 0x02	; 2
	}

	return res;
}
    4e6c:	81 2f       	mov	r24, r17
    4e6e:	df 91       	pop	r29
    4e70:	cf 91       	pop	r28
    4e72:	1f 91       	pop	r17
    4e74:	0f 91       	pop	r16
    4e76:	ff 90       	pop	r15
    4e78:	ef 90       	pop	r14
    4e7a:	df 90       	pop	r13
    4e7c:	cf 90       	pop	r12
    4e7e:	bf 90       	pop	r11
    4e80:	af 90       	pop	r10
    4e82:	9f 90       	pop	r9
    4e84:	8f 90       	pop	r8
    4e86:	7f 90       	pop	r7
    4e88:	6f 90       	pop	r6
    4e8a:	08 95       	ret
		res = FR_INT_ERR;

	} else {
		switch (fs->fs_type) {
		case FS_FAT12 :
			bc = clst; bc += bc / 2;
    4e8c:	3a 01       	movw	r6, r20
    4e8e:	76 94       	lsr	r7
    4e90:	67 94       	ror	r6
    4e92:	64 0e       	add	r6, r20
    4e94:	75 1e       	adc	r7, r21
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
    4e96:	a3 01       	movw	r20, r6
    4e98:	45 2f       	mov	r20, r21
    4e9a:	55 27       	eor	r21, r21
    4e9c:	46 95       	lsr	r20
    4e9e:	60 e0       	ldi	r22, 0x00	; 0
    4ea0:	70 e0       	ldi	r23, 0x00	; 0
    4ea2:	8e 8d       	ldd	r24, Y+30	; 0x1e
    4ea4:	9f 8d       	ldd	r25, Y+31	; 0x1f
    4ea6:	a8 a1       	ldd	r26, Y+32	; 0x20
    4ea8:	b9 a1       	ldd	r27, Y+33	; 0x21
    4eaa:	48 0f       	add	r20, r24
    4eac:	59 1f       	adc	r21, r25
    4eae:	6a 1f       	adc	r22, r26
    4eb0:	7b 1f       	adc	r23, r27
    4eb2:	ce 01       	movw	r24, r28
    4eb4:	0e 94 8b 26 	call	0x4d16	; 0x4d16 <move_window>
    4eb8:	18 2f       	mov	r17, r24
			if (res != FR_OK) break;
    4eba:	88 23       	and	r24, r24
    4ebc:	99 f6       	brne	.-90     	; 0x4e64 <put_fat+0x56>
			p = &fs->win[bc % SS(fs)];
    4ebe:	93 01       	movw	r18, r6
    4ec0:	31 70       	andi	r19, 0x01	; 1
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
    4ec2:	a1 e0       	ldi	r26, 0x01	; 1
    4ec4:	ca 22       	and	r12, r26
    4ec6:	dd 24       	eor	r13, r13
    4ec8:	c1 14       	cp	r12, r1
    4eca:	d1 04       	cpc	r13, r1
    4ecc:	09 f0       	breq	.+2      	; 0x4ed0 <put_fat+0xc2>
    4ece:	9e c0       	rjmp	.+316    	; 0x500c <put_fat+0x1fe>
    4ed0:	98 2d       	mov	r25, r8
    4ed2:	fe 01       	movw	r30, r28
    4ed4:	e2 0f       	add	r30, r18
    4ed6:	f3 1f       	adc	r31, r19
    4ed8:	96 a7       	std	Z+46, r25	; 0x2e
			bc++;
    4eda:	73 01       	movw	r14, r6
    4edc:	08 94       	sec
    4ede:	e1 1c       	adc	r14, r1
    4ee0:	f1 1c       	adc	r15, r1
			fs->wflag = 1;
    4ee2:	81 e0       	ldi	r24, 0x01	; 1
    4ee4:	8c 83       	std	Y+4, r24	; 0x04
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
    4ee6:	a7 01       	movw	r20, r14
    4ee8:	45 2f       	mov	r20, r21
    4eea:	55 27       	eor	r21, r21
    4eec:	46 95       	lsr	r20
    4eee:	60 e0       	ldi	r22, 0x00	; 0
    4ef0:	70 e0       	ldi	r23, 0x00	; 0
    4ef2:	8e 8d       	ldd	r24, Y+30	; 0x1e
    4ef4:	9f 8d       	ldd	r25, Y+31	; 0x1f
    4ef6:	a8 a1       	ldd	r26, Y+32	; 0x20
    4ef8:	b9 a1       	ldd	r27, Y+33	; 0x21
    4efa:	48 0f       	add	r20, r24
    4efc:	59 1f       	adc	r21, r25
    4efe:	6a 1f       	adc	r22, r26
    4f00:	7b 1f       	adc	r23, r27
    4f02:	ce 01       	movw	r24, r28
    4f04:	0e 94 8b 26 	call	0x4d16	; 0x4d16 <move_window>
    4f08:	18 2f       	mov	r17, r24
			if (res != FR_OK) break;
    4f0a:	88 23       	and	r24, r24
    4f0c:	09 f0       	breq	.+2      	; 0x4f10 <put_fat+0x102>
    4f0e:	aa cf       	rjmp	.-172    	; 0x4e64 <put_fat+0x56>
			p = &fs->win[bc % SS(fs)];
    4f10:	a7 01       	movw	r20, r14
    4f12:	51 70       	andi	r21, 0x01	; 1
			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
    4f14:	cd 28       	or	r12, r13
    4f16:	09 f4       	brne	.+2      	; 0x4f1a <put_fat+0x10c>
    4f18:	83 c0       	rjmp	.+262    	; 0x5020 <put_fat+0x212>
    4f1a:	84 e0       	ldi	r24, 0x04	; 4
    4f1c:	b6 94       	lsr	r11
    4f1e:	a7 94       	ror	r10
    4f20:	97 94       	ror	r9
    4f22:	87 94       	ror	r8
    4f24:	8a 95       	dec	r24
    4f26:	d1 f7       	brne	.-12     	; 0x4f1c <put_fat+0x10e>
    4f28:	68 2d       	mov	r22, r8
    4f2a:	fe 01       	movw	r30, r28
    4f2c:	e4 0f       	add	r30, r20
    4f2e:	f5 1f       	adc	r31, r21
    4f30:	66 a7       	std	Z+46, r22	; 0x2e
    4f32:	98 cf       	rjmp	.-208    	; 0x4e64 <put_fat+0x56>
			p = &fs->win[clst * 2 % SS(fs)];
			ST_WORD(p, (WORD)val);
			break;

		case FS_FAT32 :
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
    4f34:	e7 e0       	ldi	r30, 0x07	; 7
    4f36:	76 95       	lsr	r23
    4f38:	67 95       	ror	r22
    4f3a:	57 95       	ror	r21
    4f3c:	47 95       	ror	r20
    4f3e:	ea 95       	dec	r30
    4f40:	d1 f7       	brne	.-12     	; 0x4f36 <put_fat+0x128>
    4f42:	8e 8d       	ldd	r24, Y+30	; 0x1e
    4f44:	9f 8d       	ldd	r25, Y+31	; 0x1f
    4f46:	a8 a1       	ldd	r26, Y+32	; 0x20
    4f48:	b9 a1       	ldd	r27, Y+33	; 0x21
    4f4a:	48 0f       	add	r20, r24
    4f4c:	59 1f       	adc	r21, r25
    4f4e:	6a 1f       	adc	r22, r26
    4f50:	7b 1f       	adc	r23, r27
    4f52:	ce 01       	movw	r24, r28
    4f54:	0e 94 8b 26 	call	0x4d16	; 0x4d16 <move_window>
    4f58:	18 2f       	mov	r17, r24
			if (res != FR_OK) break;
    4f5a:	88 23       	and	r24, r24
    4f5c:	09 f0       	breq	.+2      	; 0x4f60 <put_fat+0x152>
    4f5e:	82 cf       	rjmp	.-252    	; 0x4e64 <put_fat+0x56>
			p = &fs->win[clst * 4 % SS(fs)];
    4f60:	cc 0c       	add	r12, r12
    4f62:	dd 1c       	adc	r13, r13
    4f64:	ee 1c       	adc	r14, r14
    4f66:	ff 1c       	adc	r15, r15
    4f68:	cc 0c       	add	r12, r12
    4f6a:	dd 1c       	adc	r13, r13
    4f6c:	ee 1c       	adc	r14, r14
    4f6e:	ff 1c       	adc	r15, r15
    4f70:	f6 01       	movw	r30, r12
    4f72:	f1 70       	andi	r31, 0x01	; 1
    4f74:	be 96       	adiw	r30, 0x2e	; 46
    4f76:	be 01       	movw	r22, r28
    4f78:	6e 0f       	add	r22, r30
    4f7a:	7f 1f       	adc	r23, r31
    4f7c:	be 97       	sbiw	r30, 0x2e	; 46
			val |= LD_DWORD(p) & 0xF0000000;
    4f7e:	db 01       	movw	r26, r22
    4f80:	13 96       	adiw	r26, 0x03	; 3
    4f82:	8c 91       	ld	r24, X
    4f84:	90 e0       	ldi	r25, 0x00	; 0
    4f86:	a0 e0       	ldi	r26, 0x00	; 0
    4f88:	b0 e0       	ldi	r27, 0x00	; 0
    4f8a:	b8 2f       	mov	r27, r24
    4f8c:	aa 27       	eor	r26, r26
    4f8e:	99 27       	eor	r25, r25
    4f90:	88 27       	eor	r24, r24
    4f92:	ec 0f       	add	r30, r28
    4f94:	fd 1f       	adc	r31, r29
    4f96:	80 70       	andi	r24, 0x00	; 0
    4f98:	90 70       	andi	r25, 0x00	; 0
    4f9a:	a0 70       	andi	r26, 0x00	; 0
    4f9c:	b0 7f       	andi	r27, 0xF0	; 240
    4f9e:	88 29       	or	r24, r8
    4fa0:	99 29       	or	r25, r9
    4fa2:	aa 29       	or	r26, r10
    4fa4:	bb 29       	or	r27, r11
			ST_DWORD(p, val);
    4fa6:	86 a7       	std	Z+46, r24	; 0x2e
    4fa8:	29 2f       	mov	r18, r25
    4faa:	33 27       	eor	r19, r19
    4fac:	fb 01       	movw	r30, r22
    4fae:	21 83       	std	Z+1, r18	; 0x01
    4fb0:	9d 01       	movw	r18, r26
    4fb2:	44 27       	eor	r20, r20
    4fb4:	55 27       	eor	r21, r21
    4fb6:	22 83       	std	Z+2, r18	; 0x02
    4fb8:	8b 2f       	mov	r24, r27
    4fba:	99 27       	eor	r25, r25
    4fbc:	aa 27       	eor	r26, r26
    4fbe:	bb 27       	eor	r27, r27
    4fc0:	83 83       	std	Z+3, r24	; 0x03
    4fc2:	50 cf       	rjmp	.-352    	; 0x4e64 <put_fat+0x56>
			p = &fs->win[bc % SS(fs)];
			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
			break;

		case FS_FAT16 :
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
    4fc4:	45 2f       	mov	r20, r21
    4fc6:	56 2f       	mov	r21, r22
    4fc8:	67 2f       	mov	r22, r23
    4fca:	77 27       	eor	r23, r23
    4fcc:	8e 8d       	ldd	r24, Y+30	; 0x1e
    4fce:	9f 8d       	ldd	r25, Y+31	; 0x1f
    4fd0:	a8 a1       	ldd	r26, Y+32	; 0x20
    4fd2:	b9 a1       	ldd	r27, Y+33	; 0x21
    4fd4:	48 0f       	add	r20, r24
    4fd6:	59 1f       	adc	r21, r25
    4fd8:	6a 1f       	adc	r22, r26
    4fda:	7b 1f       	adc	r23, r27
    4fdc:	ce 01       	movw	r24, r28
    4fde:	0e 94 8b 26 	call	0x4d16	; 0x4d16 <move_window>
    4fe2:	18 2f       	mov	r17, r24
			if (res != FR_OK) break;
    4fe4:	88 23       	and	r24, r24
    4fe6:	09 f0       	breq	.+2      	; 0x4fea <put_fat+0x1dc>
    4fe8:	3d cf       	rjmp	.-390    	; 0x4e64 <put_fat+0x56>
			p = &fs->win[clst * 2 % SS(fs)];
    4fea:	cc 0c       	add	r12, r12
    4fec:	dd 1c       	adc	r13, r13
    4fee:	ee 1c       	adc	r14, r14
    4ff0:	ff 1c       	adc	r15, r15
    4ff2:	f6 01       	movw	r30, r12
    4ff4:	f1 70       	andi	r31, 0x01	; 1
			ST_WORD(p, (WORD)val);
    4ff6:	de 01       	movw	r26, r28
    4ff8:	ae 0f       	add	r26, r30
    4ffa:	bf 1f       	adc	r27, r31
    4ffc:	9e 96       	adiw	r26, 0x2e	; 46
    4ffe:	8c 92       	st	X, r8
    5000:	9e 97       	sbiw	r26, 0x2e	; 46
    5002:	fd 01       	movw	r30, r26
    5004:	89 2d       	mov	r24, r9
    5006:	99 27       	eor	r25, r25
    5008:	87 a7       	std	Z+47, r24	; 0x2f
    500a:	2c cf       	rjmp	.-424    	; 0x4e64 <put_fat+0x56>
		case FS_FAT12 :
			bc = clst; bc += bc / 2;
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
			if (res != FR_OK) break;
			p = &fs->win[bc % SS(fs)];
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
    500c:	fe 01       	movw	r30, r28
    500e:	e2 0f       	add	r30, r18
    5010:	f3 1f       	adc	r31, r19
    5012:	86 a5       	ldd	r24, Z+46	; 0x2e
    5014:	8f 70       	andi	r24, 0x0F	; 15
    5016:	98 2d       	mov	r25, r8
    5018:	92 95       	swap	r25
    501a:	90 7f       	andi	r25, 0xF0	; 240
    501c:	98 2b       	or	r25, r24
    501e:	5c cf       	rjmp	.-328    	; 0x4ed8 <put_fat+0xca>
			bc++;
			fs->wflag = 1;
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
			if (res != FR_OK) break;
			p = &fs->win[bc % SS(fs)];
			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
    5020:	fe 01       	movw	r30, r28
    5022:	e4 0f       	add	r30, r20
    5024:	f5 1f       	adc	r31, r21
    5026:	66 a5       	ldd	r22, Z+46	; 0x2e
    5028:	60 7f       	andi	r22, 0xF0	; 240
    502a:	bb 27       	eor	r27, r27
    502c:	ab 2d       	mov	r26, r11
    502e:	9a 2d       	mov	r25, r10
    5030:	89 2d       	mov	r24, r9
    5032:	8f 70       	andi	r24, 0x0F	; 15
    5034:	68 2b       	or	r22, r24
    5036:	66 a7       	std	Z+46, r22	; 0x2e
    5038:	15 cf       	rjmp	.-470    	; 0x4e64 <put_fat+0x56>

0000503a <get_fat>:

DWORD get_fat (	/* 0xFFFFFFFF:Disk error, 1:Internal error, Else:Cluster status */
	FATFS *fs,	/* File system object */
	DWORD clst	/* Cluster# to get the link information */
)
{
    503a:	bf 92       	push	r11
    503c:	cf 92       	push	r12
    503e:	df 92       	push	r13
    5040:	ef 92       	push	r14
    5042:	ff 92       	push	r15
    5044:	0f 93       	push	r16
    5046:	1f 93       	push	r17
    5048:	cf 93       	push	r28
    504a:	df 93       	push	r29
    504c:	ec 01       	movw	r28, r24
    504e:	7a 01       	movw	r14, r20
    5050:	8b 01       	movw	r16, r22
	UINT wc, bc;
	BYTE *p;


	if (clst < 2 || clst >= fs->n_fatent)	/* Chack range */
    5052:	42 30       	cpi	r20, 0x02	; 2
    5054:	51 05       	cpc	r21, r1
    5056:	61 05       	cpc	r22, r1
    5058:	71 05       	cpc	r23, r1
    505a:	b8 f0       	brcs	.+46     	; 0x508a <get_fat+0x50>
    505c:	8e 89       	ldd	r24, Y+22	; 0x16
    505e:	9f 89       	ldd	r25, Y+23	; 0x17
    5060:	a8 8d       	ldd	r26, Y+24	; 0x18
    5062:	b9 8d       	ldd	r27, Y+25	; 0x19
    5064:	48 17       	cp	r20, r24
    5066:	59 07       	cpc	r21, r25
    5068:	6a 07       	cpc	r22, r26
    506a:	7b 07       	cpc	r23, r27
    506c:	70 f4       	brcc	.+28     	; 0x508a <get_fat+0x50>
		return 1;

	switch (fs->fs_type) {
    506e:	88 81       	ld	r24, Y
    5070:	82 30       	cpi	r24, 0x02	; 2
    5072:	09 f4       	brne	.+2      	; 0x5076 <get_fat+0x3c>
    5074:	c4 c0       	rjmp	.+392    	; 0x51fe <get_fat+0x1c4>
    5076:	83 30       	cpi	r24, 0x03	; 3
    5078:	09 f4       	brne	.+2      	; 0x507c <get_fat+0x42>
    507a:	69 c0       	rjmp	.+210    	; 0x514e <get_fat+0x114>
    507c:	81 30       	cpi	r24, 0x01	; 1
    507e:	b1 f0       	breq	.+44     	; 0x50ac <get_fat+0x72>
		return LD_WORD(p);

	case FS_FAT32 :
		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)))) break;
		p = &fs->win[clst * 4 % SS(fs)];
		return LD_DWORD(p) & 0x0FFFFFFF;
    5080:	ee 24       	eor	r14, r14
    5082:	ea 94       	dec	r14
    5084:	fe 2c       	mov	r15, r14
    5086:	87 01       	movw	r16, r14
    5088:	05 c0       	rjmp	.+10     	; 0x5094 <get_fat+0x5a>
    508a:	41 e0       	ldi	r20, 0x01	; 1
    508c:	e4 2e       	mov	r14, r20
    508e:	f1 2c       	mov	r15, r1
    5090:	01 2d       	mov	r16, r1
    5092:	11 2d       	mov	r17, r1
	}

	return 0xFFFFFFFF;	/* An error occurred at the disk I/O layer */
}
    5094:	b7 01       	movw	r22, r14
    5096:	c8 01       	movw	r24, r16
    5098:	df 91       	pop	r29
    509a:	cf 91       	pop	r28
    509c:	1f 91       	pop	r17
    509e:	0f 91       	pop	r16
    50a0:	ff 90       	pop	r15
    50a2:	ef 90       	pop	r14
    50a4:	df 90       	pop	r13
    50a6:	cf 90       	pop	r12
    50a8:	bf 90       	pop	r11
    50aa:	08 95       	ret
	if (clst < 2 || clst >= fs->n_fatent)	/* Chack range */
		return 1;

	switch (fs->fs_type) {
	case FS_FAT12 :
		bc = (UINT)clst; bc += bc / 2;
    50ac:	6a 01       	movw	r12, r20
    50ae:	d6 94       	lsr	r13
    50b0:	c7 94       	ror	r12
    50b2:	c4 0e       	add	r12, r20
    50b4:	d5 1e       	adc	r13, r21
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
    50b6:	a6 01       	movw	r20, r12
    50b8:	45 2f       	mov	r20, r21
    50ba:	55 27       	eor	r21, r21
    50bc:	46 95       	lsr	r20
    50be:	60 e0       	ldi	r22, 0x00	; 0
    50c0:	70 e0       	ldi	r23, 0x00	; 0
    50c2:	8e 8d       	ldd	r24, Y+30	; 0x1e
    50c4:	9f 8d       	ldd	r25, Y+31	; 0x1f
    50c6:	a8 a1       	ldd	r26, Y+32	; 0x20
    50c8:	b9 a1       	ldd	r27, Y+33	; 0x21
    50ca:	48 0f       	add	r20, r24
    50cc:	59 1f       	adc	r21, r25
    50ce:	6a 1f       	adc	r22, r26
    50d0:	7b 1f       	adc	r23, r27
    50d2:	ce 01       	movw	r24, r28
    50d4:	0e 94 8b 26 	call	0x4d16	; 0x4d16 <move_window>
    50d8:	88 23       	and	r24, r24
    50da:	91 f6       	brne	.-92     	; 0x5080 <get_fat+0x46>
		wc = fs->win[bc % SS(fs)]; bc++;
    50dc:	f6 01       	movw	r30, r12
    50de:	f1 70       	andi	r31, 0x01	; 1
    50e0:	ec 0f       	add	r30, r28
    50e2:	fd 1f       	adc	r31, r29
    50e4:	b6 a4       	ldd	r11, Z+46	; 0x2e
    50e6:	08 94       	sec
    50e8:	c1 1c       	adc	r12, r1
    50ea:	d1 1c       	adc	r13, r1
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
    50ec:	a6 01       	movw	r20, r12
    50ee:	45 2f       	mov	r20, r21
    50f0:	55 27       	eor	r21, r21
    50f2:	46 95       	lsr	r20
    50f4:	60 e0       	ldi	r22, 0x00	; 0
    50f6:	70 e0       	ldi	r23, 0x00	; 0
    50f8:	8e 8d       	ldd	r24, Y+30	; 0x1e
    50fa:	9f 8d       	ldd	r25, Y+31	; 0x1f
    50fc:	a8 a1       	ldd	r26, Y+32	; 0x20
    50fe:	b9 a1       	ldd	r27, Y+33	; 0x21
    5100:	48 0f       	add	r20, r24
    5102:	59 1f       	adc	r21, r25
    5104:	6a 1f       	adc	r22, r26
    5106:	7b 1f       	adc	r23, r27
    5108:	ce 01       	movw	r24, r28
    510a:	0e 94 8b 26 	call	0x4d16	; 0x4d16 <move_window>
    510e:	88 23       	and	r24, r24
    5110:	09 f0       	breq	.+2      	; 0x5114 <get_fat+0xda>
    5112:	b6 cf       	rjmp	.-148    	; 0x5080 <get_fat+0x46>

	switch (fs->fs_type) {
	case FS_FAT12 :
		bc = (UINT)clst; bc += bc / 2;
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
		wc = fs->win[bc % SS(fs)]; bc++;
    5114:	2b 2d       	mov	r18, r11
    5116:	30 e0       	ldi	r19, 0x00	; 0
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
		wc |= fs->win[bc % SS(fs)] << 8;
    5118:	af ef       	ldi	r26, 0xFF	; 255
    511a:	b1 e0       	ldi	r27, 0x01	; 1
    511c:	ca 22       	and	r12, r26
    511e:	db 22       	and	r13, r27
    5120:	cc 0e       	add	r12, r28
    5122:	dd 1e       	adc	r13, r29
    5124:	f6 01       	movw	r30, r12
    5126:	96 a5       	ldd	r25, Z+46	; 0x2e
    5128:	80 e0       	ldi	r24, 0x00	; 0
    512a:	28 2b       	or	r18, r24
    512c:	39 2b       	or	r19, r25
		return (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
    512e:	c7 01       	movw	r24, r14
    5130:	81 70       	andi	r24, 0x01	; 1
    5132:	90 70       	andi	r25, 0x00	; 0
    5134:	89 2b       	or	r24, r25
    5136:	09 f4       	brne	.+2      	; 0x513a <get_fat+0x100>
    5138:	87 c0       	rjmp	.+270    	; 0x5248 <get_fat+0x20e>
    513a:	32 95       	swap	r19
    513c:	22 95       	swap	r18
    513e:	2f 70       	andi	r18, 0x0F	; 15
    5140:	23 27       	eor	r18, r19
    5142:	3f 70       	andi	r19, 0x0F	; 15
    5144:	23 27       	eor	r18, r19
    5146:	79 01       	movw	r14, r18
    5148:	00 e0       	ldi	r16, 0x00	; 0
    514a:	10 e0       	ldi	r17, 0x00	; 0
    514c:	a3 cf       	rjmp	.-186    	; 0x5094 <get_fat+0x5a>
		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)))) break;
		p = &fs->win[clst * 2 % SS(fs)];
		return LD_WORD(p);

	case FS_FAT32 :
		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)))) break;
    514e:	e7 e0       	ldi	r30, 0x07	; 7
    5150:	76 95       	lsr	r23
    5152:	67 95       	ror	r22
    5154:	57 95       	ror	r21
    5156:	47 95       	ror	r20
    5158:	ea 95       	dec	r30
    515a:	d1 f7       	brne	.-12     	; 0x5150 <get_fat+0x116>
    515c:	8e 8d       	ldd	r24, Y+30	; 0x1e
    515e:	9f 8d       	ldd	r25, Y+31	; 0x1f
    5160:	a8 a1       	ldd	r26, Y+32	; 0x20
    5162:	b9 a1       	ldd	r27, Y+33	; 0x21
    5164:	48 0f       	add	r20, r24
    5166:	59 1f       	adc	r21, r25
    5168:	6a 1f       	adc	r22, r26
    516a:	7b 1f       	adc	r23, r27
    516c:	ce 01       	movw	r24, r28
    516e:	0e 94 8b 26 	call	0x4d16	; 0x4d16 <move_window>
    5172:	88 23       	and	r24, r24
    5174:	09 f0       	breq	.+2      	; 0x5178 <get_fat+0x13e>
    5176:	84 cf       	rjmp	.-248    	; 0x5080 <get_fat+0x46>
		p = &fs->win[clst * 4 % SS(fs)];
    5178:	ee 0c       	add	r14, r14
    517a:	ff 1c       	adc	r15, r15
    517c:	00 1f       	adc	r16, r16
    517e:	11 1f       	adc	r17, r17
    5180:	ee 0c       	add	r14, r14
    5182:	ff 1c       	adc	r15, r15
    5184:	00 1f       	adc	r16, r16
    5186:	11 1f       	adc	r17, r17
    5188:	f7 01       	movw	r30, r14
    518a:	f1 70       	andi	r31, 0x01	; 1
    518c:	be 96       	adiw	r30, 0x2e	; 46
    518e:	9e 01       	movw	r18, r28
    5190:	2e 0f       	add	r18, r30
    5192:	3f 1f       	adc	r19, r31
    5194:	be 97       	sbiw	r30, 0x2e	; 46
		return LD_DWORD(p) & 0x0FFFFFFF;
    5196:	d9 01       	movw	r26, r18
    5198:	12 96       	adiw	r26, 0x02	; 2
    519a:	8c 91       	ld	r24, X
    519c:	90 e0       	ldi	r25, 0x00	; 0
    519e:	a0 e0       	ldi	r26, 0x00	; 0
    51a0:	b0 e0       	ldi	r27, 0x00	; 0
    51a2:	8c 01       	movw	r16, r24
    51a4:	ff 24       	eor	r15, r15
    51a6:	ee 24       	eor	r14, r14
    51a8:	d9 01       	movw	r26, r18
    51aa:	13 96       	adiw	r26, 0x03	; 3
    51ac:	8c 91       	ld	r24, X
    51ae:	90 e0       	ldi	r25, 0x00	; 0
    51b0:	a0 e0       	ldi	r26, 0x00	; 0
    51b2:	b0 e0       	ldi	r27, 0x00	; 0
    51b4:	b8 2f       	mov	r27, r24
    51b6:	aa 27       	eor	r26, r26
    51b8:	99 27       	eor	r25, r25
    51ba:	88 27       	eor	r24, r24
    51bc:	e8 2a       	or	r14, r24
    51be:	f9 2a       	or	r15, r25
    51c0:	0a 2b       	or	r16, r26
    51c2:	1b 2b       	or	r17, r27
    51c4:	d9 01       	movw	r26, r18
    51c6:	11 96       	adiw	r26, 0x01	; 1
    51c8:	9c 91       	ld	r25, X
    51ca:	80 e0       	ldi	r24, 0x00	; 0
    51cc:	a0 e0       	ldi	r26, 0x00	; 0
    51ce:	b0 e0       	ldi	r27, 0x00	; 0
    51d0:	e8 2a       	or	r14, r24
    51d2:	f9 2a       	or	r15, r25
    51d4:	0a 2b       	or	r16, r26
    51d6:	1b 2b       	or	r17, r27
    51d8:	ec 0f       	add	r30, r28
    51da:	fd 1f       	adc	r31, r29
    51dc:	86 a5       	ldd	r24, Z+46	; 0x2e
    51de:	90 e0       	ldi	r25, 0x00	; 0
    51e0:	a0 e0       	ldi	r26, 0x00	; 0
    51e2:	b0 e0       	ldi	r27, 0x00	; 0
    51e4:	e8 2a       	or	r14, r24
    51e6:	f9 2a       	or	r15, r25
    51e8:	0a 2b       	or	r16, r26
    51ea:	1b 2b       	or	r17, r27
    51ec:	8f ef       	ldi	r24, 0xFF	; 255
    51ee:	9f ef       	ldi	r25, 0xFF	; 255
    51f0:	af ef       	ldi	r26, 0xFF	; 255
    51f2:	bf e0       	ldi	r27, 0x0F	; 15
    51f4:	e8 22       	and	r14, r24
    51f6:	f9 22       	and	r15, r25
    51f8:	0a 23       	and	r16, r26
    51fa:	1b 23       	and	r17, r27
    51fc:	4b cf       	rjmp	.-362    	; 0x5094 <get_fat+0x5a>
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
		wc |= fs->win[bc % SS(fs)] << 8;
		return (clst & 1) ? (wc >> 4) : (wc & 0xFFF);

	case FS_FAT16 :
		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)))) break;
    51fe:	45 2f       	mov	r20, r21
    5200:	56 2f       	mov	r21, r22
    5202:	67 2f       	mov	r22, r23
    5204:	77 27       	eor	r23, r23
    5206:	8e 8d       	ldd	r24, Y+30	; 0x1e
    5208:	9f 8d       	ldd	r25, Y+31	; 0x1f
    520a:	a8 a1       	ldd	r26, Y+32	; 0x20
    520c:	b9 a1       	ldd	r27, Y+33	; 0x21
    520e:	48 0f       	add	r20, r24
    5210:	59 1f       	adc	r21, r25
    5212:	6a 1f       	adc	r22, r26
    5214:	7b 1f       	adc	r23, r27
    5216:	ce 01       	movw	r24, r28
    5218:	0e 94 8b 26 	call	0x4d16	; 0x4d16 <move_window>
    521c:	88 23       	and	r24, r24
    521e:	09 f0       	breq	.+2      	; 0x5222 <get_fat+0x1e8>
    5220:	2f cf       	rjmp	.-418    	; 0x5080 <get_fat+0x46>
		p = &fs->win[clst * 2 % SS(fs)];
    5222:	ee 0c       	add	r14, r14
    5224:	ff 1c       	adc	r15, r15
    5226:	00 1f       	adc	r16, r16
    5228:	11 1f       	adc	r17, r17
    522a:	d7 01       	movw	r26, r14
    522c:	b1 70       	andi	r27, 0x01	; 1
		return LD_WORD(p);
    522e:	fe 01       	movw	r30, r28
    5230:	ea 0f       	add	r30, r26
    5232:	fb 1f       	adc	r31, r27
    5234:	26 a5       	ldd	r18, Z+46	; 0x2e
    5236:	30 e0       	ldi	r19, 0x00	; 0
    5238:	97 a5       	ldd	r25, Z+47	; 0x2f
    523a:	80 e0       	ldi	r24, 0x00	; 0
    523c:	28 2b       	or	r18, r24
    523e:	39 2b       	or	r19, r25
    5240:	79 01       	movw	r14, r18
    5242:	00 e0       	ldi	r16, 0x00	; 0
    5244:	10 e0       	ldi	r17, 0x00	; 0
    5246:	26 cf       	rjmp	.-436    	; 0x5094 <get_fat+0x5a>
		bc = (UINT)clst; bc += bc / 2;
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
		wc = fs->win[bc % SS(fs)]; bc++;
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
		wc |= fs->win[bc % SS(fs)] << 8;
		return (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
    5248:	79 01       	movw	r14, r18
    524a:	00 e0       	ldi	r16, 0x00	; 0
    524c:	10 e0       	ldi	r17, 0x00	; 0
    524e:	8f ef       	ldi	r24, 0xFF	; 255
    5250:	9f e0       	ldi	r25, 0x0F	; 15
    5252:	a0 e0       	ldi	r26, 0x00	; 0
    5254:	b0 e0       	ldi	r27, 0x00	; 0
    5256:	e8 22       	and	r14, r24
    5258:	f9 22       	and	r15, r25
    525a:	0a 23       	and	r16, r26
    525c:	1b 23       	and	r17, r27
    525e:	1a cf       	rjmp	.-460    	; 0x5094 <get_fat+0x5a>

00005260 <dir_sdi>:
static
FRESULT dir_sdi (
	DIR *dj,		/* Pointer to directory object */
	WORD idx		/* Directory index number */
)
{
    5260:	8f 92       	push	r8
    5262:	9f 92       	push	r9
    5264:	af 92       	push	r10
    5266:	bf 92       	push	r11
    5268:	cf 92       	push	r12
    526a:	df 92       	push	r13
    526c:	ef 92       	push	r14
    526e:	ff 92       	push	r15
    5270:	0f 93       	push	r16
    5272:	1f 93       	push	r17
    5274:	cf 93       	push	r28
    5276:	df 93       	push	r29
    5278:	6c 01       	movw	r12, r24
    527a:	7b 01       	movw	r14, r22
	DWORD clst;
	WORD ic;


	dj->index = idx;
    527c:	fc 01       	movw	r30, r24
    527e:	75 83       	std	Z+5, r23	; 0x05
    5280:	64 83       	std	Z+4, r22	; 0x04
	clst = dj->sclust;
    5282:	46 81       	ldd	r20, Z+6	; 0x06
    5284:	57 81       	ldd	r21, Z+7	; 0x07
    5286:	60 85       	ldd	r22, Z+8	; 0x08
    5288:	71 85       	ldd	r23, Z+9	; 0x09
	if (clst == 1 || clst >= dj->fs->n_fatent)	/* Check start cluster range */
    528a:	41 30       	cpi	r20, 0x01	; 1
    528c:	51 05       	cpc	r21, r1
    528e:	61 05       	cpc	r22, r1
    5290:	71 05       	cpc	r23, r1
    5292:	09 f4       	brne	.+2      	; 0x5296 <dir_sdi+0x36>
    5294:	68 c0       	rjmp	.+208    	; 0x5366 <dir_sdi+0x106>
    5296:	c0 81       	ld	r28, Z
    5298:	d1 81       	ldd	r29, Z+1	; 0x01
    529a:	8e 89       	ldd	r24, Y+22	; 0x16
    529c:	9f 89       	ldd	r25, Y+23	; 0x17
    529e:	a8 8d       	ldd	r26, Y+24	; 0x18
    52a0:	b9 8d       	ldd	r27, Y+25	; 0x19
    52a2:	48 17       	cp	r20, r24
    52a4:	59 07       	cpc	r21, r25
    52a6:	6a 07       	cpc	r22, r26
    52a8:	7b 07       	cpc	r23, r27
    52aa:	08 f0       	brcs	.+2      	; 0x52ae <dir_sdi+0x4e>
    52ac:	5c c0       	rjmp	.+184    	; 0x5366 <dir_sdi+0x106>
		return FR_INT_ERR;
	if (!clst && dj->fs->fs_type == FS_FAT32)	/* Replace cluster# 0 with root cluster# if in FAT32 */
    52ae:	41 15       	cp	r20, r1
    52b0:	51 05       	cpc	r21, r1
    52b2:	61 05       	cpc	r22, r1
    52b4:	71 05       	cpc	r23, r1
    52b6:	09 f4       	brne	.+2      	; 0x52ba <dir_sdi+0x5a>
    52b8:	3f c0       	rjmp	.+126    	; 0x5338 <dir_sdi+0xd8>
		if (idx >= dj->fs->n_rootdir)		/* Index is out of range */
			return FR_INT_ERR;
		dj->sect = dj->fs->dirbase + idx / (SS(dj->fs) / 32);	/* Sector# */
	}
	else {				/* Dynamic table (sub-dirs or root-dir in FAT32) */
		ic = SS(dj->fs) / 32 * dj->fs->csize;	/* Entries per cluster */
    52ba:	8a 81       	ldd	r24, Y+2	; 0x02
    52bc:	08 2f       	mov	r16, r24
    52be:	10 e0       	ldi	r17, 0x00	; 0
    52c0:	02 95       	swap	r16
    52c2:	12 95       	swap	r17
    52c4:	10 7f       	andi	r17, 0xF0	; 240
    52c6:	10 27       	eor	r17, r16
    52c8:	00 7f       	andi	r16, 0xF0	; 240
    52ca:	10 27       	eor	r17, r16
		while (idx >= ic) {	/* Follow cluster chain */
    52cc:	e0 16       	cp	r14, r16
    52ce:	f1 06       	cpc	r15, r17
    52d0:	08 f4       	brcc	.+2      	; 0x52d4 <dir_sdi+0x74>
    52d2:	83 c0       	rjmp	.+262    	; 0x53da <dir_sdi+0x17a>
    52d4:	aa 24       	eor	r10, r10
    52d6:	bb 24       	eor	r11, r11
    52d8:	a0 1a       	sub	r10, r16
    52da:	b1 0a       	sbc	r11, r17
    52dc:	e0 1a       	sub	r14, r16
    52de:	f1 0a       	sbc	r15, r17
    52e0:	1c c0       	rjmp	.+56     	; 0x531a <dir_sdi+0xba>
			clst = get_fat(dj->fs, clst);				/* Get next cluster */
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
			if (clst < 2 || clst >= dj->fs->n_fatent)	/* Reached to end of table or int error */
    52e2:	42 30       	cpi	r20, 0x02	; 2
    52e4:	51 05       	cpc	r21, r1
    52e6:	61 05       	cpc	r22, r1
    52e8:	71 05       	cpc	r23, r1
    52ea:	e8 f1       	brcs	.+122    	; 0x5366 <dir_sdi+0x106>
    52ec:	f6 01       	movw	r30, r12
    52ee:	c0 81       	ld	r28, Z
    52f0:	d1 81       	ldd	r29, Z+1	; 0x01
    52f2:	8e 89       	ldd	r24, Y+22	; 0x16
    52f4:	9f 89       	ldd	r25, Y+23	; 0x17
    52f6:	a8 8d       	ldd	r26, Y+24	; 0x18
    52f8:	b9 8d       	ldd	r27, Y+25	; 0x19
    52fa:	48 17       	cp	r20, r24
    52fc:	59 07       	cpc	r21, r25
    52fe:	6a 07       	cpc	r22, r26
    5300:	7b 07       	cpc	r23, r27
    5302:	88 f5       	brcc	.+98     	; 0x5366 <dir_sdi+0x106>
    5304:	97 01       	movw	r18, r14
    5306:	2a 0d       	add	r18, r10
    5308:	3b 1d       	adc	r19, r11
			return FR_INT_ERR;
		dj->sect = dj->fs->dirbase + idx / (SS(dj->fs) / 32);	/* Sector# */
	}
	else {				/* Dynamic table (sub-dirs or root-dir in FAT32) */
		ic = SS(dj->fs) / 32 * dj->fs->csize;	/* Entries per cluster */
		while (idx >= ic) {	/* Follow cluster chain */
    530a:	c9 01       	movw	r24, r18
    530c:	80 0f       	add	r24, r16
    530e:	91 1f       	adc	r25, r17
    5310:	80 17       	cp	r24, r16
    5312:	91 07       	cpc	r25, r17
    5314:	08 f4       	brcc	.+2      	; 0x5318 <dir_sdi+0xb8>
    5316:	61 c0       	rjmp	.+194    	; 0x53da <dir_sdi+0x17a>
    5318:	79 01       	movw	r14, r18
			clst = get_fat(dj->fs, clst);				/* Get next cluster */
    531a:	ce 01       	movw	r24, r28
    531c:	0e 94 1d 28 	call	0x503a	; 0x503a <get_fat>
    5320:	ab 01       	movw	r20, r22
    5322:	bc 01       	movw	r22, r24
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
    5324:	4f 3f       	cpi	r20, 0xFF	; 255
    5326:	ff ef       	ldi	r31, 0xFF	; 255
    5328:	5f 07       	cpc	r21, r31
    532a:	ff ef       	ldi	r31, 0xFF	; 255
    532c:	6f 07       	cpc	r22, r31
    532e:	ff ef       	ldi	r31, 0xFF	; 255
    5330:	7f 07       	cpc	r23, r31
    5332:	b9 f6       	brne	.-82     	; 0x52e2 <dir_sdi+0x82>
    5334:	81 e0       	ldi	r24, 0x01	; 1
    5336:	18 c0       	rjmp	.+48     	; 0x5368 <dir_sdi+0x108>

	dj->index = idx;
	clst = dj->sclust;
	if (clst == 1 || clst >= dj->fs->n_fatent)	/* Check start cluster range */
		return FR_INT_ERR;
	if (!clst && dj->fs->fs_type == FS_FAT32)	/* Replace cluster# 0 with root cluster# if in FAT32 */
    5338:	88 81       	ld	r24, Y
    533a:	83 30       	cpi	r24, 0x03	; 3
    533c:	51 f4       	brne	.+20     	; 0x5352 <dir_sdi+0xf2>
		clst = dj->fs->dirbase;
    533e:	4a a1       	ldd	r20, Y+34	; 0x22
    5340:	5b a1       	ldd	r21, Y+35	; 0x23
    5342:	6c a1       	ldd	r22, Y+36	; 0x24
    5344:	7d a1       	ldd	r23, Y+37	; 0x25

	if (clst == 0) {	/* Static table (root-dir in FAT12/16) */
    5346:	41 15       	cp	r20, r1
    5348:	51 05       	cpc	r21, r1
    534a:	61 05       	cpc	r22, r1
    534c:	71 05       	cpc	r23, r1
    534e:	09 f0       	breq	.+2      	; 0x5352 <dir_sdi+0xf2>
    5350:	b4 cf       	rjmp	.-152    	; 0x52ba <dir_sdi+0x5a>
		dj->clust = clst;
    5352:	f6 01       	movw	r30, r12
    5354:	12 86       	std	Z+10, r1	; 0x0a
    5356:	13 86       	std	Z+11, r1	; 0x0b
    5358:	14 86       	std	Z+12, r1	; 0x0c
    535a:	15 86       	std	Z+13, r1	; 0x0d
		if (idx >= dj->fs->n_rootdir)		/* Index is out of range */
    535c:	88 85       	ldd	r24, Y+8	; 0x08
    535e:	99 85       	ldd	r25, Y+9	; 0x09
    5360:	e8 16       	cp	r14, r24
    5362:	f9 06       	cpc	r15, r25
    5364:	70 f0       	brcs	.+28     	; 0x5382 <dir_sdi+0x122>
		dj->sect = clust2sect(dj->fs, clst) + idx / (SS(dj->fs) / 32);	/* Sector# */
	}

	dj->dir = dj->fs->win + (idx % (SS(dj->fs) / 32)) * 32;	/* Ptr to the entry in the sector */

	return FR_OK;	/* Seek succeeded */
    5366:	82 e0       	ldi	r24, 0x02	; 2
}
    5368:	df 91       	pop	r29
    536a:	cf 91       	pop	r28
    536c:	1f 91       	pop	r17
    536e:	0f 91       	pop	r16
    5370:	ff 90       	pop	r15
    5372:	ef 90       	pop	r14
    5374:	df 90       	pop	r13
    5376:	cf 90       	pop	r12
    5378:	bf 90       	pop	r11
    537a:	af 90       	pop	r10
    537c:	9f 90       	pop	r9
    537e:	8f 90       	pop	r8
    5380:	08 95       	ret

	if (clst == 0) {	/* Static table (root-dir in FAT12/16) */
		dj->clust = clst;
		if (idx >= dj->fs->n_rootdir)		/* Index is out of range */
			return FR_INT_ERR;
		dj->sect = dj->fs->dirbase + idx / (SS(dj->fs) / 32);	/* Sector# */
    5382:	c7 01       	movw	r24, r14
    5384:	92 95       	swap	r25
    5386:	82 95       	swap	r24
    5388:	8f 70       	andi	r24, 0x0F	; 15
    538a:	89 27       	eor	r24, r25
    538c:	9f 70       	andi	r25, 0x0F	; 15
    538e:	89 27       	eor	r24, r25
    5390:	a0 e0       	ldi	r26, 0x00	; 0
    5392:	b0 e0       	ldi	r27, 0x00	; 0
    5394:	2a a1       	ldd	r18, Y+34	; 0x22
    5396:	3b a1       	ldd	r19, Y+35	; 0x23
    5398:	4c a1       	ldd	r20, Y+36	; 0x24
    539a:	5d a1       	ldd	r21, Y+37	; 0x25
    539c:	82 0f       	add	r24, r18
    539e:	93 1f       	adc	r25, r19
    53a0:	a4 1f       	adc	r26, r20
    53a2:	b5 1f       	adc	r27, r21
    53a4:	86 87       	std	Z+14, r24	; 0x0e
    53a6:	97 87       	std	Z+15, r25	; 0x0f
    53a8:	a0 8b       	std	Z+16, r26	; 0x10
    53aa:	b1 8b       	std	Z+17, r27	; 0x11
		}
		dj->clust = clst;
		dj->sect = clust2sect(dj->fs, clst) + idx / (SS(dj->fs) / 32);	/* Sector# */
	}

	dj->dir = dj->fs->win + (idx % (SS(dj->fs) / 32)) * 32;	/* Ptr to the entry in the sector */
    53ac:	ff e0       	ldi	r31, 0x0F	; 15
    53ae:	ef 22       	and	r14, r31
    53b0:	ff 24       	eor	r15, r15
    53b2:	ee 0c       	add	r14, r14
    53b4:	ff 1c       	adc	r15, r15
    53b6:	e2 94       	swap	r14
    53b8:	f2 94       	swap	r15
    53ba:	30 ef       	ldi	r19, 0xF0	; 240
    53bc:	f3 22       	and	r15, r19
    53be:	fe 24       	eor	r15, r14
    53c0:	e3 22       	and	r14, r19
    53c2:	fe 24       	eor	r15, r14
    53c4:	8e e2       	ldi	r24, 0x2E	; 46
    53c6:	90 e0       	ldi	r25, 0x00	; 0
    53c8:	e8 0e       	add	r14, r24
    53ca:	f9 1e       	adc	r15, r25
    53cc:	ce 0d       	add	r28, r14
    53ce:	df 1d       	adc	r29, r15
    53d0:	f6 01       	movw	r30, r12
    53d2:	d3 8b       	std	Z+19, r29	; 0x13
    53d4:	c2 8b       	std	Z+18, r28	; 0x12
    53d6:	80 e0       	ldi	r24, 0x00	; 0
    53d8:	c7 cf       	rjmp	.-114    	; 0x5368 <dir_sdi+0x108>
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
			if (clst < 2 || clst >= dj->fs->n_fatent)	/* Reached to end of table or int error */
				return FR_INT_ERR;
			idx -= ic;
		}
		dj->clust = clst;
    53da:	f6 01       	movw	r30, r12
    53dc:	42 87       	std	Z+10, r20	; 0x0a
    53de:	53 87       	std	Z+11, r21	; 0x0b
    53e0:	64 87       	std	Z+12, r22	; 0x0c
    53e2:	75 87       	std	Z+13, r23	; 0x0d
DWORD clust2sect (	/* !=0: Sector number, 0: Failed - invalid cluster# */
	FATFS *fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
    53e4:	ee ef       	ldi	r30, 0xFE	; 254
    53e6:	8e 2e       	mov	r8, r30
    53e8:	ef ef       	ldi	r30, 0xFF	; 255
    53ea:	9e 2e       	mov	r9, r30
    53ec:	ef ef       	ldi	r30, 0xFF	; 255
    53ee:	ae 2e       	mov	r10, r30
    53f0:	ef ef       	ldi	r30, 0xFF	; 255
    53f2:	be 2e       	mov	r11, r30
    53f4:	84 0e       	add	r8, r20
    53f6:	95 1e       	adc	r9, r21
    53f8:	a6 1e       	adc	r10, r22
    53fa:	b7 1e       	adc	r11, r23
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
    53fc:	8e 89       	ldd	r24, Y+22	; 0x16
    53fe:	9f 89       	ldd	r25, Y+23	; 0x17
    5400:	a8 8d       	ldd	r26, Y+24	; 0x18
    5402:	b9 8d       	ldd	r27, Y+25	; 0x19
    5404:	02 97       	sbiw	r24, 0x02	; 2
    5406:	a1 09       	sbc	r26, r1
    5408:	b1 09       	sbc	r27, r1
    540a:	88 16       	cp	r8, r24
    540c:	99 06       	cpc	r9, r25
    540e:	aa 06       	cpc	r10, r26
    5410:	bb 06       	cpc	r11, r27
    5412:	b8 f0       	brcs	.+46     	; 0x5442 <dir_sdi+0x1e2>
    5414:	20 e0       	ldi	r18, 0x00	; 0
    5416:	30 e0       	ldi	r19, 0x00	; 0
    5418:	40 e0       	ldi	r20, 0x00	; 0
    541a:	50 e0       	ldi	r21, 0x00	; 0
			if (clst < 2 || clst >= dj->fs->n_fatent)	/* Reached to end of table or int error */
				return FR_INT_ERR;
			idx -= ic;
		}
		dj->clust = clst;
		dj->sect = clust2sect(dj->fs, clst) + idx / (SS(dj->fs) / 32);	/* Sector# */
    541c:	c7 01       	movw	r24, r14
    541e:	92 95       	swap	r25
    5420:	82 95       	swap	r24
    5422:	8f 70       	andi	r24, 0x0F	; 15
    5424:	89 27       	eor	r24, r25
    5426:	9f 70       	andi	r25, 0x0F	; 15
    5428:	89 27       	eor	r24, r25
    542a:	a0 e0       	ldi	r26, 0x00	; 0
    542c:	b0 e0       	ldi	r27, 0x00	; 0
    542e:	28 0f       	add	r18, r24
    5430:	39 1f       	adc	r19, r25
    5432:	4a 1f       	adc	r20, r26
    5434:	5b 1f       	adc	r21, r27
    5436:	f6 01       	movw	r30, r12
    5438:	26 87       	std	Z+14, r18	; 0x0e
    543a:	37 87       	std	Z+15, r19	; 0x0f
    543c:	40 8b       	std	Z+16, r20	; 0x10
    543e:	51 8b       	std	Z+17, r21	; 0x11
    5440:	b5 cf       	rjmp	.-150    	; 0x53ac <dir_sdi+0x14c>
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
	return clst * fs->csize + fs->database;
    5442:	2a 81       	ldd	r18, Y+2	; 0x02
    5444:	30 e0       	ldi	r19, 0x00	; 0
    5446:	40 e0       	ldi	r20, 0x00	; 0
    5448:	50 e0       	ldi	r21, 0x00	; 0
    544a:	c5 01       	movw	r24, r10
    544c:	b4 01       	movw	r22, r8
    544e:	0e 94 bb 7f 	call	0xff76	; 0xff76 <__mulsi3>
    5452:	9b 01       	movw	r18, r22
    5454:	ac 01       	movw	r20, r24
    5456:	8e a1       	ldd	r24, Y+38	; 0x26
    5458:	9f a1       	ldd	r25, Y+39	; 0x27
    545a:	a8 a5       	ldd	r26, Y+40	; 0x28
    545c:	b9 a5       	ldd	r27, Y+41	; 0x29
    545e:	28 0f       	add	r18, r24
    5460:	39 1f       	adc	r19, r25
    5462:	4a 1f       	adc	r20, r26
    5464:	5b 1f       	adc	r21, r27
    5466:	da cf       	rjmp	.-76     	; 0x541c <dir_sdi+0x1bc>

00005468 <create_chain>:
static
DWORD create_chain (	/* 0:No free cluster, 1:Internal error, 0xFFFFFFFF:Disk error, >=2:New cluster# */
	FATFS *fs,			/* File system object */
	DWORD clst			/* Cluster# to stretch. 0 means create a new chain. */
)
{
    5468:	4f 92       	push	r4
    546a:	5f 92       	push	r5
    546c:	6f 92       	push	r6
    546e:	7f 92       	push	r7
    5470:	8f 92       	push	r8
    5472:	9f 92       	push	r9
    5474:	af 92       	push	r10
    5476:	bf 92       	push	r11
    5478:	cf 92       	push	r12
    547a:	df 92       	push	r13
    547c:	ef 92       	push	r14
    547e:	ff 92       	push	r15
    5480:	0f 93       	push	r16
    5482:	1f 93       	push	r17
    5484:	cf 93       	push	r28
    5486:	df 93       	push	r29
    5488:	ec 01       	movw	r28, r24
    548a:	2a 01       	movw	r4, r20
    548c:	3b 01       	movw	r6, r22
	DWORD cs, ncl, scl;
	FRESULT res;


	if (clst == 0) {		/* Create a new chain */
    548e:	41 15       	cp	r20, r1
    5490:	51 05       	cpc	r21, r1
    5492:	61 05       	cpc	r22, r1
    5494:	71 05       	cpc	r23, r1
    5496:	09 f0       	breq	.+2      	; 0x549a <create_chain+0x32>
    5498:	a5 c0       	rjmp	.+330    	; 0x55e4 <create_chain+0x17c>
		scl = fs->last_clust;			/* Get suggested start point */
    549a:	8a 84       	ldd	r8, Y+10	; 0x0a
    549c:	9b 84       	ldd	r9, Y+11	; 0x0b
    549e:	ac 84       	ldd	r10, Y+12	; 0x0c
    54a0:	bd 84       	ldd	r11, Y+13	; 0x0d
		if (!scl || scl >= fs->n_fatent) scl = 1;
    54a2:	81 14       	cp	r8, r1
    54a4:	91 04       	cpc	r9, r1
    54a6:	a1 04       	cpc	r10, r1
    54a8:	b1 04       	cpc	r11, r1
    54aa:	09 f0       	breq	.+2      	; 0x54ae <create_chain+0x46>
    54ac:	47 c0       	rjmp	.+142    	; 0x553c <create_chain+0xd4>
    54ae:	8e 89       	ldd	r24, Y+22	; 0x16
    54b0:	9f 89       	ldd	r25, Y+23	; 0x17
    54b2:	a8 8d       	ldd	r26, Y+24	; 0x18
    54b4:	b9 8d       	ldd	r27, Y+25	; 0x19
	}
	else {					/* Stretch the current chain */
		cs = get_fat(fs, clst);			/* Check the cluster status */
		if (cs < 2) return 1;			/* It is an invalid cluster */
		if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
    54b6:	11 e0       	ldi	r17, 0x01	; 1
    54b8:	81 2e       	mov	r8, r17
    54ba:	91 2c       	mov	r9, r1
    54bc:	a1 2c       	mov	r10, r1
    54be:	b1 2c       	mov	r11, r1
    54c0:	75 01       	movw	r14, r10
    54c2:	64 01       	movw	r12, r8
		scl = clst;
	}

	ncl = scl;				/* Start cluster */
	for (;;) {
		ncl++;							/* Next cluster */
    54c4:	08 94       	sec
    54c6:	c1 1c       	adc	r12, r1
    54c8:	d1 1c       	adc	r13, r1
    54ca:	e1 1c       	adc	r14, r1
    54cc:	f1 1c       	adc	r15, r1
		if (ncl >= fs->n_fatent) {		/* Wrap around */
    54ce:	c8 16       	cp	r12, r24
    54d0:	d9 06       	cpc	r13, r25
    54d2:	ea 06       	cpc	r14, r26
    54d4:	fb 06       	cpc	r15, r27
    54d6:	60 f0       	brcs	.+24     	; 0x54f0 <create_chain+0x88>
			ncl = 2;
			if (ncl > scl) return 0;	/* No free cluster */
    54d8:	22 e0       	ldi	r18, 0x02	; 2
    54da:	82 16       	cp	r8, r18
    54dc:	91 04       	cpc	r9, r1
    54de:	a1 04       	cpc	r10, r1
    54e0:	b1 04       	cpc	r11, r1
    54e2:	08 f4       	brcc	.+2      	; 0x54e6 <create_chain+0x7e>
    54e4:	7a c0       	rjmp	.+244    	; 0x55da <create_chain+0x172>
    54e6:	b2 e0       	ldi	r27, 0x02	; 2
    54e8:	cb 2e       	mov	r12, r27
    54ea:	d1 2c       	mov	r13, r1
    54ec:	e1 2c       	mov	r14, r1
    54ee:	f1 2c       	mov	r15, r1
		}
		cs = get_fat(fs, ncl);			/* Get the cluster status */
    54f0:	ce 01       	movw	r24, r28
    54f2:	b7 01       	movw	r22, r14
    54f4:	a6 01       	movw	r20, r12
    54f6:	0e 94 1d 28 	call	0x503a	; 0x503a <get_fat>
    54fa:	9b 01       	movw	r18, r22
    54fc:	ac 01       	movw	r20, r24
		if (cs == 0) break;				/* Found a free cluster */
    54fe:	61 15       	cp	r22, r1
    5500:	71 05       	cpc	r23, r1
    5502:	81 05       	cpc	r24, r1
    5504:	91 05       	cpc	r25, r1
    5506:	29 f1       	breq	.+74     	; 0x5552 <create_chain+0xea>
		if (cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
    5508:	2f 3f       	cpi	r18, 0xFF	; 255
    550a:	8f ef       	ldi	r24, 0xFF	; 255
    550c:	38 07       	cpc	r19, r24
    550e:	8f ef       	ldi	r24, 0xFF	; 255
    5510:	48 07       	cpc	r20, r24
    5512:	8f ef       	ldi	r24, 0xFF	; 255
    5514:	58 07       	cpc	r21, r24
    5516:	09 f4       	brne	.+2      	; 0x551a <create_chain+0xb2>
    5518:	4d c0       	rjmp	.+154    	; 0x55b4 <create_chain+0x14c>
    551a:	21 30       	cpi	r18, 0x01	; 1
    551c:	31 05       	cpc	r19, r1
    551e:	41 05       	cpc	r20, r1
    5520:	51 05       	cpc	r21, r1
    5522:	09 f4       	brne	.+2      	; 0x5526 <create_chain+0xbe>
    5524:	47 c0       	rjmp	.+142    	; 0x55b4 <create_chain+0x14c>
			return cs;
		if (ncl == scl) return 0;		/* No free cluster */
    5526:	c8 14       	cp	r12, r8
    5528:	d9 04       	cpc	r13, r9
    552a:	ea 04       	cpc	r14, r10
    552c:	fb 04       	cpc	r15, r11
    552e:	09 f4       	brne	.+2      	; 0x5532 <create_chain+0xca>
    5530:	54 c0       	rjmp	.+168    	; 0x55da <create_chain+0x172>
    5532:	8e 89       	ldd	r24, Y+22	; 0x16
    5534:	9f 89       	ldd	r25, Y+23	; 0x17
    5536:	a8 8d       	ldd	r26, Y+24	; 0x18
    5538:	b9 8d       	ldd	r27, Y+25	; 0x19
    553a:	c4 cf       	rjmp	.-120    	; 0x54c4 <create_chain+0x5c>
	FRESULT res;


	if (clst == 0) {		/* Create a new chain */
		scl = fs->last_clust;			/* Get suggested start point */
		if (!scl || scl >= fs->n_fatent) scl = 1;
    553c:	8e 89       	ldd	r24, Y+22	; 0x16
    553e:	9f 89       	ldd	r25, Y+23	; 0x17
    5540:	a8 8d       	ldd	r26, Y+24	; 0x18
    5542:	b9 8d       	ldd	r27, Y+25	; 0x19
    5544:	88 16       	cp	r8, r24
    5546:	99 06       	cpc	r9, r25
    5548:	aa 06       	cpc	r10, r26
    554a:	bb 06       	cpc	r11, r27
    554c:	08 f0       	brcs	.+2      	; 0x5550 <create_chain+0xe8>
    554e:	b3 cf       	rjmp	.-154    	; 0x54b6 <create_chain+0x4e>
    5550:	b7 cf       	rjmp	.-146    	; 0x54c0 <create_chain+0x58>
		}
		cs = get_fat(fs, ncl);			/* Get the cluster status */
		if (cs == 0) break;				/* Found a free cluster */
		if (cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
			return cs;
		if (ncl == scl) return 0;		/* No free cluster */
    5552:	bc 2c       	mov	r11, r12
    5554:	ad 2c       	mov	r10, r13
    5556:	9e 2c       	mov	r9, r14
    5558:	8f 2c       	mov	r8, r15
	}

	res = put_fat(fs, ncl, 0x0FFFFFFF);	/* Mark the new cluster "last link" */
    555a:	ce 01       	movw	r24, r28
    555c:	a6 01       	movw	r20, r12
    555e:	b7 01       	movw	r22, r14
    5560:	0f ef       	ldi	r16, 0xFF	; 255
    5562:	1f ef       	ldi	r17, 0xFF	; 255
    5564:	2f ef       	ldi	r18, 0xFF	; 255
    5566:	3f e0       	ldi	r19, 0x0F	; 15
    5568:	0e 94 07 27 	call	0x4e0e	; 0x4e0e <put_fat>
	if (res == FR_OK && clst != 0) {
    556c:	88 23       	and	r24, r24
    556e:	09 f0       	breq	.+2      	; 0x5572 <create_chain+0x10a>
    5570:	5d c0       	rjmp	.+186    	; 0x562c <create_chain+0x1c4>
    5572:	41 14       	cp	r4, r1
    5574:	51 04       	cpc	r5, r1
    5576:	61 04       	cpc	r6, r1
    5578:	71 04       	cpc	r7, r1
    557a:	09 f0       	breq	.+2      	; 0x557e <create_chain+0x116>
    557c:	4d c0       	rjmp	.+154    	; 0x5618 <create_chain+0x1b0>
		res = put_fat(fs, clst, ncl);	/* Link it to the previous one if needed */
	}
	if (res == FR_OK) {
		fs->last_clust = ncl;			/* Update FSINFO */
    557e:	ba 86       	std	Y+10, r11	; 0x0a
    5580:	ab 86       	std	Y+11, r10	; 0x0b
    5582:	9c 86       	std	Y+12, r9	; 0x0c
    5584:	8d 86       	std	Y+13, r8	; 0x0d
		if (fs->free_clust != 0xFFFFFFFF) {
    5586:	8e 85       	ldd	r24, Y+14	; 0x0e
    5588:	9f 85       	ldd	r25, Y+15	; 0x0f
    558a:	a8 89       	ldd	r26, Y+16	; 0x10
    558c:	b9 89       	ldd	r27, Y+17	; 0x11
    558e:	8f 3f       	cpi	r24, 0xFF	; 255
    5590:	2f ef       	ldi	r18, 0xFF	; 255
    5592:	92 07       	cpc	r25, r18
    5594:	2f ef       	ldi	r18, 0xFF	; 255
    5596:	a2 07       	cpc	r26, r18
    5598:	2f ef       	ldi	r18, 0xFF	; 255
    559a:	b2 07       	cpc	r27, r18
    559c:	49 f0       	breq	.+18     	; 0x55b0 <create_chain+0x148>
			fs->free_clust--;
    559e:	01 97       	sbiw	r24, 0x01	; 1
    55a0:	a1 09       	sbc	r26, r1
    55a2:	b1 09       	sbc	r27, r1
    55a4:	8e 87       	std	Y+14, r24	; 0x0e
    55a6:	9f 87       	std	Y+15, r25	; 0x0f
    55a8:	a8 8b       	std	Y+16, r26	; 0x10
    55aa:	b9 8b       	std	Y+17, r27	; 0x11
			fs->fsi_flag = 1;
    55ac:	81 e0       	ldi	r24, 0x01	; 1
    55ae:	8d 83       	std	Y+5, r24	; 0x05
    55b0:	a7 01       	movw	r20, r14
    55b2:	96 01       	movw	r18, r12
	} else {
		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;
	}

	return ncl;		/* Return new cluster number or error code */
}
    55b4:	b9 01       	movw	r22, r18
    55b6:	ca 01       	movw	r24, r20
    55b8:	df 91       	pop	r29
    55ba:	cf 91       	pop	r28
    55bc:	1f 91       	pop	r17
    55be:	0f 91       	pop	r16
    55c0:	ff 90       	pop	r15
    55c2:	ef 90       	pop	r14
    55c4:	df 90       	pop	r13
    55c6:	cf 90       	pop	r12
    55c8:	bf 90       	pop	r11
    55ca:	af 90       	pop	r10
    55cc:	9f 90       	pop	r9
    55ce:	8f 90       	pop	r8
    55d0:	7f 90       	pop	r7
    55d2:	6f 90       	pop	r6
    55d4:	5f 90       	pop	r5
    55d6:	4f 90       	pop	r4
    55d8:	08 95       	ret
		if (fs->free_clust != 0xFFFFFFFF) {
			fs->free_clust--;
			fs->fsi_flag = 1;
		}
	} else {
		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;
    55da:	20 e0       	ldi	r18, 0x00	; 0
    55dc:	30 e0       	ldi	r19, 0x00	; 0
    55de:	40 e0       	ldi	r20, 0x00	; 0
    55e0:	50 e0       	ldi	r21, 0x00	; 0
    55e2:	e8 cf       	rjmp	.-48     	; 0x55b4 <create_chain+0x14c>
	if (clst == 0) {		/* Create a new chain */
		scl = fs->last_clust;			/* Get suggested start point */
		if (!scl || scl >= fs->n_fatent) scl = 1;
	}
	else {					/* Stretch the current chain */
		cs = get_fat(fs, clst);			/* Check the cluster status */
    55e4:	0e 94 1d 28 	call	0x503a	; 0x503a <get_fat>
    55e8:	9b 01       	movw	r18, r22
    55ea:	ac 01       	movw	r20, r24
		if (cs < 2) return 1;			/* It is an invalid cluster */
    55ec:	62 30       	cpi	r22, 0x02	; 2
    55ee:	71 05       	cpc	r23, r1
    55f0:	81 05       	cpc	r24, r1
    55f2:	91 05       	cpc	r25, r1
    55f4:	60 f0       	brcs	.+24     	; 0x560e <create_chain+0x1a6>
		if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
    55f6:	8e 89       	ldd	r24, Y+22	; 0x16
    55f8:	9f 89       	ldd	r25, Y+23	; 0x17
    55fa:	a8 8d       	ldd	r26, Y+24	; 0x18
    55fc:	b9 8d       	ldd	r27, Y+25	; 0x19
    55fe:	28 17       	cp	r18, r24
    5600:	39 07       	cpc	r19, r25
    5602:	4a 07       	cpc	r20, r26
    5604:	5b 07       	cpc	r21, r27
    5606:	b0 f2       	brcs	.-84     	; 0x55b4 <create_chain+0x14c>
    5608:	53 01       	movw	r10, r6
    560a:	42 01       	movw	r8, r4
    560c:	59 cf       	rjmp	.-334    	; 0x54c0 <create_chain+0x58>
		if (fs->free_clust != 0xFFFFFFFF) {
			fs->free_clust--;
			fs->fsi_flag = 1;
		}
	} else {
		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;
    560e:	21 e0       	ldi	r18, 0x01	; 1
    5610:	30 e0       	ldi	r19, 0x00	; 0
    5612:	40 e0       	ldi	r20, 0x00	; 0
    5614:	50 e0       	ldi	r21, 0x00	; 0
    5616:	ce cf       	rjmp	.-100    	; 0x55b4 <create_chain+0x14c>
		if (ncl == scl) return 0;		/* No free cluster */
	}

	res = put_fat(fs, ncl, 0x0FFFFFFF);	/* Mark the new cluster "last link" */
	if (res == FR_OK && clst != 0) {
		res = put_fat(fs, clst, ncl);	/* Link it to the previous one if needed */
    5618:	ce 01       	movw	r24, r28
    561a:	b3 01       	movw	r22, r6
    561c:	a2 01       	movw	r20, r4
    561e:	86 01       	movw	r16, r12
    5620:	97 01       	movw	r18, r14
    5622:	0e 94 07 27 	call	0x4e0e	; 0x4e0e <put_fat>
	}
	if (res == FR_OK) {
    5626:	88 23       	and	r24, r24
    5628:	09 f4       	brne	.+2      	; 0x562c <create_chain+0x1c4>
    562a:	a9 cf       	rjmp	.-174    	; 0x557e <create_chain+0x116>
		if (fs->free_clust != 0xFFFFFFFF) {
			fs->free_clust--;
			fs->fsi_flag = 1;
		}
	} else {
		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;
    562c:	81 30       	cpi	r24, 0x01	; 1
    562e:	79 f7       	brne	.-34     	; 0x560e <create_chain+0x1a6>
    5630:	2f ef       	ldi	r18, 0xFF	; 255
    5632:	3f ef       	ldi	r19, 0xFF	; 255
    5634:	4f ef       	ldi	r20, 0xFF	; 255
    5636:	5f ef       	ldi	r21, 0xFF	; 255
    5638:	bd cf       	rjmp	.-134    	; 0x55b4 <create_chain+0x14c>

0000563a <f_lseek>:

FRESULT f_lseek (
	FIL *fp,		/* Pointer to the file object */
	DWORD ofs		/* File pointer from top of file */
)
{
    563a:	2f 92       	push	r2
    563c:	3f 92       	push	r3
    563e:	4f 92       	push	r4
    5640:	5f 92       	push	r5
    5642:	6f 92       	push	r6
    5644:	7f 92       	push	r7
    5646:	8f 92       	push	r8
    5648:	9f 92       	push	r9
    564a:	af 92       	push	r10
    564c:	bf 92       	push	r11
    564e:	cf 92       	push	r12
    5650:	df 92       	push	r13
    5652:	ef 92       	push	r14
    5654:	ff 92       	push	r15
    5656:	0f 93       	push	r16
    5658:	1f 93       	push	r17
    565a:	df 93       	push	r29
    565c:	cf 93       	push	r28
    565e:	cd b7       	in	r28, 0x3d	; 61
    5660:	de b7       	in	r29, 0x3e	; 62
    5662:	29 97       	sbiw	r28, 0x09	; 9
    5664:	0f b6       	in	r0, 0x3f	; 63
    5666:	f8 94       	cli
    5668:	de bf       	out	0x3e, r29	; 62
    566a:	0f be       	out	0x3f, r0	; 63
    566c:	cd bf       	out	0x3d, r28	; 61
    566e:	99 87       	std	Y+9, r25	; 0x09
    5670:	88 87       	std	Y+8, r24	; 0x08
    5672:	7a 01       	movw	r14, r20
    5674:	8b 01       	movw	r16, r22
	FRESULT res;


	res = validate(fp->fs, fp->id);		/* Check validity of the object */
    5676:	dc 01       	movw	r26, r24
    5678:	12 96       	adiw	r26, 0x02	; 2
    567a:	6d 91       	ld	r22, X+
    567c:	7c 91       	ld	r23, X
    567e:	13 97       	sbiw	r26, 0x03	; 3
    5680:	8d 91       	ld	r24, X+
    5682:	9c 91       	ld	r25, X
    5684:	0e 94 75 26 	call	0x4cea	; 0x4cea <validate>
    5688:	8d 83       	std	Y+5, r24	; 0x05
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
    568a:	88 23       	and	r24, r24
    568c:	09 f0       	breq	.+2      	; 0x5690 <f_lseek+0x56>
    568e:	8c c0       	rjmp	.+280    	; 0x57a8 <f_lseek+0x16e>
	if (fp->flag & FA__ERROR)			/* Check abort flag */
    5690:	e8 85       	ldd	r30, Y+8	; 0x08
    5692:	f9 85       	ldd	r31, Y+9	; 0x09
    5694:	84 81       	ldd	r24, Z+4	; 0x04
    5696:	87 fd       	sbrc	r24, 7
    5698:	b6 c0       	rjmp	.+364    	; 0x5806 <f_lseek+0x1cc>

	/* Normal Seek */
	{
		DWORD clst, bcs, nsect, ifptr;

		if (ofs > fp->fsize					/* In read-only mode, clip offset with the file size */
    569a:	a8 85       	ldd	r26, Y+8	; 0x08
    569c:	b9 85       	ldd	r27, Y+9	; 0x09
    569e:	1a 96       	adiw	r26, 0x0a	; 10
    56a0:	2d 90       	ld	r2, X+
    56a2:	3d 90       	ld	r3, X+
    56a4:	4d 90       	ld	r4, X+
    56a6:	5c 90       	ld	r5, X
    56a8:	1d 97       	sbiw	r26, 0x0d	; 13
    56aa:	2e 14       	cp	r2, r14
    56ac:	3f 04       	cpc	r3, r15
    56ae:	40 06       	cpc	r4, r16
    56b0:	51 06       	cpc	r5, r17
    56b2:	08 f0       	brcs	.+2      	; 0x56b6 <f_lseek+0x7c>
    56b4:	ab c0       	rjmp	.+342    	; 0x580c <f_lseek+0x1d2>
    56b6:	81 fd       	sbrc	r24, 1
    56b8:	a9 c0       	rjmp	.+338    	; 0x580c <f_lseek+0x1d2>
#if !_FS_READONLY
			 && !(fp->flag & FA_WRITE)
#endif
			) ofs = fp->fsize;

		ifptr = fp->fptr;
    56ba:	e8 85       	ldd	r30, Y+8	; 0x08
    56bc:	f9 85       	ldd	r31, Y+9	; 0x09
    56be:	e6 80       	ldd	r14, Z+6	; 0x06
    56c0:	f7 80       	ldd	r15, Z+7	; 0x07
    56c2:	00 85       	ldd	r16, Z+8	; 0x08
    56c4:	11 85       	ldd	r17, Z+9	; 0x09
		fp->fptr = nsect = 0;
    56c6:	16 82       	std	Z+6, r1	; 0x06
    56c8:	17 82       	std	Z+7, r1	; 0x07
    56ca:	10 86       	std	Z+8, r1	; 0x08
    56cc:	11 86       	std	Z+9, r1	; 0x09
		if (ofs) {
    56ce:	21 14       	cp	r2, r1
    56d0:	31 04       	cpc	r3, r1
    56d2:	41 04       	cpc	r4, r1
    56d4:	51 04       	cpc	r5, r1
    56d6:	09 f4       	brne	.+2      	; 0x56da <f_lseek+0xa0>
    56d8:	67 c0       	rjmp	.+206    	; 0x57a8 <f_lseek+0x16e>
			bcs = (DWORD)fp->fs->csize * SS(fp->fs);	/* Cluster size (byte) */
    56da:	01 90       	ld	r0, Z+
    56dc:	f0 81       	ld	r31, Z
    56de:	e0 2d       	mov	r30, r0
    56e0:	ff 83       	std	Y+7, r31	; 0x07
    56e2:	ee 83       	std	Y+6, r30	; 0x06
    56e4:	82 81       	ldd	r24, Z+2	; 0x02
    56e6:	68 2e       	mov	r6, r24
    56e8:	77 24       	eor	r7, r7
    56ea:	88 24       	eor	r8, r8
    56ec:	99 24       	eor	r9, r9
    56ee:	99 e0       	ldi	r25, 0x09	; 9
    56f0:	66 0c       	add	r6, r6
    56f2:	77 1c       	adc	r7, r7
    56f4:	88 1c       	adc	r8, r8
    56f6:	99 1c       	adc	r9, r9
    56f8:	9a 95       	dec	r25
    56fa:	d1 f7       	brne	.-12     	; 0x56f0 <f_lseek+0xb6>
			if (ifptr > 0 &&
    56fc:	e1 14       	cp	r14, r1
    56fe:	f1 04       	cpc	r15, r1
    5700:	01 05       	cpc	r16, r1
    5702:	11 05       	cpc	r17, r1
    5704:	09 f0       	breq	.+2      	; 0x5708 <f_lseek+0xce>
    5706:	85 c0       	rjmp	.+266    	; 0x5812 <f_lseek+0x1d8>
				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
				fp->fptr = (ifptr - 1) & ~(bcs - 1);	/* start from the current cluster */
				ofs -= fp->fptr;
				clst = fp->curr_clust;
			} else {									/* When seek to back cluster, */
				clst = fp->org_clust;					/* start from the first cluster */
    5708:	a8 85       	ldd	r26, Y+8	; 0x08
    570a:	b9 85       	ldd	r27, Y+9	; 0x09
    570c:	1e 96       	adiw	r26, 0x0e	; 14
    570e:	ed 90       	ld	r14, X+
    5710:	fd 90       	ld	r15, X+
    5712:	0d 91       	ld	r16, X+
    5714:	1c 91       	ld	r17, X
    5716:	51 97       	sbiw	r26, 0x11	; 17
#if !_FS_READONLY
				if (clst == 0) {						/* If no cluster chain, create a new chain */
    5718:	e1 14       	cp	r14, r1
    571a:	f1 04       	cpc	r15, r1
    571c:	01 05       	cpc	r16, r1
    571e:	11 05       	cpc	r17, r1
    5720:	09 f4       	brne	.+2      	; 0x5724 <f_lseek+0xea>
    5722:	5c c0       	rjmp	.+184    	; 0x57dc <f_lseek+0x1a2>
					if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
					fp->org_clust = clst;
				}
#endif
				fp->curr_clust = clst;
    5724:	a8 85       	ldd	r26, Y+8	; 0x08
    5726:	b9 85       	ldd	r27, Y+9	; 0x09
    5728:	52 96       	adiw	r26, 0x12	; 18
    572a:	ed 92       	st	X+, r14
    572c:	fd 92       	st	X+, r15
    572e:	0d 93       	st	X+, r16
    5730:	1c 93       	st	X, r17
    5732:	55 97       	sbiw	r26, 0x15	; 21
			}
			if (clst != 0) {
    5734:	e1 14       	cp	r14, r1
    5736:	f1 04       	cpc	r15, r1
    5738:	01 05       	cpc	r16, r1
    573a:	11 05       	cpc	r17, r1
    573c:	09 f0       	breq	.+2      	; 0x5740 <f_lseek+0x106>
    573e:	a2 c0       	rjmp	.+324    	; 0x5884 <f_lseek+0x24a>
    5740:	e8 85       	ldd	r30, Y+8	; 0x08
    5742:	f9 85       	ldd	r31, Y+9	; 0x09
    5744:	a6 80       	ldd	r10, Z+6	; 0x06
    5746:	b7 80       	ldd	r11, Z+7	; 0x07
    5748:	c0 84       	ldd	r12, Z+8	; 0x08
    574a:	d1 84       	ldd	r13, Z+9	; 0x09
				}
				fp->fptr += ofs;
				if (ofs % SS(fp->fs)) {
					nsect = clust2sect(fp->fs, clst);	/* Current sector */
					if (!nsect) ABORT(fp->fs, FR_INT_ERR);
					nsect += ofs / SS(fp->fs);
    574c:	20 e0       	ldi	r18, 0x00	; 0
    574e:	30 e0       	ldi	r19, 0x00	; 0
    5750:	40 e0       	ldi	r20, 0x00	; 0
    5752:	50 e0       	ldi	r21, 0x00	; 0
				}
			}
		}
		if (fp->fptr % SS(fp->fs) && nsect != fp->dsect) {
    5754:	d6 01       	movw	r26, r12
    5756:	c5 01       	movw	r24, r10
    5758:	91 70       	andi	r25, 0x01	; 1
    575a:	a0 70       	andi	r26, 0x00	; 0
    575c:	b0 70       	andi	r27, 0x00	; 0
    575e:	00 97       	sbiw	r24, 0x00	; 0
    5760:	a1 05       	cpc	r26, r1
    5762:	b1 05       	cpc	r27, r1
    5764:	79 f0       	breq	.+30     	; 0x5784 <f_lseek+0x14a>
    5766:	e8 85       	ldd	r30, Y+8	; 0x08
    5768:	f9 85       	ldd	r31, Y+9	; 0x09
    576a:	86 89       	ldd	r24, Z+22	; 0x16
    576c:	97 89       	ldd	r25, Z+23	; 0x17
    576e:	a0 8d       	ldd	r26, Z+24	; 0x18
    5770:	b1 8d       	ldd	r27, Z+25	; 0x19
    5772:	82 17       	cp	r24, r18
    5774:	93 07       	cpc	r25, r19
    5776:	a4 07       	cpc	r26, r20
    5778:	b5 07       	cpc	r27, r21
    577a:	21 f0       	breq	.+8      	; 0x5784 <f_lseek+0x14a>
			}
#endif
			if (disk_read(fp->fs->drv, fp->buf, nsect, 1) != RES_OK)
				ABORT(fp->fs, FR_DISK_ERR);
#endif
			fp->dsect = nsect;
    577c:	26 8b       	std	Z+22, r18	; 0x16
    577e:	37 8b       	std	Z+23, r19	; 0x17
    5780:	40 8f       	std	Z+24, r20	; 0x18
    5782:	51 8f       	std	Z+25, r21	; 0x19
		}
#if !_FS_READONLY
		if (fp->fptr > fp->fsize) {			/* Set change flag if the file size is extended */
    5784:	e8 85       	ldd	r30, Y+8	; 0x08
    5786:	f9 85       	ldd	r31, Y+9	; 0x09
    5788:	82 85       	ldd	r24, Z+10	; 0x0a
    578a:	93 85       	ldd	r25, Z+11	; 0x0b
    578c:	a4 85       	ldd	r26, Z+12	; 0x0c
    578e:	b5 85       	ldd	r27, Z+13	; 0x0d
    5790:	8a 15       	cp	r24, r10
    5792:	9b 05       	cpc	r25, r11
    5794:	ac 05       	cpc	r26, r12
    5796:	bd 05       	cpc	r27, r13
    5798:	38 f4       	brcc	.+14     	; 0x57a8 <f_lseek+0x16e>
			fp->fsize = fp->fptr;
    579a:	a2 86       	std	Z+10, r10	; 0x0a
    579c:	b3 86       	std	Z+11, r11	; 0x0b
    579e:	c4 86       	std	Z+12, r12	; 0x0c
    57a0:	d5 86       	std	Z+13, r13	; 0x0d
			fp->flag |= FA__WRITTEN;
    57a2:	84 81       	ldd	r24, Z+4	; 0x04
    57a4:	80 62       	ori	r24, 0x20	; 32
    57a6:	84 83       	std	Z+4, r24	; 0x04
		}
#endif
	}

	LEAVE_FF(fp->fs, res);
}
    57a8:	8d 81       	ldd	r24, Y+5	; 0x05
    57aa:	29 96       	adiw	r28, 0x09	; 9
    57ac:	0f b6       	in	r0, 0x3f	; 63
    57ae:	f8 94       	cli
    57b0:	de bf       	out	0x3e, r29	; 62
    57b2:	0f be       	out	0x3f, r0	; 63
    57b4:	cd bf       	out	0x3d, r28	; 61
    57b6:	cf 91       	pop	r28
    57b8:	df 91       	pop	r29
    57ba:	1f 91       	pop	r17
    57bc:	0f 91       	pop	r16
    57be:	ff 90       	pop	r15
    57c0:	ef 90       	pop	r14
    57c2:	df 90       	pop	r13
    57c4:	cf 90       	pop	r12
    57c6:	bf 90       	pop	r11
    57c8:	af 90       	pop	r10
    57ca:	9f 90       	pop	r9
    57cc:	8f 90       	pop	r8
    57ce:	7f 90       	pop	r7
    57d0:	6f 90       	pop	r6
    57d2:	5f 90       	pop	r5
    57d4:	4f 90       	pop	r4
    57d6:	3f 90       	pop	r3
    57d8:	2f 90       	pop	r2
    57da:	08 95       	ret
				clst = fp->curr_clust;
			} else {									/* When seek to back cluster, */
				clst = fp->org_clust;					/* start from the first cluster */
#if !_FS_READONLY
				if (clst == 0) {						/* If no cluster chain, create a new chain */
					clst = create_chain(fp->fs, 0);
    57dc:	8e 81       	ldd	r24, Y+6	; 0x06
    57de:	9f 81       	ldd	r25, Y+7	; 0x07
    57e0:	40 e0       	ldi	r20, 0x00	; 0
    57e2:	50 e0       	ldi	r21, 0x00	; 0
    57e4:	60 e0       	ldi	r22, 0x00	; 0
    57e6:	70 e0       	ldi	r23, 0x00	; 0
    57e8:	0e 94 34 2a 	call	0x5468	; 0x5468 <create_chain>
    57ec:	7b 01       	movw	r14, r22
    57ee:	8c 01       	movw	r16, r24
					if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
    57f0:	61 30       	cpi	r22, 0x01	; 1
    57f2:	71 05       	cpc	r23, r1
    57f4:	81 05       	cpc	r24, r1
    57f6:	91 05       	cpc	r25, r1
    57f8:	09 f0       	breq	.+2      	; 0x57fc <f_lseek+0x1c2>
    57fa:	cd c0       	rjmp	.+410    	; 0x5996 <f_lseek+0x35c>
    57fc:	e8 85       	ldd	r30, Y+8	; 0x08
    57fe:	f9 85       	ldd	r31, Y+9	; 0x09
    5800:	84 81       	ldd	r24, Z+4	; 0x04
    5802:	80 68       	ori	r24, 0x80	; 128
    5804:	84 83       	std	Z+4, r24	; 0x04
    5806:	f2 e0       	ldi	r31, 0x02	; 2
    5808:	fd 83       	std	Y+5, r31	; 0x05
    580a:	ce cf       	rjmp	.-100    	; 0x57a8 <f_lseek+0x16e>

	/* Normal Seek */
	{
		DWORD clst, bcs, nsect, ifptr;

		if (ofs > fp->fsize					/* In read-only mode, clip offset with the file size */
    580c:	17 01       	movw	r2, r14
    580e:	28 01       	movw	r4, r16
    5810:	54 cf       	rjmp	.-344    	; 0x56ba <f_lseek+0x80>

		ifptr = fp->fptr;
		fp->fptr = nsect = 0;
		if (ofs) {
			bcs = (DWORD)fp->fs->csize * SS(fp->fs);	/* Cluster size (byte) */
			if (ifptr > 0 &&
    5812:	57 01       	movw	r10, r14
    5814:	68 01       	movw	r12, r16
    5816:	08 94       	sec
    5818:	a1 08       	sbc	r10, r1
    581a:	b1 08       	sbc	r11, r1
    581c:	c1 08       	sbc	r12, r1
    581e:	d1 08       	sbc	r13, r1
    5820:	c2 01       	movw	r24, r4
    5822:	b1 01       	movw	r22, r2
    5824:	61 50       	subi	r22, 0x01	; 1
    5826:	70 40       	sbci	r23, 0x00	; 0
    5828:	80 40       	sbci	r24, 0x00	; 0
    582a:	90 40       	sbci	r25, 0x00	; 0
    582c:	a4 01       	movw	r20, r8
    582e:	93 01       	movw	r18, r6
    5830:	0e 94 0d 80 	call	0x1001a	; 0x1001a <__udivmodsi4>
    5834:	79 01       	movw	r14, r18
    5836:	8a 01       	movw	r16, r20
    5838:	c6 01       	movw	r24, r12
    583a:	b5 01       	movw	r22, r10
    583c:	a4 01       	movw	r20, r8
    583e:	93 01       	movw	r18, r6
    5840:	0e 94 0d 80 	call	0x1001a	; 0x1001a <__udivmodsi4>
    5844:	e2 16       	cp	r14, r18
    5846:	f3 06       	cpc	r15, r19
    5848:	04 07       	cpc	r16, r20
    584a:	15 07       	cpc	r17, r21
    584c:	08 f4       	brcc	.+2      	; 0x5850 <f_lseek+0x216>
    584e:	5c cf       	rjmp	.-328    	; 0x5708 <f_lseek+0xce>
				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
				fp->fptr = (ifptr - 1) & ~(bcs - 1);	/* start from the current cluster */
    5850:	88 27       	eor	r24, r24
    5852:	99 27       	eor	r25, r25
    5854:	dc 01       	movw	r26, r24
    5856:	86 19       	sub	r24, r6
    5858:	97 09       	sbc	r25, r7
    585a:	a8 09       	sbc	r26, r8
    585c:	b9 09       	sbc	r27, r9
    585e:	8a 21       	and	r24, r10
    5860:	9b 21       	and	r25, r11
    5862:	ac 21       	and	r26, r12
    5864:	bd 21       	and	r27, r13
    5866:	e8 85       	ldd	r30, Y+8	; 0x08
    5868:	f9 85       	ldd	r31, Y+9	; 0x09
    586a:	86 83       	std	Z+6, r24	; 0x06
    586c:	97 83       	std	Z+7, r25	; 0x07
    586e:	a0 87       	std	Z+8, r26	; 0x08
    5870:	b1 87       	std	Z+9, r27	; 0x09
				ofs -= fp->fptr;
    5872:	28 1a       	sub	r2, r24
    5874:	39 0a       	sbc	r3, r25
    5876:	4a 0a       	sbc	r4, r26
    5878:	5b 0a       	sbc	r5, r27
				clst = fp->curr_clust;
    587a:	e2 88       	ldd	r14, Z+18	; 0x12
    587c:	f3 88       	ldd	r15, Z+19	; 0x13
    587e:	04 89       	ldd	r16, Z+20	; 0x14
    5880:	15 89       	ldd	r17, Z+21	; 0x15
    5882:	58 cf       	rjmp	.-336    	; 0x5734 <f_lseek+0xfa>
				}
#endif
				fp->curr_clust = clst;
			}
			if (clst != 0) {
				while (ofs > bcs) {						/* Cluster following loop */
    5884:	62 14       	cp	r6, r2
    5886:	73 04       	cpc	r7, r3
    5888:	84 04       	cpc	r8, r4
    588a:	95 04       	cpc	r9, r5
    588c:	08 f0       	brcs	.+2      	; 0x5890 <f_lseek+0x256>
    588e:	9e c0       	rjmp	.+316    	; 0x59cc <f_lseek+0x392>
    5890:	88 27       	eor	r24, r24
    5892:	99 27       	eor	r25, r25
    5894:	dc 01       	movw	r26, r24
    5896:	86 19       	sub	r24, r6
    5898:	97 09       	sbc	r25, r7
    589a:	a8 09       	sbc	r26, r8
    589c:	b9 09       	sbc	r27, r9
    589e:	89 83       	std	Y+1, r24	; 0x01
    58a0:	9a 83       	std	Y+2, r25	; 0x02
    58a2:	ab 83       	std	Y+3, r26	; 0x03
    58a4:	bc 83       	std	Y+4, r27	; 0x04
    58a6:	26 18       	sub	r2, r6
    58a8:	37 08       	sbc	r3, r7
    58aa:	48 08       	sbc	r4, r8
    58ac:	59 08       	sbc	r5, r9
    58ae:	a8 85       	ldd	r26, Y+8	; 0x08
    58b0:	b9 85       	ldd	r27, Y+9	; 0x09
    58b2:	0d 90       	ld	r0, X+
    58b4:	bc 91       	ld	r27, X
    58b6:	a0 2d       	mov	r26, r0
    58b8:	bf 83       	std	Y+7, r27	; 0x07
    58ba:	ae 83       	std	Y+6, r26	; 0x06
    58bc:	5e c0       	rjmp	.+188    	; 0x597a <f_lseek+0x340>
#if !_FS_READONLY
					if (fp->flag & FA_WRITE) {			/* Check if in write mode or not */
						clst = create_chain(fp->fs, clst);	/* Force stretch if in write mode */
    58be:	8e 81       	ldd	r24, Y+6	; 0x06
    58c0:	9f 81       	ldd	r25, Y+7	; 0x07
    58c2:	b8 01       	movw	r22, r16
    58c4:	a7 01       	movw	r20, r14
    58c6:	0e 94 34 2a 	call	0x5468	; 0x5468 <create_chain>
    58ca:	7b 01       	movw	r14, r22
    58cc:	8c 01       	movw	r16, r24
						if (clst == 0) {				/* When disk gets full, clip file size */
    58ce:	61 15       	cp	r22, r1
    58d0:	71 05       	cpc	r23, r1
    58d2:	81 05       	cpc	r24, r1
    58d4:	91 05       	cpc	r25, r1
    58d6:	09 f4       	brne	.+2      	; 0x58da <f_lseek+0x2a0>
    58d8:	77 c0       	rjmp	.+238    	; 0x59c8 <f_lseek+0x38e>
							ofs = bcs; break;
						}
					} else
#endif
						clst = get_fat(fp->fs, clst);	/* Follow cluster chain if not in write mode */
					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
    58da:	ff ef       	ldi	r31, 0xFF	; 255
    58dc:	ef 16       	cp	r14, r31
    58de:	ff ef       	ldi	r31, 0xFF	; 255
    58e0:	ff 06       	cpc	r15, r31
    58e2:	ff ef       	ldi	r31, 0xFF	; 255
    58e4:	0f 07       	cpc	r16, r31
    58e6:	ff ef       	ldi	r31, 0xFF	; 255
    58e8:	1f 07       	cpc	r17, r31
    58ea:	09 f4       	brne	.+2      	; 0x58ee <f_lseek+0x2b4>
    58ec:	c8 c0       	rjmp	.+400    	; 0x5a7e <f_lseek+0x444>
					if (clst <= 1 || clst >= fp->fs->n_fatent) ABORT(fp->fs, FR_INT_ERR);
    58ee:	e2 e0       	ldi	r30, 0x02	; 2
    58f0:	ee 16       	cp	r14, r30
    58f2:	f1 04       	cpc	r15, r1
    58f4:	01 05       	cpc	r16, r1
    58f6:	11 05       	cpc	r17, r1
    58f8:	08 f4       	brcc	.+2      	; 0x58fc <f_lseek+0x2c2>
    58fa:	5e c0       	rjmp	.+188    	; 0x59b8 <f_lseek+0x37e>
    58fc:	a8 85       	ldd	r26, Y+8	; 0x08
    58fe:	b9 85       	ldd	r27, Y+9	; 0x09
    5900:	0d 90       	ld	r0, X+
    5902:	bc 91       	ld	r27, X
    5904:	a0 2d       	mov	r26, r0
    5906:	bf 83       	std	Y+7, r27	; 0x07
    5908:	ae 83       	std	Y+6, r26	; 0x06
    590a:	56 96       	adiw	r26, 0x16	; 22
    590c:	8d 91       	ld	r24, X+
    590e:	9d 91       	ld	r25, X+
    5910:	0d 90       	ld	r0, X+
    5912:	bc 91       	ld	r27, X
    5914:	a0 2d       	mov	r26, r0
    5916:	e8 16       	cp	r14, r24
    5918:	f9 06       	cpc	r15, r25
    591a:	0a 07       	cpc	r16, r26
    591c:	1b 07       	cpc	r17, r27
    591e:	08 f0       	brcs	.+2      	; 0x5922 <f_lseek+0x2e8>
    5920:	4b c0       	rjmp	.+150    	; 0x59b8 <f_lseek+0x37e>
					fp->curr_clust = clst;
    5922:	a8 85       	ldd	r26, Y+8	; 0x08
    5924:	b9 85       	ldd	r27, Y+9	; 0x09
    5926:	52 96       	adiw	r26, 0x12	; 18
    5928:	ed 92       	st	X+, r14
    592a:	fd 92       	st	X+, r15
    592c:	0d 93       	st	X+, r16
    592e:	1c 93       	st	X, r17
    5930:	55 97       	sbiw	r26, 0x15	; 21
					fp->fptr += bcs;
    5932:	16 96       	adiw	r26, 0x06	; 6
    5934:	ad 90       	ld	r10, X+
    5936:	bd 90       	ld	r11, X+
    5938:	cd 90       	ld	r12, X+
    593a:	dc 90       	ld	r13, X
    593c:	19 97       	sbiw	r26, 0x09	; 9
    593e:	a6 0c       	add	r10, r6
    5940:	b7 1c       	adc	r11, r7
    5942:	c8 1c       	adc	r12, r8
    5944:	d9 1c       	adc	r13, r9
    5946:	fd 01       	movw	r30, r26
    5948:	a6 82       	std	Z+6, r10	; 0x06
    594a:	b7 82       	std	Z+7, r11	; 0x07
    594c:	c0 86       	std	Z+8, r12	; 0x08
    594e:	d1 86       	std	Z+9, r13	; 0x09
    5950:	29 81       	ldd	r18, Y+1	; 0x01
    5952:	3a 81       	ldd	r19, Y+2	; 0x02
    5954:	4b 81       	ldd	r20, Y+3	; 0x03
    5956:	5c 81       	ldd	r21, Y+4	; 0x04
    5958:	22 0d       	add	r18, r2
    595a:	33 1d       	adc	r19, r3
    595c:	44 1d       	adc	r20, r4
    595e:	55 1d       	adc	r21, r5
				}
#endif
				fp->curr_clust = clst;
			}
			if (clst != 0) {
				while (ofs > bcs) {						/* Cluster following loop */
    5960:	da 01       	movw	r26, r20
    5962:	c9 01       	movw	r24, r18
    5964:	86 0d       	add	r24, r6
    5966:	97 1d       	adc	r25, r7
    5968:	a8 1d       	adc	r26, r8
    596a:	b9 1d       	adc	r27, r9
    596c:	68 16       	cp	r6, r24
    596e:	79 06       	cpc	r7, r25
    5970:	8a 06       	cpc	r8, r26
    5972:	9b 06       	cpc	r9, r27
    5974:	98 f5       	brcc	.+102    	; 0x59dc <f_lseek+0x3a2>
    5976:	19 01       	movw	r2, r18
    5978:	2a 01       	movw	r4, r20
#if !_FS_READONLY
					if (fp->flag & FA_WRITE) {			/* Check if in write mode or not */
    597a:	e8 85       	ldd	r30, Y+8	; 0x08
    597c:	f9 85       	ldd	r31, Y+9	; 0x09
    597e:	84 81       	ldd	r24, Z+4	; 0x04
    5980:	81 fd       	sbrc	r24, 1
    5982:	9d cf       	rjmp	.-198    	; 0x58be <f_lseek+0x284>
						if (clst == 0) {				/* When disk gets full, clip file size */
							ofs = bcs; break;
						}
					} else
#endif
						clst = get_fat(fp->fs, clst);	/* Follow cluster chain if not in write mode */
    5984:	8e 81       	ldd	r24, Y+6	; 0x06
    5986:	9f 81       	ldd	r25, Y+7	; 0x07
    5988:	b8 01       	movw	r22, r16
    598a:	a7 01       	movw	r20, r14
    598c:	0e 94 1d 28 	call	0x503a	; 0x503a <get_fat>
    5990:	7b 01       	movw	r14, r22
    5992:	8c 01       	movw	r16, r24
    5994:	a2 cf       	rjmp	.-188    	; 0x58da <f_lseek+0x2a0>
				clst = fp->org_clust;					/* start from the first cluster */
#if !_FS_READONLY
				if (clst == 0) {						/* If no cluster chain, create a new chain */
					clst = create_chain(fp->fs, 0);
					if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
    5996:	8f ef       	ldi	r24, 0xFF	; 255
    5998:	e8 16       	cp	r14, r24
    599a:	8f ef       	ldi	r24, 0xFF	; 255
    599c:	f8 06       	cpc	r15, r24
    599e:	8f ef       	ldi	r24, 0xFF	; 255
    59a0:	08 07       	cpc	r16, r24
    59a2:	8f ef       	ldi	r24, 0xFF	; 255
    59a4:	18 07       	cpc	r17, r24
    59a6:	09 f4       	brne	.+2      	; 0x59aa <f_lseek+0x370>
    59a8:	6a c0       	rjmp	.+212    	; 0x5a7e <f_lseek+0x444>
					fp->org_clust = clst;
    59aa:	e8 85       	ldd	r30, Y+8	; 0x08
    59ac:	f9 85       	ldd	r31, Y+9	; 0x09
    59ae:	e6 86       	std	Z+14, r14	; 0x0e
    59b0:	f7 86       	std	Z+15, r15	; 0x0f
    59b2:	00 8b       	std	Z+16, r16	; 0x10
    59b4:	11 8b       	std	Z+17, r17	; 0x11
    59b6:	b6 ce       	rjmp	.-660    	; 0x5724 <f_lseek+0xea>
						}
					} else
#endif
						clst = get_fat(fp->fs, clst);	/* Follow cluster chain if not in write mode */
					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
					if (clst <= 1 || clst >= fp->fs->n_fatent) ABORT(fp->fs, FR_INT_ERR);
    59b8:	e8 85       	ldd	r30, Y+8	; 0x08
    59ba:	f9 85       	ldd	r31, Y+9	; 0x09
    59bc:	84 81       	ldd	r24, Z+4	; 0x04
    59be:	80 68       	ori	r24, 0x80	; 128
    59c0:	84 83       	std	Z+4, r24	; 0x04
    59c2:	f2 e0       	ldi	r31, 0x02	; 2
    59c4:	fd 83       	std	Y+5, r31	; 0x05
    59c6:	f0 ce       	rjmp	.-544    	; 0x57a8 <f_lseek+0x16e>
				}
#endif
				fp->curr_clust = clst;
			}
			if (clst != 0) {
				while (ofs > bcs) {						/* Cluster following loop */
    59c8:	13 01       	movw	r2, r6
    59ca:	24 01       	movw	r4, r8
    59cc:	a8 85       	ldd	r26, Y+8	; 0x08
    59ce:	b9 85       	ldd	r27, Y+9	; 0x09
    59d0:	16 96       	adiw	r26, 0x06	; 6
    59d2:	ad 90       	ld	r10, X+
    59d4:	bd 90       	ld	r11, X+
    59d6:	cd 90       	ld	r12, X+
    59d8:	dc 90       	ld	r13, X
    59da:	19 97       	sbiw	r26, 0x09	; 9
					if (clst <= 1 || clst >= fp->fs->n_fatent) ABORT(fp->fs, FR_INT_ERR);
					fp->curr_clust = clst;
					fp->fptr += bcs;
					ofs -= bcs;
				}
				fp->fptr += ofs;
    59dc:	a2 0c       	add	r10, r2
    59de:	b3 1c       	adc	r11, r3
    59e0:	c4 1c       	adc	r12, r4
    59e2:	d5 1c       	adc	r13, r5
    59e4:	e8 85       	ldd	r30, Y+8	; 0x08
    59e6:	f9 85       	ldd	r31, Y+9	; 0x09
    59e8:	a6 82       	std	Z+6, r10	; 0x06
    59ea:	b7 82       	std	Z+7, r11	; 0x07
    59ec:	c0 86       	std	Z+8, r12	; 0x08
    59ee:	d1 86       	std	Z+9, r13	; 0x09
				if (ofs % SS(fp->fs)) {
    59f0:	d2 01       	movw	r26, r4
    59f2:	c1 01       	movw	r24, r2
    59f4:	91 70       	andi	r25, 0x01	; 1
    59f6:	a0 70       	andi	r26, 0x00	; 0
    59f8:	b0 70       	andi	r27, 0x00	; 0
    59fa:	00 97       	sbiw	r24, 0x00	; 0
    59fc:	a1 05       	cpc	r26, r1
    59fe:	b1 05       	cpc	r27, r1
    5a00:	09 f4       	brne	.+2      	; 0x5a04 <f_lseek+0x3ca>
    5a02:	a4 ce       	rjmp	.-696    	; 0x574c <f_lseek+0x112>
					nsect = clust2sect(fp->fs, clst);	/* Current sector */
    5a04:	80 80       	ld	r8, Z
    5a06:	91 80       	ldd	r9, Z+1	; 0x01
DWORD clust2sect (	/* !=0: Sector number, 0: Failed - invalid cluster# */
	FATFS *fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
    5a08:	8e ef       	ldi	r24, 0xFE	; 254
    5a0a:	9f ef       	ldi	r25, 0xFF	; 255
    5a0c:	af ef       	ldi	r26, 0xFF	; 255
    5a0e:	bf ef       	ldi	r27, 0xFF	; 255
    5a10:	e8 0e       	add	r14, r24
    5a12:	f9 1e       	adc	r15, r25
    5a14:	0a 1f       	adc	r16, r26
    5a16:	1b 1f       	adc	r17, r27
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
    5a18:	f4 01       	movw	r30, r8
    5a1a:	86 89       	ldd	r24, Z+22	; 0x16
    5a1c:	97 89       	ldd	r25, Z+23	; 0x17
    5a1e:	a0 8d       	ldd	r26, Z+24	; 0x18
    5a20:	b1 8d       	ldd	r27, Z+25	; 0x19
    5a22:	02 97       	sbiw	r24, 0x02	; 2
    5a24:	a1 09       	sbc	r26, r1
    5a26:	b1 09       	sbc	r27, r1
    5a28:	e8 16       	cp	r14, r24
    5a2a:	f9 06       	cpc	r15, r25
    5a2c:	0a 07       	cpc	r16, r26
    5a2e:	1b 07       	cpc	r17, r27
    5a30:	88 f5       	brcc	.+98     	; 0x5a94 <f_lseek+0x45a>
	return clst * fs->csize + fs->database;
    5a32:	22 81       	ldd	r18, Z+2	; 0x02
    5a34:	30 e0       	ldi	r19, 0x00	; 0
    5a36:	40 e0       	ldi	r20, 0x00	; 0
    5a38:	50 e0       	ldi	r21, 0x00	; 0
    5a3a:	c8 01       	movw	r24, r16
    5a3c:	b7 01       	movw	r22, r14
    5a3e:	0e 94 bb 7f 	call	0xff76	; 0xff76 <__mulsi3>
    5a42:	7b 01       	movw	r14, r22
    5a44:	8c 01       	movw	r16, r24
    5a46:	f4 01       	movw	r30, r8
    5a48:	86 a1       	ldd	r24, Z+38	; 0x26
    5a4a:	97 a1       	ldd	r25, Z+39	; 0x27
    5a4c:	a0 a5       	ldd	r26, Z+40	; 0x28
    5a4e:	b1 a5       	ldd	r27, Z+41	; 0x29
    5a50:	e8 0e       	add	r14, r24
    5a52:	f9 1e       	adc	r15, r25
    5a54:	0a 1f       	adc	r16, r26
    5a56:	1b 1f       	adc	r17, r27
					ofs -= bcs;
				}
				fp->fptr += ofs;
				if (ofs % SS(fp->fs)) {
					nsect = clust2sect(fp->fs, clst);	/* Current sector */
					if (!nsect) ABORT(fp->fs, FR_INT_ERR);
    5a58:	e1 14       	cp	r14, r1
    5a5a:	f1 04       	cpc	r15, r1
    5a5c:	01 05       	cpc	r16, r1
    5a5e:	11 05       	cpc	r17, r1
    5a60:	c9 f0       	breq	.+50     	; 0x5a94 <f_lseek+0x45a>
					nsect += ofs / SS(fp->fs);
    5a62:	a2 01       	movw	r20, r4
    5a64:	91 01       	movw	r18, r2
    5a66:	89 e0       	ldi	r24, 0x09	; 9
    5a68:	56 95       	lsr	r21
    5a6a:	47 95       	ror	r20
    5a6c:	37 95       	ror	r19
    5a6e:	27 95       	ror	r18
    5a70:	8a 95       	dec	r24
    5a72:	d1 f7       	brne	.-12     	; 0x5a68 <f_lseek+0x42e>
    5a74:	2e 0d       	add	r18, r14
    5a76:	3f 1d       	adc	r19, r15
    5a78:	40 1f       	adc	r20, r16
    5a7a:	51 1f       	adc	r21, r17
    5a7c:	6b ce       	rjmp	.-810    	; 0x5754 <f_lseek+0x11a>
							ofs = bcs; break;
						}
					} else
#endif
						clst = get_fat(fp->fs, clst);	/* Follow cluster chain if not in write mode */
					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
    5a7e:	a8 85       	ldd	r26, Y+8	; 0x08
    5a80:	b9 85       	ldd	r27, Y+9	; 0x09
    5a82:	14 96       	adiw	r26, 0x04	; 4
    5a84:	8c 91       	ld	r24, X
    5a86:	14 97       	sbiw	r26, 0x04	; 4
    5a88:	80 68       	ori	r24, 0x80	; 128
    5a8a:	14 96       	adiw	r26, 0x04	; 4
    5a8c:	8c 93       	st	X, r24
    5a8e:	b1 e0       	ldi	r27, 0x01	; 1
    5a90:	bd 83       	std	Y+5, r27	; 0x05
    5a92:	8a ce       	rjmp	.-748    	; 0x57a8 <f_lseek+0x16e>
					ofs -= bcs;
				}
				fp->fptr += ofs;
				if (ofs % SS(fp->fs)) {
					nsect = clust2sect(fp->fs, clst);	/* Current sector */
					if (!nsect) ABORT(fp->fs, FR_INT_ERR);
    5a94:	a8 85       	ldd	r26, Y+8	; 0x08
    5a96:	b9 85       	ldd	r27, Y+9	; 0x09
    5a98:	14 96       	adiw	r26, 0x04	; 4
    5a9a:	8c 91       	ld	r24, X
    5a9c:	14 97       	sbiw	r26, 0x04	; 4
    5a9e:	80 68       	ori	r24, 0x80	; 128
    5aa0:	14 96       	adiw	r26, 0x04	; 4
    5aa2:	8c 93       	st	X, r24
    5aa4:	b2 e0       	ldi	r27, 0x02	; 2
    5aa6:	bd 83       	std	Y+5, r27	; 0x05
    5aa8:	7f ce       	rjmp	.-770    	; 0x57a8 <f_lseek+0x16e>

00005aaa <f_forward>:
	FIL *fp, 						/* Pointer to the file object */
	UINT (*func)(const BYTE*,UINT),	/* Pointer to the streaming function */
	UINT btr,						/* Number of bytes to forward */
	UINT *bf						/* Pointer to number of bytes forwarded */
)
{
    5aaa:	2f 92       	push	r2
    5aac:	3f 92       	push	r3
    5aae:	5f 92       	push	r5
    5ab0:	6f 92       	push	r6
    5ab2:	7f 92       	push	r7
    5ab4:	8f 92       	push	r8
    5ab6:	9f 92       	push	r9
    5ab8:	af 92       	push	r10
    5aba:	bf 92       	push	r11
    5abc:	cf 92       	push	r12
    5abe:	df 92       	push	r13
    5ac0:	ef 92       	push	r14
    5ac2:	ff 92       	push	r15
    5ac4:	0f 93       	push	r16
    5ac6:	1f 93       	push	r17
    5ac8:	cf 93       	push	r28
    5aca:	df 93       	push	r29
    5acc:	6c 01       	movw	r12, r24
    5ace:	3b 01       	movw	r6, r22
    5ad0:	5a 01       	movw	r10, r20
    5ad2:	49 01       	movw	r8, r18
	DWORD remain, clst, sect;
	UINT rcnt;
	BYTE csect;


	*bf = 0;	/* Initialize byte counter */
    5ad4:	d9 01       	movw	r26, r18
    5ad6:	1d 92       	st	X+, r1
    5ad8:	1c 92       	st	X, r1

	res = validate(fp->fs, fp->id);					/* Check validity of the object */
    5ada:	fc 01       	movw	r30, r24
    5adc:	62 81       	ldd	r22, Z+2	; 0x02
    5ade:	73 81       	ldd	r23, Z+3	; 0x03
    5ae0:	80 81       	ld	r24, Z
    5ae2:	91 81       	ldd	r25, Z+1	; 0x01
    5ae4:	0e 94 75 26 	call	0x4cea	; 0x4cea <validate>
    5ae8:	58 2e       	mov	r5, r24
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
    5aea:	88 23       	and	r24, r24
    5aec:	09 f0       	breq	.+2      	; 0x5af0 <f_forward+0x46>
    5aee:	8b c0       	rjmp	.+278    	; 0x5c06 <f_forward+0x15c>
	if (fp->flag & FA__ERROR)						/* Check error flag */
    5af0:	d6 01       	movw	r26, r12
    5af2:	14 96       	adiw	r26, 0x04	; 4
    5af4:	8c 91       	ld	r24, X
    5af6:	87 fd       	sbrc	r24, 7
    5af8:	0d c1       	rjmp	.+538    	; 0x5d14 <f_forward+0x26a>
		LEAVE_FF(fp->fs, FR_INT_ERR);
	if (!(fp->flag & FA_READ))						/* Check access mode */
    5afa:	80 ff       	sbrs	r24, 0
    5afc:	97 c0       	rjmp	.+302    	; 0x5c2c <f_forward+0x182>
		LEAVE_FF(fp->fs, FR_DENIED);

	remain = fp->fsize - fp->fptr;
    5afe:	f6 01       	movw	r30, r12
    5b00:	22 85       	ldd	r18, Z+10	; 0x0a
    5b02:	33 85       	ldd	r19, Z+11	; 0x0b
    5b04:	44 85       	ldd	r20, Z+12	; 0x0c
    5b06:	55 85       	ldd	r21, Z+13	; 0x0d
    5b08:	86 81       	ldd	r24, Z+6	; 0x06
    5b0a:	97 81       	ldd	r25, Z+7	; 0x07
    5b0c:	a0 85       	ldd	r26, Z+8	; 0x08
    5b0e:	b1 85       	ldd	r27, Z+9	; 0x09
    5b10:	28 1b       	sub	r18, r24
    5b12:	39 0b       	sbc	r19, r25
    5b14:	4a 0b       	sbc	r20, r26
    5b16:	5b 0b       	sbc	r21, r27
	if (btr > remain) btr = (UINT)remain;			/* Truncate btr by remaining bytes */
    5b18:	c5 01       	movw	r24, r10
    5b1a:	a0 e0       	ldi	r26, 0x00	; 0
    5b1c:	b0 e0       	ldi	r27, 0x00	; 0
    5b1e:	28 17       	cp	r18, r24
    5b20:	39 07       	cpc	r19, r25
    5b22:	4a 07       	cpc	r20, r26
    5b24:	5b 07       	cpc	r21, r27
    5b26:	08 f4       	brcc	.+2      	; 0x5b2a <f_forward+0x80>
    5b28:	ef c0       	rjmp	.+478    	; 0x5d08 <f_forward+0x25e>

	for ( ;  btr && (*func)(0, 0);					/* Repeat until all data transferred or stream becomes busy */
    5b2a:	a1 14       	cp	r10, r1
    5b2c:	b1 04       	cpc	r11, r1
    5b2e:	09 f4       	brne	.+2      	; 0x5b32 <f_forward+0x88>
    5b30:	6a c0       	rjmp	.+212    	; 0x5c06 <f_forward+0x15c>
		if (!sect) ABORT(fp->fs, FR_INT_ERR);
		sect += csect;
		if (move_window(fp->fs, sect))				/* Move sector window */
			ABORT(fp->fs, FR_DISK_ERR);
		fp->dsect = sect;
		rcnt = SS(fp->fs) - (WORD)(fp->fptr % SS(fp->fs));	/* Forward data from sector window */
    5b32:	21 2c       	mov	r2, r1
    5b34:	22 e0       	ldi	r18, 0x02	; 2
    5b36:	32 2e       	mov	r3, r18
		LEAVE_FF(fp->fs, FR_DENIED);

	remain = fp->fsize - fp->fptr;
	if (btr > remain) btr = (UINT)remain;			/* Truncate btr by remaining bytes */

	for ( ;  btr && (*func)(0, 0);					/* Repeat until all data transferred or stream becomes busy */
    5b38:	80 e0       	ldi	r24, 0x00	; 0
    5b3a:	90 e0       	ldi	r25, 0x00	; 0
    5b3c:	60 e0       	ldi	r22, 0x00	; 0
    5b3e:	70 e0       	ldi	r23, 0x00	; 0
    5b40:	f3 01       	movw	r30, r6
    5b42:	09 95       	icall
    5b44:	89 2b       	or	r24, r25
    5b46:	09 f4       	brne	.+2      	; 0x5b4a <f_forward+0xa0>
    5b48:	5e c0       	rjmp	.+188    	; 0x5c06 <f_forward+0x15c>
		fp->fptr += rcnt, *bf += rcnt, btr -= rcnt) {
		csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
    5b4a:	d6 01       	movw	r26, r12
    5b4c:	16 96       	adiw	r26, 0x06	; 6
    5b4e:	2d 91       	ld	r18, X+
    5b50:	3d 91       	ld	r19, X+
    5b52:	4d 91       	ld	r20, X+
    5b54:	5c 91       	ld	r21, X
    5b56:	19 97       	sbiw	r26, 0x09	; 9
    5b58:	cd 91       	ld	r28, X+
    5b5a:	dc 91       	ld	r29, X
    5b5c:	da 01       	movw	r26, r20
    5b5e:	c9 01       	movw	r24, r18
    5b60:	69 e0       	ldi	r22, 0x09	; 9
    5b62:	b6 95       	lsr	r27
    5b64:	a7 95       	ror	r26
    5b66:	97 95       	ror	r25
    5b68:	87 95       	ror	r24
    5b6a:	6a 95       	dec	r22
    5b6c:	d1 f7       	brne	.-12     	; 0x5b62 <f_forward+0xb8>
    5b6e:	1a 81       	ldd	r17, Y+2	; 0x02
    5b70:	11 50       	subi	r17, 0x01	; 1
    5b72:	18 23       	and	r17, r24
		if ((fp->fptr % SS(fp->fs)) == 0) {			/* On the sector boundary? */
    5b74:	da 01       	movw	r26, r20
    5b76:	c9 01       	movw	r24, r18
    5b78:	91 70       	andi	r25, 0x01	; 1
    5b7a:	a0 70       	andi	r26, 0x00	; 0
    5b7c:	b0 70       	andi	r27, 0x00	; 0
    5b7e:	00 97       	sbiw	r24, 0x00	; 0
    5b80:	a1 05       	cpc	r26, r1
    5b82:	b1 05       	cpc	r27, r1
    5b84:	19 f5       	brne	.+70     	; 0x5bcc <f_forward+0x122>
			if (!csect) {							/* On the cluster boundary? */
    5b86:	11 23       	and	r17, r17
    5b88:	09 f5       	brne	.+66     	; 0x5bcc <f_forward+0x122>
				clst = (fp->fptr == 0) ?			/* On the top of the file? */
    5b8a:	21 15       	cp	r18, r1
    5b8c:	31 05       	cpc	r19, r1
    5b8e:	41 05       	cpc	r20, r1
    5b90:	51 05       	cpc	r21, r1
    5b92:	09 f0       	breq	.+2      	; 0x5b96 <f_forward+0xec>
    5b94:	ae c0       	rjmp	.+348    	; 0x5cf2 <f_forward+0x248>
    5b96:	f6 01       	movw	r30, r12
    5b98:	66 85       	ldd	r22, Z+14	; 0x0e
    5b9a:	77 85       	ldd	r23, Z+15	; 0x0f
    5b9c:	80 89       	ldd	r24, Z+16	; 0x10
    5b9e:	91 89       	ldd	r25, Z+17	; 0x11
					fp->org_clust : get_fat(fp->fs, fp->curr_clust);
				if (clst <= 1) ABORT(fp->fs, FR_INT_ERR);
    5ba0:	62 30       	cpi	r22, 0x02	; 2
    5ba2:	71 05       	cpc	r23, r1
    5ba4:	81 05       	cpc	r24, r1
    5ba6:	91 05       	cpc	r25, r1
    5ba8:	08 f4       	brcc	.+2      	; 0x5bac <f_forward+0x102>
    5baa:	b0 c0       	rjmp	.+352    	; 0x5d0c <f_forward+0x262>
				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
    5bac:	6f 3f       	cpi	r22, 0xFF	; 255
    5bae:	ff ef       	ldi	r31, 0xFF	; 255
    5bb0:	7f 07       	cpc	r23, r31
    5bb2:	ff ef       	ldi	r31, 0xFF	; 255
    5bb4:	8f 07       	cpc	r24, r31
    5bb6:	ff ef       	ldi	r31, 0xFF	; 255
    5bb8:	9f 07       	cpc	r25, r31
    5bba:	09 f4       	brne	.+2      	; 0x5bbe <f_forward+0x114>
    5bbc:	ae c0       	rjmp	.+348    	; 0x5d1a <f_forward+0x270>
				fp->curr_clust = clst;				/* Update current cluster */
    5bbe:	f6 01       	movw	r30, r12
    5bc0:	62 8b       	std	Z+18, r22	; 0x12
    5bc2:	73 8b       	std	Z+19, r23	; 0x13
    5bc4:	84 8b       	std	Z+20, r24	; 0x14
    5bc6:	95 8b       	std	Z+21, r25	; 0x15
    5bc8:	c0 81       	ld	r28, Z
    5bca:	d1 81       	ldd	r29, Z+1	; 0x01
DWORD clust2sect (	/* !=0: Sector number, 0: Failed - invalid cluster# */
	FATFS *fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
    5bcc:	d6 01       	movw	r26, r12
    5bce:	52 96       	adiw	r26, 0x12	; 18
    5bd0:	2d 91       	ld	r18, X+
    5bd2:	3d 91       	ld	r19, X+
    5bd4:	4d 91       	ld	r20, X+
    5bd6:	5c 91       	ld	r21, X
    5bd8:	55 97       	sbiw	r26, 0x15	; 21
    5bda:	22 50       	subi	r18, 0x02	; 2
    5bdc:	30 40       	sbci	r19, 0x00	; 0
    5bde:	40 40       	sbci	r20, 0x00	; 0
    5be0:	50 40       	sbci	r21, 0x00	; 0
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
    5be2:	8e 89       	ldd	r24, Y+22	; 0x16
    5be4:	9f 89       	ldd	r25, Y+23	; 0x17
    5be6:	a8 8d       	ldd	r26, Y+24	; 0x18
    5be8:	b9 8d       	ldd	r27, Y+25	; 0x19
    5bea:	02 97       	sbiw	r24, 0x02	; 2
    5bec:	a1 09       	sbc	r26, r1
    5bee:	b1 09       	sbc	r27, r1
    5bf0:	28 17       	cp	r18, r24
    5bf2:	39 07       	cpc	r19, r25
    5bf4:	4a 07       	cpc	r20, r26
    5bf6:	5b 07       	cpc	r21, r27
    5bf8:	e0 f0       	brcs	.+56     	; 0x5c32 <f_forward+0x188>
			ABORT(fp->fs, FR_DISK_ERR);
		fp->dsect = sect;
		rcnt = SS(fp->fs) - (WORD)(fp->fptr % SS(fp->fs));	/* Forward data from sector window */
		if (rcnt > btr) rcnt = btr;
		rcnt = (*func)(&fp->fs->win[(WORD)fp->fptr % SS(fp->fs)], rcnt);
		if (!rcnt) ABORT(fp->fs, FR_INT_ERR);
    5bfa:	f6 01       	movw	r30, r12
    5bfc:	84 81       	ldd	r24, Z+4	; 0x04
    5bfe:	80 68       	ori	r24, 0x80	; 128
    5c00:	84 83       	std	Z+4, r24	; 0x04
    5c02:	32 e0       	ldi	r19, 0x02	; 2
    5c04:	53 2e       	mov	r5, r19
	}

	LEAVE_FF(fp->fs, FR_OK);
}
    5c06:	85 2d       	mov	r24, r5
    5c08:	df 91       	pop	r29
    5c0a:	cf 91       	pop	r28
    5c0c:	1f 91       	pop	r17
    5c0e:	0f 91       	pop	r16
    5c10:	ff 90       	pop	r15
    5c12:	ef 90       	pop	r14
    5c14:	df 90       	pop	r13
    5c16:	cf 90       	pop	r12
    5c18:	bf 90       	pop	r11
    5c1a:	af 90       	pop	r10
    5c1c:	9f 90       	pop	r9
    5c1e:	8f 90       	pop	r8
    5c20:	7f 90       	pop	r7
    5c22:	6f 90       	pop	r6
    5c24:	5f 90       	pop	r5
    5c26:	3f 90       	pop	r3
    5c28:	2f 90       	pop	r2
    5c2a:	08 95       	ret

	res = validate(fp->fs, fp->id);					/* Check validity of the object */
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
	if (fp->flag & FA__ERROR)						/* Check error flag */
		LEAVE_FF(fp->fs, FR_INT_ERR);
	if (!(fp->flag & FA_READ))						/* Check access mode */
    5c2c:	77 e0       	ldi	r23, 0x07	; 7
    5c2e:	57 2e       	mov	r5, r23
    5c30:	ea cf       	rjmp	.-44     	; 0x5c06 <f_forward+0x15c>
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
	return clst * fs->csize + fs->database;
    5c32:	6a 81       	ldd	r22, Y+2	; 0x02
    5c34:	70 e0       	ldi	r23, 0x00	; 0
    5c36:	80 e0       	ldi	r24, 0x00	; 0
    5c38:	90 e0       	ldi	r25, 0x00	; 0
    5c3a:	0e 94 bb 7f 	call	0xff76	; 0xff76 <__mulsi3>
    5c3e:	ab 01       	movw	r20, r22
    5c40:	bc 01       	movw	r22, r24
    5c42:	8e a1       	ldd	r24, Y+38	; 0x26
    5c44:	9f a1       	ldd	r25, Y+39	; 0x27
    5c46:	a8 a5       	ldd	r26, Y+40	; 0x28
    5c48:	b9 a5       	ldd	r27, Y+41	; 0x29
    5c4a:	48 0f       	add	r20, r24
    5c4c:	59 1f       	adc	r21, r25
    5c4e:	6a 1f       	adc	r22, r26
    5c50:	7b 1f       	adc	r23, r27
				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
				fp->curr_clust = clst;				/* Update current cluster */
			}
		}
		sect = clust2sect(fp->fs, fp->curr_clust);	/* Get current data sector */
		if (!sect) ABORT(fp->fs, FR_INT_ERR);
    5c52:	41 15       	cp	r20, r1
    5c54:	51 05       	cpc	r21, r1
    5c56:	61 05       	cpc	r22, r1
    5c58:	71 05       	cpc	r23, r1
    5c5a:	79 f2       	breq	.-98     	; 0x5bfa <f_forward+0x150>
		sect += csect;
    5c5c:	db 01       	movw	r26, r22
    5c5e:	ca 01       	movw	r24, r20
    5c60:	81 0f       	add	r24, r17
    5c62:	91 1d       	adc	r25, r1
    5c64:	a1 1d       	adc	r26, r1
    5c66:	b1 1d       	adc	r27, r1
    5c68:	7c 01       	movw	r14, r24
    5c6a:	8d 01       	movw	r16, r26
		if (move_window(fp->fs, sect))				/* Move sector window */
    5c6c:	ce 01       	movw	r24, r28
    5c6e:	b8 01       	movw	r22, r16
    5c70:	a7 01       	movw	r20, r14
    5c72:	0e 94 8b 26 	call	0x4d16	; 0x4d16 <move_window>
    5c76:	88 23       	and	r24, r24
    5c78:	09 f0       	breq	.+2      	; 0x5c7c <f_forward+0x1d2>
    5c7a:	4f c0       	rjmp	.+158    	; 0x5d1a <f_forward+0x270>
			ABORT(fp->fs, FR_DISK_ERR);
		fp->dsect = sect;
    5c7c:	f6 01       	movw	r30, r12
    5c7e:	e6 8a       	std	Z+22, r14	; 0x16
    5c80:	f7 8a       	std	Z+23, r15	; 0x17
    5c82:	00 8f       	std	Z+24, r16	; 0x18
    5c84:	11 8f       	std	Z+25, r17	; 0x19
		rcnt = SS(fp->fs) - (WORD)(fp->fptr % SS(fp->fs));	/* Forward data from sector window */
    5c86:	26 81       	ldd	r18, Z+6	; 0x06
    5c88:	37 81       	ldd	r19, Z+7	; 0x07
    5c8a:	31 70       	andi	r19, 0x01	; 1
    5c8c:	a1 01       	movw	r20, r2
    5c8e:	42 1b       	sub	r20, r18
    5c90:	53 0b       	sbc	r21, r19
    5c92:	b5 01       	movw	r22, r10
    5c94:	4a 15       	cp	r20, r10
    5c96:	5b 05       	cpc	r21, r11
    5c98:	08 f4       	brcc	.+2      	; 0x5c9c <f_forward+0x1f2>
    5c9a:	ba 01       	movw	r22, r20
		if (rcnt > btr) rcnt = btr;
		rcnt = (*func)(&fp->fs->win[(WORD)fp->fptr % SS(fp->fs)], rcnt);
    5c9c:	22 5d       	subi	r18, 0xD2	; 210
    5c9e:	3f 4f       	sbci	r19, 0xFF	; 255
    5ca0:	d6 01       	movw	r26, r12
    5ca2:	8d 91       	ld	r24, X+
    5ca4:	9c 91       	ld	r25, X
    5ca6:	82 0f       	add	r24, r18
    5ca8:	93 1f       	adc	r25, r19
    5caa:	f3 01       	movw	r30, r6
    5cac:	09 95       	icall
    5cae:	bc 01       	movw	r22, r24
		if (!rcnt) ABORT(fp->fs, FR_INT_ERR);
    5cb0:	00 97       	sbiw	r24, 0x00	; 0
    5cb2:	09 f4       	brne	.+2      	; 0x5cb6 <f_forward+0x20c>
    5cb4:	a2 cf       	rjmp	.-188    	; 0x5bfa <f_forward+0x150>

	remain = fp->fsize - fp->fptr;
	if (btr > remain) btr = (UINT)remain;			/* Truncate btr by remaining bytes */

	for ( ;  btr && (*func)(0, 0);					/* Repeat until all data transferred or stream becomes busy */
		fp->fptr += rcnt, *bf += rcnt, btr -= rcnt) {
    5cb6:	a0 e0       	ldi	r26, 0x00	; 0
    5cb8:	b0 e0       	ldi	r27, 0x00	; 0
    5cba:	f6 01       	movw	r30, r12
    5cbc:	26 81       	ldd	r18, Z+6	; 0x06
    5cbe:	37 81       	ldd	r19, Z+7	; 0x07
    5cc0:	40 85       	ldd	r20, Z+8	; 0x08
    5cc2:	51 85       	ldd	r21, Z+9	; 0x09
    5cc4:	28 0f       	add	r18, r24
    5cc6:	39 1f       	adc	r19, r25
    5cc8:	4a 1f       	adc	r20, r26
    5cca:	5b 1f       	adc	r21, r27
    5ccc:	d6 01       	movw	r26, r12
    5cce:	16 96       	adiw	r26, 0x06	; 6
    5cd0:	2d 93       	st	X+, r18
    5cd2:	3d 93       	st	X+, r19
    5cd4:	4d 93       	st	X+, r20
    5cd6:	5c 93       	st	X, r21
    5cd8:	19 97       	sbiw	r26, 0x09	; 9
    5cda:	f4 01       	movw	r30, r8
    5cdc:	80 81       	ld	r24, Z
    5cde:	91 81       	ldd	r25, Z+1	; 0x01
    5ce0:	86 0f       	add	r24, r22
    5ce2:	97 1f       	adc	r25, r23
    5ce4:	91 83       	std	Z+1, r25	; 0x01
    5ce6:	80 83       	st	Z, r24
    5ce8:	a6 1a       	sub	r10, r22
    5cea:	b7 0a       	sbc	r11, r23
		LEAVE_FF(fp->fs, FR_DENIED);

	remain = fp->fsize - fp->fptr;
	if (btr > remain) btr = (UINT)remain;			/* Truncate btr by remaining bytes */

	for ( ;  btr && (*func)(0, 0);					/* Repeat until all data transferred or stream becomes busy */
    5cec:	09 f0       	breq	.+2      	; 0x5cf0 <f_forward+0x246>
    5cee:	24 cf       	rjmp	.-440    	; 0x5b38 <f_forward+0x8e>
    5cf0:	8a cf       	rjmp	.-236    	; 0x5c06 <f_forward+0x15c>
		fp->fptr += rcnt, *bf += rcnt, btr -= rcnt) {
		csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
		if ((fp->fptr % SS(fp->fs)) == 0) {			/* On the sector boundary? */
			if (!csect) {							/* On the cluster boundary? */
				clst = (fp->fptr == 0) ?			/* On the top of the file? */
    5cf2:	d6 01       	movw	r26, r12
    5cf4:	52 96       	adiw	r26, 0x12	; 18
    5cf6:	4d 91       	ld	r20, X+
    5cf8:	5d 91       	ld	r21, X+
    5cfa:	6d 91       	ld	r22, X+
    5cfc:	7c 91       	ld	r23, X
    5cfe:	55 97       	sbiw	r26, 0x15	; 21
    5d00:	ce 01       	movw	r24, r28
    5d02:	0e 94 1d 28 	call	0x503a	; 0x503a <get_fat>
    5d06:	4c cf       	rjmp	.-360    	; 0x5ba0 <f_forward+0xf6>
		LEAVE_FF(fp->fs, FR_INT_ERR);
	if (!(fp->flag & FA_READ))						/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);

	remain = fp->fsize - fp->fptr;
	if (btr > remain) btr = (UINT)remain;			/* Truncate btr by remaining bytes */
    5d08:	59 01       	movw	r10, r18
    5d0a:	0f cf       	rjmp	.-482    	; 0x5b2a <f_forward+0x80>
		csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
		if ((fp->fptr % SS(fp->fs)) == 0) {			/* On the sector boundary? */
			if (!csect) {							/* On the cluster boundary? */
				clst = (fp->fptr == 0) ?			/* On the top of the file? */
					fp->org_clust : get_fat(fp->fs, fp->curr_clust);
				if (clst <= 1) ABORT(fp->fs, FR_INT_ERR);
    5d0c:	f6 01       	movw	r30, r12
    5d0e:	84 81       	ldd	r24, Z+4	; 0x04
    5d10:	80 68       	ori	r24, 0x80	; 128
    5d12:	84 83       	std	Z+4, r24	; 0x04
    5d14:	42 e0       	ldi	r20, 0x02	; 2
    5d16:	54 2e       	mov	r5, r20
    5d18:	76 cf       	rjmp	.-276    	; 0x5c06 <f_forward+0x15c>
		}
		sect = clust2sect(fp->fs, fp->curr_clust);	/* Get current data sector */
		if (!sect) ABORT(fp->fs, FR_INT_ERR);
		sect += csect;
		if (move_window(fp->fs, sect))				/* Move sector window */
			ABORT(fp->fs, FR_DISK_ERR);
    5d1a:	d6 01       	movw	r26, r12
    5d1c:	14 96       	adiw	r26, 0x04	; 4
    5d1e:	8c 91       	ld	r24, X
    5d20:	14 97       	sbiw	r26, 0x04	; 4
    5d22:	80 68       	ori	r24, 0x80	; 128
    5d24:	14 96       	adiw	r26, 0x04	; 4
    5d26:	8c 93       	st	X, r24
    5d28:	55 24       	eor	r5, r5
    5d2a:	53 94       	inc	r5
    5d2c:	6c cf       	rjmp	.-296    	; 0x5c06 <f_forward+0x15c>

00005d2e <dir_next>:
static
FRESULT dir_next (	/* FR_OK:Succeeded, FR_NO_FILE:End of table, FR_DENIED:EOT and could not stretch */
	DIR *dj,		/* Pointer to directory object */
	int stretch		/* 0: Do not stretch table, 1: Stretch table if needed */
)
{
    5d2e:	2f 92       	push	r2
    5d30:	3f 92       	push	r3
    5d32:	4f 92       	push	r4
    5d34:	5f 92       	push	r5
    5d36:	6f 92       	push	r6
    5d38:	7f 92       	push	r7
    5d3a:	8f 92       	push	r8
    5d3c:	9f 92       	push	r9
    5d3e:	af 92       	push	r10
    5d40:	bf 92       	push	r11
    5d42:	cf 92       	push	r12
    5d44:	df 92       	push	r13
    5d46:	ef 92       	push	r14
    5d48:	ff 92       	push	r15
    5d4a:	0f 93       	push	r16
    5d4c:	1f 93       	push	r17
    5d4e:	cf 93       	push	r28
    5d50:	df 93       	push	r29
    5d52:	ec 01       	movw	r28, r24
    5d54:	5b 01       	movw	r10, r22
	DWORD clst;
	WORD i;


	i = dj->index + 1;
    5d56:	0c 81       	ldd	r16, Y+4	; 0x04
    5d58:	1d 81       	ldd	r17, Y+5	; 0x05
    5d5a:	0f 5f       	subi	r16, 0xFF	; 255
    5d5c:	1f 4f       	sbci	r17, 0xFF	; 255
	if (!i || !dj->sect)	/* Report EOT when index has reached 65535 */
    5d5e:	41 f1       	breq	.+80     	; 0x5db0 <dir_next+0x82>
    5d60:	8e 85       	ldd	r24, Y+14	; 0x0e
    5d62:	9f 85       	ldd	r25, Y+15	; 0x0f
    5d64:	a8 89       	ldd	r26, Y+16	; 0x10
    5d66:	b9 89       	ldd	r27, Y+17	; 0x11
    5d68:	00 97       	sbiw	r24, 0x00	; 0
    5d6a:	a1 05       	cpc	r26, r1
    5d6c:	b1 05       	cpc	r27, r1
    5d6e:	01 f1       	breq	.+64     	; 0x5db0 <dir_next+0x82>
		return FR_NO_FILE;

	if (!(i % (SS(dj->fs) / 32))) {	/* Sector changed? */
    5d70:	2f e0       	ldi	r18, 0x0F	; 15
    5d72:	c2 2e       	mov	r12, r18
    5d74:	d1 2c       	mov	r13, r1
    5d76:	c0 22       	and	r12, r16
    5d78:	d1 22       	and	r13, r17
    5d7a:	c1 14       	cp	r12, r1
    5d7c:	d1 04       	cpc	r13, r1
    5d7e:	61 f5       	brne	.+88     	; 0x5dd8 <dir_next+0xaa>
		dj->sect++;					/* Next sector */
    5d80:	01 96       	adiw	r24, 0x01	; 1
    5d82:	a1 1d       	adc	r26, r1
    5d84:	b1 1d       	adc	r27, r1
    5d86:	8e 87       	std	Y+14, r24	; 0x0e
    5d88:	9f 87       	std	Y+15, r25	; 0x0f
    5d8a:	a8 8b       	std	Y+16, r26	; 0x10
    5d8c:	b9 8b       	std	Y+17, r27	; 0x11

		if (dj->clust == 0) {	/* Static table */
    5d8e:	4a 85       	ldd	r20, Y+10	; 0x0a
    5d90:	5b 85       	ldd	r21, Y+11	; 0x0b
    5d92:	6c 85       	ldd	r22, Y+12	; 0x0c
    5d94:	7d 85       	ldd	r23, Y+13	; 0x0d
    5d96:	41 15       	cp	r20, r1
    5d98:	51 05       	cpc	r21, r1
    5d9a:	61 05       	cpc	r22, r1
    5d9c:	71 05       	cpc	r23, r1
    5d9e:	99 f5       	brne	.+102    	; 0x5e06 <dir_next+0xd8>
			if (i >= dj->fs->n_rootdir)	/* Report EOT when end of table */
    5da0:	e8 80       	ld	r14, Y
    5da2:	f9 80       	ldd	r15, Y+1	; 0x01
    5da4:	f7 01       	movw	r30, r14
    5da6:	80 85       	ldd	r24, Z+8	; 0x08
    5da8:	91 85       	ldd	r25, Z+9	; 0x09
    5daa:	08 17       	cp	r16, r24
    5dac:	19 07       	cpc	r17, r25
    5dae:	b0 f0       	brcs	.+44     	; 0x5ddc <dir_next+0xae>
	}

	dj->index = i;
	dj->dir = dj->fs->win + (i % (SS(dj->fs) / 32)) * 32;

	return FR_OK;
    5db0:	84 e0       	ldi	r24, 0x04	; 4
}
    5db2:	df 91       	pop	r29
    5db4:	cf 91       	pop	r28
    5db6:	1f 91       	pop	r17
    5db8:	0f 91       	pop	r16
    5dba:	ff 90       	pop	r15
    5dbc:	ef 90       	pop	r14
    5dbe:	df 90       	pop	r13
    5dc0:	cf 90       	pop	r12
    5dc2:	bf 90       	pop	r11
    5dc4:	af 90       	pop	r10
    5dc6:	9f 90       	pop	r9
    5dc8:	8f 90       	pop	r8
    5dca:	7f 90       	pop	r7
    5dcc:	6f 90       	pop	r6
    5dce:	5f 90       	pop	r5
    5dd0:	4f 90       	pop	r4
    5dd2:	3f 90       	pop	r3
    5dd4:	2f 90       	pop	r2
    5dd6:	08 95       	ret
    5dd8:	e8 80       	ld	r14, Y
    5dda:	f9 80       	ldd	r15, Y+1	; 0x01
				dj->sect = clust2sect(dj->fs, clst);
			}
		}
	}

	dj->index = i;
    5ddc:	1d 83       	std	Y+5, r17	; 0x05
    5dde:	0c 83       	std	Y+4, r16	; 0x04
	dj->dir = dj->fs->win + (i % (SS(dj->fs) / 32)) * 32;
    5de0:	cc 0c       	add	r12, r12
    5de2:	dd 1c       	adc	r13, r13
    5de4:	c2 94       	swap	r12
    5de6:	d2 94       	swap	r13
    5de8:	e0 ef       	ldi	r30, 0xF0	; 240
    5dea:	de 22       	and	r13, r30
    5dec:	dc 24       	eor	r13, r12
    5dee:	ce 22       	and	r12, r30
    5df0:	dc 24       	eor	r13, r12
    5df2:	8e e2       	ldi	r24, 0x2E	; 46
    5df4:	90 e0       	ldi	r25, 0x00	; 0
    5df6:	c8 0e       	add	r12, r24
    5df8:	d9 1e       	adc	r13, r25
    5dfa:	ec 0c       	add	r14, r12
    5dfc:	fd 1c       	adc	r15, r13
    5dfe:	fb 8a       	std	Y+19, r15	; 0x13
    5e00:	ea 8a       	std	Y+18, r14	; 0x12
    5e02:	80 e0       	ldi	r24, 0x00	; 0
    5e04:	d6 cf       	rjmp	.-84     	; 0x5db2 <dir_next+0x84>
		if (dj->clust == 0) {	/* Static table */
			if (i >= dj->fs->n_rootdir)	/* Report EOT when end of table */
				return FR_NO_FILE;
		}
		else {					/* Dynamic table */
			if (((i / (SS(dj->fs) / 32)) & (dj->fs->csize - 1)) == 0) {	/* Cluster changed? */
    5e06:	e8 80       	ld	r14, Y
    5e08:	f9 80       	ldd	r15, Y+1	; 0x01
    5e0a:	f7 01       	movw	r30, r14
    5e0c:	82 81       	ldd	r24, Z+2	; 0x02
    5e0e:	90 e0       	ldi	r25, 0x00	; 0
    5e10:	01 97       	sbiw	r24, 0x01	; 1
    5e12:	98 01       	movw	r18, r16
    5e14:	32 95       	swap	r19
    5e16:	22 95       	swap	r18
    5e18:	2f 70       	andi	r18, 0x0F	; 15
    5e1a:	23 27       	eor	r18, r19
    5e1c:	3f 70       	andi	r19, 0x0F	; 15
    5e1e:	23 27       	eor	r18, r19
    5e20:	82 23       	and	r24, r18
    5e22:	93 23       	and	r25, r19
    5e24:	89 2b       	or	r24, r25
    5e26:	d1 f6       	brne	.-76     	; 0x5ddc <dir_next+0xae>
				clst = get_fat(dj->fs, dj->clust);				/* Get next cluster */
    5e28:	c7 01       	movw	r24, r14
    5e2a:	0e 94 1d 28 	call	0x503a	; 0x503a <get_fat>
    5e2e:	3b 01       	movw	r6, r22
    5e30:	4c 01       	movw	r8, r24
				if (clst <= 1) return FR_INT_ERR;
    5e32:	62 30       	cpi	r22, 0x02	; 2
    5e34:	71 05       	cpc	r23, r1
    5e36:	81 05       	cpc	r24, r1
    5e38:	91 05       	cpc	r25, r1
    5e3a:	08 f4       	brcc	.+2      	; 0x5e3e <dir_next+0x110>
    5e3c:	ab c0       	rjmp	.+342    	; 0x5f94 <dir_next+0x266>
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
    5e3e:	6f 3f       	cpi	r22, 0xFF	; 255
    5e40:	2f ef       	ldi	r18, 0xFF	; 255
    5e42:	72 07       	cpc	r23, r18
    5e44:	2f ef       	ldi	r18, 0xFF	; 255
    5e46:	82 07       	cpc	r24, r18
    5e48:	2f ef       	ldi	r18, 0xFF	; 255
    5e4a:	92 07       	cpc	r25, r18
    5e4c:	09 f4       	brne	.+2      	; 0x5e50 <dir_next+0x122>
    5e4e:	a0 c0       	rjmp	.+320    	; 0x5f90 <dir_next+0x262>
				if (clst >= dj->fs->n_fatent) {					/* When it reached end of dynamic table */
    5e50:	e8 80       	ld	r14, Y
    5e52:	f9 80       	ldd	r15, Y+1	; 0x01
    5e54:	f7 01       	movw	r30, r14
    5e56:	86 89       	ldd	r24, Z+22	; 0x16
    5e58:	97 89       	ldd	r25, Z+23	; 0x17
    5e5a:	a0 8d       	ldd	r26, Z+24	; 0x18
    5e5c:	b1 8d       	ldd	r27, Z+25	; 0x19
    5e5e:	68 16       	cp	r6, r24
    5e60:	79 06       	cpc	r7, r25
    5e62:	8a 06       	cpc	r8, r26
    5e64:	9b 06       	cpc	r9, r27
    5e66:	08 f4       	brcc	.+2      	; 0x5e6a <dir_next+0x13c>
    5e68:	97 c0       	rjmp	.+302    	; 0x5f98 <dir_next+0x26a>
#if !_FS_READONLY
					BYTE c;
					if (!stretch) return FR_NO_FILE;			/* When do not stretch, report EOT */
    5e6a:	ab 28       	or	r10, r11
    5e6c:	09 f4       	brne	.+2      	; 0x5e70 <dir_next+0x142>
    5e6e:	a0 cf       	rjmp	.-192    	; 0x5db0 <dir_next+0x82>
					clst = create_chain(dj->fs, dj->clust);		/* Stretch cluster chain */
    5e70:	4a 85       	ldd	r20, Y+10	; 0x0a
    5e72:	5b 85       	ldd	r21, Y+11	; 0x0b
    5e74:	6c 85       	ldd	r22, Y+12	; 0x0c
    5e76:	7d 85       	ldd	r23, Y+13	; 0x0d
    5e78:	c7 01       	movw	r24, r14
    5e7a:	0e 94 34 2a 	call	0x5468	; 0x5468 <create_chain>
    5e7e:	3b 01       	movw	r6, r22
    5e80:	4c 01       	movw	r8, r24
					if (clst == 0) return FR_DENIED;			/* No free cluster */
    5e82:	61 15       	cp	r22, r1
    5e84:	71 05       	cpc	r23, r1
    5e86:	81 05       	cpc	r24, r1
    5e88:	91 05       	cpc	r25, r1
    5e8a:	09 f4       	brne	.+2      	; 0x5e8e <dir_next+0x160>
    5e8c:	c0 c0       	rjmp	.+384    	; 0x600e <dir_next+0x2e0>
					if (clst == 1) return FR_INT_ERR;
    5e8e:	61 30       	cpi	r22, 0x01	; 1
    5e90:	71 05       	cpc	r23, r1
    5e92:	81 05       	cpc	r24, r1
    5e94:	91 05       	cpc	r25, r1
    5e96:	09 f4       	brne	.+2      	; 0x5e9a <dir_next+0x16c>
    5e98:	7d c0       	rjmp	.+250    	; 0x5f94 <dir_next+0x266>
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
    5e9a:	6f 3f       	cpi	r22, 0xFF	; 255
    5e9c:	2f ef       	ldi	r18, 0xFF	; 255
    5e9e:	72 07       	cpc	r23, r18
    5ea0:	2f ef       	ldi	r18, 0xFF	; 255
    5ea2:	82 07       	cpc	r24, r18
    5ea4:	2f ef       	ldi	r18, 0xFF	; 255
    5ea6:	92 07       	cpc	r25, r18
    5ea8:	09 f4       	brne	.+2      	; 0x5eac <dir_next+0x17e>
    5eaa:	72 c0       	rjmp	.+228    	; 0x5f90 <dir_next+0x262>
					/* Clean-up stretched table */
					if (move_window(dj->fs, 0)) return FR_DISK_ERR;	/* Flush active window */
    5eac:	88 81       	ld	r24, Y
    5eae:	99 81       	ldd	r25, Y+1	; 0x01
    5eb0:	40 e0       	ldi	r20, 0x00	; 0
    5eb2:	50 e0       	ldi	r21, 0x00	; 0
    5eb4:	60 e0       	ldi	r22, 0x00	; 0
    5eb6:	70 e0       	ldi	r23, 0x00	; 0
    5eb8:	0e 94 8b 26 	call	0x4d16	; 0x4d16 <move_window>
    5ebc:	88 23       	and	r24, r24
    5ebe:	09 f0       	breq	.+2      	; 0x5ec2 <dir_next+0x194>
    5ec0:	67 c0       	rjmp	.+206    	; 0x5f90 <dir_next+0x262>
}

/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;
    5ec2:	e8 81       	ld	r30, Y
    5ec4:	f9 81       	ldd	r31, Y+1	; 0x01
    5ec6:	be 96       	adiw	r30, 0x2e	; 46
    5ec8:	8f ef       	ldi	r24, 0xFF	; 255
    5eca:	91 e0       	ldi	r25, 0x01	; 1

	while (cnt--)
		*d++ = (BYTE)val;
    5ecc:	11 92       	st	Z+, r1
/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
    5ece:	01 97       	sbiw	r24, 0x01	; 1
    5ed0:	2f ef       	ldi	r18, 0xFF	; 255
    5ed2:	8f 3f       	cpi	r24, 0xFF	; 255
    5ed4:	92 07       	cpc	r25, r18
    5ed6:	d1 f7       	brne	.-12     	; 0x5ecc <dir_next+0x19e>
					if (clst == 1) return FR_INT_ERR;
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
					/* Clean-up stretched table */
					if (move_window(dj->fs, 0)) return FR_DISK_ERR;	/* Flush active window */
					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
					dj->fs->winsect = clust2sect(dj->fs, clst);	/* Cluster start sector */
    5ed8:	e8 80       	ld	r14, Y
    5eda:	f9 80       	ldd	r15, Y+1	; 0x01
DWORD clust2sect (	/* !=0: Sector number, 0: Failed - invalid cluster# */
	FATFS *fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
    5edc:	fe ef       	ldi	r31, 0xFE	; 254
    5ede:	2f 2e       	mov	r2, r31
    5ee0:	ff ef       	ldi	r31, 0xFF	; 255
    5ee2:	3f 2e       	mov	r3, r31
    5ee4:	ff ef       	ldi	r31, 0xFF	; 255
    5ee6:	4f 2e       	mov	r4, r31
    5ee8:	ff ef       	ldi	r31, 0xFF	; 255
    5eea:	5f 2e       	mov	r5, r31
    5eec:	26 0c       	add	r2, r6
    5eee:	37 1c       	adc	r3, r7
    5ef0:	48 1c       	adc	r4, r8
    5ef2:	59 1c       	adc	r5, r9
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
    5ef4:	f7 01       	movw	r30, r14
    5ef6:	86 89       	ldd	r24, Z+22	; 0x16
    5ef8:	97 89       	ldd	r25, Z+23	; 0x17
    5efa:	a0 8d       	ldd	r26, Z+24	; 0x18
    5efc:	b1 8d       	ldd	r27, Z+25	; 0x19
    5efe:	02 97       	sbiw	r24, 0x02	; 2
    5f00:	a1 09       	sbc	r26, r1
    5f02:	b1 09       	sbc	r27, r1
    5f04:	28 16       	cp	r2, r24
    5f06:	39 06       	cpc	r3, r25
    5f08:	4a 06       	cpc	r4, r26
    5f0a:	5b 06       	cpc	r5, r27
    5f0c:	08 f0       	brcs	.+2      	; 0x5f10 <dir_next+0x1e2>
    5f0e:	81 c0       	rjmp	.+258    	; 0x6012 <dir_next+0x2e4>
	return clst * fs->csize + fs->database;
    5f10:	f7 01       	movw	r30, r14
    5f12:	22 81       	ldd	r18, Z+2	; 0x02
    5f14:	30 e0       	ldi	r19, 0x00	; 0
    5f16:	40 e0       	ldi	r20, 0x00	; 0
    5f18:	50 e0       	ldi	r21, 0x00	; 0
    5f1a:	c2 01       	movw	r24, r4
    5f1c:	b1 01       	movw	r22, r2
    5f1e:	0e 94 bb 7f 	call	0xff76	; 0xff76 <__mulsi3>
    5f22:	9b 01       	movw	r18, r22
    5f24:	ac 01       	movw	r20, r24
    5f26:	f7 01       	movw	r30, r14
    5f28:	86 a1       	ldd	r24, Z+38	; 0x26
    5f2a:	97 a1       	ldd	r25, Z+39	; 0x27
    5f2c:	a0 a5       	ldd	r26, Z+40	; 0x28
    5f2e:	b1 a5       	ldd	r27, Z+41	; 0x29
    5f30:	28 0f       	add	r18, r24
    5f32:	39 1f       	adc	r19, r25
    5f34:	4a 1f       	adc	r20, r26
    5f36:	5b 1f       	adc	r21, r27
					if (clst == 1) return FR_INT_ERR;
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
					/* Clean-up stretched table */
					if (move_window(dj->fs, 0)) return FR_DISK_ERR;	/* Flush active window */
					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
					dj->fs->winsect = clust2sect(dj->fs, clst);	/* Cluster start sector */
    5f38:	f7 01       	movw	r30, r14
    5f3a:	22 a7       	std	Z+42, r18	; 0x2a
    5f3c:	33 a7       	std	Z+43, r19	; 0x2b
    5f3e:	44 a7       	std	Z+44, r20	; 0x2c
    5f40:	55 a7       	std	Z+45, r21	; 0x2d
					for (c = 0; c < dj->fs->csize; c++) {		/* Fill the new cluster with 0 */
    5f42:	82 81       	ldd	r24, Z+2	; 0x02
    5f44:	88 23       	and	r24, r24
    5f46:	09 f4       	brne	.+2      	; 0x5f4a <dir_next+0x21c>
    5f48:	7b c0       	rjmp	.+246    	; 0x6040 <dir_next+0x312>
    5f4a:	bb 24       	eor	r11, r11
						dj->fs->wflag = 1;
    5f4c:	aa 24       	eor	r10, r10
    5f4e:	a3 94       	inc	r10
    5f50:	13 c0       	rjmp	.+38     	; 0x5f78 <dir_next+0x24a>
						if (move_window(dj->fs, 0)) return FR_DISK_ERR;
						dj->fs->winsect++;
    5f52:	e8 80       	ld	r14, Y
    5f54:	f9 80       	ldd	r15, Y+1	; 0x01
    5f56:	f7 01       	movw	r30, r14
    5f58:	82 a5       	ldd	r24, Z+42	; 0x2a
    5f5a:	93 a5       	ldd	r25, Z+43	; 0x2b
    5f5c:	a4 a5       	ldd	r26, Z+44	; 0x2c
    5f5e:	b5 a5       	ldd	r27, Z+45	; 0x2d
    5f60:	01 96       	adiw	r24, 0x01	; 1
    5f62:	a1 1d       	adc	r26, r1
    5f64:	b1 1d       	adc	r27, r1
    5f66:	82 a7       	std	Z+42, r24	; 0x2a
    5f68:	93 a7       	std	Z+43, r25	; 0x2b
    5f6a:	a4 a7       	std	Z+44, r26	; 0x2c
    5f6c:	b5 a7       	std	Z+45, r27	; 0x2d
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
					/* Clean-up stretched table */
					if (move_window(dj->fs, 0)) return FR_DISK_ERR;	/* Flush active window */
					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
					dj->fs->winsect = clust2sect(dj->fs, clst);	/* Cluster start sector */
					for (c = 0; c < dj->fs->csize; c++) {		/* Fill the new cluster with 0 */
    5f6e:	b3 94       	inc	r11
    5f70:	82 81       	ldd	r24, Z+2	; 0x02
    5f72:	b8 16       	cp	r11, r24
    5f74:	08 f0       	brcs	.+2      	; 0x5f78 <dir_next+0x24a>
    5f76:	52 c0       	rjmp	.+164    	; 0x601c <dir_next+0x2ee>
						dj->fs->wflag = 1;
    5f78:	f7 01       	movw	r30, r14
    5f7a:	a4 82       	std	Z+4, r10	; 0x04
						if (move_window(dj->fs, 0)) return FR_DISK_ERR;
    5f7c:	88 81       	ld	r24, Y
    5f7e:	99 81       	ldd	r25, Y+1	; 0x01
    5f80:	40 e0       	ldi	r20, 0x00	; 0
    5f82:	50 e0       	ldi	r21, 0x00	; 0
    5f84:	60 e0       	ldi	r22, 0x00	; 0
    5f86:	70 e0       	ldi	r23, 0x00	; 0
    5f88:	0e 94 8b 26 	call	0x4d16	; 0x4d16 <move_window>
    5f8c:	88 23       	and	r24, r24
    5f8e:	09 f3       	breq	.-62     	; 0x5f52 <dir_next+0x224>
	}

	dj->index = i;
	dj->dir = dj->fs->win + (i % (SS(dj->fs) / 32)) * 32;

	return FR_OK;
    5f90:	81 e0       	ldi	r24, 0x01	; 1
    5f92:	0f cf       	rjmp	.-482    	; 0x5db2 <dir_next+0x84>
    5f94:	82 e0       	ldi	r24, 0x02	; 2
    5f96:	0d cf       	rjmp	.-486    	; 0x5db2 <dir_next+0x84>
		else {					/* Dynamic table */
			if (((i / (SS(dj->fs) / 32)) & (dj->fs->csize - 1)) == 0) {	/* Cluster changed? */
				clst = get_fat(dj->fs, dj->clust);				/* Get next cluster */
				if (clst <= 1) return FR_INT_ERR;
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
				if (clst >= dj->fs->n_fatent) {					/* When it reached end of dynamic table */
    5f98:	ae ef       	ldi	r26, 0xFE	; 254
    5f9a:	2a 2e       	mov	r2, r26
    5f9c:	af ef       	ldi	r26, 0xFF	; 255
    5f9e:	3a 2e       	mov	r3, r26
    5fa0:	af ef       	ldi	r26, 0xFF	; 255
    5fa2:	4a 2e       	mov	r4, r26
    5fa4:	af ef       	ldi	r26, 0xFF	; 255
    5fa6:	5a 2e       	mov	r5, r26
    5fa8:	26 0c       	add	r2, r6
    5faa:	37 1c       	adc	r3, r7
    5fac:	48 1c       	adc	r4, r8
    5fae:	59 1c       	adc	r5, r9
					dj->fs->winsect -= c;						/* Rewind window address */
#else
					return FR_NO_FILE;			/* Report EOT */
#endif
				}
				dj->clust = clst;				/* Initialize data for new cluster */
    5fb0:	6a 86       	std	Y+10, r6	; 0x0a
    5fb2:	7b 86       	std	Y+11, r7	; 0x0b
    5fb4:	8c 86       	std	Y+12, r8	; 0x0c
    5fb6:	9d 86       	std	Y+13, r9	; 0x0d
	FATFS *fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
    5fb8:	f7 01       	movw	r30, r14
    5fba:	86 89       	ldd	r24, Z+22	; 0x16
    5fbc:	97 89       	ldd	r25, Z+23	; 0x17
    5fbe:	a0 8d       	ldd	r26, Z+24	; 0x18
    5fc0:	b1 8d       	ldd	r27, Z+25	; 0x19
    5fc2:	02 97       	sbiw	r24, 0x02	; 2
    5fc4:	a1 09       	sbc	r26, r1
    5fc6:	b1 09       	sbc	r27, r1
    5fc8:	28 16       	cp	r2, r24
    5fca:	39 06       	cpc	r3, r25
    5fcc:	4a 06       	cpc	r4, r26
    5fce:	5b 06       	cpc	r5, r27
    5fd0:	48 f0       	brcs	.+18     	; 0x5fe4 <dir_next+0x2b6>
    5fd2:	20 e0       	ldi	r18, 0x00	; 0
    5fd4:	30 e0       	ldi	r19, 0x00	; 0
    5fd6:	40 e0       	ldi	r20, 0x00	; 0
    5fd8:	50 e0       	ldi	r21, 0x00	; 0
#else
					return FR_NO_FILE;			/* Report EOT */
#endif
				}
				dj->clust = clst;				/* Initialize data for new cluster */
				dj->sect = clust2sect(dj->fs, clst);
    5fda:	2e 87       	std	Y+14, r18	; 0x0e
    5fdc:	3f 87       	std	Y+15, r19	; 0x0f
    5fde:	48 8b       	std	Y+16, r20	; 0x10
    5fe0:	59 8b       	std	Y+17, r21	; 0x11
    5fe2:	fc ce       	rjmp	.-520    	; 0x5ddc <dir_next+0xae>
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
	return clst * fs->csize + fs->database;
    5fe4:	f7 01       	movw	r30, r14
    5fe6:	22 81       	ldd	r18, Z+2	; 0x02
    5fe8:	30 e0       	ldi	r19, 0x00	; 0
    5fea:	40 e0       	ldi	r20, 0x00	; 0
    5fec:	50 e0       	ldi	r21, 0x00	; 0
    5fee:	c2 01       	movw	r24, r4
    5ff0:	b1 01       	movw	r22, r2
    5ff2:	0e 94 bb 7f 	call	0xff76	; 0xff76 <__mulsi3>
    5ff6:	9b 01       	movw	r18, r22
    5ff8:	ac 01       	movw	r20, r24
    5ffa:	f7 01       	movw	r30, r14
    5ffc:	86 a1       	ldd	r24, Z+38	; 0x26
    5ffe:	97 a1       	ldd	r25, Z+39	; 0x27
    6000:	a0 a5       	ldd	r26, Z+40	; 0x28
    6002:	b1 a5       	ldd	r27, Z+41	; 0x29
    6004:	28 0f       	add	r18, r24
    6006:	39 1f       	adc	r19, r25
    6008:	4a 1f       	adc	r20, r26
    600a:	5b 1f       	adc	r21, r27
    600c:	e6 cf       	rjmp	.-52     	; 0x5fda <dir_next+0x2ac>
				if (clst >= dj->fs->n_fatent) {					/* When it reached end of dynamic table */
#if !_FS_READONLY
					BYTE c;
					if (!stretch) return FR_NO_FILE;			/* When do not stretch, report EOT */
					clst = create_chain(dj->fs, dj->clust);		/* Stretch cluster chain */
					if (clst == 0) return FR_DENIED;			/* No free cluster */
    600e:	87 e0       	ldi	r24, 0x07	; 7
    6010:	d0 ce       	rjmp	.-608    	; 0x5db2 <dir_next+0x84>
	FATFS *fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
    6012:	20 e0       	ldi	r18, 0x00	; 0
    6014:	30 e0       	ldi	r19, 0x00	; 0
    6016:	40 e0       	ldi	r20, 0x00	; 0
    6018:	50 e0       	ldi	r21, 0x00	; 0
    601a:	8e cf       	rjmp	.-228    	; 0x5f38 <dir_next+0x20a>
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
					/* Clean-up stretched table */
					if (move_window(dj->fs, 0)) return FR_DISK_ERR;	/* Flush active window */
					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
					dj->fs->winsect = clust2sect(dj->fs, clst);	/* Cluster start sector */
					for (c = 0; c < dj->fs->csize; c++) {		/* Fill the new cluster with 0 */
    601c:	2b 2d       	mov	r18, r11
    601e:	30 e0       	ldi	r19, 0x00	; 0
    6020:	40 e0       	ldi	r20, 0x00	; 0
    6022:	50 e0       	ldi	r21, 0x00	; 0
						dj->fs->wflag = 1;
						if (move_window(dj->fs, 0)) return FR_DISK_ERR;
						dj->fs->winsect++;
					}
					dj->fs->winsect -= c;						/* Rewind window address */
    6024:	f7 01       	movw	r30, r14
    6026:	82 a5       	ldd	r24, Z+42	; 0x2a
    6028:	93 a5       	ldd	r25, Z+43	; 0x2b
    602a:	a4 a5       	ldd	r26, Z+44	; 0x2c
    602c:	b5 a5       	ldd	r27, Z+45	; 0x2d
    602e:	82 1b       	sub	r24, r18
    6030:	93 0b       	sbc	r25, r19
    6032:	a4 0b       	sbc	r26, r20
    6034:	b5 0b       	sbc	r27, r21
    6036:	82 a7       	std	Z+42, r24	; 0x2a
    6038:	93 a7       	std	Z+43, r25	; 0x2b
    603a:	a4 a7       	std	Z+44, r26	; 0x2c
    603c:	b5 a7       	std	Z+45, r27	; 0x2d
    603e:	b8 cf       	rjmp	.-144    	; 0x5fb0 <dir_next+0x282>
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
					/* Clean-up stretched table */
					if (move_window(dj->fs, 0)) return FR_DISK_ERR;	/* Flush active window */
					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
					dj->fs->winsect = clust2sect(dj->fs, clst);	/* Cluster start sector */
					for (c = 0; c < dj->fs->csize; c++) {		/* Fill the new cluster with 0 */
    6040:	20 e0       	ldi	r18, 0x00	; 0
    6042:	30 e0       	ldi	r19, 0x00	; 0
    6044:	40 e0       	ldi	r20, 0x00	; 0
    6046:	50 e0       	ldi	r21, 0x00	; 0
    6048:	ed cf       	rjmp	.-38     	; 0x6024 <dir_next+0x2f6>

0000604a <f_readdir>:

FRESULT f_readdir (
	DIR *dj,			/* Pointer to the open directory object */
	FILINFO *fno		/* Pointer to file information to return */
)
{
    604a:	cf 92       	push	r12
    604c:	df 92       	push	r13
    604e:	ef 92       	push	r14
    6050:	ff 92       	push	r15
    6052:	0f 93       	push	r16
    6054:	1f 93       	push	r17
    6056:	df 93       	push	r29
    6058:	cf 93       	push	r28
    605a:	cd b7       	in	r28, 0x3d	; 61
    605c:	de b7       	in	r29, 0x3e	; 62
    605e:	2c 97       	sbiw	r28, 0x0c	; 12
    6060:	0f b6       	in	r0, 0x3f	; 63
    6062:	f8 94       	cli
    6064:	de bf       	out	0x3e, r29	; 62
    6066:	0f be       	out	0x3f, r0	; 63
    6068:	cd bf       	out	0x3d, r28	; 61
    606a:	8c 01       	movw	r16, r24
    606c:	6b 01       	movw	r12, r22
	FRESULT res;
	DEF_NAMEBUF;


	res = validate(dj->fs, dj->id);			/* Check validity of the object */
    606e:	dc 01       	movw	r26, r24
    6070:	12 96       	adiw	r26, 0x02	; 2
    6072:	6d 91       	ld	r22, X+
    6074:	7c 91       	ld	r23, X
    6076:	13 97       	sbiw	r26, 0x03	; 3
    6078:	8d 91       	ld	r24, X+
    607a:	9c 91       	ld	r25, X
    607c:	0e 94 75 26 	call	0x4cea	; 0x4cea <validate>
	if (res == FR_OK) {
    6080:	88 23       	and	r24, r24
    6082:	09 f0       	breq	.+2      	; 0x6086 <f_readdir+0x3c>
    6084:	48 c0       	rjmp	.+144    	; 0x6116 <f_readdir+0xcc>
		if (!fno) {
    6086:	c1 14       	cp	r12, r1
    6088:	d1 04       	cpc	r13, r1
    608a:	09 f4       	brne	.+2      	; 0x608e <f_readdir+0x44>
    608c:	64 c0       	rjmp	.+200    	; 0x6156 <f_readdir+0x10c>
			res = dir_sdi(dj, 0);			/* Rewind the directory object */
		} else {
			INIT_BUF(*dj);
    608e:	ce 01       	movw	r24, r28
    6090:	01 96       	adiw	r24, 0x01	; 1
    6092:	f8 01       	movw	r30, r16
    6094:	95 8b       	std	Z+21, r25	; 0x15
    6096:	84 8b       	std	Z+20, r24	; 0x14
    6098:	84 e0       	ldi	r24, 0x04	; 4
#if _USE_LFN
	BYTE a, ord = 0xFF, sum = 0xFF;
#endif

	res = FR_NO_FILE;
	while (dj->sect) {
    609a:	f8 01       	movw	r30, r16
    609c:	46 85       	ldd	r20, Z+14	; 0x0e
    609e:	57 85       	ldd	r21, Z+15	; 0x0f
    60a0:	60 89       	ldd	r22, Z+16	; 0x10
    60a2:	71 89       	ldd	r23, Z+17	; 0x11
    60a4:	41 15       	cp	r20, r1
    60a6:	51 05       	cpc	r21, r1
    60a8:	61 05       	cpc	r22, r1
    60aa:	71 05       	cpc	r23, r1
    60ac:	09 f4       	brne	.+2      	; 0x60b0 <f_readdir+0x66>
    60ae:	4e c0       	rjmp	.+156    	; 0x614c <f_readdir+0x102>
		res = move_window(dj->fs, dj->sect);
    60b0:	d8 01       	movw	r26, r16
    60b2:	8d 91       	ld	r24, X+
    60b4:	9c 91       	ld	r25, X
    60b6:	0e 94 8b 26 	call	0x4d16	; 0x4d16 <move_window>
		if (res != FR_OK) break;
    60ba:	88 23       	and	r24, r24
    60bc:	b9 f4       	brne	.+46     	; 0x60ec <f_readdir+0xa2>
		dir = dj->dir;					/* Ptr to the directory entry of current index */
    60be:	f8 01       	movw	r30, r16
    60c0:	62 89       	ldd	r22, Z+18	; 0x12
    60c2:	73 89       	ldd	r23, Z+19	; 0x13
		c = dir[DIR_Name];
    60c4:	db 01       	movw	r26, r22
    60c6:	8c 91       	ld	r24, X
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
    60c8:	88 23       	and	r24, r24
    60ca:	09 f4       	brne	.+2      	; 0x60ce <f_readdir+0x84>
    60cc:	42 c0       	rjmp	.+132    	; 0x6152 <f_readdir+0x108>
					dj->lfn_idx = 0xFFFF;		/* It has no LFN. */
				break;
			}
		}
#else		/* Non LFN configuration */
		if (c != 0xE5 && (_FS_RPATH || c != '.') && !(dir[DIR_Attr] & AM_VOL))	/* Is it a valid entry? */
    60ce:	85 3e       	cpi	r24, 0xE5	; 229
    60d0:	31 f0       	breq	.+12     	; 0x60de <f_readdir+0x94>
    60d2:	8e 32       	cpi	r24, 0x2E	; 46
    60d4:	21 f0       	breq	.+8      	; 0x60de <f_readdir+0x94>
    60d6:	1b 96       	adiw	r26, 0x0b	; 11
    60d8:	8c 91       	ld	r24, X
    60da:	83 ff       	sbrs	r24, 3
    60dc:	42 c0       	rjmp	.+132    	; 0x6162 <f_readdir+0x118>
			break;
#endif
		res = dir_next(dj, 0);				/* Next entry */
    60de:	c8 01       	movw	r24, r16
    60e0:	60 e0       	ldi	r22, 0x00	; 0
    60e2:	70 e0       	ldi	r23, 0x00	; 0
    60e4:	0e 94 97 2e 	call	0x5d2e	; 0x5d2e <dir_next>
		if (res != FR_OK) break;
    60e8:	88 23       	and	r24, r24
    60ea:	b9 f2       	breq	.-82     	; 0x609a <f_readdir+0x50>
	}

	if (res != FR_OK) dj->sect = 0;
    60ec:	d8 01       	movw	r26, r16
    60ee:	1e 96       	adiw	r26, 0x0e	; 14
    60f0:	1d 92       	st	X+, r1
    60f2:	1d 92       	st	X+, r1
    60f4:	1d 92       	st	X+, r1
    60f6:	1c 92       	st	X, r1
    60f8:	51 97       	sbiw	r26, 0x11	; 17
		if (!fno) {
			res = dir_sdi(dj, 0);			/* Rewind the directory object */
		} else {
			INIT_BUF(*dj);
			res = dir_read(dj);				/* Read an directory item */
			if (res == FR_NO_FILE) {		/* Reached end of dir */
    60fa:	84 30       	cpi	r24, 0x04	; 4
    60fc:	d9 f4       	brne	.+54     	; 0x6134 <f_readdir+0xea>
	UINT i;
	BYTE nt, *dir;
	TCHAR *p, c;


	p = fno->fname;
    60fe:	96 01       	movw	r18, r12
    6100:	27 5f       	subi	r18, 0xF7	; 247
    6102:	3f 4f       	sbci	r19, 0xFF	; 255
		fno->fattrib = dir[DIR_Attr];				/* Attribute */
		fno->fsize = LD_DWORD(dir+DIR_FileSize);	/* Size */
		fno->fdate = LD_WORD(dir+DIR_WrtDate);		/* Date */
		fno->ftime = LD_WORD(dir+DIR_WrtTime);		/* Time */
	}
	*p = 0;		/* Terminate SFN str by a \0 */
    6104:	f9 01       	movw	r30, r18
    6106:	10 82       	st	Z, r1
				dj->sect = 0;
				res = FR_OK;
			}
			if (res == FR_OK) {				/* A valid entry is found */
				get_fileinfo(dj, fno);		/* Get the object information */
				res = dir_next(dj, 0);		/* Increment index for next */
    6108:	c8 01       	movw	r24, r16
    610a:	60 e0       	ldi	r22, 0x00	; 0
    610c:	70 e0       	ldi	r23, 0x00	; 0
    610e:	0e 94 97 2e 	call	0x5d2e	; 0x5d2e <dir_next>
				if (res == FR_NO_FILE) {
    6112:	84 30       	cpi	r24, 0x04	; 4
    6114:	91 f0       	breq	.+36     	; 0x613a <f_readdir+0xf0>
			FREE_BUF();
		}
	}

	LEAVE_FF(dj->fs, res);
}
    6116:	2c 96       	adiw	r28, 0x0c	; 12
    6118:	0f b6       	in	r0, 0x3f	; 63
    611a:	f8 94       	cli
    611c:	de bf       	out	0x3e, r29	; 62
    611e:	0f be       	out	0x3f, r0	; 63
    6120:	cd bf       	out	0x3d, r28	; 61
    6122:	cf 91       	pop	r28
    6124:	df 91       	pop	r29
    6126:	1f 91       	pop	r17
    6128:	0f 91       	pop	r16
    612a:	ff 90       	pop	r15
    612c:	ef 90       	pop	r14
    612e:	df 90       	pop	r13
    6130:	cf 90       	pop	r12
    6132:	08 95       	ret
			res = dir_read(dj);				/* Read an directory item */
			if (res == FR_NO_FILE) {		/* Reached end of dir */
				dj->sect = 0;
				res = FR_OK;
			}
			if (res == FR_OK) {				/* A valid entry is found */
    6134:	88 23       	and	r24, r24
    6136:	79 f7       	brne	.-34     	; 0x6116 <f_readdir+0xcc>
    6138:	e2 cf       	rjmp	.-60     	; 0x60fe <f_readdir+0xb4>
				get_fileinfo(dj, fno);		/* Get the object information */
				res = dir_next(dj, 0);		/* Increment index for next */
				if (res == FR_NO_FILE) {
					dj->sect = 0;
    613a:	d8 01       	movw	r26, r16
    613c:	1e 96       	adiw	r26, 0x0e	; 14
    613e:	1d 92       	st	X+, r1
    6140:	1d 92       	st	X+, r1
    6142:	1d 92       	st	X+, r1
    6144:	1c 92       	st	X, r1
    6146:	51 97       	sbiw	r26, 0x11	; 17
    6148:	80 e0       	ldi	r24, 0x00	; 0
    614a:	e5 cf       	rjmp	.-54     	; 0x6116 <f_readdir+0xcc>
#endif
		res = dir_next(dj, 0);				/* Next entry */
		if (res != FR_OK) break;
	}

	if (res != FR_OK) dj->sect = 0;
    614c:	88 23       	and	r24, r24
    614e:	b9 f2       	breq	.-82     	; 0x60fe <f_readdir+0xb4>
    6150:	cd cf       	rjmp	.-102    	; 0x60ec <f_readdir+0xa2>
			}
			if (res == FR_OK) {				/* A valid entry is found */
				get_fileinfo(dj, fno);		/* Get the object information */
				res = dir_next(dj, 0);		/* Increment index for next */
				if (res == FR_NO_FILE) {
					dj->sect = 0;
    6152:	84 e0       	ldi	r24, 0x04	; 4
    6154:	cb cf       	rjmp	.-106    	; 0x60ec <f_readdir+0xa2>


	res = validate(dj->fs, dj->id);			/* Check validity of the object */
	if (res == FR_OK) {
		if (!fno) {
			res = dir_sdi(dj, 0);			/* Rewind the directory object */
    6156:	c8 01       	movw	r24, r16
    6158:	60 e0       	ldi	r22, 0x00	; 0
    615a:	70 e0       	ldi	r23, 0x00	; 0
    615c:	0e 94 30 29 	call	0x5260	; 0x5260 <dir_sdi>
    6160:	da cf       	rjmp	.-76     	; 0x6116 <f_readdir+0xcc>
	UINT i;
	BYTE nt, *dir;
	TCHAR *p, c;


	p = fno->fname;
    6162:	96 01       	movw	r18, r12
    6164:	27 5f       	subi	r18, 0xF7	; 247
    6166:	3f 4f       	sbci	r19, 0xFF	; 255
	if (dj->sect) {
    6168:	f8 01       	movw	r30, r16
    616a:	86 85       	ldd	r24, Z+14	; 0x0e
    616c:	97 85       	ldd	r25, Z+15	; 0x0f
    616e:	a0 89       	ldd	r26, Z+16	; 0x10
    6170:	b1 89       	ldd	r27, Z+17	; 0x11
    6172:	00 97       	sbiw	r24, 0x00	; 0
    6174:	a1 05       	cpc	r26, r1
    6176:	b1 05       	cpc	r27, r1
    6178:	29 f2       	breq	.-118    	; 0x6104 <f_readdir+0xba>
		dir = dj->dir;
    617a:	80 e0       	ldi	r24, 0x00	; 0
    617c:	90 e0       	ldi	r25, 0x00	; 0
    617e:	07 c0       	rjmp	.+14     	; 0x618e <f_readdir+0x144>
			if (IsDBCS1(c) && i < 7 && IsDBCS2(dir[i+1]))
				c = (c << 8) | dir[++i];
			c = ff_convert(c, 1);
			if (!c) c = '?';
#endif
			*p++ = c;
    6180:	d9 01       	movw	r26, r18
    6182:	ed 93       	st	X+, r30
    6184:	9d 01       	movw	r18, r26

	p = fno->fname;
	if (dj->sect) {
		dir = dj->dir;
		nt = dir[DIR_NTres];		/* NT flag */
		for (i = 0; i < 8; i++) {	/* Copy name body */
    6186:	01 96       	adiw	r24, 0x01	; 1
    6188:	88 30       	cpi	r24, 0x08	; 8
    618a:	91 05       	cpc	r25, r1
    618c:	81 f0       	breq	.+32     	; 0x61ae <f_readdir+0x164>
			c = dir[i];
    618e:	fb 01       	movw	r30, r22
    6190:	e8 0f       	add	r30, r24
    6192:	f9 1f       	adc	r31, r25
    6194:	e0 81       	ld	r30, Z
			if (c == ' ') break;
    6196:	e0 32       	cpi	r30, 0x20	; 32
    6198:	51 f0       	breq	.+20     	; 0x61ae <f_readdir+0x164>
			if (c == 0x05) c = (TCHAR)0xE5;
    619a:	e5 30       	cpi	r30, 0x05	; 5
    619c:	89 f7       	brne	.-30     	; 0x6180 <f_readdir+0x136>
    619e:	e5 ee       	ldi	r30, 0xE5	; 229
			if (IsDBCS1(c) && i < 7 && IsDBCS2(dir[i+1]))
				c = (c << 8) | dir[++i];
			c = ff_convert(c, 1);
			if (!c) c = '?';
#endif
			*p++ = c;
    61a0:	d9 01       	movw	r26, r18
    61a2:	ed 93       	st	X+, r30
    61a4:	9d 01       	movw	r18, r26

	p = fno->fname;
	if (dj->sect) {
		dir = dj->dir;
		nt = dir[DIR_NTres];		/* NT flag */
		for (i = 0; i < 8; i++) {	/* Copy name body */
    61a6:	01 96       	adiw	r24, 0x01	; 1
    61a8:	88 30       	cpi	r24, 0x08	; 8
    61aa:	91 05       	cpc	r25, r1
    61ac:	81 f7       	brne	.-32     	; 0x618e <f_readdir+0x144>
			c = ff_convert(c, 1);
			if (!c) c = '?';
#endif
			*p++ = c;
		}
		if (dir[8] != ' ') {		/* Copy name extension */
    61ae:	fb 01       	movw	r30, r22
    61b0:	80 85       	ldd	r24, Z+8	; 0x08
    61b2:	80 32       	cpi	r24, 0x20	; 32
    61b4:	09 f4       	brne	.+2      	; 0x61b8 <f_readdir+0x16e>
    61b6:	58 c0       	rjmp	.+176    	; 0x6268 <f_readdir+0x21e>
			*p++ = '.';
    61b8:	8e e2       	ldi	r24, 0x2E	; 46
    61ba:	d9 01       	movw	r26, r18
    61bc:	8d 93       	st	X+, r24
    61be:	7d 01       	movw	r14, r26
    61c0:	fb 01       	movw	r30, r22
			for (i = 8; i < 11; i++) {
    61c2:	2c 5f       	subi	r18, 0xFC	; 252
    61c4:	3f 4f       	sbci	r19, 0xFF	; 255
				c = dir[i];
    61c6:	80 85       	ldd	r24, Z+8	; 0x08
				if (c == ' ') break;
    61c8:	80 32       	cpi	r24, 0x20	; 32
    61ca:	39 f0       	breq	.+14     	; 0x61da <f_readdir+0x190>
				if (IsDBCS1(c) && i < 10 && IsDBCS2(dir[i+1]))
					c = (c << 8) | dir[++i];
				c = ff_convert(c, 1);
				if (!c) c = '?';
#endif
				*p++ = c;
    61cc:	d7 01       	movw	r26, r14
    61ce:	8d 93       	st	X+, r24
    61d0:	7d 01       	movw	r14, r26
    61d2:	31 96       	adiw	r30, 0x01	; 1
#endif
			*p++ = c;
		}
		if (dir[8] != ' ') {		/* Copy name extension */
			*p++ = '.';
			for (i = 8; i < 11; i++) {
    61d4:	a2 17       	cp	r26, r18
    61d6:	b3 07       	cpc	r27, r19
    61d8:	b1 f7       	brne	.-20     	; 0x61c6 <f_readdir+0x17c>
				if (!c) c = '?';
#endif
				*p++ = c;
			}
		}
		fno->fattrib = dir[DIR_Attr];				/* Attribute */
    61da:	fb 01       	movw	r30, r22
    61dc:	83 85       	ldd	r24, Z+11	; 0x0b
    61de:	d6 01       	movw	r26, r12
    61e0:	18 96       	adiw	r26, 0x08	; 8
    61e2:	8c 93       	st	X, r24
		fno->fsize = LD_DWORD(dir+DIR_FileSize);	/* Size */
    61e4:	27 8d       	ldd	r18, Z+31	; 0x1f
    61e6:	30 e0       	ldi	r19, 0x00	; 0
    61e8:	40 e0       	ldi	r20, 0x00	; 0
    61ea:	50 e0       	ldi	r21, 0x00	; 0
    61ec:	52 2f       	mov	r21, r18
    61ee:	44 27       	eor	r20, r20
    61f0:	33 27       	eor	r19, r19
    61f2:	22 27       	eor	r18, r18
    61f4:	86 8d       	ldd	r24, Z+30	; 0x1e
    61f6:	90 e0       	ldi	r25, 0x00	; 0
    61f8:	a0 e0       	ldi	r26, 0x00	; 0
    61fa:	b0 e0       	ldi	r27, 0x00	; 0
    61fc:	dc 01       	movw	r26, r24
    61fe:	99 27       	eor	r25, r25
    6200:	88 27       	eor	r24, r24
    6202:	28 2b       	or	r18, r24
    6204:	39 2b       	or	r19, r25
    6206:	4a 2b       	or	r20, r26
    6208:	5b 2b       	or	r21, r27
    620a:	84 8d       	ldd	r24, Z+28	; 0x1c
    620c:	90 e0       	ldi	r25, 0x00	; 0
    620e:	a0 e0       	ldi	r26, 0x00	; 0
    6210:	b0 e0       	ldi	r27, 0x00	; 0
    6212:	28 2b       	or	r18, r24
    6214:	39 2b       	or	r19, r25
    6216:	4a 2b       	or	r20, r26
    6218:	5b 2b       	or	r21, r27
    621a:	95 8d       	ldd	r25, Z+29	; 0x1d
    621c:	80 e0       	ldi	r24, 0x00	; 0
    621e:	a0 e0       	ldi	r26, 0x00	; 0
    6220:	b0 e0       	ldi	r27, 0x00	; 0
    6222:	28 2b       	or	r18, r24
    6224:	39 2b       	or	r19, r25
    6226:	4a 2b       	or	r20, r26
    6228:	5b 2b       	or	r21, r27
    622a:	f6 01       	movw	r30, r12
    622c:	20 83       	st	Z, r18
    622e:	31 83       	std	Z+1, r19	; 0x01
    6230:	42 83       	std	Z+2, r20	; 0x02
    6232:	53 83       	std	Z+3, r21	; 0x03
		fno->fdate = LD_WORD(dir+DIR_WrtDate);		/* Date */
    6234:	db 01       	movw	r26, r22
    6236:	59 96       	adiw	r26, 0x19	; 25
    6238:	9c 91       	ld	r25, X
    623a:	59 97       	sbiw	r26, 0x19	; 25
    623c:	80 e0       	ldi	r24, 0x00	; 0
    623e:	58 96       	adiw	r26, 0x18	; 24
    6240:	2c 91       	ld	r18, X
    6242:	58 97       	sbiw	r26, 0x18	; 24
    6244:	30 e0       	ldi	r19, 0x00	; 0
    6246:	82 2b       	or	r24, r18
    6248:	93 2b       	or	r25, r19
    624a:	95 83       	std	Z+5, r25	; 0x05
    624c:	84 83       	std	Z+4, r24	; 0x04
		fno->ftime = LD_WORD(dir+DIR_WrtTime);		/* Time */
    624e:	57 96       	adiw	r26, 0x17	; 23
    6250:	9c 91       	ld	r25, X
    6252:	57 97       	sbiw	r26, 0x17	; 23
    6254:	80 e0       	ldi	r24, 0x00	; 0
    6256:	56 96       	adiw	r26, 0x16	; 22
    6258:	2c 91       	ld	r18, X
    625a:	30 e0       	ldi	r19, 0x00	; 0
    625c:	82 2b       	or	r24, r18
    625e:	93 2b       	or	r25, r19
    6260:	97 83       	std	Z+7, r25	; 0x07
    6262:	86 83       	std	Z+6, r24	; 0x06
    6264:	97 01       	movw	r18, r14
    6266:	4e cf       	rjmp	.-356    	; 0x6104 <f_readdir+0xba>
			c = ff_convert(c, 1);
			if (!c) c = '?';
#endif
			*p++ = c;
		}
		if (dir[8] != ' ') {		/* Copy name extension */
    6268:	79 01       	movw	r14, r18
    626a:	b7 cf       	rjmp	.-146    	; 0x61da <f_readdir+0x190>

0000626c <follow_path>:
static
FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
	DIR *dj,			/* Directory object to return last directory and found object */
	const TCHAR *path	/* Full-path string to find a file or directory */
)
{
    626c:	5f 92       	push	r5
    626e:	6f 92       	push	r6
    6270:	7f 92       	push	r7
    6272:	8f 92       	push	r8
    6274:	9f 92       	push	r9
    6276:	af 92       	push	r10
    6278:	bf 92       	push	r11
    627a:	cf 92       	push	r12
    627c:	df 92       	push	r13
    627e:	ef 92       	push	r14
    6280:	ff 92       	push	r15
    6282:	0f 93       	push	r16
    6284:	1f 93       	push	r17
    6286:	cf 93       	push	r28
    6288:	df 93       	push	r29
    628a:	5c 01       	movw	r10, r24
    628c:	6b 01       	movw	r12, r22
		path++;	dj->sclust = 0;		/* Strip it and start from the root dir */
	} else {							/* No heading separator */
		dj->sclust = dj->fs->cdir;	/* Start from the current dir */
	}
#else
	if (*path == '/' || *path == '\\')	/* Strip heading separator if exist */
    628e:	db 01       	movw	r26, r22
    6290:	8c 91       	ld	r24, X
    6292:	8f 32       	cpi	r24, 0x2F	; 47
    6294:	09 f4       	brne	.+2      	; 0x6298 <follow_path+0x2c>
    6296:	61 c0       	rjmp	.+194    	; 0x635a <follow_path+0xee>
    6298:	8c 35       	cpi	r24, 0x5C	; 92
    629a:	09 f4       	brne	.+2      	; 0x629e <follow_path+0x32>
    629c:	5e c0       	rjmp	.+188    	; 0x635a <follow_path+0xee>
		path++;
	dj->sclust = 0;						/* Start from the root dir */
    629e:	f5 01       	movw	r30, r10
    62a0:	16 82       	std	Z+6, r1	; 0x06
    62a2:	17 82       	std	Z+7, r1	; 0x07
    62a4:	10 86       	std	Z+8, r1	; 0x08
    62a6:	11 86       	std	Z+9, r1	; 0x09
#endif

	if ((UINT)*path < ' ') {			/* Nul path means the start directory itself */
    62a8:	d6 01       	movw	r26, r12
    62aa:	8c 91       	ld	r24, X
    62ac:	80 32       	cpi	r24, 0x20	; 32
    62ae:	08 f4       	brcc	.+2      	; 0x62b2 <follow_path+0x46>
    62b0:	52 c1       	rjmp	.+676    	; 0x6556 <follow_path+0x2ea>
    62b2:	f5 01       	movw	r30, r10
    62b4:	04 89       	ldd	r16, Z+20	; 0x14
    62b6:	15 89       	ldd	r17, Z+21	; 0x15
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
		*d++ = (BYTE)val;
    62b8:	30 e2       	ldi	r19, 0x20	; 32
    62ba:	e3 2e       	mov	r14, r19
	}
	*path = &p[si];						/* Return pointer to the next segment */
	c = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */

	if (!i) return FR_INVALID_NAME;		/* Reject nul string */
	if (sfn[0] == 0xE5) sfn[0] = 0x05;	/* When first char collides with 0xE5, replace it with 0x05 */
    62bc:	25 e0       	ldi	r18, 0x05	; 5
    62be:	52 2e       	mov	r5, r18
	BYTE b, c, d, *sfn;
	UINT ni, si, i;
	const char *p;

	/* Create file name in directory form */
	sfn = dj->fn;
    62c0:	f8 01       	movw	r30, r16
    62c2:	8a e0       	ldi	r24, 0x0A	; 10
    62c4:	90 e0       	ldi	r25, 0x00	; 0
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
		*d++ = (BYTE)val;
    62c6:	e1 92       	st	Z+, r14
/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
    62c8:	01 97       	sbiw	r24, 0x01	; 1
    62ca:	bf ef       	ldi	r27, 0xFF	; 255
    62cc:	8f 3f       	cpi	r24, 0xFF	; 255
    62ce:	9b 07       	cpc	r25, r27
    62d0:	d1 f7       	brne	.-12     	; 0x62c6 <follow_path+0x5a>
    62d2:	60 e0       	ldi	r22, 0x00	; 0
    62d4:	70 e0       	ldi	r23, 0x00	; 0
    62d6:	40 e0       	ldi	r20, 0x00	; 0
    62d8:	50 e0       	ldi	r21, 0x00	; 0
    62da:	c8 e0       	ldi	r28, 0x08	; 8
    62dc:	d0 e0       	ldi	r29, 0x00	; 0
    62de:	ff 24       	eor	r15, r15
		sfn[NS] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT;	/* Set last segment flag if end of path */
		return FR_OK;
	}
#endif
	for (;;) {
		c = (BYTE)p[si++];
    62e0:	f6 01       	movw	r30, r12
    62e2:	e4 0f       	add	r30, r20
    62e4:	f5 1f       	adc	r31, r21
    62e6:	20 81       	ld	r18, Z
    62e8:	4f 5f       	subi	r20, 0xFF	; 255
    62ea:	5f 4f       	sbci	r21, 0xFF	; 255
		if (c <= ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
    62ec:	21 32       	cpi	r18, 0x21	; 33
    62ee:	08 f4       	brcc	.+2      	; 0x62f2 <follow_path+0x86>
    62f0:	0a c1       	rjmp	.+532    	; 0x6506 <follow_path+0x29a>
    62f2:	2f 32       	cpi	r18, 0x2F	; 47
    62f4:	09 f4       	brne	.+2      	; 0x62f8 <follow_path+0x8c>
    62f6:	70 c0       	rjmp	.+224    	; 0x63d8 <follow_path+0x16c>
    62f8:	2c 35       	cpi	r18, 0x5C	; 92
    62fa:	09 f4       	brne	.+2      	; 0x62fe <follow_path+0x92>
    62fc:	6d c0       	rjmp	.+218    	; 0x63d8 <follow_path+0x16c>
		if (c == '.' || i >= ni) {
    62fe:	2e 32       	cpi	r18, 0x2E	; 46
    6300:	81 f1       	breq	.+96     	; 0x6362 <follow_path+0xf6>
    6302:	6c 17       	cp	r22, r28
    6304:	7d 07       	cpc	r23, r29
    6306:	68 f5       	brcc	.+90     	; 0x6362 <follow_path+0xf6>
			if (ni != 8 || c != '.') return FR_INVALID_NAME;
			i = 8; ni = 11;
			b <<= 2; continue;
		}
		if (c >= 0x80) {				/* Extended char? */
    6308:	27 fd       	sbrc	r18, 7
    630a:	5a c0       	rjmp	.+180    	; 0x63c0 <follow_path+0x154>
#if !_DF1S	/* ASCII only cfg */
			return FR_INVALID_NAME;
#endif
#endif
		}
		if (IsDBCS1(c)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
    630c:	82 2f       	mov	r24, r18
    630e:	81 58       	subi	r24, 0x81	; 129
    6310:	8f 31       	cpi	r24, 0x1F	; 31
    6312:	a0 f1       	brcs	.+104    	; 0x637c <follow_path+0x110>
    6314:	8f 55       	subi	r24, 0x5F	; 95
    6316:	8d 31       	cpi	r24, 0x1D	; 29
    6318:	88 f1       	brcs	.+98     	; 0x637c <follow_path+0x110>
			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
				return FR_INVALID_NAME;
			sfn[i++] = c;
			sfn[i++] = d;
		} else {						/* Single byte code */
			if (chk_chr("\"*+,:;<=>\?[]|\x7F", c))	/* Reject illegal chrs for SFN */
    631a:	a2 2f       	mov	r26, r18
    631c:	b0 e0       	ldi	r27, 0x00	; 0
}

/* Check if chr is contained in the string */
static
int chk_chr (const char* str, int chr) {
	while (*str && *str != chr) str++;
    631e:	a2 32       	cpi	r26, 0x22	; 34
    6320:	b1 05       	cpc	r27, r1
    6322:	09 f4       	brne	.+2      	; 0x6326 <follow_path+0xba>
    6324:	f6 c0       	rjmp	.+492    	; 0x6512 <follow_path+0x2a6>
    6326:	e7 ec       	ldi	r30, 0xC7	; 199
    6328:	f3 e0       	ldi	r31, 0x03	; 3
    632a:	05 c0       	rjmp	.+10     	; 0x6336 <follow_path+0xca>
    632c:	90 e0       	ldi	r25, 0x00	; 0
    632e:	a8 17       	cp	r26, r24
    6330:	b9 07       	cpc	r27, r25
    6332:	09 f4       	brne	.+2      	; 0x6336 <follow_path+0xca>
    6334:	ee c0       	rjmp	.+476    	; 0x6512 <follow_path+0x2a6>
    6336:	31 96       	adiw	r30, 0x01	; 1
    6338:	80 81       	ld	r24, Z
    633a:	88 23       	and	r24, r24
    633c:	b9 f7       	brne	.-18     	; 0x632c <follow_path+0xc0>
			sfn[i++] = c;
			sfn[i++] = d;
		} else {						/* Single byte code */
			if (chk_chr("\"*+,:;<=>\?[]|\x7F", c))	/* Reject illegal chrs for SFN */
				return FR_INVALID_NAME;
			if (IsUpper(c)) {			/* ASCII large capital? */
    633e:	82 2f       	mov	r24, r18
    6340:	81 54       	subi	r24, 0x41	; 65
    6342:	8a 31       	cpi	r24, 0x1A	; 26
    6344:	08 f0       	brcs	.+2      	; 0x6348 <follow_path+0xdc>
    6346:	3f c0       	rjmp	.+126    	; 0x63c6 <follow_path+0x15a>
				b |= 2;
    6348:	f2 e0       	ldi	r31, 0x02	; 2
    634a:	ff 2a       	or	r15, r31
			} else {
				if (IsLower(c)) {		/* ASCII small capital? */
					b |= 1; c -= 0x20;
				}
			}
			sfn[i++] = c;
    634c:	f8 01       	movw	r30, r16
    634e:	e6 0f       	add	r30, r22
    6350:	f7 1f       	adc	r31, r23
    6352:	20 83       	st	Z, r18
    6354:	6f 5f       	subi	r22, 0xFF	; 255
    6356:	7f 4f       	sbci	r23, 0xFF	; 255
    6358:	c3 cf       	rjmp	.-122    	; 0x62e0 <follow_path+0x74>
	} else {							/* No heading separator */
		dj->sclust = dj->fs->cdir;	/* Start from the current dir */
	}
#else
	if (*path == '/' || *path == '\\')	/* Strip heading separator if exist */
		path++;
    635a:	08 94       	sec
    635c:	c1 1c       	adc	r12, r1
    635e:	d1 1c       	adc	r13, r1
    6360:	9e cf       	rjmp	.-196    	; 0x629e <follow_path+0x32>
#endif
	for (;;) {
		c = (BYTE)p[si++];
		if (c <= ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
		if (c == '.' || i >= ni) {
			if (ni != 8 || c != '.') return FR_INVALID_NAME;
    6362:	28 97       	sbiw	r28, 0x08	; 8
    6364:	09 f0       	breq	.+2      	; 0x6368 <follow_path+0xfc>
    6366:	d5 c0       	rjmp	.+426    	; 0x6512 <follow_path+0x2a6>
    6368:	2e 32       	cpi	r18, 0x2E	; 46
    636a:	09 f0       	breq	.+2      	; 0x636e <follow_path+0x102>
    636c:	d2 c0       	rjmp	.+420    	; 0x6512 <follow_path+0x2a6>
			i = 8; ni = 11;
			b <<= 2; continue;
    636e:	ff 0c       	add	r15, r15
    6370:	ff 0c       	add	r15, r15
    6372:	68 e0       	ldi	r22, 0x08	; 8
    6374:	70 e0       	ldi	r23, 0x00	; 0
    6376:	cb e0       	ldi	r28, 0x0B	; 11
    6378:	d0 e0       	ldi	r29, 0x00	; 0
    637a:	b2 cf       	rjmp	.-156    	; 0x62e0 <follow_path+0x74>
			return FR_INVALID_NAME;
#endif
#endif
		}
		if (IsDBCS1(c)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
			d = (BYTE)p[si++];			/* Get 2nd byte */
    637c:	f6 01       	movw	r30, r12
    637e:	e4 0f       	add	r30, r20
    6380:	f5 1f       	adc	r31, r21
    6382:	30 81       	ld	r19, Z
			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
    6384:	83 2f       	mov	r24, r19
    6386:	80 54       	subi	r24, 0x40	; 64
    6388:	8f 33       	cpi	r24, 0x3F	; 63
    638a:	20 f0       	brcs	.+8      	; 0x6394 <follow_path+0x128>
    638c:	80 54       	subi	r24, 0x40	; 64
    638e:	8d 37       	cpi	r24, 0x7D	; 125
    6390:	08 f0       	brcs	.+2      	; 0x6394 <follow_path+0x128>
    6392:	bf c0       	rjmp	.+382    	; 0x6512 <follow_path+0x2a6>
    6394:	ce 01       	movw	r24, r28
    6396:	01 97       	sbiw	r24, 0x01	; 1
    6398:	68 17       	cp	r22, r24
    639a:	79 07       	cpc	r23, r25
    639c:	08 f0       	brcs	.+2      	; 0x63a0 <follow_path+0x134>
    639e:	b9 c0       	rjmp	.+370    	; 0x6512 <follow_path+0x2a6>
			return FR_INVALID_NAME;
#endif
#endif
		}
		if (IsDBCS1(c)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
			d = (BYTE)p[si++];			/* Get 2nd byte */
    63a0:	4f 5f       	subi	r20, 0xFF	; 255
    63a2:	5f 4f       	sbci	r21, 0xFF	; 255
			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
				return FR_INVALID_NAME;
			sfn[i++] = c;
    63a4:	f8 01       	movw	r30, r16
    63a6:	e6 0f       	add	r30, r22
    63a8:	f7 1f       	adc	r31, r23
    63aa:	20 83       	st	Z, r18
    63ac:	cb 01       	movw	r24, r22
    63ae:	01 96       	adiw	r24, 0x01	; 1
			sfn[i++] = d;
    63b0:	f8 01       	movw	r30, r16
    63b2:	e8 0f       	add	r30, r24
    63b4:	f9 1f       	adc	r31, r25
    63b6:	30 83       	st	Z, r19
    63b8:	bc 01       	movw	r22, r24
    63ba:	6f 5f       	subi	r22, 0xFF	; 255
    63bc:	7f 4f       	sbci	r23, 0xFF	; 255
    63be:	90 cf       	rjmp	.-224    	; 0x62e0 <follow_path+0x74>
			if (ni != 8 || c != '.') return FR_INVALID_NAME;
			i = 8; ni = 11;
			b <<= 2; continue;
		}
		if (c >= 0x80) {				/* Extended char? */
			b |= 3;						/* Eliminate NT flag */
    63c0:	e3 e0       	ldi	r30, 0x03	; 3
    63c2:	fe 2a       	or	r15, r30
    63c4:	a3 cf       	rjmp	.-186    	; 0x630c <follow_path+0xa0>
			if (chk_chr("\"*+,:;<=>\?[]|\x7F", c))	/* Reject illegal chrs for SFN */
				return FR_INVALID_NAME;
			if (IsUpper(c)) {			/* ASCII large capital? */
				b |= 2;
			} else {
				if (IsLower(c)) {		/* ASCII small capital? */
    63c6:	82 2f       	mov	r24, r18
    63c8:	81 56       	subi	r24, 0x61	; 97
    63ca:	8a 31       	cpi	r24, 0x1A	; 26
    63cc:	08 f0       	brcs	.+2      	; 0x63d0 <follow_path+0x164>
    63ce:	be cf       	rjmp	.-132    	; 0x634c <follow_path+0xe0>
					b |= 1; c -= 0x20;
    63d0:	81 e0       	ldi	r24, 0x01	; 1
    63d2:	f8 2a       	or	r15, r24
    63d4:	20 52       	subi	r18, 0x20	; 32
    63d6:	ba cf       	rjmp	.-140    	; 0x634c <follow_path+0xe0>
				}
			}
			sfn[i++] = c;
		}
	}
	*path = &p[si];						/* Return pointer to the next segment */
    63d8:	c4 0e       	add	r12, r20
    63da:	d5 1e       	adc	r13, r21
    63dc:	40 e0       	ldi	r20, 0x00	; 0
	c = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */

	if (!i) return FR_INVALID_NAME;		/* Reject nul string */
    63de:	67 2b       	or	r22, r23
    63e0:	09 f4       	brne	.+2      	; 0x63e4 <follow_path+0x178>
    63e2:	97 c0       	rjmp	.+302    	; 0x6512 <follow_path+0x2a6>
	if (sfn[0] == 0xE5) sfn[0] = 0x05;	/* When first char collides with 0xE5, replace it with 0x05 */
    63e4:	d8 01       	movw	r26, r16
    63e6:	8c 91       	ld	r24, X
    63e8:	85 3e       	cpi	r24, 0xE5	; 229
    63ea:	09 f4       	brne	.+2      	; 0x63ee <follow_path+0x182>
    63ec:	96 c0       	rjmp	.+300    	; 0x651a <follow_path+0x2ae>

	if (ni == 8) b <<= 2;
    63ee:	28 97       	sbiw	r28, 0x08	; 8
    63f0:	09 f4       	brne	.+2      	; 0x63f4 <follow_path+0x188>
    63f2:	97 c0       	rjmp	.+302    	; 0x6522 <follow_path+0x2b6>
	if ((b & 0x03) == 0x01) c |= NS_EXT;	/* NT flag (Name extension has only small capital) */
    63f4:	2f 2d       	mov	r18, r15
    63f6:	30 e0       	ldi	r19, 0x00	; 0
    63f8:	c9 01       	movw	r24, r18
    63fa:	83 70       	andi	r24, 0x03	; 3
    63fc:	90 70       	andi	r25, 0x00	; 0
    63fe:	01 97       	sbiw	r24, 0x01	; 1
    6400:	09 f4       	brne	.+2      	; 0x6404 <follow_path+0x198>
    6402:	99 c0       	rjmp	.+306    	; 0x6536 <follow_path+0x2ca>
	if ((b & 0x0C) == 0x04) c |= NS_BODY;	/* NT flag (Name body has only small capital) */
    6404:	2c 70       	andi	r18, 0x0C	; 12
    6406:	30 70       	andi	r19, 0x00	; 0
    6408:	24 30       	cpi	r18, 0x04	; 4
    640a:	31 05       	cpc	r19, r1
    640c:	09 f4       	brne	.+2      	; 0x6410 <follow_path+0x1a4>
    640e:	83 c0       	rjmp	.+262    	; 0x6516 <follow_path+0x2aa>

	sfn[NS] = c;		/* Store NT flag, File name is created */
    6410:	f8 01       	movw	r30, r16
    6412:	43 87       	std	Z+11, r20	; 0x0b
	BYTE c, *dir;
#if _USE_LFN
	BYTE a, ord, sum;
#endif

	res = dir_sdi(dj, 0);			/* Rewind directory object */
    6414:	c5 01       	movw	r24, r10
    6416:	60 e0       	ldi	r22, 0x00	; 0
    6418:	70 e0       	ldi	r23, 0x00	; 0
    641a:	0e 94 30 29 	call	0x5260	; 0x5260 <dir_sdi>
    641e:	48 2f       	mov	r20, r24
	if (res != FR_OK) return res;
    6420:	88 23       	and	r24, r24
    6422:	11 f1       	breq	.+68     	; 0x6468 <follow_path+0x1fc>
	} else {							/* Follow path */
		for (;;) {
			res = create_name(dj, &path);	/* Get a segment */
			if (res != FR_OK) break;
			res = dir_find(dj);				/* Find it */
			ns = *(dj->fn+NS);
    6424:	d5 01       	movw	r26, r10
    6426:	54 96       	adiw	r26, 0x14	; 20
    6428:	ed 91       	ld	r30, X+
    642a:	fc 91       	ld	r31, X
    642c:	55 97       	sbiw	r26, 0x15	; 21
    642e:	83 85       	ldd	r24, Z+11	; 0x0b
			if (res != FR_OK) {				/* Failed to find the object */
				if (res != FR_NO_FILE) break;	/* Abort if any hard error occured */
    6430:	44 30       	cpi	r20, 0x04	; 4
    6432:	09 f4       	brne	.+2      	; 0x6436 <follow_path+0x1ca>
    6434:	8c c0       	rjmp	.+280    	; 0x654e <follow_path+0x2e2>
			dj->sclust = LD_CLUST(dir);
		}
	}

	return res;
}
    6436:	84 2f       	mov	r24, r20
    6438:	df 91       	pop	r29
    643a:	cf 91       	pop	r28
    643c:	1f 91       	pop	r17
    643e:	0f 91       	pop	r16
    6440:	ff 90       	pop	r15
    6442:	ef 90       	pop	r14
    6444:	df 90       	pop	r13
    6446:	cf 90       	pop	r12
    6448:	bf 90       	pop	r11
    644a:	af 90       	pop	r10
    644c:	9f 90       	pop	r9
    644e:	8f 90       	pop	r8
    6450:	7f 90       	pop	r7
    6452:	6f 90       	pop	r6
    6454:	5f 90       	pop	r5
    6456:	08 95       	ret
		}
#else		/* Non LFN configuration */
		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dj->fn, 11)) /* Is it a valid entry? */
			break;
#endif
		res = dir_next(dj, 0);		/* Next entry */
    6458:	c5 01       	movw	r24, r10
    645a:	60 e0       	ldi	r22, 0x00	; 0
    645c:	70 e0       	ldi	r23, 0x00	; 0
    645e:	0e 94 97 2e 	call	0x5d2e	; 0x5d2e <dir_next>
    6462:	48 2f       	mov	r20, r24
	} while (res == FR_OK);
    6464:	88 23       	and	r24, r24
    6466:	f1 f6       	brne	.-68     	; 0x6424 <follow_path+0x1b8>

#if _USE_LFN
	ord = sum = 0xFF;
#endif
	do {
		res = move_window(dj->fs, dj->sect);
    6468:	d5 01       	movw	r26, r10
    646a:	1e 96       	adiw	r26, 0x0e	; 14
    646c:	4d 91       	ld	r20, X+
    646e:	5d 91       	ld	r21, X+
    6470:	6d 91       	ld	r22, X+
    6472:	7c 91       	ld	r23, X
    6474:	51 97       	sbiw	r26, 0x11	; 17
    6476:	8d 91       	ld	r24, X+
    6478:	9c 91       	ld	r25, X
    647a:	0e 94 8b 26 	call	0x4d16	; 0x4d16 <move_window>
    647e:	48 2f       	mov	r20, r24
		if (res != FR_OK) break;
    6480:	88 23       	and	r24, r24
    6482:	81 f6       	brne	.-96     	; 0x6424 <follow_path+0x1b8>
		dir = dj->dir;					/* Ptr to the directory entry of current index */
    6484:	f5 01       	movw	r30, r10
    6486:	c2 89       	ldd	r28, Z+18	; 0x12
    6488:	d3 89       	ldd	r29, Z+19	; 0x13
		c = dir[DIR_Name];
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
    648a:	88 81       	ld	r24, Y
    648c:	88 23       	and	r24, r24
    648e:	09 f4       	brne	.+2      	; 0x6492 <follow_path+0x226>
    6490:	54 c0       	rjmp	.+168    	; 0x653a <follow_path+0x2ce>
				ord = 0xFF; dj->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
				if (!(dj->fn[NS] & NS_LOSS) && !mem_cmp(dir, dj->fn, 11)) break;	/* SFN matched? */
			}
		}
#else		/* Non LFN configuration */
		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dj->fn, 11)) /* Is it a valid entry? */
    6492:	8b 85       	ldd	r24, Y+11	; 0x0b
    6494:	58 2f       	mov	r21, r24
    6496:	83 fd       	sbrc	r24, 3
    6498:	df cf       	rjmp	.-66     	; 0x6458 <follow_path+0x1ec>
    649a:	04 89       	ldd	r16, Z+20	; 0x14
    649c:	15 89       	ldd	r17, Z+21	; 0x15
    649e:	20 e0       	ldi	r18, 0x00	; 0
    64a0:	30 e0       	ldi	r19, 0x00	; 0
static
int mem_cmp (const void* dst, const void* src, UINT cnt) {
	const BYTE *d = (const BYTE *)dst, *s = (const BYTE *)src;
	int r = 0;

	while (cnt-- && (r = *d++ - *s++) == 0) ;
    64a2:	fe 01       	movw	r30, r28
    64a4:	e2 0f       	add	r30, r18
    64a6:	f3 1f       	adc	r31, r19
    64a8:	d8 01       	movw	r26, r16
    64aa:	a2 0f       	add	r26, r18
    64ac:	b3 1f       	adc	r27, r19
    64ae:	90 81       	ld	r25, Z
    64b0:	8c 91       	ld	r24, X
    64b2:	98 17       	cp	r25, r24
    64b4:	89 f6       	brne	.-94     	; 0x6458 <follow_path+0x1ec>
				ord = 0xFF; dj->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
				if (!(dj->fn[NS] & NS_LOSS) && !mem_cmp(dir, dj->fn, 11)) break;	/* SFN matched? */
			}
		}
#else		/* Non LFN configuration */
		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dj->fn, 11)) /* Is it a valid entry? */
    64b6:	2f 5f       	subi	r18, 0xFF	; 255
    64b8:	3f 4f       	sbci	r19, 0xFF	; 255
static
int mem_cmp (const void* dst, const void* src, UINT cnt) {
	const BYTE *d = (const BYTE *)dst, *s = (const BYTE *)src;
	int r = 0;

	while (cnt-- && (r = *d++ - *s++) == 0) ;
    64ba:	2b 30       	cpi	r18, 0x0B	; 11
    64bc:	31 05       	cpc	r19, r1
    64be:	89 f7       	brne	.-30     	; 0x64a2 <follow_path+0x236>
				} else {							/* Could not find the object */
					if (!(ns & NS_LAST)) res = FR_NO_PATH;
				}
				break;
			}
			if (ns & NS_LAST) break;			/* Last segment match. Function completed. */
    64c0:	f8 01       	movw	r30, r16
    64c2:	83 85       	ldd	r24, Z+11	; 0x0b
    64c4:	82 fd       	sbrc	r24, 2
    64c6:	b7 cf       	rjmp	.-146    	; 0x6436 <follow_path+0x1ca>
			dir = dj->dir;						/* There is next segment. Follow the sub directory */
			if (!(dir[DIR_Attr] & AM_DIR)) {	/* Cannot follow because it is a file */
    64c8:	54 ff       	sbrs	r21, 4
    64ca:	43 c0       	rjmp	.+134    	; 0x6552 <follow_path+0x2e6>
				res = FR_NO_PATH; break;
			}
			dj->sclust = LD_CLUST(dir);
    64cc:	7d 88       	ldd	r7, Y+21	; 0x15
    64ce:	66 24       	eor	r6, r6
    64d0:	2c 89       	ldd	r18, Y+20	; 0x14
    64d2:	30 e0       	ldi	r19, 0x00	; 0
    64d4:	26 29       	or	r18, r6
    64d6:	37 29       	or	r19, r7
    64d8:	40 e0       	ldi	r20, 0x00	; 0
    64da:	50 e0       	ldi	r21, 0x00	; 0
    64dc:	a9 01       	movw	r20, r18
    64de:	33 27       	eor	r19, r19
    64e0:	22 27       	eor	r18, r18
    64e2:	9b 8c       	ldd	r9, Y+27	; 0x1b
    64e4:	88 24       	eor	r8, r8
    64e6:	8a 8d       	ldd	r24, Y+26	; 0x1a
    64e8:	90 e0       	ldi	r25, 0x00	; 0
    64ea:	88 29       	or	r24, r8
    64ec:	99 29       	or	r25, r9
    64ee:	a0 e0       	ldi	r26, 0x00	; 0
    64f0:	b0 e0       	ldi	r27, 0x00	; 0
    64f2:	28 2b       	or	r18, r24
    64f4:	39 2b       	or	r19, r25
    64f6:	4a 2b       	or	r20, r26
    64f8:	5b 2b       	or	r21, r27
    64fa:	f5 01       	movw	r30, r10
    64fc:	26 83       	std	Z+6, r18	; 0x06
    64fe:	37 83       	std	Z+7, r19	; 0x07
    6500:	40 87       	std	Z+8, r20	; 0x08
    6502:	51 87       	std	Z+9, r21	; 0x09
    6504:	dd ce       	rjmp	.-582    	; 0x62c0 <follow_path+0x54>
				}
			}
			sfn[i++] = c;
		}
	}
	*path = &p[si];						/* Return pointer to the next segment */
    6506:	c4 0e       	add	r12, r20
    6508:	d5 1e       	adc	r13, r21
    650a:	44 e0       	ldi	r20, 0x04	; 4
	c = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */

	if (!i) return FR_INVALID_NAME;		/* Reject nul string */
    650c:	67 2b       	or	r22, r23
    650e:	09 f0       	breq	.+2      	; 0x6512 <follow_path+0x2a6>
    6510:	69 cf       	rjmp	.-302    	; 0x63e4 <follow_path+0x178>
			dir = dj->dir;						/* There is next segment. Follow the sub directory */
			if (!(dir[DIR_Attr] & AM_DIR)) {	/* Cannot follow because it is a file */
				res = FR_NO_PATH; break;
			}
			dj->sclust = LD_CLUST(dir);
		}
    6512:	46 e0       	ldi	r20, 0x06	; 6
    6514:	90 cf       	rjmp	.-224    	; 0x6436 <follow_path+0x1ca>
	if (!i) return FR_INVALID_NAME;		/* Reject nul string */
	if (sfn[0] == 0xE5) sfn[0] = 0x05;	/* When first char collides with 0xE5, replace it with 0x05 */

	if (ni == 8) b <<= 2;
	if ((b & 0x03) == 0x01) c |= NS_EXT;	/* NT flag (Name extension has only small capital) */
	if ((b & 0x0C) == 0x04) c |= NS_BODY;	/* NT flag (Name body has only small capital) */
    6516:	48 60       	ori	r20, 0x08	; 8
    6518:	7b cf       	rjmp	.-266    	; 0x6410 <follow_path+0x1a4>
	}
	*path = &p[si];						/* Return pointer to the next segment */
	c = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */

	if (!i) return FR_INVALID_NAME;		/* Reject nul string */
	if (sfn[0] == 0xE5) sfn[0] = 0x05;	/* When first char collides with 0xE5, replace it with 0x05 */
    651a:	5c 92       	st	X, r5

	if (ni == 8) b <<= 2;
    651c:	28 97       	sbiw	r28, 0x08	; 8
    651e:	09 f0       	breq	.+2      	; 0x6522 <follow_path+0x2b6>
    6520:	69 cf       	rjmp	.-302    	; 0x63f4 <follow_path+0x188>
    6522:	ff 0c       	add	r15, r15
    6524:	ff 0c       	add	r15, r15
	if ((b & 0x03) == 0x01) c |= NS_EXT;	/* NT flag (Name extension has only small capital) */
    6526:	2f 2d       	mov	r18, r15
    6528:	30 e0       	ldi	r19, 0x00	; 0
    652a:	c9 01       	movw	r24, r18
    652c:	83 70       	andi	r24, 0x03	; 3
    652e:	90 70       	andi	r25, 0x00	; 0
    6530:	01 97       	sbiw	r24, 0x01	; 1
    6532:	09 f0       	breq	.+2      	; 0x6536 <follow_path+0x2ca>
    6534:	67 cf       	rjmp	.-306    	; 0x6404 <follow_path+0x198>
    6536:	40 61       	ori	r20, 0x10	; 16
    6538:	65 cf       	rjmp	.-310    	; 0x6404 <follow_path+0x198>
				}
			}
			sfn[i++] = c;
		}
	}
	*path = &p[si];						/* Return pointer to the next segment */
    653a:	44 e0       	ldi	r20, 0x04	; 4
	} else {							/* Follow path */
		for (;;) {
			res = create_name(dj, &path);	/* Get a segment */
			if (res != FR_OK) break;
			res = dir_find(dj);				/* Find it */
			ns = *(dj->fn+NS);
    653c:	d5 01       	movw	r26, r10
    653e:	54 96       	adiw	r26, 0x14	; 20
    6540:	ed 91       	ld	r30, X+
    6542:	fc 91       	ld	r31, X
    6544:	55 97       	sbiw	r26, 0x15	; 21
    6546:	83 85       	ldd	r24, Z+11	; 0x0b
			if (res != FR_OK) {				/* Failed to find the object */
				if (res != FR_NO_FILE) break;	/* Abort if any hard error occured */
    6548:	44 30       	cpi	r20, 0x04	; 4
    654a:	09 f0       	breq	.+2      	; 0x654e <follow_path+0x2e2>
    654c:	74 cf       	rjmp	.-280    	; 0x6436 <follow_path+0x1ca>
				if (_FS_RPATH && (ns & NS_DOT)) {	/* If dot entry is not exit */
					dj->sclust = 0; dj->dir = 0;	/* It is the root dir */
					res = FR_OK;
					if (!(ns & NS_LAST)) continue;
				} else {							/* Could not find the object */
					if (!(ns & NS_LAST)) res = FR_NO_PATH;
    654e:	82 fd       	sbrc	r24, 2
    6550:	72 cf       	rjmp	.-284    	; 0x6436 <follow_path+0x1ca>
			dir = dj->dir;						/* There is next segment. Follow the sub directory */
			if (!(dir[DIR_Attr] & AM_DIR)) {	/* Cannot follow because it is a file */
				res = FR_NO_PATH; break;
			}
			dj->sclust = LD_CLUST(dir);
		}
    6552:	45 e0       	ldi	r20, 0x05	; 5
    6554:	70 cf       	rjmp	.-288    	; 0x6436 <follow_path+0x1ca>
		path++;
	dj->sclust = 0;						/* Start from the root dir */
#endif

	if ((UINT)*path < ' ') {			/* Nul path means the start directory itself */
		res = dir_sdi(dj, 0);
    6556:	c5 01       	movw	r24, r10
    6558:	60 e0       	ldi	r22, 0x00	; 0
    655a:	70 e0       	ldi	r23, 0x00	; 0
    655c:	0e 94 30 29 	call	0x5260	; 0x5260 <dir_sdi>
    6560:	48 2f       	mov	r20, r24
		dj->dir = 0;
    6562:	d5 01       	movw	r26, r10
    6564:	53 96       	adiw	r26, 0x13	; 19
    6566:	1c 92       	st	X, r1
    6568:	1e 92       	st	-X, r1
    656a:	52 97       	sbiw	r26, 0x12	; 18
    656c:	64 cf       	rjmp	.-312    	; 0x6436 <follow_path+0x1ca>

0000656e <f_write>:
	FIL *fp,			/* Pointer to the file object */
	const void *buff,	/* Pointer to the data to be written */
	UINT btw,			/* Number of bytes to write */
	UINT *bw			/* Pointer to number of bytes written */
)
{
    656e:	2f 92       	push	r2
    6570:	3f 92       	push	r3
    6572:	4f 92       	push	r4
    6574:	5f 92       	push	r5
    6576:	6f 92       	push	r6
    6578:	7f 92       	push	r7
    657a:	8f 92       	push	r8
    657c:	9f 92       	push	r9
    657e:	af 92       	push	r10
    6580:	bf 92       	push	r11
    6582:	cf 92       	push	r12
    6584:	df 92       	push	r13
    6586:	ef 92       	push	r14
    6588:	ff 92       	push	r15
    658a:	0f 93       	push	r16
    658c:	1f 93       	push	r17
    658e:	df 93       	push	r29
    6590:	cf 93       	push	r28
    6592:	00 d0       	rcall	.+0      	; 0x6594 <f_write+0x26>
    6594:	00 d0       	rcall	.+0      	; 0x6596 <f_write+0x28>
    6596:	cd b7       	in	r28, 0x3d	; 61
    6598:	de b7       	in	r29, 0x3e	; 62
    659a:	6c 01       	movw	r12, r24
    659c:	16 2f       	mov	r17, r22
    659e:	07 2f       	mov	r16, r23
    65a0:	2a 01       	movw	r4, r20
    65a2:	3a 83       	std	Y+2, r19	; 0x02
    65a4:	29 83       	std	Y+1, r18	; 0x01
	UINT wcnt, cc;
	const BYTE *wbuff = buff;
	BYTE csect;


	*bw = 0;	/* Initialize byte counter */
    65a6:	d9 01       	movw	r26, r18
    65a8:	1d 92       	st	X+, r1
    65aa:	1c 92       	st	X, r1

	res = validate(fp->fs, fp->id);					/* Check validity of the object */
    65ac:	fc 01       	movw	r30, r24
    65ae:	62 81       	ldd	r22, Z+2	; 0x02
    65b0:	73 81       	ldd	r23, Z+3	; 0x03
    65b2:	80 81       	ld	r24, Z
    65b4:	91 81       	ldd	r25, Z+1	; 0x01
    65b6:	0e 94 75 26 	call	0x4cea	; 0x4cea <validate>
    65ba:	68 2e       	mov	r6, r24
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
    65bc:	88 23       	and	r24, r24
    65be:	09 f0       	breq	.+2      	; 0x65c2 <f_write+0x54>
    65c0:	03 c1       	rjmp	.+518    	; 0x67c8 <f_write+0x25a>
	if (fp->flag & FA__ERROR)						/* Check abort flag */
    65c2:	d6 01       	movw	r26, r12
    65c4:	14 96       	adiw	r26, 0x04	; 4
    65c6:	6c 91       	ld	r22, X
    65c8:	67 fd       	sbrc	r22, 7
    65ca:	14 c2       	rjmp	.+1064   	; 0x69f4 <f_write+0x486>
		LEAVE_FF(fp->fs, FR_INT_ERR);
	if (!(fp->flag & FA_WRITE))						/* Check access mode */
    65cc:	61 ff       	sbrs	r22, 1
    65ce:	14 c1       	rjmp	.+552    	; 0x67f8 <f_write+0x28a>
		LEAVE_FF(fp->fs, FR_DENIED);
	if (fp->fsize + btw < fp->fsize) btw = 0;		/* File size cannot reach 4GB */
    65d0:	f6 01       	movw	r30, r12
    65d2:	22 85       	ldd	r18, Z+10	; 0x0a
    65d4:	33 85       	ldd	r19, Z+11	; 0x0b
    65d6:	44 85       	ldd	r20, Z+12	; 0x0c
    65d8:	55 85       	ldd	r21, Z+13	; 0x0d
    65da:	c2 01       	movw	r24, r4
    65dc:	a0 e0       	ldi	r26, 0x00	; 0
    65de:	b0 e0       	ldi	r27, 0x00	; 0
    65e0:	82 0f       	add	r24, r18
    65e2:	93 1f       	adc	r25, r19
    65e4:	a4 1f       	adc	r26, r20
    65e6:	b5 1f       	adc	r27, r21
    65e8:	82 17       	cp	r24, r18
    65ea:	93 07       	cpc	r25, r19
    65ec:	a4 07       	cpc	r26, r20
    65ee:	b5 07       	cpc	r27, r21
    65f0:	08 f4       	brcc	.+2      	; 0x65f4 <f_write+0x86>
    65f2:	05 c1       	rjmp	.+522    	; 0x67fe <f_write+0x290>

	for ( ;  btw;									/* Repeat until all data transferred */
    65f4:	41 14       	cp	r4, r1
    65f6:	51 04       	cpc	r5, r1
    65f8:	09 f4       	brne	.+2      	; 0x65fc <f_write+0x8e>
    65fa:	1a c2       	rjmp	.+1076   	; 0x6a30 <f_write+0x4c2>
)
{
	FRESULT res;
	DWORD clst, sect;
	UINT wcnt, cc;
	const BYTE *wbuff = buff;
    65fc:	81 2f       	mov	r24, r17
    65fe:	90 2f       	mov	r25, r16
    6600:	9c 01       	movw	r18, r24
    6602:	19 01       	movw	r2, r18
    6604:	d6 01       	movw	r26, r12
    6606:	16 96       	adiw	r26, 0x06	; 6
    6608:	ed 90       	ld	r14, X+
    660a:	fd 90       	ld	r15, X+
    660c:	0d 91       	ld	r16, X+
    660e:	1c 91       	ld	r17, X
    6610:	19 97       	sbiw	r26, 0x09	; 9
		LEAVE_FF(fp->fs, FR_DENIED);
	if (fp->fsize + btw < fp->fsize) btw = 0;		/* File size cannot reach 4GB */

	for ( ;  btw;									/* Repeat until all data transferred */
		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
		if ((fp->fptr % SS(fp->fs)) == 0) {			/* On the sector boundary? */
    6612:	d8 01       	movw	r26, r16
    6614:	c7 01       	movw	r24, r14
    6616:	91 70       	andi	r25, 0x01	; 1
    6618:	a0 70       	andi	r26, 0x00	; 0
    661a:	b0 70       	andi	r27, 0x00	; 0
    661c:	00 97       	sbiw	r24, 0x00	; 0
    661e:	a1 05       	cpc	r26, r1
    6620:	b1 05       	cpc	r27, r1
    6622:	09 f4       	brne	.+2      	; 0x6626 <f_write+0xb8>
    6624:	5a c0       	rjmp	.+180    	; 0x66da <f_write+0x16c>
    6626:	f6 01       	movw	r30, r12
    6628:	01 90       	ld	r0, Z+
    662a:	f0 81       	ld	r31, Z
    662c:	e0 2d       	mov	r30, r0
    662e:	fc 83       	std	Y+4, r31	; 0x04
    6630:	eb 83       	std	Y+3, r30	; 0x03
			fp->dsect = sect;
		}
		wcnt = SS(fp->fs) - (fp->fptr % SS(fp->fs));/* Put partial sector into file I/O buffer */
		if (wcnt > btw) wcnt = btw;
#if _FS_TINY
		if (move_window(fp->fs, fp->dsect))			/* Move sector window */
    6632:	f6 01       	movw	r30, r12
    6634:	46 89       	ldd	r20, Z+22	; 0x16
    6636:	57 89       	ldd	r21, Z+23	; 0x17
    6638:	60 8d       	ldd	r22, Z+24	; 0x18
    663a:	71 8d       	ldd	r23, Z+25	; 0x19
    663c:	8b 81       	ldd	r24, Y+3	; 0x03
    663e:	9c 81       	ldd	r25, Y+4	; 0x04
    6640:	0e 94 8b 26 	call	0x4d16	; 0x4d16 <move_window>
    6644:	88 23       	and	r24, r24
    6646:	09 f0       	breq	.+2      	; 0x664a <f_write+0xdc>
    6648:	d8 c1       	rjmp	.+944    	; 0x69fa <f_write+0x48c>
						ABORT(fp->fs, FR_DISK_ERR);
			}
#endif
			fp->dsect = sect;
		}
		wcnt = SS(fp->fs) - (fp->fptr % SS(fp->fs));/* Put partial sector into file I/O buffer */
    664a:	c7 01       	movw	r24, r14
    664c:	91 70       	andi	r25, 0x01	; 1
    664e:	40 e0       	ldi	r20, 0x00	; 0
    6650:	52 e0       	ldi	r21, 0x02	; 2
    6652:	48 1b       	sub	r20, r24
    6654:	59 0b       	sbc	r21, r25
    6656:	44 16       	cp	r4, r20
    6658:	55 06       	cpc	r5, r21
    665a:	08 f4       	brcc	.+2      	; 0x665e <f_write+0xf0>
    665c:	a2 01       	movw	r20, r4
		if (wcnt > btw) wcnt = btw;
#if _FS_TINY
		if (move_window(fp->fs, fp->dsect))			/* Move sector window */
			ABORT(fp->fs, FR_DISK_ERR);
		mem_cpy(&fp->fs->win[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
    665e:	f6 01       	movw	r30, r12
    6660:	20 81       	ld	r18, Z
    6662:	31 81       	ldd	r19, Z+1	; 0x01
    6664:	86 81       	ldd	r24, Z+6	; 0x06
    6666:	97 81       	ldd	r25, Z+7	; 0x07
    6668:	a0 85       	ldd	r26, Z+8	; 0x08
    666a:	b1 85       	ldd	r27, Z+9	; 0x09
		*(int*)d = *(int*)s;
		d += sizeof(int); s += sizeof(int);
		cnt -= sizeof(int);
	}
#endif
	while (cnt--)
    666c:	41 15       	cp	r20, r1
    666e:	51 05       	cpc	r21, r1
    6670:	79 f0       	breq	.+30     	; 0x6690 <f_write+0x122>
/*-----------------------------------------------------------------------*/

/* Copy memory to memory */
static
void mem_cpy (void* dst, const void* src, UINT cnt) {
	BYTE *d = (BYTE*)dst;
    6672:	fc 01       	movw	r30, r24
    6674:	f1 70       	andi	r31, 0x01	; 1
    6676:	be 96       	adiw	r30, 0x2e	; 46
    6678:	e2 0f       	add	r30, r18
    667a:	f3 1f       	adc	r31, r19
    667c:	d1 01       	movw	r26, r2
    667e:	9a 01       	movw	r18, r20
		d += sizeof(int); s += sizeof(int);
		cnt -= sizeof(int);
	}
#endif
	while (cnt--)
		*d++ = *s++;
    6680:	8d 91       	ld	r24, X+
    6682:	81 93       	st	Z+, r24
    6684:	21 50       	subi	r18, 0x01	; 1
    6686:	30 40       	sbci	r19, 0x00	; 0
		*(int*)d = *(int*)s;
		d += sizeof(int); s += sizeof(int);
		cnt -= sizeof(int);
	}
#endif
	while (cnt--)
    6688:	d9 f7       	brne	.-10     	; 0x6680 <f_write+0x112>
    668a:	d6 01       	movw	r26, r12
    668c:	2d 91       	ld	r18, X+
    668e:	3c 91       	ld	r19, X
		if (wcnt > btw) wcnt = btw;
#if _FS_TINY
		if (move_window(fp->fs, fp->dsect))			/* Move sector window */
			ABORT(fp->fs, FR_DISK_ERR);
		mem_cpy(&fp->fs->win[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
		fp->fs->wflag = 1;
    6690:	81 e0       	ldi	r24, 0x01	; 1
    6692:	f9 01       	movw	r30, r18
    6694:	84 83       	std	Z+4, r24	; 0x04
	if (!(fp->flag & FA_WRITE))						/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
	if (fp->fsize + btw < fp->fsize) btw = 0;		/* File size cannot reach 4GB */

	for ( ;  btw;									/* Repeat until all data transferred */
		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
    6696:	ca 01       	movw	r24, r20
    6698:	a0 e0       	ldi	r26, 0x00	; 0
    669a:	b0 e0       	ldi	r27, 0x00	; 0
    669c:	f6 01       	movw	r30, r12
    669e:	e6 80       	ldd	r14, Z+6	; 0x06
    66a0:	f7 80       	ldd	r15, Z+7	; 0x07
    66a2:	00 85       	ldd	r16, Z+8	; 0x08
    66a4:	11 85       	ldd	r17, Z+9	; 0x09
    66a6:	e8 0e       	add	r14, r24
    66a8:	f9 1e       	adc	r15, r25
    66aa:	0a 1f       	adc	r16, r26
    66ac:	1b 1f       	adc	r17, r27
    66ae:	d6 01       	movw	r26, r12
    66b0:	16 96       	adiw	r26, 0x06	; 6
    66b2:	ed 92       	st	X+, r14
    66b4:	fd 92       	st	X+, r15
    66b6:	0d 93       	st	X+, r16
    66b8:	1c 93       	st	X, r17
    66ba:	19 97       	sbiw	r26, 0x09	; 9
    66bc:	e9 81       	ldd	r30, Y+1	; 0x01
    66be:	fa 81       	ldd	r31, Y+2	; 0x02
    66c0:	80 81       	ld	r24, Z
    66c2:	91 81       	ldd	r25, Z+1	; 0x01
    66c4:	84 0f       	add	r24, r20
    66c6:	95 1f       	adc	r25, r21
    66c8:	91 83       	std	Z+1, r25	; 0x01
    66ca:	80 83       	st	Z, r24
    66cc:	44 1a       	sub	r4, r20
    66ce:	55 0a       	sbc	r5, r21
		LEAVE_FF(fp->fs, FR_INT_ERR);
	if (!(fp->flag & FA_WRITE))						/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
	if (fp->fsize + btw < fp->fsize) btw = 0;		/* File size cannot reach 4GB */

	for ( ;  btw;									/* Repeat until all data transferred */
    66d0:	09 f4       	brne	.+2      	; 0x66d4 <f_write+0x166>
    66d2:	9d c1       	rjmp	.+826    	; 0x6a0e <f_write+0x4a0>
		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
    66d4:	24 0e       	add	r2, r20
    66d6:	35 1e       	adc	r3, r21
    66d8:	9c cf       	rjmp	.-200    	; 0x6612 <f_write+0xa4>
		if ((fp->fptr % SS(fp->fs)) == 0) {			/* On the sector boundary? */
			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
    66da:	d6 01       	movw	r26, r12
    66dc:	0d 90       	ld	r0, X+
    66de:	bc 91       	ld	r27, X
    66e0:	a0 2d       	mov	r26, r0
    66e2:	bc 83       	std	Y+4, r27	; 0x04
    66e4:	ab 83       	std	Y+3, r26	; 0x03
    66e6:	d8 01       	movw	r26, r16
    66e8:	c7 01       	movw	r24, r14
    66ea:	29 e0       	ldi	r18, 0x09	; 9
    66ec:	b6 95       	lsr	r27
    66ee:	a7 95       	ror	r26
    66f0:	97 95       	ror	r25
    66f2:	87 95       	ror	r24
    66f4:	2a 95       	dec	r18
    66f6:	d1 f7       	brne	.-12     	; 0x66ec <f_write+0x17e>
    66f8:	eb 81       	ldd	r30, Y+3	; 0x03
    66fa:	fc 81       	ldd	r31, Y+4	; 0x04
    66fc:	72 80       	ldd	r7, Z+2	; 0x02
    66fe:	7a 94       	dec	r7
    6700:	78 22       	and	r7, r24
			if (!csect) {							/* On the cluster boundary? */
    6702:	69 f5       	brne	.+90     	; 0x675e <f_write+0x1f0>
				if (fp->fptr == 0) {				/* On the top of the file? */
    6704:	e1 14       	cp	r14, r1
    6706:	f1 04       	cpc	r15, r1
    6708:	01 05       	cpc	r16, r1
    670a:	11 05       	cpc	r17, r1
    670c:	09 f0       	breq	.+2      	; 0x6710 <f_write+0x1a2>
    670e:	28 c1       	rjmp	.+592    	; 0x6960 <f_write+0x3f2>
					clst = fp->org_clust;			/* Follow from the origin */
    6710:	d6 01       	movw	r26, r12
    6712:	1e 96       	adiw	r26, 0x0e	; 14
    6714:	6d 91       	ld	r22, X+
    6716:	7d 91       	ld	r23, X+
    6718:	8d 91       	ld	r24, X+
    671a:	9c 91       	ld	r25, X
    671c:	51 97       	sbiw	r26, 0x11	; 17
					if (clst == 0)					/* When there is no cluster chain, */
    671e:	61 15       	cp	r22, r1
    6720:	71 05       	cpc	r23, r1
    6722:	81 05       	cpc	r24, r1
    6724:	91 05       	cpc	r25, r1
    6726:	09 f4       	brne	.+2      	; 0x672a <f_write+0x1bc>
    6728:	51 c1       	rjmp	.+674    	; 0x69cc <f_write+0x45e>
						fp->org_clust = clst = create_chain(fp->fs, 0);	/* Create a new cluster chain */
				} else {							/* Middle or end of the file */
					clst = create_chain(fp->fs, fp->curr_clust);			/* Follow or stretch cluster chain */
				}
				if (clst == 0) break;				/* Could not allocate a new cluster (disk full) */
				if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
    672a:	61 30       	cpi	r22, 0x01	; 1
    672c:	71 05       	cpc	r23, r1
    672e:	81 05       	cpc	r24, r1
    6730:	91 05       	cpc	r25, r1
    6732:	09 f4       	brne	.+2      	; 0x6736 <f_write+0x1c8>
    6734:	58 c1       	rjmp	.+688    	; 0x69e6 <f_write+0x478>
				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
    6736:	6f 3f       	cpi	r22, 0xFF	; 255
    6738:	bf ef       	ldi	r27, 0xFF	; 255
    673a:	7b 07       	cpc	r23, r27
    673c:	bf ef       	ldi	r27, 0xFF	; 255
    673e:	8b 07       	cpc	r24, r27
    6740:	bf ef       	ldi	r27, 0xFF	; 255
    6742:	9b 07       	cpc	r25, r27
    6744:	09 f4       	brne	.+2      	; 0x6748 <f_write+0x1da>
    6746:	6d c1       	rjmp	.+730    	; 0x6a22 <f_write+0x4b4>
				fp->curr_clust = clst;				/* Update current cluster */
    6748:	d6 01       	movw	r26, r12
    674a:	52 96       	adiw	r26, 0x12	; 18
    674c:	6d 93       	st	X+, r22
    674e:	7d 93       	st	X+, r23
    6750:	8d 93       	st	X+, r24
    6752:	9c 93       	st	X, r25
    6754:	55 97       	sbiw	r26, 0x15	; 21
    6756:	ed 91       	ld	r30, X+
    6758:	fc 91       	ld	r31, X
    675a:	fc 83       	std	Y+4, r31	; 0x04
    675c:	eb 83       	std	Y+3, r30	; 0x03
			}
#if _FS_TINY
			if (fp->fs->winsect == fp->dsect && move_window(fp->fs, 0))	/* Write back data buffer prior to following direct transfer */
    675e:	ab 81       	ldd	r26, Y+3	; 0x03
    6760:	bc 81       	ldd	r27, Y+4	; 0x04
    6762:	9a 96       	adiw	r26, 0x2a	; 42
    6764:	2d 91       	ld	r18, X+
    6766:	3d 91       	ld	r19, X+
    6768:	4d 91       	ld	r20, X+
    676a:	5c 91       	ld	r21, X
    676c:	9d 97       	sbiw	r26, 0x2d	; 45
    676e:	f6 01       	movw	r30, r12
    6770:	86 89       	ldd	r24, Z+22	; 0x16
    6772:	97 89       	ldd	r25, Z+23	; 0x17
    6774:	a0 8d       	ldd	r26, Z+24	; 0x18
    6776:	b1 8d       	ldd	r27, Z+25	; 0x19
    6778:	28 17       	cp	r18, r24
    677a:	39 07       	cpc	r19, r25
    677c:	4a 07       	cpc	r20, r26
    677e:	5b 07       	cpc	r21, r27
    6780:	09 f4       	brne	.+2      	; 0x6784 <f_write+0x216>
    6782:	dc c0       	rjmp	.+440    	; 0x693c <f_write+0x3ce>
DWORD clust2sect (	/* !=0: Sector number, 0: Failed - invalid cluster# */
	FATFS *fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
    6784:	d6 01       	movw	r26, r12
    6786:	52 96       	adiw	r26, 0x12	; 18
    6788:	2d 91       	ld	r18, X+
    678a:	3d 91       	ld	r19, X+
    678c:	4d 91       	ld	r20, X+
    678e:	5c 91       	ld	r21, X
    6790:	55 97       	sbiw	r26, 0x15	; 21
    6792:	22 50       	subi	r18, 0x02	; 2
    6794:	30 40       	sbci	r19, 0x00	; 0
    6796:	40 40       	sbci	r20, 0x00	; 0
    6798:	50 40       	sbci	r21, 0x00	; 0
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
    679a:	eb 81       	ldd	r30, Y+3	; 0x03
    679c:	fc 81       	ldd	r31, Y+4	; 0x04
    679e:	86 89       	ldd	r24, Z+22	; 0x16
    67a0:	97 89       	ldd	r25, Z+23	; 0x17
    67a2:	a0 8d       	ldd	r26, Z+24	; 0x18
    67a4:	b1 8d       	ldd	r27, Z+25	; 0x19
    67a6:	02 97       	sbiw	r24, 0x02	; 2
    67a8:	a1 09       	sbc	r26, r1
    67aa:	b1 09       	sbc	r27, r1
    67ac:	28 17       	cp	r18, r24
    67ae:	39 07       	cpc	r19, r25
    67b0:	4a 07       	cpc	r20, r26
    67b2:	5b 07       	cpc	r21, r27
    67b4:	d0 f1       	brcs	.+116    	; 0x682a <f_write+0x2bc>
					ABORT(fp->fs, FR_DISK_ERR);
				fp->flag &= ~FA__DIRTY;
			}
#endif
			sect = clust2sect(fp->fs, fp->curr_clust);	/* Get current sector */
			if (!sect) ABORT(fp->fs, FR_INT_ERR);
    67b6:	d6 01       	movw	r26, r12
    67b8:	14 96       	adiw	r26, 0x04	; 4
    67ba:	8c 91       	ld	r24, X
    67bc:	14 97       	sbiw	r26, 0x04	; 4
    67be:	80 68       	ori	r24, 0x80	; 128
    67c0:	14 96       	adiw	r26, 0x04	; 4
    67c2:	8c 93       	st	X, r24
    67c4:	f2 e0       	ldi	r31, 0x02	; 2
    67c6:	6f 2e       	mov	r6, r31

	if (fp->fptr > fp->fsize) fp->fsize = fp->fptr;	/* Update file size if needed */
	fp->flag |= FA__WRITTEN;						/* Set file change flag */

	LEAVE_FF(fp->fs, FR_OK);
}
    67c8:	86 2d       	mov	r24, r6
    67ca:	0f 90       	pop	r0
    67cc:	0f 90       	pop	r0
    67ce:	0f 90       	pop	r0
    67d0:	0f 90       	pop	r0
    67d2:	cf 91       	pop	r28
    67d4:	df 91       	pop	r29
    67d6:	1f 91       	pop	r17
    67d8:	0f 91       	pop	r16
    67da:	ff 90       	pop	r15
    67dc:	ef 90       	pop	r14
    67de:	df 90       	pop	r13
    67e0:	cf 90       	pop	r12
    67e2:	bf 90       	pop	r11
    67e4:	af 90       	pop	r10
    67e6:	9f 90       	pop	r9
    67e8:	8f 90       	pop	r8
    67ea:	7f 90       	pop	r7
    67ec:	6f 90       	pop	r6
    67ee:	5f 90       	pop	r5
    67f0:	4f 90       	pop	r4
    67f2:	3f 90       	pop	r3
    67f4:	2f 90       	pop	r2
    67f6:	08 95       	ret

	res = validate(fp->fs, fp->id);					/* Check validity of the object */
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
	if (fp->flag & FA__ERROR)						/* Check abort flag */
		LEAVE_FF(fp->fs, FR_INT_ERR);
	if (!(fp->flag & FA_WRITE))						/* Check access mode */
    67f8:	37 e0       	ldi	r19, 0x07	; 7
    67fa:	63 2e       	mov	r6, r19
    67fc:	e5 cf       	rjmp	.-54     	; 0x67c8 <f_write+0x25a>
    67fe:	d6 01       	movw	r26, r12
    6800:	16 96       	adiw	r26, 0x06	; 6
    6802:	ed 90       	ld	r14, X+
    6804:	fd 90       	ld	r15, X+
    6806:	0d 91       	ld	r16, X+
    6808:	1c 91       	ld	r17, X
    680a:	19 97       	sbiw	r26, 0x09	; 9
		mem_cpy(&fp->buf[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
		fp->flag |= FA__DIRTY;
#endif
	}

	if (fp->fptr > fp->fsize) fp->fsize = fp->fptr;	/* Update file size if needed */
    680c:	2e 15       	cp	r18, r14
    680e:	3f 05       	cpc	r19, r15
    6810:	40 07       	cpc	r20, r16
    6812:	51 07       	cpc	r21, r17
    6814:	28 f4       	brcc	.+10     	; 0x6820 <f_write+0x2b2>
    6816:	f6 01       	movw	r30, r12
    6818:	e2 86       	std	Z+10, r14	; 0x0a
    681a:	f3 86       	std	Z+11, r15	; 0x0b
    681c:	04 87       	std	Z+12, r16	; 0x0c
    681e:	15 87       	std	Z+13, r17	; 0x0d
	fp->flag |= FA__WRITTEN;						/* Set file change flag */
    6820:	60 62       	ori	r22, 0x20	; 32
    6822:	d6 01       	movw	r26, r12
    6824:	14 96       	adiw	r26, 0x04	; 4
    6826:	6c 93       	st	X, r22
    6828:	cf cf       	rjmp	.-98     	; 0x67c8 <f_write+0x25a>
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
	return clst * fs->csize + fs->database;
    682a:	12 81       	ldd	r17, Z+2	; 0x02
    682c:	61 2f       	mov	r22, r17
    682e:	70 e0       	ldi	r23, 0x00	; 0
    6830:	80 e0       	ldi	r24, 0x00	; 0
    6832:	90 e0       	ldi	r25, 0x00	; 0
    6834:	0e 94 bb 7f 	call	0xff76	; 0xff76 <__mulsi3>
    6838:	9b 01       	movw	r18, r22
    683a:	ac 01       	movw	r20, r24
    683c:	eb 81       	ldd	r30, Y+3	; 0x03
    683e:	fc 81       	ldd	r31, Y+4	; 0x04
    6840:	86 a1       	ldd	r24, Z+38	; 0x26
    6842:	97 a1       	ldd	r25, Z+39	; 0x27
    6844:	a0 a5       	ldd	r26, Z+40	; 0x28
    6846:	b1 a5       	ldd	r27, Z+41	; 0x29
    6848:	28 0f       	add	r18, r24
    684a:	39 1f       	adc	r19, r25
    684c:	4a 1f       	adc	r20, r26
    684e:	5b 1f       	adc	r21, r27
					ABORT(fp->fs, FR_DISK_ERR);
				fp->flag &= ~FA__DIRTY;
			}
#endif
			sect = clust2sect(fp->fs, fp->curr_clust);	/* Get current sector */
			if (!sect) ABORT(fp->fs, FR_INT_ERR);
    6850:	21 15       	cp	r18, r1
    6852:	31 05       	cpc	r19, r1
    6854:	41 05       	cpc	r20, r1
    6856:	51 05       	cpc	r21, r1
    6858:	09 f4       	brne	.+2      	; 0x685c <f_write+0x2ee>
    685a:	ad cf       	rjmp	.-166    	; 0x67b6 <f_write+0x248>
			sect += csect;
    685c:	49 01       	movw	r8, r18
    685e:	5a 01       	movw	r10, r20
    6860:	87 0c       	add	r8, r7
    6862:	91 1c       	adc	r9, r1
    6864:	a1 1c       	adc	r10, r1
    6866:	b1 1c       	adc	r11, r1
			cc = btw / SS(fp->fs);					/* When remaining bytes >= sector size, */
    6868:	72 01       	movw	r14, r4
    686a:	ef 2c       	mov	r14, r15
    686c:	ff 24       	eor	r15, r15
    686e:	e6 94       	lsr	r14
			if (cc) {								/* Write maximum contiguous sectors directly */
    6870:	e1 14       	cp	r14, r1
    6872:	f1 04       	cpc	r15, r1
    6874:	09 f4       	brne	.+2      	; 0x6878 <f_write+0x30a>
    6876:	4c c0       	rjmp	.+152    	; 0x6910 <f_write+0x3a2>
				if (csect + cc > fp->fs->csize)		/* Clip at cluster boundary */
    6878:	27 2d       	mov	r18, r7
    687a:	30 e0       	ldi	r19, 0x00	; 0
    687c:	c7 01       	movw	r24, r14
    687e:	82 0f       	add	r24, r18
    6880:	93 1f       	adc	r25, r19
    6882:	61 2f       	mov	r22, r17
    6884:	70 e0       	ldi	r23, 0x00	; 0
    6886:	68 17       	cp	r22, r24
    6888:	79 07       	cpc	r23, r25
    688a:	18 f4       	brcc	.+6      	; 0x6892 <f_write+0x324>
					cc = fp->fs->csize - csect;
    688c:	7b 01       	movw	r14, r22
    688e:	e2 1a       	sub	r14, r18
    6890:	f3 0a       	sbc	r15, r19
				if (disk_write(fp->fs->drv, wbuff, sect, (BYTE)cc) != RES_OK)
    6892:	eb 81       	ldd	r30, Y+3	; 0x03
    6894:	fc 81       	ldd	r31, Y+4	; 0x04
    6896:	81 81       	ldd	r24, Z+1	; 0x01
    6898:	b1 01       	movw	r22, r2
    689a:	a5 01       	movw	r20, r10
    689c:	94 01       	movw	r18, r8
    689e:	0e 2d       	mov	r16, r14
    68a0:	0e 94 f5 24 	call	0x49ea	; 0x49ea <disk_write>
    68a4:	88 23       	and	r24, r24
    68a6:	09 f0       	breq	.+2      	; 0x68aa <f_write+0x33c>
    68a8:	a8 c0       	rjmp	.+336    	; 0x69fa <f_write+0x48c>
					ABORT(fp->fs, FR_DISK_ERR);
#if _FS_TINY
				if (fp->fs->winsect - sect < cc) {	/* Refill sector cache if it gets dirty by the direct write */
    68aa:	f6 01       	movw	r30, r12
    68ac:	01 90       	ld	r0, Z+
    68ae:	f0 81       	ld	r31, Z
    68b0:	e0 2d       	mov	r30, r0
    68b2:	fc 83       	std	Y+4, r31	; 0x04
    68b4:	eb 83       	std	Y+3, r30	; 0x03
    68b6:	22 a5       	ldd	r18, Z+42	; 0x2a
    68b8:	33 a5       	ldd	r19, Z+43	; 0x2b
    68ba:	44 a5       	ldd	r20, Z+44	; 0x2c
    68bc:	55 a5       	ldd	r21, Z+45	; 0x2d
    68be:	28 19       	sub	r18, r8
    68c0:	39 09       	sbc	r19, r9
    68c2:	4a 09       	sbc	r20, r10
    68c4:	5b 09       	sbc	r21, r11
    68c6:	c7 01       	movw	r24, r14
    68c8:	a0 e0       	ldi	r26, 0x00	; 0
    68ca:	b0 e0       	ldi	r27, 0x00	; 0
    68cc:	28 17       	cp	r18, r24
    68ce:	39 07       	cpc	r19, r25
    68d0:	4a 07       	cpc	r20, r26
    68d2:	5b 07       	cpc	r21, r27
    68d4:	c0 f4       	brcc	.+48     	; 0x6906 <f_write+0x398>
/*-----------------------------------------------------------------------*/

/* Copy memory to memory */
static
void mem_cpy (void* dst, const void* src, UINT cnt) {
	BYTE *d = (BYTE*)dst;
    68d6:	df 01       	movw	r26, r30
    68d8:	9e 96       	adiw	r26, 0x2e	; 46
	const BYTE *s = (const BYTE*)src;
    68da:	79 e0       	ldi	r23, 0x09	; 9
    68dc:	22 0f       	add	r18, r18
    68de:	33 1f       	adc	r19, r19
    68e0:	44 1f       	adc	r20, r20
    68e2:	55 1f       	adc	r21, r21
    68e4:	7a 95       	dec	r23
    68e6:	d1 f7       	brne	.-12     	; 0x68dc <f_write+0x36e>
    68e8:	f1 01       	movw	r30, r2
    68ea:	e2 0f       	add	r30, r18
    68ec:	f3 1f       	adc	r31, r19
    68ee:	9f 01       	movw	r18, r30
    68f0:	20 50       	subi	r18, 0x00	; 0
    68f2:	3e 4f       	sbci	r19, 0xFE	; 254
		d += sizeof(int); s += sizeof(int);
		cnt -= sizeof(int);
	}
#endif
	while (cnt--)
		*d++ = *s++;
    68f4:	81 91       	ld	r24, Z+
    68f6:	8d 93       	st	X+, r24
		*(int*)d = *(int*)s;
		d += sizeof(int); s += sizeof(int);
		cnt -= sizeof(int);
	}
#endif
	while (cnt--)
    68f8:	e2 17       	cp	r30, r18
    68fa:	f3 07       	cpc	r31, r19
    68fc:	d9 f7       	brne	.-10     	; 0x68f4 <f_write+0x386>
				if (disk_write(fp->fs->drv, wbuff, sect, (BYTE)cc) != RES_OK)
					ABORT(fp->fs, FR_DISK_ERR);
#if _FS_TINY
				if (fp->fs->winsect - sect < cc) {	/* Refill sector cache if it gets dirty by the direct write */
					mem_cpy(fp->fs->win, wbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), SS(fp->fs));
					fp->fs->wflag = 0;
    68fe:	d6 01       	movw	r26, r12
    6900:	ed 91       	ld	r30, X+
    6902:	fc 91       	ld	r31, X
    6904:	14 82       	std	Z+4, r1	; 0x04
				if (fp->dsect - sect < cc) {		/* Refill sector cache if it gets dirty by the direct write */
					mem_cpy(fp->buf, wbuff + ((fp->dsect - sect) * SS(fp->fs)), SS(fp->fs));
					fp->flag &= ~FA__DIRTY;
				}
#endif
				wcnt = SS(fp->fs) * cc;				/* Number of bytes transferred */
    6906:	a7 01       	movw	r20, r14
    6908:	54 2f       	mov	r21, r20
    690a:	44 27       	eor	r20, r20
    690c:	55 0f       	add	r21, r21
    690e:	c3 ce       	rjmp	.-634    	; 0x6696 <f_write+0x128>
				continue;
			}
#if _FS_TINY
			if (fp->fptr >= fp->fsize) {			/* Avoid silly buffer filling at growing edge */
    6910:	f6 01       	movw	r30, r12
    6912:	e6 80       	ldd	r14, Z+6	; 0x06
    6914:	f7 80       	ldd	r15, Z+7	; 0x07
    6916:	00 85       	ldd	r16, Z+8	; 0x08
    6918:	11 85       	ldd	r17, Z+9	; 0x09
    691a:	82 85       	ldd	r24, Z+10	; 0x0a
    691c:	93 85       	ldd	r25, Z+11	; 0x0b
    691e:	a4 85       	ldd	r26, Z+12	; 0x0c
    6920:	b5 85       	ldd	r27, Z+13	; 0x0d
    6922:	e8 16       	cp	r14, r24
    6924:	f9 06       	cpc	r15, r25
    6926:	0a 07       	cpc	r16, r26
    6928:	1b 07       	cpc	r17, r27
    692a:	b0 f5       	brcc	.+108    	; 0x6998 <f_write+0x42a>
				if (fp->fptr < fp->fsize &&
					disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)
						ABORT(fp->fs, FR_DISK_ERR);
			}
#endif
			fp->dsect = sect;
    692c:	d6 01       	movw	r26, r12
    692e:	56 96       	adiw	r26, 0x16	; 22
    6930:	8d 92       	st	X+, r8
    6932:	9d 92       	st	X+, r9
    6934:	ad 92       	st	X+, r10
    6936:	bc 92       	st	X, r11
    6938:	59 97       	sbiw	r26, 0x19	; 25
    693a:	7b ce       	rjmp	.-778    	; 0x6632 <f_write+0xc4>
				if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
				fp->curr_clust = clst;				/* Update current cluster */
			}
#if _FS_TINY
			if (fp->fs->winsect == fp->dsect && move_window(fp->fs, 0))	/* Write back data buffer prior to following direct transfer */
    693c:	8b 81       	ldd	r24, Y+3	; 0x03
    693e:	9c 81       	ldd	r25, Y+4	; 0x04
    6940:	40 e0       	ldi	r20, 0x00	; 0
    6942:	50 e0       	ldi	r21, 0x00	; 0
    6944:	60 e0       	ldi	r22, 0x00	; 0
    6946:	70 e0       	ldi	r23, 0x00	; 0
    6948:	0e 94 8b 26 	call	0x4d16	; 0x4d16 <move_window>
    694c:	88 23       	and	r24, r24
    694e:	09 f0       	breq	.+2      	; 0x6952 <f_write+0x3e4>
    6950:	68 c0       	rjmp	.+208    	; 0x6a22 <f_write+0x4b4>
    6952:	d6 01       	movw	r26, r12
    6954:	0d 90       	ld	r0, X+
    6956:	bc 91       	ld	r27, X
    6958:	a0 2d       	mov	r26, r0
    695a:	bc 83       	std	Y+4, r27	; 0x04
    695c:	ab 83       	std	Y+3, r26	; 0x03
    695e:	12 cf       	rjmp	.-476    	; 0x6784 <f_write+0x216>
				if (fp->fptr == 0) {				/* On the top of the file? */
					clst = fp->org_clust;			/* Follow from the origin */
					if (clst == 0)					/* When there is no cluster chain, */
						fp->org_clust = clst = create_chain(fp->fs, 0);	/* Create a new cluster chain */
				} else {							/* Middle or end of the file */
					clst = create_chain(fp->fs, fp->curr_clust);			/* Follow or stretch cluster chain */
    6960:	d6 01       	movw	r26, r12
    6962:	52 96       	adiw	r26, 0x12	; 18
    6964:	4d 91       	ld	r20, X+
    6966:	5d 91       	ld	r21, X+
    6968:	6d 91       	ld	r22, X+
    696a:	7c 91       	ld	r23, X
    696c:	55 97       	sbiw	r26, 0x15	; 21
    696e:	8b 81       	ldd	r24, Y+3	; 0x03
    6970:	9c 81       	ldd	r25, Y+4	; 0x04
    6972:	0e 94 34 2a 	call	0x5468	; 0x5468 <create_chain>
				}
				if (clst == 0) break;				/* Could not allocate a new cluster (disk full) */
    6976:	61 15       	cp	r22, r1
    6978:	71 05       	cpc	r23, r1
    697a:	81 05       	cpc	r24, r1
    697c:	91 05       	cpc	r25, r1
    697e:	09 f0       	breq	.+2      	; 0x6982 <f_write+0x414>
    6980:	d4 ce       	rjmp	.-600    	; 0x672a <f_write+0x1bc>
    6982:	f6 01       	movw	r30, r12
    6984:	22 85       	ldd	r18, Z+10	; 0x0a
    6986:	33 85       	ldd	r19, Z+11	; 0x0b
    6988:	44 85       	ldd	r20, Z+12	; 0x0c
    698a:	55 85       	ldd	r21, Z+13	; 0x0d
    698c:	64 81       	ldd	r22, Z+4	; 0x04
    698e:	e6 80       	ldd	r14, Z+6	; 0x06
    6990:	f7 80       	ldd	r15, Z+7	; 0x07
    6992:	00 85       	ldd	r16, Z+8	; 0x08
    6994:	11 85       	ldd	r17, Z+9	; 0x09
    6996:	3a cf       	rjmp	.-396    	; 0x680c <f_write+0x29e>
				wcnt = SS(fp->fs) * cc;				/* Number of bytes transferred */
				continue;
			}
#if _FS_TINY
			if (fp->fptr >= fp->fsize) {			/* Avoid silly buffer filling at growing edge */
				if (move_window(fp->fs, 0)) ABORT(fp->fs, FR_DISK_ERR);
    6998:	8b 81       	ldd	r24, Y+3	; 0x03
    699a:	9c 81       	ldd	r25, Y+4	; 0x04
    699c:	40 e0       	ldi	r20, 0x00	; 0
    699e:	50 e0       	ldi	r21, 0x00	; 0
    69a0:	60 e0       	ldi	r22, 0x00	; 0
    69a2:	70 e0       	ldi	r23, 0x00	; 0
    69a4:	0e 94 8b 26 	call	0x4d16	; 0x4d16 <move_window>
    69a8:	88 23       	and	r24, r24
    69aa:	39 f5       	brne	.+78     	; 0x69fa <f_write+0x48c>
				fp->fs->winsect = sect;
    69ac:	f6 01       	movw	r30, r12
    69ae:	01 90       	ld	r0, Z+
    69b0:	f0 81       	ld	r31, Z
    69b2:	e0 2d       	mov	r30, r0
    69b4:	fc 83       	std	Y+4, r31	; 0x04
    69b6:	eb 83       	std	Y+3, r30	; 0x03
    69b8:	82 a6       	std	Z+42, r8	; 0x2a
    69ba:	93 a6       	std	Z+43, r9	; 0x2b
    69bc:	a4 a6       	std	Z+44, r10	; 0x2c
    69be:	b5 a6       	std	Z+45, r11	; 0x2d
    69c0:	f6 01       	movw	r30, r12
    69c2:	e6 80       	ldd	r14, Z+6	; 0x06
    69c4:	f7 80       	ldd	r15, Z+7	; 0x07
    69c6:	00 85       	ldd	r16, Z+8	; 0x08
    69c8:	11 85       	ldd	r17, Z+9	; 0x09
    69ca:	b0 cf       	rjmp	.-160    	; 0x692c <f_write+0x3be>
			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
			if (!csect) {							/* On the cluster boundary? */
				if (fp->fptr == 0) {				/* On the top of the file? */
					clst = fp->org_clust;			/* Follow from the origin */
					if (clst == 0)					/* When there is no cluster chain, */
						fp->org_clust = clst = create_chain(fp->fs, 0);	/* Create a new cluster chain */
    69cc:	cf 01       	movw	r24, r30
    69ce:	40 e0       	ldi	r20, 0x00	; 0
    69d0:	50 e0       	ldi	r21, 0x00	; 0
    69d2:	60 e0       	ldi	r22, 0x00	; 0
    69d4:	70 e0       	ldi	r23, 0x00	; 0
    69d6:	0e 94 34 2a 	call	0x5468	; 0x5468 <create_chain>
    69da:	f6 01       	movw	r30, r12
    69dc:	66 87       	std	Z+14, r22	; 0x0e
    69de:	77 87       	std	Z+15, r23	; 0x0f
    69e0:	80 8b       	std	Z+16, r24	; 0x10
    69e2:	91 8b       	std	Z+17, r25	; 0x11
    69e4:	c8 cf       	rjmp	.-112    	; 0x6976 <f_write+0x408>
				} else {							/* Middle or end of the file */
					clst = create_chain(fp->fs, fp->curr_clust);			/* Follow or stretch cluster chain */
				}
				if (clst == 0) break;				/* Could not allocate a new cluster (disk full) */
				if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
    69e6:	d6 01       	movw	r26, r12
    69e8:	14 96       	adiw	r26, 0x04	; 4
    69ea:	8c 91       	ld	r24, X
    69ec:	14 97       	sbiw	r26, 0x04	; 4
    69ee:	80 68       	ori	r24, 0x80	; 128
    69f0:	14 96       	adiw	r26, 0x04	; 4
    69f2:	8c 93       	st	X, r24
    69f4:	a2 e0       	ldi	r26, 0x02	; 2
    69f6:	6a 2e       	mov	r6, r26
    69f8:	e7 ce       	rjmp	.-562    	; 0x67c8 <f_write+0x25a>
		}
		wcnt = SS(fp->fs) - (fp->fptr % SS(fp->fs));/* Put partial sector into file I/O buffer */
		if (wcnt > btw) wcnt = btw;
#if _FS_TINY
		if (move_window(fp->fs, fp->dsect))			/* Move sector window */
			ABORT(fp->fs, FR_DISK_ERR);
    69fa:	d6 01       	movw	r26, r12
    69fc:	14 96       	adiw	r26, 0x04	; 4
    69fe:	8c 91       	ld	r24, X
    6a00:	14 97       	sbiw	r26, 0x04	; 4
    6a02:	80 68       	ori	r24, 0x80	; 128
    6a04:	14 96       	adiw	r26, 0x04	; 4
    6a06:	8c 93       	st	X, r24
    6a08:	66 24       	eor	r6, r6
    6a0a:	63 94       	inc	r6
    6a0c:	dd ce       	rjmp	.-582    	; 0x67c8 <f_write+0x25a>
	if (!(fp->flag & FA_WRITE))						/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
	if (fp->fsize + btw < fp->fsize) btw = 0;		/* File size cannot reach 4GB */

	for ( ;  btw;									/* Repeat until all data transferred */
		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
    6a0e:	d6 01       	movw	r26, r12
    6a10:	1a 96       	adiw	r26, 0x0a	; 10
    6a12:	2d 91       	ld	r18, X+
    6a14:	3d 91       	ld	r19, X+
    6a16:	4d 91       	ld	r20, X+
    6a18:	5c 91       	ld	r21, X
    6a1a:	1d 97       	sbiw	r26, 0x0d	; 13
    6a1c:	14 96       	adiw	r26, 0x04	; 4
    6a1e:	6c 91       	ld	r22, X
    6a20:	f5 ce       	rjmp	.-534    	; 0x680c <f_write+0x29e>
				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
				fp->curr_clust = clst;				/* Update current cluster */
			}
#if _FS_TINY
			if (fp->fs->winsect == fp->dsect && move_window(fp->fs, 0))	/* Write back data buffer prior to following direct transfer */
				ABORT(fp->fs, FR_DISK_ERR);
    6a22:	f6 01       	movw	r30, r12
    6a24:	84 81       	ldd	r24, Z+4	; 0x04
    6a26:	80 68       	ori	r24, 0x80	; 128
    6a28:	84 83       	std	Z+4, r24	; 0x04
    6a2a:	66 24       	eor	r6, r6
    6a2c:	63 94       	inc	r6
    6a2e:	cc ce       	rjmp	.-616    	; 0x67c8 <f_write+0x25a>
    6a30:	f6 01       	movw	r30, r12
    6a32:	e6 80       	ldd	r14, Z+6	; 0x06
    6a34:	f7 80       	ldd	r15, Z+7	; 0x07
    6a36:	00 85       	ldd	r16, Z+8	; 0x08
    6a38:	11 85       	ldd	r17, Z+9	; 0x09
    6a3a:	e8 ce       	rjmp	.-560    	; 0x680c <f_write+0x29e>

00006a3c <check_fs>:
static
BYTE check_fs (	/* 0:The FAT BR, 1:Valid BR but not an FAT, 2:Not a BR, 3:Disk error */
	FATFS *fs,	/* File system object */
	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
)
{
    6a3c:	0f 93       	push	r16
    6a3e:	cf 93       	push	r28
    6a40:	df 93       	push	r29
    6a42:	ec 01       	movw	r28, r24
    6a44:	9a 01       	movw	r18, r20
    6a46:	ab 01       	movw	r20, r22
	if (disk_read(fs->drv, fs->win, sect, 1) != RES_OK)	/* Load boot record */
    6a48:	bc 01       	movw	r22, r24
    6a4a:	62 5d       	subi	r22, 0xD2	; 210
    6a4c:	7f 4f       	sbci	r23, 0xFF	; 255
    6a4e:	89 81       	ldd	r24, Y+1	; 0x01
    6a50:	01 e0       	ldi	r16, 0x01	; 1
    6a52:	0e 94 89 24 	call	0x4912	; 0x4912 <disk_read>
    6a56:	88 23       	and	r24, r24
    6a58:	09 f0       	breq	.+2      	; 0x6a5c <check_fs+0x20>
    6a5a:	75 c0       	rjmp	.+234    	; 0x6b46 <check_fs+0x10a>
		return 3;
	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)		/* Check record signature (always placed at offset 510 even if the sector size is >512) */
    6a5c:	c3 5d       	subi	r28, 0xD3	; 211
    6a5e:	dd 4f       	sbci	r29, 0xFD	; 253
    6a60:	98 81       	ld	r25, Y
    6a62:	80 e0       	ldi	r24, 0x00	; 0
    6a64:	2a 91       	ld	r18, -Y
    6a66:	cc 52       	subi	r28, 0x2C	; 44
    6a68:	d2 40       	sbci	r29, 0x02	; 2
    6a6a:	30 e0       	ldi	r19, 0x00	; 0
    6a6c:	82 2b       	or	r24, r18
    6a6e:	93 2b       	or	r25, r19
    6a70:	85 55       	subi	r24, 0x55	; 85
    6a72:	9a 4a       	sbci	r25, 0xAA	; 170
    6a74:	31 f0       	breq	.+12     	; 0x6a82 <check_fs+0x46>
    6a76:	62 e0       	ldi	r22, 0x02	; 2
		return 0;
	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)
		return 0;

	return 1;
}
    6a78:	86 2f       	mov	r24, r22
    6a7a:	df 91       	pop	r29
    6a7c:	cf 91       	pop	r28
    6a7e:	0f 91       	pop	r16
    6a80:	08 95       	ret
	if (disk_read(fs->drv, fs->win, sect, 1) != RES_OK)	/* Load boot record */
		return 3;
	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)		/* Check record signature (always placed at offset 510 even if the sector size is >512) */
		return 2;

	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
    6a82:	c9 59       	subi	r28, 0x99	; 153
    6a84:	df 4f       	sbci	r29, 0xFF	; 255
    6a86:	28 81       	ld	r18, Y
    6a88:	30 e0       	ldi	r19, 0x00	; 0
    6a8a:	40 e0       	ldi	r20, 0x00	; 0
    6a8c:	50 e0       	ldi	r21, 0x00	; 0
    6a8e:	52 2f       	mov	r21, r18
    6a90:	44 27       	eor	r20, r20
    6a92:	33 27       	eor	r19, r19
    6a94:	22 27       	eor	r18, r18
    6a96:	8a 91       	ld	r24, -Y
    6a98:	90 e0       	ldi	r25, 0x00	; 0
    6a9a:	a0 e0       	ldi	r26, 0x00	; 0
    6a9c:	b0 e0       	ldi	r27, 0x00	; 0
    6a9e:	dc 01       	movw	r26, r24
    6aa0:	99 27       	eor	r25, r25
    6aa2:	88 27       	eor	r24, r24
    6aa4:	28 2b       	or	r18, r24
    6aa6:	39 2b       	or	r19, r25
    6aa8:	4a 2b       	or	r20, r26
    6aaa:	5b 2b       	or	r21, r27
    6aac:	22 97       	sbiw	r28, 0x02	; 2
    6aae:	89 91       	ld	r24, Y+
    6ab0:	90 e0       	ldi	r25, 0x00	; 0
    6ab2:	a0 e0       	ldi	r26, 0x00	; 0
    6ab4:	b0 e0       	ldi	r27, 0x00	; 0
    6ab6:	28 2b       	or	r18, r24
    6ab8:	39 2b       	or	r19, r25
    6aba:	4a 2b       	or	r20, r26
    6abc:	5b 2b       	or	r21, r27
    6abe:	98 81       	ld	r25, Y
    6ac0:	c5 56       	subi	r28, 0x65	; 101
    6ac2:	d0 40       	sbci	r29, 0x00	; 0
    6ac4:	80 e0       	ldi	r24, 0x00	; 0
    6ac6:	a0 e0       	ldi	r26, 0x00	; 0
    6ac8:	b0 e0       	ldi	r27, 0x00	; 0
    6aca:	28 2b       	or	r18, r24
    6acc:	39 2b       	or	r19, r25
    6ace:	4a 2b       	or	r20, r26
    6ad0:	5b 2b       	or	r21, r27
    6ad2:	50 70       	andi	r21, 0x00	; 0
    6ad4:	26 54       	subi	r18, 0x46	; 70
    6ad6:	31 44       	sbci	r19, 0x41	; 65
    6ad8:	44 45       	sbci	r20, 0x54	; 84
    6ada:	50 40       	sbci	r21, 0x00	; 0
    6adc:	d1 f1       	breq	.+116    	; 0x6b52 <check_fs+0x116>
    6ade:	60 e0       	ldi	r22, 0x00	; 0
    6ae0:	cd 57       	subi	r28, 0x7D	; 125
    6ae2:	df 4f       	sbci	r29, 0xFF	; 255
    6ae4:	28 81       	ld	r18, Y
    6ae6:	30 e0       	ldi	r19, 0x00	; 0
    6ae8:	40 e0       	ldi	r20, 0x00	; 0
    6aea:	50 e0       	ldi	r21, 0x00	; 0
    6aec:	52 2f       	mov	r21, r18
    6aee:	44 27       	eor	r20, r20
    6af0:	33 27       	eor	r19, r19
    6af2:	22 27       	eor	r18, r18
    6af4:	8a 91       	ld	r24, -Y
    6af6:	90 e0       	ldi	r25, 0x00	; 0
    6af8:	a0 e0       	ldi	r26, 0x00	; 0
    6afa:	b0 e0       	ldi	r27, 0x00	; 0
    6afc:	dc 01       	movw	r26, r24
    6afe:	99 27       	eor	r25, r25
    6b00:	88 27       	eor	r24, r24
    6b02:	28 2b       	or	r18, r24
    6b04:	39 2b       	or	r19, r25
    6b06:	4a 2b       	or	r20, r26
    6b08:	5b 2b       	or	r21, r27
    6b0a:	22 97       	sbiw	r28, 0x02	; 2
    6b0c:	89 91       	ld	r24, Y+
    6b0e:	90 e0       	ldi	r25, 0x00	; 0
    6b10:	a0 e0       	ldi	r26, 0x00	; 0
    6b12:	b0 e0       	ldi	r27, 0x00	; 0
    6b14:	28 2b       	or	r18, r24
    6b16:	39 2b       	or	r19, r25
    6b18:	4a 2b       	or	r20, r26
    6b1a:	5b 2b       	or	r21, r27
    6b1c:	98 81       	ld	r25, Y
    6b1e:	80 e0       	ldi	r24, 0x00	; 0
    6b20:	a0 e0       	ldi	r26, 0x00	; 0
    6b22:	b0 e0       	ldi	r27, 0x00	; 0
    6b24:	28 2b       	or	r18, r24
    6b26:	39 2b       	or	r19, r25
    6b28:	4a 2b       	or	r20, r26
    6b2a:	5b 2b       	or	r21, r27
    6b2c:	50 70       	andi	r21, 0x00	; 0
    6b2e:	26 54       	subi	r18, 0x46	; 70
    6b30:	31 44       	sbci	r19, 0x41	; 65
    6b32:	44 45       	sbci	r20, 0x54	; 84
    6b34:	50 40       	sbci	r21, 0x00	; 0
    6b36:	09 f4       	brne	.+2      	; 0x6b3a <check_fs+0xfe>
    6b38:	9f cf       	rjmp	.-194    	; 0x6a78 <check_fs+0x3c>
    6b3a:	61 e0       	ldi	r22, 0x01	; 1
		return 0;
	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)
		return 0;

	return 1;
}
    6b3c:	86 2f       	mov	r24, r22
    6b3e:	df 91       	pop	r29
    6b40:	cf 91       	pop	r28
    6b42:	0f 91       	pop	r16
    6b44:	08 95       	ret
BYTE check_fs (	/* 0:The FAT BR, 1:Valid BR but not an FAT, 2:Not a BR, 3:Disk error */
	FATFS *fs,	/* File system object */
	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
)
{
	if (disk_read(fs->drv, fs->win, sect, 1) != RES_OK)	/* Load boot record */
    6b46:	63 e0       	ldi	r22, 0x03	; 3
		return 0;
	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)
		return 0;

	return 1;
}
    6b48:	86 2f       	mov	r24, r22
    6b4a:	df 91       	pop	r29
    6b4c:	cf 91       	pop	r28
    6b4e:	0f 91       	pop	r16
    6b50:	08 95       	ret
	if (disk_read(fs->drv, fs->win, sect, 1) != RES_OK)	/* Load boot record */
		return 3;
	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)		/* Check record signature (always placed at offset 510 even if the sector size is >512) */
		return 2;

	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
    6b52:	60 e0       	ldi	r22, 0x00	; 0
    6b54:	91 cf       	rjmp	.-222    	; 0x6a78 <check_fs+0x3c>

00006b56 <f_read>:
	FIL *fp, 		/* Pointer to the file object */
	void *buff,		/* Pointer to data buffer */
	UINT btr,		/* Number of bytes to read */
	UINT *br		/* Pointer to number of bytes read */
)
{
    6b56:	2f 92       	push	r2
    6b58:	3f 92       	push	r3
    6b5a:	4f 92       	push	r4
    6b5c:	5f 92       	push	r5
    6b5e:	6f 92       	push	r6
    6b60:	7f 92       	push	r7
    6b62:	8f 92       	push	r8
    6b64:	9f 92       	push	r9
    6b66:	af 92       	push	r10
    6b68:	bf 92       	push	r11
    6b6a:	cf 92       	push	r12
    6b6c:	df 92       	push	r13
    6b6e:	ef 92       	push	r14
    6b70:	ff 92       	push	r15
    6b72:	0f 93       	push	r16
    6b74:	1f 93       	push	r17
    6b76:	df 93       	push	r29
    6b78:	cf 93       	push	r28
    6b7a:	00 d0       	rcall	.+0      	; 0x6b7c <f_read+0x26>
    6b7c:	00 d0       	rcall	.+0      	; 0x6b7e <f_read+0x28>
    6b7e:	cd b7       	in	r28, 0x3d	; 61
    6b80:	de b7       	in	r29, 0x3e	; 62
    6b82:	6c 01       	movw	r12, r24
    6b84:	b6 2e       	mov	r11, r22
    6b86:	a7 2e       	mov	r10, r23
    6b88:	2a 01       	movw	r4, r20
    6b8a:	3a 83       	std	Y+2, r19	; 0x02
    6b8c:	29 83       	std	Y+1, r18	; 0x01
	DWORD clst, sect, remain;
	UINT rcnt, cc;
	BYTE csect, *rbuff = buff;


	*br = 0;	/* Initialize byte counter */
    6b8e:	f9 01       	movw	r30, r18
    6b90:	11 82       	std	Z+1, r1	; 0x01
    6b92:	10 82       	st	Z, r1

	res = validate(fp->fs, fp->id);					/* Check validity of the object */
    6b94:	fc 01       	movw	r30, r24
    6b96:	62 81       	ldd	r22, Z+2	; 0x02
    6b98:	73 81       	ldd	r23, Z+3	; 0x03
    6b9a:	80 81       	ld	r24, Z
    6b9c:	91 81       	ldd	r25, Z+1	; 0x01
    6b9e:	0e 94 75 26 	call	0x4cea	; 0x4cea <validate>
    6ba2:	68 2e       	mov	r6, r24
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
    6ba4:	88 23       	and	r24, r24
    6ba6:	09 f0       	breq	.+2      	; 0x6baa <f_read+0x54>
    6ba8:	da c0       	rjmp	.+436    	; 0x6d5e <f_read+0x208>
	if (fp->flag & FA__ERROR)						/* Check abort flag */
    6baa:	f6 01       	movw	r30, r12
    6bac:	84 81       	ldd	r24, Z+4	; 0x04
    6bae:	87 fd       	sbrc	r24, 7
    6bb0:	85 c1       	rjmp	.+778    	; 0x6ebc <f_read+0x366>
		LEAVE_FF(fp->fs, FR_INT_ERR);
	if (!(fp->flag & FA_READ)) 						/* Check access mode */
    6bb2:	80 ff       	sbrs	r24, 0
    6bb4:	ec c0       	rjmp	.+472    	; 0x6d8e <f_read+0x238>
		LEAVE_FF(fp->fs, FR_DENIED);
	remain = fp->fsize - fp->fptr;
    6bb6:	f6 01       	movw	r30, r12
    6bb8:	e6 80       	ldd	r14, Z+6	; 0x06
    6bba:	f7 80       	ldd	r15, Z+7	; 0x07
    6bbc:	00 85       	ldd	r16, Z+8	; 0x08
    6bbe:	11 85       	ldd	r17, Z+9	; 0x09
    6bc0:	22 85       	ldd	r18, Z+10	; 0x0a
    6bc2:	33 85       	ldd	r19, Z+11	; 0x0b
    6bc4:	44 85       	ldd	r20, Z+12	; 0x0c
    6bc6:	55 85       	ldd	r21, Z+13	; 0x0d
    6bc8:	2e 19       	sub	r18, r14
    6bca:	3f 09       	sbc	r19, r15
    6bcc:	40 0b       	sbc	r20, r16
    6bce:	51 0b       	sbc	r21, r17
	if (btr > remain) btr = (UINT)remain;			/* Truncate btr by remaining bytes */
    6bd0:	c2 01       	movw	r24, r4
    6bd2:	a0 e0       	ldi	r26, 0x00	; 0
    6bd4:	b0 e0       	ldi	r27, 0x00	; 0
    6bd6:	28 17       	cp	r18, r24
    6bd8:	39 07       	cpc	r19, r25
    6bda:	4a 07       	cpc	r20, r26
    6bdc:	5b 07       	cpc	r21, r27
    6bde:	08 f4       	brcc	.+2      	; 0x6be2 <f_read+0x8c>
    6be0:	64 c1       	rjmp	.+712    	; 0x6eaa <f_read+0x354>

	for ( ;  btr;									/* Repeat until all data transferred */
    6be2:	41 14       	cp	r4, r1
    6be4:	51 04       	cpc	r5, r1
    6be6:	09 f4       	brne	.+2      	; 0x6bea <f_read+0x94>
    6be8:	ba c0       	rjmp	.+372    	; 0x6d5e <f_read+0x208>
)
{
	FRESULT res;
	DWORD clst, sect, remain;
	UINT rcnt, cc;
	BYTE csect, *rbuff = buff;
    6bea:	8b 2d       	mov	r24, r11
    6bec:	9a 2d       	mov	r25, r10
    6bee:	9c 01       	movw	r18, r24
    6bf0:	19 01       	movw	r2, r18
	remain = fp->fsize - fp->fptr;
	if (btr > remain) btr = (UINT)remain;			/* Truncate btr by remaining bytes */

	for ( ;  btr;									/* Repeat until all data transferred */
		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
		if ((fp->fptr % SS(fp->fs)) == 0) {			/* On the sector boundary? */
    6bf2:	d8 01       	movw	r26, r16
    6bf4:	c7 01       	movw	r24, r14
    6bf6:	91 70       	andi	r25, 0x01	; 1
    6bf8:	a0 70       	andi	r26, 0x00	; 0
    6bfa:	b0 70       	andi	r27, 0x00	; 0
    6bfc:	00 97       	sbiw	r24, 0x00	; 0
    6bfe:	a1 05       	cpc	r26, r1
    6c00:	b1 05       	cpc	r27, r1
    6c02:	09 f4       	brne	.+2      	; 0x6c06 <f_read+0xb0>
    6c04:	5a c0       	rjmp	.+180    	; 0x6cba <f_read+0x164>
    6c06:	f6 01       	movw	r30, r12
    6c08:	01 90       	ld	r0, Z+
    6c0a:	f0 81       	ld	r31, Z
    6c0c:	e0 2d       	mov	r30, r0
    6c0e:	fc 83       	std	Y+4, r31	; 0x04
    6c10:	eb 83       	std	Y+3, r30	; 0x03
			fp->dsect = sect;
		}
		rcnt = SS(fp->fs) - (fp->fptr % SS(fp->fs));	/* Get partial sector data from sector buffer */
		if (rcnt > btr) rcnt = btr;
#if _FS_TINY
		if (move_window(fp->fs, fp->dsect))			/* Move sector window */
    6c12:	f6 01       	movw	r30, r12
    6c14:	46 89       	ldd	r20, Z+22	; 0x16
    6c16:	57 89       	ldd	r21, Z+23	; 0x17
    6c18:	60 8d       	ldd	r22, Z+24	; 0x18
    6c1a:	71 8d       	ldd	r23, Z+25	; 0x19
    6c1c:	8b 81       	ldd	r24, Y+3	; 0x03
    6c1e:	9c 81       	ldd	r25, Y+4	; 0x04
    6c20:	0e 94 8b 26 	call	0x4d16	; 0x4d16 <move_window>
    6c24:	88 23       	and	r24, r24
    6c26:	09 f0       	breq	.+2      	; 0x6c2a <f_read+0xd4>
    6c28:	42 c1       	rjmp	.+644    	; 0x6eae <f_read+0x358>
					ABORT(fp->fs, FR_DISK_ERR);
			}
#endif
			fp->dsect = sect;
		}
		rcnt = SS(fp->fs) - (fp->fptr % SS(fp->fs));	/* Get partial sector data from sector buffer */
    6c2a:	c7 01       	movw	r24, r14
    6c2c:	91 70       	andi	r25, 0x01	; 1
    6c2e:	00 e0       	ldi	r16, 0x00	; 0
    6c30:	12 e0       	ldi	r17, 0x02	; 2
    6c32:	08 1b       	sub	r16, r24
    6c34:	19 0b       	sbc	r17, r25
    6c36:	40 16       	cp	r4, r16
    6c38:	51 06       	cpc	r5, r17
    6c3a:	08 f4       	brcc	.+2      	; 0x6c3e <f_read+0xe8>
    6c3c:	82 01       	movw	r16, r4
		if (rcnt > btr) rcnt = btr;
#if _FS_TINY
		if (move_window(fp->fs, fp->dsect))			/* Move sector window */
			ABORT(fp->fs, FR_DISK_ERR);
		mem_cpy(rbuff, &fp->fs->win[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
    6c3e:	f6 01       	movw	r30, r12
    6c40:	01 90       	ld	r0, Z+
    6c42:	f0 81       	ld	r31, Z
    6c44:	e0 2d       	mov	r30, r0
    6c46:	fc 83       	std	Y+4, r31	; 0x04
    6c48:	eb 83       	std	Y+3, r30	; 0x03
    6c4a:	f6 01       	movw	r30, r12
    6c4c:	66 81       	ldd	r22, Z+6	; 0x06
    6c4e:	77 81       	ldd	r23, Z+7	; 0x07
    6c50:	80 85       	ldd	r24, Z+8	; 0x08
    6c52:	91 85       	ldd	r25, Z+9	; 0x09
		*(int*)d = *(int*)s;
		d += sizeof(int); s += sizeof(int);
		cnt -= sizeof(int);
	}
#endif
	while (cnt--)
    6c54:	01 15       	cp	r16, r1
    6c56:	11 05       	cpc	r17, r1
    6c58:	99 f0       	breq	.+38     	; 0x6c80 <f_read+0x12a>

/* Copy memory to memory */
static
void mem_cpy (void* dst, const void* src, UINT cnt) {
	BYTE *d = (BYTE*)dst;
	const BYTE *s = (const BYTE*)src;
    6c5a:	fb 01       	movw	r30, r22
    6c5c:	f1 70       	andi	r31, 0x01	; 1
    6c5e:	be 96       	adiw	r30, 0x2e	; 46
    6c60:	8b 81       	ldd	r24, Y+3	; 0x03
    6c62:	9c 81       	ldd	r25, Y+4	; 0x04
    6c64:	e8 0f       	add	r30, r24
    6c66:	f9 1f       	adc	r31, r25
    6c68:	d1 01       	movw	r26, r2
    6c6a:	98 01       	movw	r18, r16
		d += sizeof(int); s += sizeof(int);
		cnt -= sizeof(int);
	}
#endif
	while (cnt--)
		*d++ = *s++;
    6c6c:	81 91       	ld	r24, Z+
    6c6e:	8d 93       	st	X+, r24
    6c70:	21 50       	subi	r18, 0x01	; 1
    6c72:	30 40       	sbci	r19, 0x00	; 0
		*(int*)d = *(int*)s;
		d += sizeof(int); s += sizeof(int);
		cnt -= sizeof(int);
	}
#endif
	while (cnt--)
    6c74:	d9 f7       	brne	.-10     	; 0x6c6c <f_read+0x116>
    6c76:	f6 01       	movw	r30, r12
    6c78:	66 81       	ldd	r22, Z+6	; 0x06
    6c7a:	77 81       	ldd	r23, Z+7	; 0x07
    6c7c:	80 85       	ldd	r24, Z+8	; 0x08
    6c7e:	91 85       	ldd	r25, Z+9	; 0x09
		LEAVE_FF(fp->fs, FR_DENIED);
	remain = fp->fsize - fp->fptr;
	if (btr > remain) btr = (UINT)remain;			/* Truncate btr by remaining bytes */

	for ( ;  btr;									/* Repeat until all data transferred */
		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
    6c80:	98 01       	movw	r18, r16
    6c82:	40 e0       	ldi	r20, 0x00	; 0
    6c84:	50 e0       	ldi	r21, 0x00	; 0
    6c86:	26 0f       	add	r18, r22
    6c88:	37 1f       	adc	r19, r23
    6c8a:	48 1f       	adc	r20, r24
    6c8c:	59 1f       	adc	r21, r25
    6c8e:	f6 01       	movw	r30, r12
    6c90:	26 83       	std	Z+6, r18	; 0x06
    6c92:	37 83       	std	Z+7, r19	; 0x07
    6c94:	40 87       	std	Z+8, r20	; 0x08
    6c96:	51 87       	std	Z+9, r21	; 0x09
    6c98:	e9 81       	ldd	r30, Y+1	; 0x01
    6c9a:	fa 81       	ldd	r31, Y+2	; 0x02
    6c9c:	80 81       	ld	r24, Z
    6c9e:	91 81       	ldd	r25, Z+1	; 0x01
    6ca0:	80 0f       	add	r24, r16
    6ca2:	91 1f       	adc	r25, r17
    6ca4:	91 83       	std	Z+1, r25	; 0x01
    6ca6:	80 83       	st	Z, r24
    6ca8:	40 1a       	sub	r4, r16
    6caa:	51 0a       	sbc	r5, r17
	if (!(fp->flag & FA_READ)) 						/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
	remain = fp->fsize - fp->fptr;
	if (btr > remain) btr = (UINT)remain;			/* Truncate btr by remaining bytes */

	for ( ;  btr;									/* Repeat until all data transferred */
    6cac:	09 f4       	brne	.+2      	; 0x6cb0 <f_read+0x15a>
    6cae:	57 c0       	rjmp	.+174    	; 0x6d5e <f_read+0x208>
		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
    6cb0:	20 0e       	add	r2, r16
    6cb2:	31 1e       	adc	r3, r17
    6cb4:	79 01       	movw	r14, r18
    6cb6:	8a 01       	movw	r16, r20
    6cb8:	9c cf       	rjmp	.-200    	; 0x6bf2 <f_read+0x9c>
		if ((fp->fptr % SS(fp->fs)) == 0) {			/* On the sector boundary? */
			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
    6cba:	f6 01       	movw	r30, r12
    6cbc:	01 90       	ld	r0, Z+
    6cbe:	f0 81       	ld	r31, Z
    6cc0:	e0 2d       	mov	r30, r0
    6cc2:	fc 83       	std	Y+4, r31	; 0x04
    6cc4:	eb 83       	std	Y+3, r30	; 0x03
    6cc6:	d8 01       	movw	r26, r16
    6cc8:	c7 01       	movw	r24, r14
    6cca:	49 e0       	ldi	r20, 0x09	; 9
    6ccc:	b6 95       	lsr	r27
    6cce:	a7 95       	ror	r26
    6cd0:	97 95       	ror	r25
    6cd2:	87 95       	ror	r24
    6cd4:	4a 95       	dec	r20
    6cd6:	d1 f7       	brne	.-12     	; 0x6ccc <f_read+0x176>
    6cd8:	72 80       	ldd	r7, Z+2	; 0x02
    6cda:	7a 94       	dec	r7
    6cdc:	78 22       	and	r7, r24
			if (!csect) {							/* On the cluster boundary? */
    6cde:	11 f5       	brne	.+68     	; 0x6d24 <f_read+0x1ce>
				clst = (fp->fptr == 0) ?			/* On the top of the file? */
    6ce0:	e1 14       	cp	r14, r1
    6ce2:	f1 04       	cpc	r15, r1
    6ce4:	01 05       	cpc	r16, r1
    6ce6:	11 05       	cpc	r17, r1
    6ce8:	09 f0       	breq	.+2      	; 0x6cec <f_read+0x196>
    6cea:	d5 c0       	rjmp	.+426    	; 0x6e96 <f_read+0x340>
    6cec:	f6 01       	movw	r30, r12
    6cee:	66 85       	ldd	r22, Z+14	; 0x0e
    6cf0:	77 85       	ldd	r23, Z+15	; 0x0f
    6cf2:	80 89       	ldd	r24, Z+16	; 0x10
    6cf4:	91 89       	ldd	r25, Z+17	; 0x11
					fp->org_clust : get_fat(fp->fs, fp->curr_clust);
				if (clst <= 1) ABORT(fp->fs, FR_INT_ERR);
    6cf6:	62 30       	cpi	r22, 0x02	; 2
    6cf8:	71 05       	cpc	r23, r1
    6cfa:	81 05       	cpc	r24, r1
    6cfc:	91 05       	cpc	r25, r1
    6cfe:	48 f1       	brcs	.+82     	; 0x6d52 <f_read+0x1fc>
				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
    6d00:	6f 3f       	cpi	r22, 0xFF	; 255
    6d02:	ff ef       	ldi	r31, 0xFF	; 255
    6d04:	7f 07       	cpc	r23, r31
    6d06:	ff ef       	ldi	r31, 0xFF	; 255
    6d08:	8f 07       	cpc	r24, r31
    6d0a:	ff ef       	ldi	r31, 0xFF	; 255
    6d0c:	9f 07       	cpc	r25, r31
    6d0e:	09 f4       	brne	.+2      	; 0x6d12 <f_read+0x1bc>
    6d10:	ce c0       	rjmp	.+412    	; 0x6eae <f_read+0x358>
				fp->curr_clust = clst;				/* Update current cluster */
    6d12:	f6 01       	movw	r30, r12
    6d14:	62 8b       	std	Z+18, r22	; 0x12
    6d16:	73 8b       	std	Z+19, r23	; 0x13
    6d18:	84 8b       	std	Z+20, r24	; 0x14
    6d1a:	95 8b       	std	Z+21, r25	; 0x15
    6d1c:	80 81       	ld	r24, Z
    6d1e:	91 81       	ldd	r25, Z+1	; 0x01
    6d20:	9c 83       	std	Y+4, r25	; 0x04
    6d22:	8b 83       	std	Y+3, r24	; 0x03
DWORD clust2sect (	/* !=0: Sector number, 0: Failed - invalid cluster# */
	FATFS *fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
    6d24:	f6 01       	movw	r30, r12
    6d26:	22 89       	ldd	r18, Z+18	; 0x12
    6d28:	33 89       	ldd	r19, Z+19	; 0x13
    6d2a:	44 89       	ldd	r20, Z+20	; 0x14
    6d2c:	55 89       	ldd	r21, Z+21	; 0x15
    6d2e:	22 50       	subi	r18, 0x02	; 2
    6d30:	30 40       	sbci	r19, 0x00	; 0
    6d32:	40 40       	sbci	r20, 0x00	; 0
    6d34:	50 40       	sbci	r21, 0x00	; 0
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
    6d36:	eb 81       	ldd	r30, Y+3	; 0x03
    6d38:	fc 81       	ldd	r31, Y+4	; 0x04
    6d3a:	86 89       	ldd	r24, Z+22	; 0x16
    6d3c:	97 89       	ldd	r25, Z+23	; 0x17
    6d3e:	a0 8d       	ldd	r26, Z+24	; 0x18
    6d40:	b1 8d       	ldd	r27, Z+25	; 0x19
    6d42:	02 97       	sbiw	r24, 0x02	; 2
    6d44:	a1 09       	sbc	r26, r1
    6d46:	b1 09       	sbc	r27, r1
    6d48:	28 17       	cp	r18, r24
    6d4a:	39 07       	cpc	r19, r25
    6d4c:	4a 07       	cpc	r20, r26
    6d4e:	5b 07       	cpc	r21, r27
    6d50:	08 f1       	brcs	.+66     	; 0x6d94 <f_read+0x23e>
				if (clst <= 1) ABORT(fp->fs, FR_INT_ERR);
				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
				fp->curr_clust = clst;				/* Update current cluster */
			}
			sect = clust2sect(fp->fs, fp->curr_clust);	/* Get current sector */
			if (!sect) ABORT(fp->fs, FR_INT_ERR);
    6d52:	f6 01       	movw	r30, r12
    6d54:	84 81       	ldd	r24, Z+4	; 0x04
    6d56:	80 68       	ori	r24, 0x80	; 128
    6d58:	84 83       	std	Z+4, r24	; 0x04
    6d5a:	32 e0       	ldi	r19, 0x02	; 2
    6d5c:	63 2e       	mov	r6, r19
		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
#endif
	}

	LEAVE_FF(fp->fs, FR_OK);
}
    6d5e:	86 2d       	mov	r24, r6
    6d60:	0f 90       	pop	r0
    6d62:	0f 90       	pop	r0
    6d64:	0f 90       	pop	r0
    6d66:	0f 90       	pop	r0
    6d68:	cf 91       	pop	r28
    6d6a:	df 91       	pop	r29
    6d6c:	1f 91       	pop	r17
    6d6e:	0f 91       	pop	r16
    6d70:	ff 90       	pop	r15
    6d72:	ef 90       	pop	r14
    6d74:	df 90       	pop	r13
    6d76:	cf 90       	pop	r12
    6d78:	bf 90       	pop	r11
    6d7a:	af 90       	pop	r10
    6d7c:	9f 90       	pop	r9
    6d7e:	8f 90       	pop	r8
    6d80:	7f 90       	pop	r7
    6d82:	6f 90       	pop	r6
    6d84:	5f 90       	pop	r5
    6d86:	4f 90       	pop	r4
    6d88:	3f 90       	pop	r3
    6d8a:	2f 90       	pop	r2
    6d8c:	08 95       	ret

	res = validate(fp->fs, fp->id);					/* Check validity of the object */
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
	if (fp->flag & FA__ERROR)						/* Check abort flag */
		LEAVE_FF(fp->fs, FR_INT_ERR);
	if (!(fp->flag & FA_READ)) 						/* Check access mode */
    6d8e:	57 e0       	ldi	r21, 0x07	; 7
    6d90:	65 2e       	mov	r6, r21
    6d92:	e5 cf       	rjmp	.-54     	; 0x6d5e <f_read+0x208>
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
	return clst * fs->csize + fs->database;
    6d94:	12 81       	ldd	r17, Z+2	; 0x02
    6d96:	61 2f       	mov	r22, r17
    6d98:	70 e0       	ldi	r23, 0x00	; 0
    6d9a:	80 e0       	ldi	r24, 0x00	; 0
    6d9c:	90 e0       	ldi	r25, 0x00	; 0
    6d9e:	0e 94 bb 7f 	call	0xff76	; 0xff76 <__mulsi3>
    6da2:	9b 01       	movw	r18, r22
    6da4:	ac 01       	movw	r20, r24
    6da6:	eb 81       	ldd	r30, Y+3	; 0x03
    6da8:	fc 81       	ldd	r31, Y+4	; 0x04
    6daa:	86 a1       	ldd	r24, Z+38	; 0x26
    6dac:	97 a1       	ldd	r25, Z+39	; 0x27
    6dae:	a0 a5       	ldd	r26, Z+40	; 0x28
    6db0:	b1 a5       	ldd	r27, Z+41	; 0x29
    6db2:	28 0f       	add	r18, r24
    6db4:	39 1f       	adc	r19, r25
    6db6:	4a 1f       	adc	r20, r26
    6db8:	5b 1f       	adc	r21, r27
				if (clst <= 1) ABORT(fp->fs, FR_INT_ERR);
				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
				fp->curr_clust = clst;				/* Update current cluster */
			}
			sect = clust2sect(fp->fs, fp->curr_clust);	/* Get current sector */
			if (!sect) ABORT(fp->fs, FR_INT_ERR);
    6dba:	21 15       	cp	r18, r1
    6dbc:	31 05       	cpc	r19, r1
    6dbe:	41 05       	cpc	r20, r1
    6dc0:	51 05       	cpc	r21, r1
    6dc2:	39 f2       	breq	.-114    	; 0x6d52 <f_read+0x1fc>
			sect += csect;
    6dc4:	49 01       	movw	r8, r18
    6dc6:	5a 01       	movw	r10, r20
    6dc8:	87 0c       	add	r8, r7
    6dca:	91 1c       	adc	r9, r1
    6dcc:	a1 1c       	adc	r10, r1
    6dce:	b1 1c       	adc	r11, r1
			cc = btr / SS(fp->fs);					/* When remaining bytes >= sector size, */
    6dd0:	72 01       	movw	r14, r4
    6dd2:	ef 2c       	mov	r14, r15
    6dd4:	ff 24       	eor	r15, r15
    6dd6:	e6 94       	lsr	r14
			if (cc) {								/* Read maximum contiguous sectors directly */
    6dd8:	e1 14       	cp	r14, r1
    6dda:	f1 04       	cpc	r15, r1
    6ddc:	09 f4       	brne	.+2      	; 0x6de0 <f_read+0x28a>
    6dde:	51 c0       	rjmp	.+162    	; 0x6e82 <f_read+0x32c>
				if (csect + cc > fp->fs->csize)		/* Clip at cluster boundary */
    6de0:	27 2d       	mov	r18, r7
    6de2:	30 e0       	ldi	r19, 0x00	; 0
    6de4:	c9 01       	movw	r24, r18
    6de6:	8e 0d       	add	r24, r14
    6de8:	9f 1d       	adc	r25, r15
    6dea:	61 2f       	mov	r22, r17
    6dec:	70 e0       	ldi	r23, 0x00	; 0
    6dee:	68 17       	cp	r22, r24
    6df0:	79 07       	cpc	r23, r25
    6df2:	18 f4       	brcc	.+6      	; 0x6dfa <f_read+0x2a4>
					cc = fp->fs->csize - csect;
    6df4:	7b 01       	movw	r14, r22
    6df6:	e2 1a       	sub	r14, r18
    6df8:	f3 0a       	sbc	r15, r19
				if (disk_read(fp->fs->drv, rbuff, sect, (BYTE)cc) != RES_OK)
    6dfa:	eb 81       	ldd	r30, Y+3	; 0x03
    6dfc:	fc 81       	ldd	r31, Y+4	; 0x04
    6dfe:	81 81       	ldd	r24, Z+1	; 0x01
    6e00:	b1 01       	movw	r22, r2
    6e02:	a5 01       	movw	r20, r10
    6e04:	94 01       	movw	r18, r8
    6e06:	0e 2d       	mov	r16, r14
    6e08:	0e 94 89 24 	call	0x4912	; 0x4912 <disk_read>
    6e0c:	88 23       	and	r24, r24
    6e0e:	09 f0       	breq	.+2      	; 0x6e12 <f_read+0x2bc>
    6e10:	4e c0       	rjmp	.+156    	; 0x6eae <f_read+0x358>
					ABORT(fp->fs, FR_DISK_ERR);
#if !_FS_READONLY && _FS_MINIMIZE <= 2				/* Replace one of the read sectors with cached data if it contains a dirty sector */
#if _FS_TINY
				if (fp->fs->wflag && fp->fs->winsect - sect < cc)
    6e12:	f6 01       	movw	r30, r12
    6e14:	01 90       	ld	r0, Z+
    6e16:	f0 81       	ld	r31, Z
    6e18:	e0 2d       	mov	r30, r0
    6e1a:	fc 83       	std	Y+4, r31	; 0x04
    6e1c:	eb 83       	std	Y+3, r30	; 0x03
    6e1e:	84 81       	ldd	r24, Z+4	; 0x04
    6e20:	88 23       	and	r24, r24
    6e22:	29 f1       	breq	.+74     	; 0x6e6e <f_read+0x318>
    6e24:	22 a5       	ldd	r18, Z+42	; 0x2a
    6e26:	33 a5       	ldd	r19, Z+43	; 0x2b
    6e28:	44 a5       	ldd	r20, Z+44	; 0x2c
    6e2a:	55 a5       	ldd	r21, Z+45	; 0x2d
    6e2c:	28 19       	sub	r18, r8
    6e2e:	39 09       	sbc	r19, r9
    6e30:	4a 09       	sbc	r20, r10
    6e32:	5b 09       	sbc	r21, r11
    6e34:	c7 01       	movw	r24, r14
    6e36:	a0 e0       	ldi	r26, 0x00	; 0
    6e38:	b0 e0       	ldi	r27, 0x00	; 0
    6e3a:	28 17       	cp	r18, r24
    6e3c:	39 07       	cpc	r19, r25
    6e3e:	4a 07       	cpc	r20, r26
    6e40:	5b 07       	cpc	r21, r27
    6e42:	a8 f4       	brcc	.+42     	; 0x6e6e <f_read+0x318>
/*-----------------------------------------------------------------------*/

/* Copy memory to memory */
static
void mem_cpy (void* dst, const void* src, UINT cnt) {
	BYTE *d = (BYTE*)dst;
    6e44:	99 e0       	ldi	r25, 0x09	; 9
    6e46:	22 0f       	add	r18, r18
    6e48:	33 1f       	adc	r19, r19
    6e4a:	44 1f       	adc	r20, r20
    6e4c:	55 1f       	adc	r21, r21
    6e4e:	9a 95       	dec	r25
    6e50:	d1 f7       	brne	.-12     	; 0x6e46 <f_read+0x2f0>
    6e52:	c1 01       	movw	r24, r2
    6e54:	82 0f       	add	r24, r18
    6e56:	93 1f       	adc	r25, r19
	const BYTE *s = (const BYTE*)src;
    6e58:	df 01       	movw	r26, r30
    6e5a:	9e 96       	adiw	r26, 0x2e	; 46
    6e5c:	fc 01       	movw	r30, r24
    6e5e:	9c 01       	movw	r18, r24
    6e60:	20 50       	subi	r18, 0x00	; 0
    6e62:	3e 4f       	sbci	r19, 0xFE	; 254
		d += sizeof(int); s += sizeof(int);
		cnt -= sizeof(int);
	}
#endif
	while (cnt--)
		*d++ = *s++;
    6e64:	8d 91       	ld	r24, X+
    6e66:	81 93       	st	Z+, r24
		*(int*)d = *(int*)s;
		d += sizeof(int); s += sizeof(int);
		cnt -= sizeof(int);
	}
#endif
	while (cnt--)
    6e68:	e2 17       	cp	r30, r18
    6e6a:	f3 07       	cpc	r31, r19
    6e6c:	d9 f7       	brne	.-10     	; 0x6e64 <f_read+0x30e>
#else
				if ((fp->flag & FA__DIRTY) && fp->dsect - sect < cc)
					mem_cpy(rbuff + ((fp->dsect - sect) * SS(fp->fs)), fp->buf, SS(fp->fs));
#endif
#endif
				rcnt = SS(fp->fs) * cc;				/* Number of bytes transferred */
    6e6e:	87 01       	movw	r16, r14
    6e70:	10 2f       	mov	r17, r16
    6e72:	00 27       	eor	r16, r16
    6e74:	11 0f       	add	r17, r17
    6e76:	f6 01       	movw	r30, r12
    6e78:	66 81       	ldd	r22, Z+6	; 0x06
    6e7a:	77 81       	ldd	r23, Z+7	; 0x07
    6e7c:	80 85       	ldd	r24, Z+8	; 0x08
    6e7e:	91 85       	ldd	r25, Z+9	; 0x09
    6e80:	ff ce       	rjmp	.-514    	; 0x6c80 <f_read+0x12a>
			if (fp->dsect != sect) {				/* Fill sector buffer with file data */
				if (disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)
					ABORT(fp->fs, FR_DISK_ERR);
			}
#endif
			fp->dsect = sect;
    6e82:	f6 01       	movw	r30, r12
    6e84:	86 8a       	std	Z+22, r8	; 0x16
    6e86:	97 8a       	std	Z+23, r9	; 0x17
    6e88:	a0 8e       	std	Z+24, r10	; 0x18
    6e8a:	b1 8e       	std	Z+25, r11	; 0x19
    6e8c:	e6 80       	ldd	r14, Z+6	; 0x06
    6e8e:	f7 80       	ldd	r15, Z+7	; 0x07
    6e90:	00 85       	ldd	r16, Z+8	; 0x08
    6e92:	11 85       	ldd	r17, Z+9	; 0x09
    6e94:	be ce       	rjmp	.-644    	; 0x6c12 <f_read+0xbc>
	for ( ;  btr;									/* Repeat until all data transferred */
		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
		if ((fp->fptr % SS(fp->fs)) == 0) {			/* On the sector boundary? */
			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
			if (!csect) {							/* On the cluster boundary? */
				clst = (fp->fptr == 0) ?			/* On the top of the file? */
    6e96:	f6 01       	movw	r30, r12
    6e98:	42 89       	ldd	r20, Z+18	; 0x12
    6e9a:	53 89       	ldd	r21, Z+19	; 0x13
    6e9c:	64 89       	ldd	r22, Z+20	; 0x14
    6e9e:	75 89       	ldd	r23, Z+21	; 0x15
    6ea0:	8b 81       	ldd	r24, Y+3	; 0x03
    6ea2:	9c 81       	ldd	r25, Y+4	; 0x04
    6ea4:	0e 94 1d 28 	call	0x503a	; 0x503a <get_fat>
    6ea8:	26 cf       	rjmp	.-436    	; 0x6cf6 <f_read+0x1a0>
	if (fp->flag & FA__ERROR)						/* Check abort flag */
		LEAVE_FF(fp->fs, FR_INT_ERR);
	if (!(fp->flag & FA_READ)) 						/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
	remain = fp->fsize - fp->fptr;
	if (btr > remain) btr = (UINT)remain;			/* Truncate btr by remaining bytes */
    6eaa:	29 01       	movw	r4, r18
    6eac:	9a ce       	rjmp	.-716    	; 0x6be2 <f_read+0x8c>
		}
		rcnt = SS(fp->fs) - (fp->fptr % SS(fp->fs));	/* Get partial sector data from sector buffer */
		if (rcnt > btr) rcnt = btr;
#if _FS_TINY
		if (move_window(fp->fs, fp->dsect))			/* Move sector window */
			ABORT(fp->fs, FR_DISK_ERR);
    6eae:	f6 01       	movw	r30, r12
    6eb0:	84 81       	ldd	r24, Z+4	; 0x04
    6eb2:	80 68       	ori	r24, 0x80	; 128
    6eb4:	84 83       	std	Z+4, r24	; 0x04
    6eb6:	66 24       	eor	r6, r6
    6eb8:	63 94       	inc	r6
    6eba:	51 cf       	rjmp	.-350    	; 0x6d5e <f_read+0x208>
		LEAVE_FF(fp->fs, FR_DENIED);
	remain = fp->fsize - fp->fptr;
	if (btr > remain) btr = (UINT)remain;			/* Truncate btr by remaining bytes */

	for ( ;  btr;									/* Repeat until all data transferred */
		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
    6ebc:	b2 e0       	ldi	r27, 0x02	; 2
    6ebe:	6b 2e       	mov	r6, r27
    6ec0:	4e cf       	rjmp	.-356    	; 0x6d5e <f_read+0x208>

00006ec2 <chk_mounted>:
FRESULT chk_mounted (	/* FR_OK(0): successful, !=0: any error occurred */
	const TCHAR **path,	/* Pointer to pointer to the path name (drive number) */
	FATFS **rfs,		/* Pointer to pointer to the found file system object */
	BYTE chk_wp			/* !=0: Check media write protection for write access */
)
{
    6ec2:	2f 92       	push	r2
    6ec4:	3f 92       	push	r3
    6ec6:	4f 92       	push	r4
    6ec8:	5f 92       	push	r5
    6eca:	6f 92       	push	r6
    6ecc:	7f 92       	push	r7
    6ece:	8f 92       	push	r8
    6ed0:	9f 92       	push	r9
    6ed2:	af 92       	push	r10
    6ed4:	bf 92       	push	r11
    6ed6:	cf 92       	push	r12
    6ed8:	df 92       	push	r13
    6eda:	ef 92       	push	r14
    6edc:	ff 92       	push	r15
    6ede:	0f 93       	push	r16
    6ee0:	1f 93       	push	r17
    6ee2:	df 93       	push	r29
    6ee4:	cf 93       	push	r28
    6ee6:	cd b7       	in	r28, 0x3d	; 61
    6ee8:	de b7       	in	r29, 0x3e	; 62
    6eea:	2a 97       	sbiw	r28, 0x0a	; 10
    6eec:	0f b6       	in	r0, 0x3f	; 63
    6eee:	f8 94       	cli
    6ef0:	de bf       	out	0x3e, r29	; 62
    6ef2:	0f be       	out	0x3f, r0	; 63
    6ef4:	cd bf       	out	0x3d, r28	; 61
    6ef6:	dc 01       	movw	r26, r24
    6ef8:	04 2f       	mov	r16, r20
	BYTE fmt, b, *tbl;
	UINT vol;
	DSTATUS stat;
	DWORD bsect, fasize, tsect, sysect, nclst, szbfat;
	WORD nrsv;
	const TCHAR *p = *path;
    6efa:	ed 91       	ld	r30, X+
    6efc:	fc 91       	ld	r31, X
    6efe:	11 97       	sbiw	r26, 0x01	; 1
	FATFS *fs;

	/* Get logical drive number from the path name */
	vol = p[0] - '0';					/* Is there a drive number? */
    6f00:	80 81       	ld	r24, Z
    6f02:	28 2f       	mov	r18, r24
    6f04:	30 e0       	ldi	r19, 0x00	; 0
    6f06:	20 53       	subi	r18, 0x30	; 48
    6f08:	30 40       	sbci	r19, 0x00	; 0
	if (vol <= 9 && p[1] == ':') {		/* Found a drive number, get and strip it */
    6f0a:	2a 30       	cpi	r18, 0x0A	; 10
    6f0c:	31 05       	cpc	r19, r1
    6f0e:	20 f4       	brcc	.+8      	; 0x6f18 <chk_mounted+0x56>
    6f10:	81 81       	ldd	r24, Z+1	; 0x01
    6f12:	8a 33       	cpi	r24, 0x3A	; 58
    6f14:	09 f4       	brne	.+2      	; 0x6f18 <chk_mounted+0x56>
    6f16:	60 c0       	rjmp	.+192    	; 0x6fd8 <chk_mounted+0x116>
	}

	/* Check if the logical drive is valid or not */
	if (vol >= _VOLUMES) 				/* Is the drive number valid? */
		return FR_INVALID_DRIVE;
	*rfs = fs = FatFs[vol];				/* Return pointer to the corresponding file system object */
    6f18:	e0 90 22 07 	lds	r14, 0x0722
    6f1c:	f0 90 23 07 	lds	r15, 0x0723
    6f20:	db 01       	movw	r26, r22
    6f22:	ed 92       	st	X+, r14
    6f24:	fc 92       	st	X, r15
	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
    6f26:	e1 14       	cp	r14, r1
    6f28:	f1 04       	cpc	r15, r1
    6f2a:	09 f4       	brne	.+2      	; 0x6f2e <chk_mounted+0x6c>
    6f2c:	5f c0       	rjmp	.+190    	; 0x6fec <chk_mounted+0x12a>

	ENTER_FF(fs);						/* Lock file system */

	if (fs->fs_type) {					/* If the logical drive has been mounted */
    6f2e:	f7 01       	movw	r30, r14
    6f30:	80 81       	ld	r24, Z
    6f32:	88 23       	and	r24, r24
    6f34:	61 f5       	brne	.+88     	; 0x6f8e <chk_mounted+0xcc>
	}

	/* The logical drive must be mounted. */
	/* Following code attempts to mount a volume. (analyze BPB and initialize the fs object) */

	fs->fs_type = 0;					/* Clear the file system object */
    6f36:	d7 01       	movw	r26, r14
    6f38:	1c 92       	st	X, r1
	fs->drv = (BYTE)LD2PD(vol);			/* Bind the logical drive and a physical drive */
    6f3a:	11 96       	adiw	r26, 0x01	; 1
    6f3c:	1c 92       	st	X, r1
	stat = disk_initialize(fs->drv);	/* Initialize low level disk I/O layer */
    6f3e:	80 e0       	ldi	r24, 0x00	; 0
    6f40:	0e 94 94 23 	call	0x4728	; 0x4728 <disk_initialize>
	if (stat & STA_NOINIT)				/* Check if the initialization succeeded */
    6f44:	80 fd       	sbrc	r24, 0
    6f46:	46 c0       	rjmp	.+140    	; 0x6fd4 <chk_mounted+0x112>
#if _MAX_SS != 512						/* Get disk sector size (variable sector size cfg only) */
	if (disk_ioctl(fs->drv, GET_SECTOR_SIZE, &fs->ssize) != RES_OK)
		return FR_DISK_ERR;
#endif
#if !_FS_READONLY
	if (chk_wp && (stat & STA_PROTECT))	/* Check disk write protection if needed */
    6f48:	00 23       	and	r16, r16
    6f4a:	11 f0       	breq	.+4      	; 0x6f50 <chk_mounted+0x8e>
    6f4c:	82 fd       	sbrc	r24, 2
    6f4e:	28 c0       	rjmp	.+80     	; 0x6fa0 <chk_mounted+0xde>
		return FR_WRITE_PROTECTED;
#endif
	/* Search FAT partition on the drive. Supports only generic partitionings, FDISK and SFD. */
	fmt = check_fs(fs, bsect = 0);		/* Check sector 0 if it is a VBR */
    6f50:	c7 01       	movw	r24, r14
    6f52:	40 e0       	ldi	r20, 0x00	; 0
    6f54:	50 e0       	ldi	r21, 0x00	; 0
    6f56:	60 e0       	ldi	r22, 0x00	; 0
    6f58:	70 e0       	ldi	r23, 0x00	; 0
    6f5a:	0e 94 1e 35 	call	0x6a3c	; 0x6a3c <check_fs>
	if (fmt == 1) {						/* Not an FAT-VBR, the disk may be partitioned */
    6f5e:	81 30       	cpi	r24, 0x01	; 1
    6f60:	09 f4       	brne	.+2      	; 0x6f64 <chk_mounted+0xa2>
    6f62:	46 c0       	rjmp	.+140    	; 0x6ff0 <chk_mounted+0x12e>
    6f64:	66 24       	eor	r6, r6
    6f66:	77 24       	eor	r7, r7
    6f68:	43 01       	movw	r8, r6
		if (tbl[4]) {									/* Is the partition existing? */
			bsect = LD_DWORD(&tbl[8]);					/* Partition offset in LBA */
			fmt = check_fs(fs, bsect);					/* Check the partition */
		}
	}
	if (fmt == 3) return FR_DISK_ERR;
    6f6a:	83 30       	cpi	r24, 0x03	; 3
    6f6c:	09 f4       	brne	.+2      	; 0x6f70 <chk_mounted+0xae>
    6f6e:	62 c2       	rjmp	.+1220   	; 0x7434 <chk_mounted+0x572>
	if (fmt) return FR_NO_FILESYSTEM;					/* No FAT volume is found */
    6f70:	88 23       	and	r24, r24
    6f72:	59 f4       	brne	.+22     	; 0x6f8a <chk_mounted+0xc8>

	/* Following code initializes the file system object */

	if (LD_WORD(fs->win+BPB_BytsPerSec) != SS(fs))		/* (BPB_BytsPerSec must be equal to the physical sector size) */
    6f74:	f7 01       	movw	r30, r14
    6f76:	92 ad       	ldd	r25, Z+58	; 0x3a
    6f78:	80 e0       	ldi	r24, 0x00	; 0
    6f7a:	21 ad       	ldd	r18, Z+57	; 0x39
    6f7c:	30 e0       	ldi	r19, 0x00	; 0
    6f7e:	82 2b       	or	r24, r18
    6f80:	93 2b       	or	r25, r19
    6f82:	80 50       	subi	r24, 0x00	; 0
    6f84:	92 40       	sbci	r25, 0x02	; 2
    6f86:	09 f4       	brne	.+2      	; 0x6f8a <chk_mounted+0xc8>
    6f88:	62 c0       	rjmp	.+196    	; 0x704e <chk_mounted+0x18c>
#endif
#if _FS_SHARE				/* Clear file lock semaphores */
	clear_lock(fs);
#endif

	return FR_OK;
    6f8a:	8d e0       	ldi	r24, 0x0D	; 13
    6f8c:	0a c0       	rjmp	.+20     	; 0x6fa2 <chk_mounted+0xe0>
	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */

	ENTER_FF(fs);						/* Lock file system */

	if (fs->fs_type) {					/* If the logical drive has been mounted */
		stat = disk_status(fs->drv);
    6f8e:	81 81       	ldd	r24, Z+1	; 0x01
    6f90:	0e 94 87 23 	call	0x470e	; 0x470e <disk_status>
		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized (has not been changed), */
    6f94:	80 fd       	sbrc	r24, 0
    6f96:	cf cf       	rjmp	.-98     	; 0x6f36 <chk_mounted+0x74>
#if !_FS_READONLY
			if (chk_wp && (stat & STA_PROTECT))	/* Check write protection if needed */
    6f98:	00 23       	and	r16, r16
    6f9a:	31 f1       	breq	.+76     	; 0x6fe8 <chk_mounted+0x126>
    6f9c:	82 ff       	sbrs	r24, 2
    6f9e:	24 c0       	rjmp	.+72     	; 0x6fe8 <chk_mounted+0x126>
#endif
#if _FS_SHARE				/* Clear file lock semaphores */
	clear_lock(fs);
#endif

	return FR_OK;
    6fa0:	8a e0       	ldi	r24, 0x0A	; 10
}
    6fa2:	2a 96       	adiw	r28, 0x0a	; 10
    6fa4:	0f b6       	in	r0, 0x3f	; 63
    6fa6:	f8 94       	cli
    6fa8:	de bf       	out	0x3e, r29	; 62
    6faa:	0f be       	out	0x3f, r0	; 63
    6fac:	cd bf       	out	0x3d, r28	; 61
    6fae:	cf 91       	pop	r28
    6fb0:	df 91       	pop	r29
    6fb2:	1f 91       	pop	r17
    6fb4:	0f 91       	pop	r16
    6fb6:	ff 90       	pop	r15
    6fb8:	ef 90       	pop	r14
    6fba:	df 90       	pop	r13
    6fbc:	cf 90       	pop	r12
    6fbe:	bf 90       	pop	r11
    6fc0:	af 90       	pop	r10
    6fc2:	9f 90       	pop	r9
    6fc4:	8f 90       	pop	r8
    6fc6:	7f 90       	pop	r7
    6fc8:	6f 90       	pop	r6
    6fca:	5f 90       	pop	r5
    6fcc:	4f 90       	pop	r4
    6fce:	3f 90       	pop	r3
    6fd0:	2f 90       	pop	r2
    6fd2:	08 95       	ret
	/* Following code attempts to mount a volume. (analyze BPB and initialize the fs object) */

	fs->fs_type = 0;					/* Clear the file system object */
	fs->drv = (BYTE)LD2PD(vol);			/* Bind the logical drive and a physical drive */
	stat = disk_initialize(fs->drv);	/* Initialize low level disk I/O layer */
	if (stat & STA_NOINIT)				/* Check if the initialization succeeded */
    6fd4:	83 e0       	ldi	r24, 0x03	; 3
    6fd6:	e5 cf       	rjmp	.-54     	; 0x6fa2 <chk_mounted+0xe0>
	FATFS *fs;

	/* Get logical drive number from the path name */
	vol = p[0] - '0';					/* Is there a drive number? */
	if (vol <= 9 && p[1] == ':') {		/* Found a drive number, get and strip it */
		p += 2; *path = p;				/* Return pointer to the path name */
    6fd8:	32 96       	adiw	r30, 0x02	; 2
    6fda:	ed 93       	st	X+, r30
    6fdc:	fc 93       	st	X, r31
		vol = 0;						/* Use drive 0 */
#endif
	}

	/* Check if the logical drive is valid or not */
	if (vol >= _VOLUMES) 				/* Is the drive number valid? */
    6fde:	23 2b       	or	r18, r19
    6fe0:	09 f4       	brne	.+2      	; 0x6fe4 <chk_mounted+0x122>
    6fe2:	9a cf       	rjmp	.-204    	; 0x6f18 <chk_mounted+0x56>
    6fe4:	8b e0       	ldi	r24, 0x0B	; 11
    6fe6:	dd cf       	rjmp	.-70     	; 0x6fa2 <chk_mounted+0xe0>
#endif
#if _FS_SHARE				/* Clear file lock semaphores */
	clear_lock(fs);
#endif

	return FR_OK;
    6fe8:	80 e0       	ldi	r24, 0x00	; 0
    6fea:	db cf       	rjmp	.-74     	; 0x6fa2 <chk_mounted+0xe0>

	/* Check if the logical drive is valid or not */
	if (vol >= _VOLUMES) 				/* Is the drive number valid? */
		return FR_INVALID_DRIVE;
	*rfs = fs = FatFs[vol];				/* Return pointer to the corresponding file system object */
	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
    6fec:	8c e0       	ldi	r24, 0x0C	; 12
    6fee:	d9 cf       	rjmp	.-78     	; 0x6fa2 <chk_mounted+0xe0>
#endif
	/* Search FAT partition on the drive. Supports only generic partitionings, FDISK and SFD. */
	fmt = check_fs(fs, bsect = 0);		/* Check sector 0 if it is a VBR */
	if (fmt == 1) {						/* Not an FAT-VBR, the disk may be partitioned */
		/* Check the partition listed in top of the partition table */
		tbl = &fs->win[MBR_Table + LD2PT(vol) * 16];	/* Partition table */
    6ff0:	f7 01       	movw	r30, r14
    6ff2:	e4 51       	subi	r30, 0x14	; 20
    6ff4:	fe 4f       	sbci	r31, 0xFE	; 254
		if (tbl[4]) {									/* Is the partition existing? */
    6ff6:	84 81       	ldd	r24, Z+4	; 0x04
    6ff8:	88 23       	and	r24, r24
    6ffa:	39 f2       	breq	.-114    	; 0x6f8a <chk_mounted+0xc8>
			bsect = LD_DWORD(&tbl[8]);					/* Partition offset in LBA */
    6ffc:	83 85       	ldd	r24, Z+11	; 0x0b
    6ffe:	90 e0       	ldi	r25, 0x00	; 0
    7000:	a0 e0       	ldi	r26, 0x00	; 0
    7002:	b0 e0       	ldi	r27, 0x00	; 0
    7004:	98 2e       	mov	r9, r24
    7006:	88 24       	eor	r8, r8
    7008:	77 24       	eor	r7, r7
    700a:	66 24       	eor	r6, r6
    700c:	82 85       	ldd	r24, Z+10	; 0x0a
    700e:	90 e0       	ldi	r25, 0x00	; 0
    7010:	a0 e0       	ldi	r26, 0x00	; 0
    7012:	b0 e0       	ldi	r27, 0x00	; 0
    7014:	dc 01       	movw	r26, r24
    7016:	99 27       	eor	r25, r25
    7018:	88 27       	eor	r24, r24
    701a:	68 2a       	or	r6, r24
    701c:	79 2a       	or	r7, r25
    701e:	8a 2a       	or	r8, r26
    7020:	9b 2a       	or	r9, r27
    7022:	80 85       	ldd	r24, Z+8	; 0x08
    7024:	90 e0       	ldi	r25, 0x00	; 0
    7026:	a0 e0       	ldi	r26, 0x00	; 0
    7028:	b0 e0       	ldi	r27, 0x00	; 0
    702a:	68 2a       	or	r6, r24
    702c:	79 2a       	or	r7, r25
    702e:	8a 2a       	or	r8, r26
    7030:	9b 2a       	or	r9, r27
    7032:	91 85       	ldd	r25, Z+9	; 0x09
    7034:	80 e0       	ldi	r24, 0x00	; 0
    7036:	a0 e0       	ldi	r26, 0x00	; 0
    7038:	b0 e0       	ldi	r27, 0x00	; 0
    703a:	68 2a       	or	r6, r24
    703c:	79 2a       	or	r7, r25
    703e:	8a 2a       	or	r8, r26
    7040:	9b 2a       	or	r9, r27
			fmt = check_fs(fs, bsect);					/* Check the partition */
    7042:	c7 01       	movw	r24, r14
    7044:	b4 01       	movw	r22, r8
    7046:	a3 01       	movw	r20, r6
    7048:	0e 94 1e 35 	call	0x6a3c	; 0x6a3c <check_fs>
    704c:	8e cf       	rjmp	.-228    	; 0x6f6a <chk_mounted+0xa8>
	/* Following code initializes the file system object */

	if (LD_WORD(fs->win+BPB_BytsPerSec) != SS(fs))		/* (BPB_BytsPerSec must be equal to the physical sector size) */
		return FR_NO_FILESYSTEM;

	fasize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
    704e:	25 e4       	ldi	r18, 0x45	; 69
    7050:	30 e0       	ldi	r19, 0x00	; 0
    7052:	e2 0e       	add	r14, r18
    7054:	f3 1e       	adc	r15, r19
    7056:	d7 01       	movw	r26, r14
    7058:	9c 91       	ld	r25, X
    705a:	80 e0       	ldi	r24, 0x00	; 0
    705c:	f7 01       	movw	r30, r14
    705e:	22 91       	ld	r18, -Z
    7060:	7f 01       	movw	r14, r30
    7062:	4c eb       	ldi	r20, 0xBC	; 188
    7064:	5f ef       	ldi	r21, 0xFF	; 255
    7066:	e4 0e       	add	r14, r20
    7068:	f5 1e       	adc	r15, r21
    706a:	30 e0       	ldi	r19, 0x00	; 0
    706c:	82 2b       	or	r24, r18
    706e:	93 2b       	or	r25, r19
    7070:	5c 01       	movw	r10, r24
    7072:	cc 24       	eor	r12, r12
    7074:	dd 24       	eor	r13, r13
	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
    7076:	a1 14       	cp	r10, r1
    7078:	b1 04       	cpc	r11, r1
    707a:	c1 04       	cpc	r12, r1
    707c:	d1 04       	cpc	r13, r1
    707e:	a9 f5       	brne	.+106    	; 0x70ea <chk_mounted+0x228>
    7080:	65 e5       	ldi	r22, 0x55	; 85
    7082:	70 e0       	ldi	r23, 0x00	; 0
    7084:	e6 0e       	add	r14, r22
    7086:	f7 1e       	adc	r15, r23
    7088:	d7 01       	movw	r26, r14
    708a:	8c 91       	ld	r24, X
    708c:	90 e0       	ldi	r25, 0x00	; 0
    708e:	a0 e0       	ldi	r26, 0x00	; 0
    7090:	b0 e0       	ldi	r27, 0x00	; 0
    7092:	d8 2e       	mov	r13, r24
    7094:	cc 24       	eor	r12, r12
    7096:	bb 24       	eor	r11, r11
    7098:	aa 24       	eor	r10, r10
    709a:	f7 01       	movw	r30, r14
    709c:	82 91       	ld	r24, -Z
    709e:	7f 01       	movw	r14, r30
    70a0:	90 e0       	ldi	r25, 0x00	; 0
    70a2:	a0 e0       	ldi	r26, 0x00	; 0
    70a4:	b0 e0       	ldi	r27, 0x00	; 0
    70a6:	dc 01       	movw	r26, r24
    70a8:	99 27       	eor	r25, r25
    70aa:	88 27       	eor	r24, r24
    70ac:	a8 2a       	or	r10, r24
    70ae:	b9 2a       	or	r11, r25
    70b0:	ca 2a       	or	r12, r26
    70b2:	db 2a       	or	r13, r27
    70b4:	2e ef       	ldi	r18, 0xFE	; 254
    70b6:	3f ef       	ldi	r19, 0xFF	; 255
    70b8:	e2 0e       	add	r14, r18
    70ba:	f3 1e       	adc	r15, r19
    70bc:	d7 01       	movw	r26, r14
    70be:	8d 91       	ld	r24, X+
    70c0:	7d 01       	movw	r14, r26
    70c2:	90 e0       	ldi	r25, 0x00	; 0
    70c4:	a0 e0       	ldi	r26, 0x00	; 0
    70c6:	b0 e0       	ldi	r27, 0x00	; 0
    70c8:	a8 2a       	or	r10, r24
    70ca:	b9 2a       	or	r11, r25
    70cc:	ca 2a       	or	r12, r26
    70ce:	db 2a       	or	r13, r27
    70d0:	f7 01       	movw	r30, r14
    70d2:	90 81       	ld	r25, Z
    70d4:	2d ea       	ldi	r18, 0xAD	; 173
    70d6:	3f ef       	ldi	r19, 0xFF	; 255
    70d8:	e2 0e       	add	r14, r18
    70da:	f3 1e       	adc	r15, r19
    70dc:	80 e0       	ldi	r24, 0x00	; 0
    70de:	a0 e0       	ldi	r26, 0x00	; 0
    70e0:	b0 e0       	ldi	r27, 0x00	; 0
    70e2:	a8 2a       	or	r10, r24
    70e4:	b9 2a       	or	r11, r25
    70e6:	ca 2a       	or	r12, r26
    70e8:	db 2a       	or	r13, r27
	fs->fsize = fasize;
    70ea:	d7 01       	movw	r26, r14
    70ec:	5a 96       	adiw	r26, 0x1a	; 26
    70ee:	ad 92       	st	X+, r10
    70f0:	bd 92       	st	X+, r11
    70f2:	cd 92       	st	X+, r12
    70f4:	dc 92       	st	X, r13
    70f6:	5d 97       	sbiw	r26, 0x1d	; 29

	fs->n_fats = b = fs->win[BPB_NumFATs];				/* Number of FAT copies */
    70f8:	de 96       	adiw	r26, 0x3e	; 62
    70fa:	4c 91       	ld	r20, X
    70fc:	de 97       	sbiw	r26, 0x3e	; 62
    70fe:	13 96       	adiw	r26, 0x03	; 3
    7100:	4c 93       	st	X, r20
    7102:	13 97       	sbiw	r26, 0x03	; 3
	if (b != 1 && b != 2) return FR_NO_FILESYSTEM;		/* (Must be 1 or 2) */
    7104:	84 2f       	mov	r24, r20
    7106:	81 50       	subi	r24, 0x01	; 1
    7108:	82 30       	cpi	r24, 0x02	; 2
    710a:	08 f0       	brcs	.+2      	; 0x710e <chk_mounted+0x24c>
    710c:	3e cf       	rjmp	.-388    	; 0x6f8a <chk_mounted+0xc8>
	fasize *= b;										/* Number of sectors for FAT area */

	fs->csize = b = fs->win[BPB_SecPerClus];			/* Number of sectors per cluster */
    710e:	db 96       	adiw	r26, 0x3b	; 59
    7110:	2c 91       	ld	r18, X
    7112:	db 97       	sbiw	r26, 0x3b	; 59
    7114:	12 96       	adiw	r26, 0x02	; 2
    7116:	2c 93       	st	X, r18
	if (!b || (b & (b - 1))) return FR_NO_FILESYSTEM;	/* (Must be power of 2) */
    7118:	22 23       	and	r18, r18
    711a:	09 f4       	brne	.+2      	; 0x711e <chk_mounted+0x25c>
    711c:	36 cf       	rjmp	.-404    	; 0x6f8a <chk_mounted+0xc8>
    711e:	30 e0       	ldi	r19, 0x00	; 0
    7120:	c9 01       	movw	r24, r18
    7122:	01 97       	sbiw	r24, 0x01	; 1
    7124:	82 23       	and	r24, r18
    7126:	93 23       	and	r25, r19
    7128:	89 2b       	or	r24, r25
    712a:	09 f0       	breq	.+2      	; 0x712e <chk_mounted+0x26c>
    712c:	2e cf       	rjmp	.-420    	; 0x6f8a <chk_mounted+0xc8>

	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt);	/* Number of root directory entries */
    712e:	e0 e4       	ldi	r30, 0x40	; 64
    7130:	f0 e0       	ldi	r31, 0x00	; 0
    7132:	ee 0e       	add	r14, r30
    7134:	ff 1e       	adc	r15, r31
    7136:	d7 01       	movw	r26, r14
    7138:	9c 91       	ld	r25, X
    713a:	e0 ec       	ldi	r30, 0xC0	; 192
    713c:	ff ef       	ldi	r31, 0xFF	; 255
    713e:	ee 0e       	add	r14, r30
    7140:	ff 1e       	adc	r15, r31
    7142:	80 e0       	ldi	r24, 0x00	; 0
    7144:	d7 01       	movw	r26, r14
    7146:	df 96       	adiw	r26, 0x3f	; 63
    7148:	2c 91       	ld	r18, X
    714a:	df 97       	sbiw	r26, 0x3f	; 63
    714c:	02 2f       	mov	r16, r18
    714e:	10 e0       	ldi	r17, 0x00	; 0
    7150:	08 2b       	or	r16, r24
    7152:	19 2b       	or	r17, r25
    7154:	19 96       	adiw	r26, 0x09	; 9
    7156:	1c 93       	st	X, r17
    7158:	0e 93       	st	-X, r16
    715a:	18 97       	sbiw	r26, 0x08	; 8
	if (fs->n_rootdir % (SS(fs) / 32)) return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be sector aligned) */
    715c:	c8 01       	movw	r24, r16
    715e:	8f 70       	andi	r24, 0x0F	; 15
    7160:	90 70       	andi	r25, 0x00	; 0
    7162:	89 2b       	or	r24, r25
    7164:	09 f0       	breq	.+2      	; 0x7168 <chk_mounted+0x2a6>
    7166:	11 cf       	rjmp	.-478    	; 0x6f8a <chk_mounted+0xc8>

	tsect = LD_WORD(fs->win+BPB_TotSec16);				/* Number of sectors on the volume */
    7168:	e2 e4       	ldi	r30, 0x42	; 66
    716a:	f0 e0       	ldi	r31, 0x00	; 0
    716c:	ee 0e       	add	r14, r30
    716e:	ff 1e       	adc	r15, r31
    7170:	d7 01       	movw	r26, r14
    7172:	9c 91       	ld	r25, X
    7174:	80 e0       	ldi	r24, 0x00	; 0
    7176:	f7 01       	movw	r30, r14
    7178:	22 91       	ld	r18, -Z
    717a:	7f 01       	movw	r14, r30
    717c:	6f eb       	ldi	r22, 0xBF	; 191
    717e:	7f ef       	ldi	r23, 0xFF	; 255
    7180:	e6 0e       	add	r14, r22
    7182:	f7 1e       	adc	r15, r23
    7184:	30 e0       	ldi	r19, 0x00	; 0
    7186:	82 2b       	or	r24, r18
    7188:	93 2b       	or	r25, r19
    718a:	1c 01       	movw	r2, r24
    718c:	44 24       	eor	r4, r4
    718e:	55 24       	eor	r5, r5
	if (!tsect) tsect = LD_DWORD(fs->win+BPB_TotSec32);
    7190:	21 14       	cp	r2, r1
    7192:	31 04       	cpc	r3, r1
    7194:	41 04       	cpc	r4, r1
    7196:	51 04       	cpc	r5, r1
    7198:	a9 f5       	brne	.+106    	; 0x7204 <chk_mounted+0x342>
    719a:	81 e5       	ldi	r24, 0x51	; 81
    719c:	90 e0       	ldi	r25, 0x00	; 0
    719e:	e8 0e       	add	r14, r24
    71a0:	f9 1e       	adc	r15, r25
    71a2:	d7 01       	movw	r26, r14
    71a4:	8c 91       	ld	r24, X
    71a6:	90 e0       	ldi	r25, 0x00	; 0
    71a8:	a0 e0       	ldi	r26, 0x00	; 0
    71aa:	b0 e0       	ldi	r27, 0x00	; 0
    71ac:	58 2e       	mov	r5, r24
    71ae:	44 24       	eor	r4, r4
    71b0:	33 24       	eor	r3, r3
    71b2:	22 24       	eor	r2, r2
    71b4:	f7 01       	movw	r30, r14
    71b6:	82 91       	ld	r24, -Z
    71b8:	7f 01       	movw	r14, r30
    71ba:	90 e0       	ldi	r25, 0x00	; 0
    71bc:	a0 e0       	ldi	r26, 0x00	; 0
    71be:	b0 e0       	ldi	r27, 0x00	; 0
    71c0:	dc 01       	movw	r26, r24
    71c2:	99 27       	eor	r25, r25
    71c4:	88 27       	eor	r24, r24
    71c6:	28 2a       	or	r2, r24
    71c8:	39 2a       	or	r3, r25
    71ca:	4a 2a       	or	r4, r26
    71cc:	5b 2a       	or	r5, r27
    71ce:	2e ef       	ldi	r18, 0xFE	; 254
    71d0:	3f ef       	ldi	r19, 0xFF	; 255
    71d2:	e2 0e       	add	r14, r18
    71d4:	f3 1e       	adc	r15, r19
    71d6:	d7 01       	movw	r26, r14
    71d8:	8d 91       	ld	r24, X+
    71da:	7d 01       	movw	r14, r26
    71dc:	90 e0       	ldi	r25, 0x00	; 0
    71de:	a0 e0       	ldi	r26, 0x00	; 0
    71e0:	b0 e0       	ldi	r27, 0x00	; 0
    71e2:	28 2a       	or	r2, r24
    71e4:	39 2a       	or	r3, r25
    71e6:	4a 2a       	or	r4, r26
    71e8:	5b 2a       	or	r5, r27
    71ea:	f7 01       	movw	r30, r14
    71ec:	90 81       	ld	r25, Z
    71ee:	21 eb       	ldi	r18, 0xB1	; 177
    71f0:	3f ef       	ldi	r19, 0xFF	; 255
    71f2:	e2 0e       	add	r14, r18
    71f4:	f3 1e       	adc	r15, r19
    71f6:	80 e0       	ldi	r24, 0x00	; 0
    71f8:	a0 e0       	ldi	r26, 0x00	; 0
    71fa:	b0 e0       	ldi	r27, 0x00	; 0
    71fc:	28 2a       	or	r2, r24
    71fe:	39 2a       	or	r3, r25
    7200:	4a 2a       	or	r4, r26
    7202:	5b 2a       	or	r5, r27

	nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt);				/* Number of reserved sectors */
    7204:	d7 01       	movw	r26, r14
    7206:	dd 96       	adiw	r26, 0x3d	; 61
    7208:	9c 91       	ld	r25, X
    720a:	dd 97       	sbiw	r26, 0x3d	; 61
    720c:	80 e0       	ldi	r24, 0x00	; 0
    720e:	dc 96       	adiw	r26, 0x3c	; 60
    7210:	2c 91       	ld	r18, X
    7212:	e2 2f       	mov	r30, r18
    7214:	f0 e0       	ldi	r31, 0x00	; 0
    7216:	e8 2b       	or	r30, r24
    7218:	f9 2b       	or	r31, r25
    721a:	fa 87       	std	Y+10, r31	; 0x0a
    721c:	e9 87       	std	Y+9, r30	; 0x09
	if (!nrsv) return FR_NO_FILESYSTEM;					/* (BPB_RsvdSecCnt must not be 0) */
    721e:	ef 2b       	or	r30, r31
    7220:	09 f4       	brne	.+2      	; 0x7224 <chk_mounted+0x362>
    7222:	b3 ce       	rjmp	.-666    	; 0x6f8a <chk_mounted+0xc8>
	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
	fs->fsize = fasize;

	fs->n_fats = b = fs->win[BPB_NumFATs];				/* Number of FAT copies */
	if (b != 1 && b != 2) return FR_NO_FILESYSTEM;		/* (Must be 1 or 2) */
	fasize *= b;										/* Number of sectors for FAT area */
    7224:	24 2f       	mov	r18, r20
    7226:	30 e0       	ldi	r19, 0x00	; 0
    7228:	40 e0       	ldi	r20, 0x00	; 0
    722a:	50 e0       	ldi	r21, 0x00	; 0
    722c:	c6 01       	movw	r24, r12
    722e:	b5 01       	movw	r22, r10
    7230:	0e 94 bb 7f 	call	0xff76	; 0xff76 <__mulsi3>
    7234:	69 83       	std	Y+1, r22	; 0x01
    7236:	7a 83       	std	Y+2, r23	; 0x02
    7238:	8b 83       	std	Y+3, r24	; 0x03
    723a:	9c 83       	std	Y+4, r25	; 0x04

	nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt);				/* Number of reserved sectors */
	if (!nrsv) return FR_NO_FILESYSTEM;					/* (BPB_RsvdSecCnt must not be 0) */

	/* Determine the FAT sub type */
	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / 32);	/* RSV+FAT+DIR */
    723c:	49 85       	ldd	r20, Y+9	; 0x09
    723e:	5a 85       	ldd	r21, Y+10	; 0x0a
    7240:	9a 01       	movw	r18, r20
    7242:	40 e0       	ldi	r20, 0x00	; 0
    7244:	50 e0       	ldi	r21, 0x00	; 0
    7246:	2d 83       	std	Y+5, r18	; 0x05
    7248:	3e 83       	std	Y+6, r19	; 0x06
    724a:	4f 83       	std	Y+7, r20	; 0x07
    724c:	58 87       	std	Y+8, r21	; 0x08
    724e:	12 95       	swap	r17
    7250:	02 95       	swap	r16
    7252:	0f 70       	andi	r16, 0x0F	; 15
    7254:	01 27       	eor	r16, r17
    7256:	1f 70       	andi	r17, 0x0F	; 15
    7258:	01 27       	eor	r16, r17
    725a:	58 01       	movw	r10, r16
    725c:	cc 24       	eor	r12, r12
    725e:	dd 24       	eor	r13, r13
    7260:	a2 0e       	add	r10, r18
    7262:	b3 1e       	adc	r11, r19
    7264:	c4 1e       	adc	r12, r20
    7266:	d5 1e       	adc	r13, r21
    7268:	a6 0e       	add	r10, r22
    726a:	b7 1e       	adc	r11, r23
    726c:	c8 1e       	adc	r12, r24
    726e:	d9 1e       	adc	r13, r25
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
    7270:	2a 14       	cp	r2, r10
    7272:	3b 04       	cpc	r3, r11
    7274:	4c 04       	cpc	r4, r12
    7276:	5d 04       	cpc	r5, r13
    7278:	08 f4       	brcc	.+2      	; 0x727c <chk_mounted+0x3ba>
    727a:	87 ce       	rjmp	.-754    	; 0x6f8a <chk_mounted+0xc8>
	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
    727c:	2a 18       	sub	r2, r10
    727e:	3b 08       	sbc	r3, r11
    7280:	4c 08       	sbc	r4, r12
    7282:	5d 08       	sbc	r5, r13
    7284:	d7 01       	movw	r26, r14
    7286:	12 96       	adiw	r26, 0x02	; 2
    7288:	2c 91       	ld	r18, X
    728a:	30 e0       	ldi	r19, 0x00	; 0
    728c:	40 e0       	ldi	r20, 0x00	; 0
    728e:	50 e0       	ldi	r21, 0x00	; 0
    7290:	c2 01       	movw	r24, r4
    7292:	b1 01       	movw	r22, r2
    7294:	0e 94 0d 80 	call	0x1001a	; 0x1001a <__udivmodsi4>
    7298:	c9 01       	movw	r24, r18
    729a:	da 01       	movw	r26, r20
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
    729c:	00 97       	sbiw	r24, 0x00	; 0
    729e:	a1 05       	cpc	r26, r1
    72a0:	b1 05       	cpc	r27, r1
    72a2:	09 f4       	brne	.+2      	; 0x72a6 <chk_mounted+0x3e4>
    72a4:	72 ce       	rjmp	.-796    	; 0x6f8a <chk_mounted+0xc8>
	fmt = FS_FAT12;
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
    72a6:	86 3f       	cpi	r24, 0xF6	; 246
    72a8:	ef e0       	ldi	r30, 0x0F	; 15
    72aa:	9e 07       	cpc	r25, r30
    72ac:	e0 e0       	ldi	r30, 0x00	; 0
    72ae:	ae 07       	cpc	r26, r30
    72b0:	e0 e0       	ldi	r30, 0x00	; 0
    72b2:	be 07       	cpc	r27, r30
    72b4:	08 f4       	brcc	.+2      	; 0x72b8 <chk_mounted+0x3f6>
    72b6:	c0 c0       	rjmp	.+384    	; 0x7438 <chk_mounted+0x576>
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;
    72b8:	86 3f       	cpi	r24, 0xF6	; 246
    72ba:	ff ef       	ldi	r31, 0xFF	; 255
    72bc:	9f 07       	cpc	r25, r31
    72be:	f0 e0       	ldi	r31, 0x00	; 0
    72c0:	af 07       	cpc	r26, r31
    72c2:	f0 e0       	ldi	r31, 0x00	; 0
    72c4:	bf 07       	cpc	r27, r31
    72c6:	08 f4       	brcc	.+2      	; 0x72ca <chk_mounted+0x408>
    72c8:	3b c2       	rjmp	.+1142   	; 0x7740 <chk_mounted+0x87e>

	/* Boundaries and Limits */
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
    72ca:	62 e0       	ldi	r22, 0x02	; 2
    72cc:	26 2e       	mov	r2, r22
    72ce:	31 2c       	mov	r3, r1
    72d0:	41 2c       	mov	r4, r1
    72d2:	51 2c       	mov	r5, r1
    72d4:	28 0e       	add	r2, r24
    72d6:	39 1e       	adc	r3, r25
    72d8:	4a 1e       	adc	r4, r26
    72da:	5b 1e       	adc	r5, r27
    72dc:	f7 01       	movw	r30, r14
    72de:	26 8a       	std	Z+22, r2	; 0x16
    72e0:	37 8a       	std	Z+23, r3	; 0x17
    72e2:	40 8e       	std	Z+24, r4	; 0x18
    72e4:	51 8e       	std	Z+25, r5	; 0x19
	fs->database = bsect + sysect;						/* Data start sector */
    72e6:	a6 0c       	add	r10, r6
    72e8:	b7 1c       	adc	r11, r7
    72ea:	c8 1c       	adc	r12, r8
    72ec:	d9 1c       	adc	r13, r9
    72ee:	d7 01       	movw	r26, r14
    72f0:	96 96       	adiw	r26, 0x26	; 38
    72f2:	ad 92       	st	X+, r10
    72f4:	bd 92       	st	X+, r11
    72f6:	cd 92       	st	X+, r12
    72f8:	dc 92       	st	X, r13
    72fa:	99 97       	sbiw	r26, 0x29	; 41
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
    72fc:	2d 81       	ldd	r18, Y+5	; 0x05
    72fe:	3e 81       	ldd	r19, Y+6	; 0x06
    7300:	4f 81       	ldd	r20, Y+7	; 0x07
    7302:	58 85       	ldd	r21, Y+8	; 0x08
    7304:	26 0d       	add	r18, r6
    7306:	37 1d       	adc	r19, r7
    7308:	48 1d       	adc	r20, r8
    730a:	59 1d       	adc	r21, r9
    730c:	5e 96       	adiw	r26, 0x1e	; 30
    730e:	2d 93       	st	X+, r18
    7310:	3d 93       	st	X+, r19
    7312:	4d 93       	st	X+, r20
    7314:	5c 93       	st	X, r21
    7316:	91 97       	sbiw	r26, 0x21	; 33
	if (fmt == FS_FAT32) {
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
    7318:	18 96       	adiw	r26, 0x08	; 8
    731a:	8d 91       	ld	r24, X+
    731c:	9c 91       	ld	r25, X
    731e:	19 97       	sbiw	r26, 0x09	; 9
    7320:	89 2b       	or	r24, r25
    7322:	09 f0       	breq	.+2      	; 0x7326 <chk_mounted+0x464>
    7324:	32 ce       	rjmp	.-924    	; 0x6f8a <chk_mounted+0xc8>
		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
    7326:	ed e5       	ldi	r30, 0x5D	; 93
    7328:	f0 e0       	ldi	r31, 0x00	; 0
    732a:	ee 0e       	add	r14, r30
    732c:	ff 1e       	adc	r15, r31
    732e:	d7 01       	movw	r26, r14
    7330:	2c 91       	ld	r18, X
    7332:	30 e0       	ldi	r19, 0x00	; 0
    7334:	40 e0       	ldi	r20, 0x00	; 0
    7336:	50 e0       	ldi	r21, 0x00	; 0
    7338:	52 2f       	mov	r21, r18
    733a:	44 27       	eor	r20, r20
    733c:	33 27       	eor	r19, r19
    733e:	22 27       	eor	r18, r18
    7340:	f7 01       	movw	r30, r14
    7342:	82 91       	ld	r24, -Z
    7344:	7f 01       	movw	r14, r30
    7346:	90 e0       	ldi	r25, 0x00	; 0
    7348:	a0 e0       	ldi	r26, 0x00	; 0
    734a:	b0 e0       	ldi	r27, 0x00	; 0
    734c:	dc 01       	movw	r26, r24
    734e:	99 27       	eor	r25, r25
    7350:	88 27       	eor	r24, r24
    7352:	28 2b       	or	r18, r24
    7354:	39 2b       	or	r19, r25
    7356:	4a 2b       	or	r20, r26
    7358:	5b 2b       	or	r21, r27
    735a:	6e ef       	ldi	r22, 0xFE	; 254
    735c:	7f ef       	ldi	r23, 0xFF	; 255
    735e:	e6 0e       	add	r14, r22
    7360:	f7 1e       	adc	r15, r23
    7362:	d7 01       	movw	r26, r14
    7364:	8d 91       	ld	r24, X+
    7366:	7d 01       	movw	r14, r26
    7368:	90 e0       	ldi	r25, 0x00	; 0
    736a:	a0 e0       	ldi	r26, 0x00	; 0
    736c:	b0 e0       	ldi	r27, 0x00	; 0
    736e:	28 2b       	or	r18, r24
    7370:	39 2b       	or	r19, r25
    7372:	4a 2b       	or	r20, r26
    7374:	5b 2b       	or	r21, r27
    7376:	f7 01       	movw	r30, r14
    7378:	90 81       	ld	r25, Z
    737a:	65 ea       	ldi	r22, 0xA5	; 165
    737c:	7f ef       	ldi	r23, 0xFF	; 255
    737e:	e6 0e       	add	r14, r22
    7380:	f7 1e       	adc	r15, r23
    7382:	80 e0       	ldi	r24, 0x00	; 0
    7384:	a0 e0       	ldi	r26, 0x00	; 0
    7386:	b0 e0       	ldi	r27, 0x00	; 0
    7388:	28 2b       	or	r18, r24
    738a:	39 2b       	or	r19, r25
    738c:	4a 2b       	or	r20, r26
    738e:	5b 2b       	or	r21, r27
    7390:	d7 01       	movw	r26, r14
    7392:	92 96       	adiw	r26, 0x22	; 34
    7394:	2d 93       	st	X+, r18
    7396:	3d 93       	st	X+, r19
    7398:	4d 93       	st	X+, r20
    739a:	5c 93       	st	X, r21
    739c:	95 97       	sbiw	r26, 0x25	; 37
		szbfat = fs->n_fatent * 4;						/* (Required FAT size) */
    739e:	a2 01       	movw	r20, r4
    73a0:	91 01       	movw	r18, r2
    73a2:	22 0f       	add	r18, r18
    73a4:	33 1f       	adc	r19, r19
    73a6:	44 1f       	adc	r20, r20
    73a8:	55 1f       	adc	r21, r21
    73aa:	22 0f       	add	r18, r18
    73ac:	33 1f       	adc	r19, r19
    73ae:	44 1f       	adc	r20, r20
    73b0:	55 1f       	adc	r21, r21
    73b2:	13 e0       	ldi	r17, 0x03	; 3
		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
		szbfat = (fmt == FS_FAT16) ?					/* (Required FAT size) */
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
	}
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (FAT size must not be less than FAT sectors */
    73b4:	21 50       	subi	r18, 0x01	; 1
    73b6:	3e 4f       	sbci	r19, 0xFE	; 254
    73b8:	4f 4f       	sbci	r20, 0xFF	; 255
    73ba:	5f 4f       	sbci	r21, 0xFF	; 255
    73bc:	e9 e0       	ldi	r30, 0x09	; 9
    73be:	56 95       	lsr	r21
    73c0:	47 95       	ror	r20
    73c2:	37 95       	ror	r19
    73c4:	27 95       	ror	r18
    73c6:	ea 95       	dec	r30
    73c8:	d1 f7       	brne	.-12     	; 0x73be <chk_mounted+0x4fc>
    73ca:	f7 01       	movw	r30, r14
    73cc:	82 8d       	ldd	r24, Z+26	; 0x1a
    73ce:	93 8d       	ldd	r25, Z+27	; 0x1b
    73d0:	a4 8d       	ldd	r26, Z+28	; 0x1c
    73d2:	b5 8d       	ldd	r27, Z+29	; 0x1d
    73d4:	82 17       	cp	r24, r18
    73d6:	93 07       	cpc	r25, r19
    73d8:	a4 07       	cpc	r26, r20
    73da:	b5 07       	cpc	r27, r21
    73dc:	08 f4       	brcc	.+2      	; 0x73e0 <chk_mounted+0x51e>
    73de:	d5 cd       	rjmp	.-1110   	; 0x6f8a <chk_mounted+0xc8>
		return FR_NO_FILESYSTEM;

#if !_FS_READONLY
	/* Initialize cluster allocation information */
	fs->free_clust = 0xFFFFFFFF;
    73e0:	8f ef       	ldi	r24, 0xFF	; 255
    73e2:	9f ef       	ldi	r25, 0xFF	; 255
    73e4:	af ef       	ldi	r26, 0xFF	; 255
    73e6:	bf ef       	ldi	r27, 0xFF	; 255
    73e8:	86 87       	std	Z+14, r24	; 0x0e
    73ea:	97 87       	std	Z+15, r25	; 0x0f
    73ec:	a0 8b       	std	Z+16, r26	; 0x10
    73ee:	b1 8b       	std	Z+17, r27	; 0x11
	fs->last_clust = 0;
    73f0:	d7 01       	movw	r26, r14
    73f2:	1a 96       	adiw	r26, 0x0a	; 10
    73f4:	1d 92       	st	X+, r1
    73f6:	1d 92       	st	X+, r1
    73f8:	1d 92       	st	X+, r1
    73fa:	1c 92       	st	X, r1
    73fc:	1d 97       	sbiw	r26, 0x0d	; 13

	/* Get fsinfo if available */
	if (fmt == FS_FAT32) {
    73fe:	13 30       	cpi	r17, 0x03	; 3
    7400:	09 f4       	brne	.+2      	; 0x7404 <chk_mounted+0x542>
    7402:	7c c0       	rjmp	.+248    	; 0x74fc <chk_mounted+0x63a>
				fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
		}
	}
#endif
	fs->fs_type = fmt;		/* FAT sub-type */
    7404:	f7 01       	movw	r30, r14
    7406:	10 83       	st	Z, r17
	fs->id = ++Fsid;		/* File system mount ID */
    7408:	80 91 24 07 	lds	r24, 0x0724
    740c:	90 91 25 07 	lds	r25, 0x0725
    7410:	01 96       	adiw	r24, 0x01	; 1
    7412:	90 93 25 07 	sts	0x0725, r25
    7416:	80 93 24 07 	sts	0x0724, r24
    741a:	97 83       	std	Z+7, r25	; 0x07
    741c:	86 83       	std	Z+6, r24	; 0x06
	fs->winsect = 0;		/* Invalidate sector cache */
    741e:	d7 01       	movw	r26, r14
    7420:	9a 96       	adiw	r26, 0x2a	; 42
    7422:	1d 92       	st	X+, r1
    7424:	1d 92       	st	X+, r1
    7426:	1d 92       	st	X+, r1
    7428:	1c 92       	st	X, r1
    742a:	9d 97       	sbiw	r26, 0x2d	; 45
	fs->wflag = 0;
    742c:	14 96       	adiw	r26, 0x04	; 4
    742e:	1c 92       	st	X, r1
    7430:	80 e0       	ldi	r24, 0x00	; 0
    7432:	b7 cd       	rjmp	.-1170   	; 0x6fa2 <chk_mounted+0xe0>
		if (tbl[4]) {									/* Is the partition existing? */
			bsect = LD_DWORD(&tbl[8]);					/* Partition offset in LBA */
			fmt = check_fs(fs, bsect);					/* Check the partition */
		}
	}
	if (fmt == 3) return FR_DISK_ERR;
    7434:	81 e0       	ldi	r24, 0x01	; 1
    7436:	b5 cd       	rjmp	.-1174   	; 0x6fa2 <chk_mounted+0xe0>
	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / 32);	/* RSV+FAT+DIR */
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
	fmt = FS_FAT12;
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
    7438:	11 e0       	ldi	r17, 0x01	; 1
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;

	/* Boundaries and Limits */
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
    743a:	22 e0       	ldi	r18, 0x02	; 2
    743c:	22 2e       	mov	r2, r18
    743e:	31 2c       	mov	r3, r1
    7440:	41 2c       	mov	r4, r1
    7442:	51 2c       	mov	r5, r1
    7444:	28 0e       	add	r2, r24
    7446:	39 1e       	adc	r3, r25
    7448:	4a 1e       	adc	r4, r26
    744a:	5b 1e       	adc	r5, r27
    744c:	d7 01       	movw	r26, r14
    744e:	56 96       	adiw	r26, 0x16	; 22
    7450:	2d 92       	st	X+, r2
    7452:	3d 92       	st	X+, r3
    7454:	4d 92       	st	X+, r4
    7456:	5c 92       	st	X, r5
    7458:	59 97       	sbiw	r26, 0x19	; 25
	fs->database = bsect + sysect;						/* Data start sector */
    745a:	a6 0c       	add	r10, r6
    745c:	b7 1c       	adc	r11, r7
    745e:	c8 1c       	adc	r12, r8
    7460:	d9 1c       	adc	r13, r9
    7462:	f7 01       	movw	r30, r14
    7464:	a6 a2       	std	Z+38, r10	; 0x26
    7466:	b7 a2       	std	Z+39, r11	; 0x27
    7468:	c0 a6       	std	Z+40, r12	; 0x28
    746a:	d1 a6       	std	Z+41, r13	; 0x29
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
    746c:	ad 80       	ldd	r10, Y+5	; 0x05
    746e:	be 80       	ldd	r11, Y+6	; 0x06
    7470:	cf 80       	ldd	r12, Y+7	; 0x07
    7472:	d8 84       	ldd	r13, Y+8	; 0x08
    7474:	a6 0c       	add	r10, r6
    7476:	b7 1c       	adc	r11, r7
    7478:	c8 1c       	adc	r12, r8
    747a:	d9 1c       	adc	r13, r9
    747c:	5e 96       	adiw	r26, 0x1e	; 30
    747e:	ad 92       	st	X+, r10
    7480:	bd 92       	st	X+, r11
    7482:	cd 92       	st	X+, r12
    7484:	dc 92       	st	X, r13
    7486:	91 97       	sbiw	r26, 0x21	; 33
	if (fmt == FS_FAT32) {
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
		szbfat = fs->n_fatent * 4;						/* (Required FAT size) */
	} else {
		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
    7488:	18 96       	adiw	r26, 0x08	; 8
    748a:	8d 91       	ld	r24, X+
    748c:	9c 91       	ld	r25, X
    748e:	19 97       	sbiw	r26, 0x09	; 9
    7490:	89 2b       	or	r24, r25
    7492:	09 f4       	brne	.+2      	; 0x7496 <chk_mounted+0x5d4>
    7494:	7a cd       	rjmp	.-1292   	; 0x6f8a <chk_mounted+0xc8>
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
    7496:	29 81       	ldd	r18, Y+1	; 0x01
    7498:	3a 81       	ldd	r19, Y+2	; 0x02
    749a:	4b 81       	ldd	r20, Y+3	; 0x03
    749c:	5c 81       	ldd	r21, Y+4	; 0x04
    749e:	a2 0e       	add	r10, r18
    74a0:	b3 1e       	adc	r11, r19
    74a2:	c4 1e       	adc	r12, r20
    74a4:	d5 1e       	adc	r13, r21
    74a6:	d7 01       	movw	r26, r14
    74a8:	92 96       	adiw	r26, 0x22	; 34
    74aa:	ad 92       	st	X+, r10
    74ac:	bd 92       	st	X+, r11
    74ae:	cd 92       	st	X+, r12
    74b0:	dc 92       	st	X, r13
    74b2:	95 97       	sbiw	r26, 0x25	; 37
		szbfat = (fmt == FS_FAT16) ?					/* (Required FAT size) */
    74b4:	12 30       	cpi	r17, 0x02	; 2
    74b6:	d9 f0       	breq	.+54     	; 0x74ee <chk_mounted+0x62c>
    74b8:	a2 01       	movw	r20, r4
    74ba:	91 01       	movw	r18, r2
    74bc:	22 0f       	add	r18, r18
    74be:	33 1f       	adc	r19, r19
    74c0:	44 1f       	adc	r20, r20
    74c2:	55 1f       	adc	r21, r21
    74c4:	22 0d       	add	r18, r2
    74c6:	33 1d       	adc	r19, r3
    74c8:	44 1d       	adc	r20, r4
    74ca:	55 1d       	adc	r21, r5
    74cc:	56 95       	lsr	r21
    74ce:	47 95       	ror	r20
    74d0:	37 95       	ror	r19
    74d2:	27 95       	ror	r18
    74d4:	61 e0       	ldi	r22, 0x01	; 1
    74d6:	70 e0       	ldi	r23, 0x00	; 0
    74d8:	80 e0       	ldi	r24, 0x00	; 0
    74da:	90 e0       	ldi	r25, 0x00	; 0
    74dc:	26 22       	and	r2, r22
    74de:	37 22       	and	r3, r23
    74e0:	48 22       	and	r4, r24
    74e2:	59 22       	and	r5, r25
    74e4:	22 0d       	add	r18, r2
    74e6:	33 1d       	adc	r19, r3
    74e8:	44 1d       	adc	r20, r4
    74ea:	55 1d       	adc	r21, r5
    74ec:	63 cf       	rjmp	.-314    	; 0x73b4 <chk_mounted+0x4f2>
    74ee:	a2 01       	movw	r20, r4
    74f0:	91 01       	movw	r18, r2
    74f2:	22 0f       	add	r18, r18
    74f4:	33 1f       	adc	r19, r19
    74f6:	44 1f       	adc	r20, r20
    74f8:	55 1f       	adc	r21, r21
    74fa:	5c cf       	rjmp	.-328    	; 0x73b4 <chk_mounted+0x4f2>
	fs->free_clust = 0xFFFFFFFF;
	fs->last_clust = 0;

	/* Get fsinfo if available */
	if (fmt == FS_FAT32) {
	 	fs->fsi_flag = 0;
    74fc:	15 96       	adiw	r26, 0x05	; 5
    74fe:	1c 92       	st	X, r1
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
    7500:	ef e5       	ldi	r30, 0x5F	; 95
    7502:	f0 e0       	ldi	r31, 0x00	; 0
    7504:	ee 0e       	add	r14, r30
    7506:	ff 1e       	adc	r15, r31
    7508:	d7 01       	movw	r26, r14
    750a:	3c 91       	ld	r19, X
    750c:	20 e0       	ldi	r18, 0x00	; 0
    750e:	f7 01       	movw	r30, r14
    7510:	82 91       	ld	r24, -Z
    7512:	7f 01       	movw	r14, r30
    7514:	42 ea       	ldi	r20, 0xA2	; 162
    7516:	5f ef       	ldi	r21, 0xFF	; 255
    7518:	e4 0e       	add	r14, r20
    751a:	f5 1e       	adc	r15, r21
    751c:	90 e0       	ldi	r25, 0x00	; 0
    751e:	28 2b       	or	r18, r24
    7520:	39 2b       	or	r19, r25
    7522:	40 e0       	ldi	r20, 0x00	; 0
    7524:	50 e0       	ldi	r21, 0x00	; 0
    7526:	26 0d       	add	r18, r6
    7528:	37 1d       	adc	r19, r7
    752a:	48 1d       	adc	r20, r8
    752c:	59 1d       	adc	r21, r9
    752e:	d7 01       	movw	r26, r14
    7530:	52 96       	adiw	r26, 0x12	; 18
    7532:	2d 93       	st	X+, r18
    7534:	3d 93       	st	X+, r19
    7536:	4d 93       	st	X+, r20
    7538:	5c 93       	st	X, r21
    753a:	55 97       	sbiw	r26, 0x15	; 21
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
    753c:	b7 01       	movw	r22, r14
    753e:	62 5d       	subi	r22, 0xD2	; 210
    7540:	7f 4f       	sbci	r23, 0xFF	; 255
    7542:	11 96       	adiw	r26, 0x01	; 1
    7544:	8c 91       	ld	r24, X
    7546:	01 e0       	ldi	r16, 0x01	; 1
    7548:	0e 94 89 24 	call	0x4912	; 0x4912 <disk_read>
    754c:	88 23       	and	r24, r24
    754e:	09 f0       	breq	.+2      	; 0x7552 <chk_mounted+0x690>
    7550:	59 cf       	rjmp	.-334    	; 0x7404 <chk_mounted+0x542>
    7552:	ed e2       	ldi	r30, 0x2D	; 45
    7554:	f2 e0       	ldi	r31, 0x02	; 2
    7556:	ee 0e       	add	r14, r30
    7558:	ff 1e       	adc	r15, r31
    755a:	d7 01       	movw	r26, r14
    755c:	9c 91       	ld	r25, X
    755e:	80 e0       	ldi	r24, 0x00	; 0
    7560:	f7 01       	movw	r30, r14
    7562:	22 91       	ld	r18, -Z
    7564:	7f 01       	movw	r14, r30
    7566:	44 ed       	ldi	r20, 0xD4	; 212
    7568:	5d ef       	ldi	r21, 0xFD	; 253
    756a:	e4 0e       	add	r14, r20
    756c:	f5 1e       	adc	r15, r21
    756e:	30 e0       	ldi	r19, 0x00	; 0
    7570:	82 2b       	or	r24, r18
    7572:	93 2b       	or	r25, r19
    7574:	85 55       	subi	r24, 0x55	; 85
    7576:	9a 4a       	sbci	r25, 0xAA	; 170
    7578:	09 f0       	breq	.+2      	; 0x757c <chk_mounted+0x6ba>
    757a:	44 cf       	rjmp	.-376    	; 0x7404 <chk_mounted+0x542>
    757c:	d7 01       	movw	r26, r14
    757e:	d1 96       	adiw	r26, 0x31	; 49
    7580:	2c 91       	ld	r18, X
    7582:	d1 97       	sbiw	r26, 0x31	; 49
    7584:	30 e0       	ldi	r19, 0x00	; 0
    7586:	40 e0       	ldi	r20, 0x00	; 0
    7588:	50 e0       	ldi	r21, 0x00	; 0
    758a:	52 2f       	mov	r21, r18
    758c:	44 27       	eor	r20, r20
    758e:	33 27       	eor	r19, r19
    7590:	22 27       	eor	r18, r18
    7592:	d0 96       	adiw	r26, 0x30	; 48
    7594:	8c 91       	ld	r24, X
    7596:	90 e0       	ldi	r25, 0x00	; 0
    7598:	a0 e0       	ldi	r26, 0x00	; 0
    759a:	b0 e0       	ldi	r27, 0x00	; 0
    759c:	dc 01       	movw	r26, r24
    759e:	99 27       	eor	r25, r25
    75a0:	88 27       	eor	r24, r24
    75a2:	28 2b       	or	r18, r24
    75a4:	39 2b       	or	r19, r25
    75a6:	4a 2b       	or	r20, r26
    75a8:	5b 2b       	or	r21, r27
    75aa:	f7 01       	movw	r30, r14
    75ac:	86 a5       	ldd	r24, Z+46	; 0x2e
    75ae:	90 e0       	ldi	r25, 0x00	; 0
    75b0:	a0 e0       	ldi	r26, 0x00	; 0
    75b2:	b0 e0       	ldi	r27, 0x00	; 0
    75b4:	28 2b       	or	r18, r24
    75b6:	39 2b       	or	r19, r25
    75b8:	4a 2b       	or	r20, r26
    75ba:	5b 2b       	or	r21, r27
    75bc:	97 a5       	ldd	r25, Z+47	; 0x2f
    75be:	80 e0       	ldi	r24, 0x00	; 0
    75c0:	a0 e0       	ldi	r26, 0x00	; 0
    75c2:	b0 e0       	ldi	r27, 0x00	; 0
    75c4:	28 2b       	or	r18, r24
    75c6:	39 2b       	or	r19, r25
    75c8:	4a 2b       	or	r20, r26
    75ca:	5b 2b       	or	r21, r27
    75cc:	22 55       	subi	r18, 0x52	; 82
    75ce:	32 45       	sbci	r19, 0x52	; 82
    75d0:	41 46       	sbci	r20, 0x61	; 97
    75d2:	51 44       	sbci	r21, 0x41	; 65
    75d4:	09 f0       	breq	.+2      	; 0x75d8 <chk_mounted+0x716>
    75d6:	16 cf       	rjmp	.-468    	; 0x7404 <chk_mounted+0x542>
    75d8:	25 e1       	ldi	r18, 0x15	; 21
    75da:	32 e0       	ldi	r19, 0x02	; 2
    75dc:	e2 0e       	add	r14, r18
    75de:	f3 1e       	adc	r15, r19
    75e0:	d7 01       	movw	r26, r14
    75e2:	2c 91       	ld	r18, X
    75e4:	30 e0       	ldi	r19, 0x00	; 0
    75e6:	40 e0       	ldi	r20, 0x00	; 0
    75e8:	50 e0       	ldi	r21, 0x00	; 0
    75ea:	52 2f       	mov	r21, r18
    75ec:	44 27       	eor	r20, r20
    75ee:	33 27       	eor	r19, r19
    75f0:	22 27       	eor	r18, r18
    75f2:	f7 01       	movw	r30, r14
    75f4:	82 91       	ld	r24, -Z
    75f6:	7f 01       	movw	r14, r30
    75f8:	90 e0       	ldi	r25, 0x00	; 0
    75fa:	a0 e0       	ldi	r26, 0x00	; 0
    75fc:	b0 e0       	ldi	r27, 0x00	; 0
    75fe:	dc 01       	movw	r26, r24
    7600:	99 27       	eor	r25, r25
    7602:	88 27       	eor	r24, r24
    7604:	28 2b       	or	r18, r24
    7606:	39 2b       	or	r19, r25
    7608:	4a 2b       	or	r20, r26
    760a:	5b 2b       	or	r21, r27
    760c:	6e ef       	ldi	r22, 0xFE	; 254
    760e:	7f ef       	ldi	r23, 0xFF	; 255
    7610:	e6 0e       	add	r14, r22
    7612:	f7 1e       	adc	r15, r23
    7614:	d7 01       	movw	r26, r14
    7616:	8d 91       	ld	r24, X+
    7618:	7d 01       	movw	r14, r26
    761a:	90 e0       	ldi	r25, 0x00	; 0
    761c:	a0 e0       	ldi	r26, 0x00	; 0
    761e:	b0 e0       	ldi	r27, 0x00	; 0
    7620:	28 2b       	or	r18, r24
    7622:	39 2b       	or	r19, r25
    7624:	4a 2b       	or	r20, r26
    7626:	5b 2b       	or	r21, r27
    7628:	f7 01       	movw	r30, r14
    762a:	90 81       	ld	r25, Z
    762c:	6d ee       	ldi	r22, 0xED	; 237
    762e:	7d ef       	ldi	r23, 0xFD	; 253
    7630:	e6 0e       	add	r14, r22
    7632:	f7 1e       	adc	r15, r23
    7634:	80 e0       	ldi	r24, 0x00	; 0
    7636:	a0 e0       	ldi	r26, 0x00	; 0
    7638:	b0 e0       	ldi	r27, 0x00	; 0
    763a:	28 2b       	or	r18, r24
    763c:	39 2b       	or	r19, r25
    763e:	4a 2b       	or	r20, r26
    7640:	5b 2b       	or	r21, r27
    7642:	22 57       	subi	r18, 0x72	; 114
    7644:	32 47       	sbci	r19, 0x72	; 114
    7646:	41 44       	sbci	r20, 0x41	; 65
    7648:	51 46       	sbci	r21, 0x61	; 97
    764a:	09 f0       	breq	.+2      	; 0x764e <chk_mounted+0x78c>
    764c:	db ce       	rjmp	.-586    	; 0x7404 <chk_mounted+0x542>
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
				fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
    764e:	8d e1       	ldi	r24, 0x1D	; 29
    7650:	92 e0       	ldi	r25, 0x02	; 2
    7652:	e8 0e       	add	r14, r24
    7654:	f9 1e       	adc	r15, r25
    7656:	d7 01       	movw	r26, r14
    7658:	2c 91       	ld	r18, X
    765a:	30 e0       	ldi	r19, 0x00	; 0
    765c:	40 e0       	ldi	r20, 0x00	; 0
    765e:	50 e0       	ldi	r21, 0x00	; 0
    7660:	52 2f       	mov	r21, r18
    7662:	44 27       	eor	r20, r20
    7664:	33 27       	eor	r19, r19
    7666:	22 27       	eor	r18, r18
    7668:	f7 01       	movw	r30, r14
    766a:	82 91       	ld	r24, -Z
    766c:	7f 01       	movw	r14, r30
    766e:	90 e0       	ldi	r25, 0x00	; 0
    7670:	a0 e0       	ldi	r26, 0x00	; 0
    7672:	b0 e0       	ldi	r27, 0x00	; 0
    7674:	dc 01       	movw	r26, r24
    7676:	99 27       	eor	r25, r25
    7678:	88 27       	eor	r24, r24
    767a:	28 2b       	or	r18, r24
    767c:	39 2b       	or	r19, r25
    767e:	4a 2b       	or	r20, r26
    7680:	5b 2b       	or	r21, r27
    7682:	6e ef       	ldi	r22, 0xFE	; 254
    7684:	7f ef       	ldi	r23, 0xFF	; 255
    7686:	e6 0e       	add	r14, r22
    7688:	f7 1e       	adc	r15, r23
    768a:	d7 01       	movw	r26, r14
    768c:	8d 91       	ld	r24, X+
    768e:	7d 01       	movw	r14, r26
    7690:	90 e0       	ldi	r25, 0x00	; 0
    7692:	a0 e0       	ldi	r26, 0x00	; 0
    7694:	b0 e0       	ldi	r27, 0x00	; 0
    7696:	28 2b       	or	r18, r24
    7698:	39 2b       	or	r19, r25
    769a:	4a 2b       	or	r20, r26
    769c:	5b 2b       	or	r21, r27
    769e:	f7 01       	movw	r30, r14
    76a0:	90 81       	ld	r25, Z
    76a2:	65 ee       	ldi	r22, 0xE5	; 229
    76a4:	7d ef       	ldi	r23, 0xFD	; 253
    76a6:	e6 0e       	add	r14, r22
    76a8:	f7 1e       	adc	r15, r23
    76aa:	80 e0       	ldi	r24, 0x00	; 0
    76ac:	a0 e0       	ldi	r26, 0x00	; 0
    76ae:	b0 e0       	ldi	r27, 0x00	; 0
    76b0:	28 2b       	or	r18, r24
    76b2:	39 2b       	or	r19, r25
    76b4:	4a 2b       	or	r20, r26
    76b6:	5b 2b       	or	r21, r27
    76b8:	d7 01       	movw	r26, r14
    76ba:	1a 96       	adiw	r26, 0x0a	; 10
    76bc:	2d 93       	st	X+, r18
    76be:	3d 93       	st	X+, r19
    76c0:	4d 93       	st	X+, r20
    76c2:	5c 93       	st	X, r21
    76c4:	1d 97       	sbiw	r26, 0x0d	; 13
				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
    76c6:	e9 e1       	ldi	r30, 0x19	; 25
    76c8:	f2 e0       	ldi	r31, 0x02	; 2
    76ca:	ee 0e       	add	r14, r30
    76cc:	ff 1e       	adc	r15, r31
    76ce:	d7 01       	movw	r26, r14
    76d0:	2c 91       	ld	r18, X
    76d2:	30 e0       	ldi	r19, 0x00	; 0
    76d4:	40 e0       	ldi	r20, 0x00	; 0
    76d6:	50 e0       	ldi	r21, 0x00	; 0
    76d8:	52 2f       	mov	r21, r18
    76da:	44 27       	eor	r20, r20
    76dc:	33 27       	eor	r19, r19
    76de:	22 27       	eor	r18, r18
    76e0:	f7 01       	movw	r30, r14
    76e2:	82 91       	ld	r24, -Z
    76e4:	7f 01       	movw	r14, r30
    76e6:	90 e0       	ldi	r25, 0x00	; 0
    76e8:	a0 e0       	ldi	r26, 0x00	; 0
    76ea:	b0 e0       	ldi	r27, 0x00	; 0
    76ec:	dc 01       	movw	r26, r24
    76ee:	99 27       	eor	r25, r25
    76f0:	88 27       	eor	r24, r24
    76f2:	28 2b       	or	r18, r24
    76f4:	39 2b       	or	r19, r25
    76f6:	4a 2b       	or	r20, r26
    76f8:	5b 2b       	or	r21, r27
    76fa:	6e ef       	ldi	r22, 0xFE	; 254
    76fc:	7f ef       	ldi	r23, 0xFF	; 255
    76fe:	e6 0e       	add	r14, r22
    7700:	f7 1e       	adc	r15, r23
    7702:	d7 01       	movw	r26, r14
    7704:	8d 91       	ld	r24, X+
    7706:	7d 01       	movw	r14, r26
    7708:	90 e0       	ldi	r25, 0x00	; 0
    770a:	a0 e0       	ldi	r26, 0x00	; 0
    770c:	b0 e0       	ldi	r27, 0x00	; 0
    770e:	28 2b       	or	r18, r24
    7710:	39 2b       	or	r19, r25
    7712:	4a 2b       	or	r20, r26
    7714:	5b 2b       	or	r21, r27
    7716:	f7 01       	movw	r30, r14
    7718:	90 81       	ld	r25, Z
    771a:	69 ee       	ldi	r22, 0xE9	; 233
    771c:	7d ef       	ldi	r23, 0xFD	; 253
    771e:	e6 0e       	add	r14, r22
    7720:	f7 1e       	adc	r15, r23
    7722:	80 e0       	ldi	r24, 0x00	; 0
    7724:	a0 e0       	ldi	r26, 0x00	; 0
    7726:	b0 e0       	ldi	r27, 0x00	; 0
    7728:	28 2b       	or	r18, r24
    772a:	39 2b       	or	r19, r25
    772c:	4a 2b       	or	r20, r26
    772e:	5b 2b       	or	r21, r27
    7730:	d7 01       	movw	r26, r14
    7732:	1e 96       	adiw	r26, 0x0e	; 14
    7734:	2d 93       	st	X+, r18
    7736:	3d 93       	st	X+, r19
    7738:	4d 93       	st	X+, r20
    773a:	5c 93       	st	X, r21
    773c:	51 97       	sbiw	r26, 0x11	; 17
    773e:	62 ce       	rjmp	.-828    	; 0x7404 <chk_mounted+0x542>
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
	fmt = FS_FAT12;
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;
    7740:	12 e0       	ldi	r17, 0x02	; 2
    7742:	7b ce       	rjmp	.-778    	; 0x743a <chk_mounted+0x578>

00007744 <f_opendir>:

FRESULT f_opendir (
	DIR *dj,			/* Pointer to directory object to create */
	const TCHAR *path	/* Pointer to the directory path */
)
{
    7744:	0f 93       	push	r16
    7746:	1f 93       	push	r17
    7748:	df 93       	push	r29
    774a:	cf 93       	push	r28
    774c:	cd b7       	in	r28, 0x3d	; 61
    774e:	de b7       	in	r29, 0x3e	; 62
    7750:	2e 97       	sbiw	r28, 0x0e	; 14
    7752:	0f b6       	in	r0, 0x3f	; 63
    7754:	f8 94       	cli
    7756:	de bf       	out	0x3e, r29	; 62
    7758:	0f be       	out	0x3f, r0	; 63
    775a:	cd bf       	out	0x3d, r28	; 61
    775c:	8c 01       	movw	r16, r24
    775e:	7e 87       	std	Y+14, r23	; 0x0e
    7760:	6d 87       	std	Y+13, r22	; 0x0d
	FRESULT res;
	DEF_NAMEBUF;


	res = chk_mounted(&path, &dj->fs, 0);
    7762:	ce 01       	movw	r24, r28
    7764:	0d 96       	adiw	r24, 0x0d	; 13
    7766:	b8 01       	movw	r22, r16
    7768:	40 e0       	ldi	r20, 0x00	; 0
    776a:	0e 94 61 37 	call	0x6ec2	; 0x6ec2 <chk_mounted>
	if (res == FR_OK) {
    776e:	88 23       	and	r24, r24
    7770:	59 f0       	breq	.+22     	; 0x7788 <f_opendir+0x44>
		}
		if (res == FR_NO_FILE) res = FR_NO_PATH;
	}

	LEAVE_FF(dj->fs, res);
}
    7772:	2e 96       	adiw	r28, 0x0e	; 14
    7774:	0f b6       	in	r0, 0x3f	; 63
    7776:	f8 94       	cli
    7778:	de bf       	out	0x3e, r29	; 62
    777a:	0f be       	out	0x3f, r0	; 63
    777c:	cd bf       	out	0x3d, r28	; 61
    777e:	cf 91       	pop	r28
    7780:	df 91       	pop	r29
    7782:	1f 91       	pop	r17
    7784:	0f 91       	pop	r16
    7786:	08 95       	ret
	DEF_NAMEBUF;


	res = chk_mounted(&path, &dj->fs, 0);
	if (res == FR_OK) {
		INIT_BUF(*dj);
    7788:	ce 01       	movw	r24, r28
    778a:	01 96       	adiw	r24, 0x01	; 1
    778c:	d8 01       	movw	r26, r16
    778e:	55 96       	adiw	r26, 0x15	; 21
    7790:	9c 93       	st	X, r25
    7792:	8e 93       	st	-X, r24
    7794:	54 97       	sbiw	r26, 0x14	; 20
		res = follow_path(dj, path);			/* Follow the path to the directory */
    7796:	6d 85       	ldd	r22, Y+13	; 0x0d
    7798:	7e 85       	ldd	r23, Y+14	; 0x0e
    779a:	c8 01       	movw	r24, r16
    779c:	0e 94 36 31 	call	0x626c	; 0x626c <follow_path>
		FREE_BUF();
		if (res == FR_OK) {						/* Follow completed */
    77a0:	88 23       	and	r24, r24
    77a2:	a9 f5       	brne	.+106    	; 0x780e <f_opendir+0xca>
			if (dj->dir) {						/* It is not the root dir */
    77a4:	d8 01       	movw	r26, r16
    77a6:	52 96       	adiw	r26, 0x12	; 18
    77a8:	ed 91       	ld	r30, X+
    77aa:	fc 91       	ld	r31, X
    77ac:	53 97       	sbiw	r26, 0x13	; 19
    77ae:	30 97       	sbiw	r30, 0x00	; 0
    77b0:	f9 f0       	breq	.+62     	; 0x77f0 <f_opendir+0xac>
				if (dj->dir[DIR_Attr] & AM_DIR) {	/* The object is a directory */
    77b2:	83 85       	ldd	r24, Z+11	; 0x0b
    77b4:	84 ff       	sbrs	r24, 4
    77b6:	2e c0       	rjmp	.+92     	; 0x7814 <f_opendir+0xd0>
					dj->sclust = LD_CLUST(dj->dir);
    77b8:	35 89       	ldd	r19, Z+21	; 0x15
    77ba:	20 e0       	ldi	r18, 0x00	; 0
    77bc:	84 89       	ldd	r24, Z+20	; 0x14
    77be:	90 e0       	ldi	r25, 0x00	; 0
    77c0:	28 2b       	or	r18, r24
    77c2:	39 2b       	or	r19, r25
    77c4:	40 e0       	ldi	r20, 0x00	; 0
    77c6:	50 e0       	ldi	r21, 0x00	; 0
    77c8:	a9 01       	movw	r20, r18
    77ca:	33 27       	eor	r19, r19
    77cc:	22 27       	eor	r18, r18
    77ce:	93 8d       	ldd	r25, Z+27	; 0x1b
    77d0:	80 e0       	ldi	r24, 0x00	; 0
    77d2:	62 8d       	ldd	r22, Z+26	; 0x1a
    77d4:	70 e0       	ldi	r23, 0x00	; 0
    77d6:	86 2b       	or	r24, r22
    77d8:	97 2b       	or	r25, r23
    77da:	a0 e0       	ldi	r26, 0x00	; 0
    77dc:	b0 e0       	ldi	r27, 0x00	; 0
    77de:	28 2b       	or	r18, r24
    77e0:	39 2b       	or	r19, r25
    77e2:	4a 2b       	or	r20, r26
    77e4:	5b 2b       	or	r21, r27
    77e6:	f8 01       	movw	r30, r16
    77e8:	26 83       	std	Z+6, r18	; 0x06
    77ea:	37 83       	std	Z+7, r19	; 0x07
    77ec:	40 87       	std	Z+8, r20	; 0x08
    77ee:	51 87       	std	Z+9, r21	; 0x09
				} else {						/* The object is not a directory */
					res = FR_NO_PATH;
				}
			}
			if (res == FR_OK) {
				dj->id = dj->fs->id;
    77f0:	d8 01       	movw	r26, r16
    77f2:	ed 91       	ld	r30, X+
    77f4:	fc 91       	ld	r31, X
    77f6:	11 97       	sbiw	r26, 0x01	; 1
    77f8:	86 81       	ldd	r24, Z+6	; 0x06
    77fa:	97 81       	ldd	r25, Z+7	; 0x07
    77fc:	13 96       	adiw	r26, 0x03	; 3
    77fe:	9c 93       	st	X, r25
    7800:	8e 93       	st	-X, r24
    7802:	12 97       	sbiw	r26, 0x02	; 2
				res = dir_sdi(dj, 0);			/* Rewind dir */
    7804:	c8 01       	movw	r24, r16
    7806:	60 e0       	ldi	r22, 0x00	; 0
    7808:	70 e0       	ldi	r23, 0x00	; 0
    780a:	0e 94 30 29 	call	0x5260	; 0x5260 <dir_sdi>
			}
		}
		if (res == FR_NO_FILE) res = FR_NO_PATH;
    780e:	84 30       	cpi	r24, 0x04	; 4
    7810:	09 f0       	breq	.+2      	; 0x7814 <f_opendir+0xd0>
    7812:	af cf       	rjmp	.-162    	; 0x7772 <f_opendir+0x2e>
    7814:	85 e0       	ldi	r24, 0x05	; 5
    7816:	ad cf       	rjmp	.-166    	; 0x7772 <f_opendir+0x2e>

00007818 <f_open>:
FRESULT f_open (
	FIL *fp,			/* Pointer to the blank file object */
	const TCHAR *path,	/* Pointer to the file name */
	BYTE mode			/* Access mode and file open mode flags */
)
{
    7818:	2f 92       	push	r2
    781a:	3f 92       	push	r3
    781c:	4f 92       	push	r4
    781e:	5f 92       	push	r5
    7820:	6f 92       	push	r6
    7822:	7f 92       	push	r7
    7824:	8f 92       	push	r8
    7826:	9f 92       	push	r9
    7828:	af 92       	push	r10
    782a:	bf 92       	push	r11
    782c:	cf 92       	push	r12
    782e:	df 92       	push	r13
    7830:	ef 92       	push	r14
    7832:	ff 92       	push	r15
    7834:	0f 93       	push	r16
    7836:	1f 93       	push	r17
    7838:	df 93       	push	r29
    783a:	cf 93       	push	r28
    783c:	cd b7       	in	r28, 0x3d	; 61
    783e:	de b7       	in	r29, 0x3e	; 62
    7840:	ad 97       	sbiw	r28, 0x2d	; 45
    7842:	0f b6       	in	r0, 0x3f	; 63
    7844:	f8 94       	cli
    7846:	de bf       	out	0x3e, r29	; 62
    7848:	0f be       	out	0x3f, r0	; 63
    784a:	cd bf       	out	0x3d, r28	; 61
    784c:	2c 01       	movw	r4, r24
    784e:	7c a3       	std	Y+36, r23	; 0x24
    7850:	6b a3       	std	Y+35, r22	; 0x23
	DIR dj;
	BYTE *dir;
	DEF_NAMEBUF;


	fp->fs = 0;			/* Clear file object */
    7852:	dc 01       	movw	r26, r24
    7854:	1d 92       	st	X+, r1
    7856:	1c 92       	st	X, r1

#if !_FS_READONLY
	mode &= FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW;
    7858:	ef e1       	ldi	r30, 0x1F	; 31
    785a:	3e 2e       	mov	r3, r30
    785c:	34 22       	and	r3, r20
	res = chk_mounted(&path, &dj.fs, (BYTE)(mode & ~FA_READ));
    785e:	7d e0       	ldi	r23, 0x0D	; 13
    7860:	e7 2e       	mov	r14, r23
    7862:	f1 2c       	mov	r15, r1
    7864:	ec 0e       	add	r14, r28
    7866:	fd 1e       	adc	r15, r29
    7868:	4e 71       	andi	r20, 0x1E	; 30
    786a:	ce 01       	movw	r24, r28
    786c:	83 96       	adiw	r24, 0x23	; 35
    786e:	b7 01       	movw	r22, r14
    7870:	0e 94 61 37 	call	0x6ec2	; 0x6ec2 <chk_mounted>
    7874:	18 2f       	mov	r17, r24
#else
	mode &= FA_READ;
	res = chk_mounted(&path, &dj.fs, 0);
#endif
	INIT_BUF(dj);
    7876:	ce 01       	movw	r24, r28
    7878:	01 96       	adiw	r24, 0x01	; 1
    787a:	9a a3       	std	Y+34, r25	; 0x22
    787c:	89 a3       	std	Y+33, r24	; 0x21
	if (res == FR_OK)
    787e:	11 23       	and	r17, r17
    7880:	c9 f1       	breq	.+114    	; 0x78f4 <f_open+0xdc>
		res = follow_path(&dj, path);	/* Follow the file path */
	dir = dj.dir;
    7882:	af 8c       	ldd	r10, Y+31	; 0x1f
    7884:	b8 a0       	ldd	r11, Y+32	; 0x20
		else
			res = chk_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
#endif
	}
	/* Create or Open a file */
	if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
    7886:	63 2c       	mov	r6, r3
    7888:	77 24       	eor	r7, r7
    788a:	c3 01       	movw	r24, r6
    788c:	8c 71       	andi	r24, 0x1C	; 28
    788e:	90 70       	andi	r25, 0x00	; 0
    7890:	89 2b       	or	r24, r25
    7892:	f9 f0       	breq	.+62     	; 0x78d2 <f_open+0xba>
		DWORD dw, cl;

		if (res != FR_OK) {					/* No file, create new */
    7894:	11 23       	and	r17, r17
    7896:	51 f1       	breq	.+84     	; 0x78ec <f_open+0xd4>
			if (res == FR_NO_FILE)			/* There is no file to open, create a new entry */
    7898:	14 30       	cpi	r17, 0x04	; 4
    789a:	09 f4       	brne	.+2      	; 0x789e <f_open+0x86>
    789c:	a5 c1       	rjmp	.+842    	; 0x7be8 <f_open+0x3d0>
#endif
		fp->fs = dj.fs; fp->id = dj.fs->id;	/* Validate file object */
	}

	LEAVE_FF(dj.fs, res);
}
    789e:	81 2f       	mov	r24, r17
    78a0:	ad 96       	adiw	r28, 0x2d	; 45
    78a2:	0f b6       	in	r0, 0x3f	; 63
    78a4:	f8 94       	cli
    78a6:	de bf       	out	0x3e, r29	; 62
    78a8:	0f be       	out	0x3f, r0	; 63
    78aa:	cd bf       	out	0x3d, r28	; 61
    78ac:	cf 91       	pop	r28
    78ae:	df 91       	pop	r29
    78b0:	1f 91       	pop	r17
    78b2:	0f 91       	pop	r16
    78b4:	ff 90       	pop	r15
    78b6:	ef 90       	pop	r14
    78b8:	df 90       	pop	r13
    78ba:	cf 90       	pop	r12
    78bc:	bf 90       	pop	r11
    78be:	af 90       	pop	r10
    78c0:	9f 90       	pop	r9
    78c2:	8f 90       	pop	r8
    78c4:	7f 90       	pop	r7
    78c6:	6f 90       	pop	r6
    78c8:	5f 90       	pop	r5
    78ca:	4f 90       	pop	r4
    78cc:	3f 90       	pop	r3
    78ce:	2f 90       	pop	r2
    78d0:	08 95       	ret
				}
			}
		}
	}
	else {	/* Open an existing file */
		if (res == FR_OK) {						/* Follow succeeded */
    78d2:	11 23       	and	r17, r17
    78d4:	21 f7       	brne	.-56     	; 0x789e <f_open+0x86>
			if (dir[DIR_Attr] & AM_DIR) {		/* It is a directory */
    78d6:	d5 01       	movw	r26, r10
    78d8:	1b 96       	adiw	r26, 0x0b	; 11
    78da:	8c 91       	ld	r24, X
    78dc:	84 fd       	sbrc	r24, 4
    78de:	1b c0       	rjmp	.+54     	; 0x7916 <f_open+0xfe>
				res = FR_NO_FILE;
			} else {
				if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
    78e0:	31 fe       	sbrs	r3, 1
    78e2:	7a c1       	rjmp	.+756    	; 0x7bd8 <f_open+0x3c0>
    78e4:	80 ff       	sbrs	r24, 0
    78e6:	78 c1       	rjmp	.+752    	; 0x7bd8 <f_open+0x3c0>
	res = chk_mounted(&path, &dj.fs, 0);
#endif
	INIT_BUF(dj);
	if (res == FR_OK)
		res = follow_path(&dj, path);	/* Follow the file path */
	dir = dj.dir;
    78e8:	17 e0       	ldi	r17, 0x07	; 7
    78ea:	d9 cf       	rjmp	.-78     	; 0x789e <f_open+0x86>
#endif
			mode |= FA_CREATE_ALWAYS;		/* File is created */
			dir = dj.dir;					/* New entry */
		}
		else {								/* Any object is already existing */
			if (mode & FA_CREATE_NEW) {		/* Cannot create new */
    78ec:	32 fe       	sbrs	r3, 2
    78ee:	15 c0       	rjmp	.+42     	; 0x791a <f_open+0x102>
    78f0:	18 e0       	ldi	r17, 0x08	; 8
    78f2:	d5 cf       	rjmp	.-86     	; 0x789e <f_open+0x86>
	mode &= FA_READ;
	res = chk_mounted(&path, &dj.fs, 0);
#endif
	INIT_BUF(dj);
	if (res == FR_OK)
		res = follow_path(&dj, path);	/* Follow the file path */
    78f4:	6b a1       	ldd	r22, Y+35	; 0x23
    78f6:	7c a1       	ldd	r23, Y+36	; 0x24
    78f8:	c7 01       	movw	r24, r14
    78fa:	0e 94 36 31 	call	0x626c	; 0x626c <follow_path>
    78fe:	18 2f       	mov	r17, r24
	dir = dj.dir;
    7900:	af 8c       	ldd	r10, Y+31	; 0x1f
    7902:	b8 a0       	ldd	r11, Y+32	; 0x20

#if !_FS_READONLY	/* R/W configuration */
	if (res == FR_OK) {
    7904:	88 23       	and	r24, r24
    7906:	09 f0       	breq	.+2      	; 0x790a <f_open+0xf2>
    7908:	be cf       	rjmp	.-132    	; 0x7886 <f_open+0x6e>
		if (!dir)	/* Current dir itself */
    790a:	a1 14       	cp	r10, r1
    790c:	b1 04       	cpc	r11, r1
    790e:	09 f0       	breq	.+2      	; 0x7912 <f_open+0xfa>
    7910:	ba cf       	rjmp	.-140    	; 0x7886 <f_open+0x6e>
    7912:	16 e0       	ldi	r17, 0x06	; 6
    7914:	b8 cf       	rjmp	.-144    	; 0x7886 <f_open+0x6e>
			}
		}
	}
	else {	/* Open an existing file */
		if (res == FR_OK) {						/* Follow succeeded */
			if (dir[DIR_Attr] & AM_DIR) {		/* It is a directory */
    7916:	14 e0       	ldi	r17, 0x04	; 4
    7918:	c2 cf       	rjmp	.-124    	; 0x789e <f_open+0x86>
		}
		else {								/* Any object is already existing */
			if (mode & FA_CREATE_NEW) {		/* Cannot create new */
				res = FR_EXIST;
			} else {
				if (dir[DIR_Attr] & (AM_RDO | AM_DIR))	/* Cannot overwrite it (R/O or DIR) */
    791a:	d5 01       	movw	r26, r10
    791c:	1b 96       	adiw	r26, 0x0b	; 11
    791e:	8c 91       	ld	r24, X
    7920:	81 71       	andi	r24, 0x11	; 17
    7922:	11 f7       	brne	.-60     	; 0x78e8 <f_open+0xd0>
					res = FR_DENIED;
			}
		}
		if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
    7924:	68 e0       	ldi	r22, 0x08	; 8
    7926:	e6 2e       	mov	r14, r22
    7928:	f1 2c       	mov	r15, r1
    792a:	e6 20       	and	r14, r6
    792c:	f7 20       	and	r15, r7
    792e:	63 fc       	sbrc	r6, 3
    7930:	7d c0       	rjmp	.+250    	; 0x7a2c <f_open+0x214>
				if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
					res = FR_DENIED;
			}
		}
	}
	if (res == FR_OK) {
    7932:	8d 84       	ldd	r8, Y+13	; 0x0d
    7934:	9e 84       	ldd	r9, Y+14	; 0x0e
    7936:	10 e0       	ldi	r17, 0x00	; 0
		if (mode & FA_CREATE_ALWAYS)			/* Set file change flag if created or overwritten */
    7938:	ef 28       	or	r14, r15
    793a:	11 f0       	breq	.+4      	; 0x7940 <f_open+0x128>
			mode |= FA__WRITTEN;
    793c:	b0 e2       	ldi	r27, 0x20	; 32
    793e:	3b 2a       	or	r3, r27
		fp->dir_sect = dj.fs->winsect;			/* Pointer to the directory entry */
    7940:	f4 01       	movw	r30, r8
    7942:	82 a5       	ldd	r24, Z+42	; 0x2a
    7944:	93 a5       	ldd	r25, Z+43	; 0x2b
    7946:	a4 a5       	ldd	r26, Z+44	; 0x2c
    7948:	b5 a5       	ldd	r27, Z+45	; 0x2d
    794a:	f2 01       	movw	r30, r4
    794c:	82 8f       	std	Z+26, r24	; 0x1a
    794e:	93 8f       	std	Z+27, r25	; 0x1b
    7950:	a4 8f       	std	Z+28, r26	; 0x1c
    7952:	b5 8f       	std	Z+29, r27	; 0x1d
		fp->dir_ptr = dir;
    7954:	b7 8e       	std	Z+31, r11	; 0x1f
    7956:	a6 8e       	std	Z+30, r10	; 0x1e
	}
#endif
	FREE_BUF();

	if (res == FR_OK) {
		fp->flag = mode;					/* File access mode */
    7958:	34 82       	std	Z+4, r3	; 0x04
		fp->org_clust =	LD_CLUST(dir);		/* File start cluster */
    795a:	d5 01       	movw	r26, r10
    795c:	55 96       	adiw	r26, 0x15	; 21
    795e:	3c 91       	ld	r19, X
    7960:	55 97       	sbiw	r26, 0x15	; 21
    7962:	20 e0       	ldi	r18, 0x00	; 0
    7964:	54 96       	adiw	r26, 0x14	; 20
    7966:	8c 91       	ld	r24, X
    7968:	54 97       	sbiw	r26, 0x14	; 20
    796a:	90 e0       	ldi	r25, 0x00	; 0
    796c:	28 2b       	or	r18, r24
    796e:	39 2b       	or	r19, r25
    7970:	40 e0       	ldi	r20, 0x00	; 0
    7972:	50 e0       	ldi	r21, 0x00	; 0
    7974:	a9 01       	movw	r20, r18
    7976:	33 27       	eor	r19, r19
    7978:	22 27       	eor	r18, r18
    797a:	5b 96       	adiw	r26, 0x1b	; 27
    797c:	9c 91       	ld	r25, X
    797e:	5b 97       	sbiw	r26, 0x1b	; 27
    7980:	80 e0       	ldi	r24, 0x00	; 0
    7982:	5a 96       	adiw	r26, 0x1a	; 26
    7984:	6c 91       	ld	r22, X
    7986:	70 e0       	ldi	r23, 0x00	; 0
    7988:	86 2b       	or	r24, r22
    798a:	97 2b       	or	r25, r23
    798c:	a0 e0       	ldi	r26, 0x00	; 0
    798e:	b0 e0       	ldi	r27, 0x00	; 0
    7990:	28 2b       	or	r18, r24
    7992:	39 2b       	or	r19, r25
    7994:	4a 2b       	or	r20, r26
    7996:	5b 2b       	or	r21, r27
    7998:	26 87       	std	Z+14, r18	; 0x0e
    799a:	37 87       	std	Z+15, r19	; 0x0f
    799c:	40 8b       	std	Z+16, r20	; 0x10
    799e:	51 8b       	std	Z+17, r21	; 0x11
		fp->fsize = LD_DWORD(dir+DIR_FileSize);	/* File size */
    79a0:	d5 01       	movw	r26, r10
    79a2:	5f 96       	adiw	r26, 0x1f	; 31
    79a4:	2c 91       	ld	r18, X
    79a6:	5f 97       	sbiw	r26, 0x1f	; 31
    79a8:	30 e0       	ldi	r19, 0x00	; 0
    79aa:	40 e0       	ldi	r20, 0x00	; 0
    79ac:	50 e0       	ldi	r21, 0x00	; 0
    79ae:	52 2f       	mov	r21, r18
    79b0:	44 27       	eor	r20, r20
    79b2:	33 27       	eor	r19, r19
    79b4:	22 27       	eor	r18, r18
    79b6:	5e 96       	adiw	r26, 0x1e	; 30
    79b8:	8c 91       	ld	r24, X
    79ba:	90 e0       	ldi	r25, 0x00	; 0
    79bc:	a0 e0       	ldi	r26, 0x00	; 0
    79be:	b0 e0       	ldi	r27, 0x00	; 0
    79c0:	dc 01       	movw	r26, r24
    79c2:	99 27       	eor	r25, r25
    79c4:	88 27       	eor	r24, r24
    79c6:	28 2b       	or	r18, r24
    79c8:	39 2b       	or	r19, r25
    79ca:	4a 2b       	or	r20, r26
    79cc:	5b 2b       	or	r21, r27
    79ce:	f5 01       	movw	r30, r10
    79d0:	84 8d       	ldd	r24, Z+28	; 0x1c
    79d2:	90 e0       	ldi	r25, 0x00	; 0
    79d4:	a0 e0       	ldi	r26, 0x00	; 0
    79d6:	b0 e0       	ldi	r27, 0x00	; 0
    79d8:	28 2b       	or	r18, r24
    79da:	39 2b       	or	r19, r25
    79dc:	4a 2b       	or	r20, r26
    79de:	5b 2b       	or	r21, r27
    79e0:	95 8d       	ldd	r25, Z+29	; 0x1d
    79e2:	80 e0       	ldi	r24, 0x00	; 0
    79e4:	a0 e0       	ldi	r26, 0x00	; 0
    79e6:	b0 e0       	ldi	r27, 0x00	; 0
    79e8:	28 2b       	or	r18, r24
    79ea:	39 2b       	or	r19, r25
    79ec:	4a 2b       	or	r20, r26
    79ee:	5b 2b       	or	r21, r27
    79f0:	d2 01       	movw	r26, r4
    79f2:	1a 96       	adiw	r26, 0x0a	; 10
    79f4:	2d 93       	st	X+, r18
    79f6:	3d 93       	st	X+, r19
    79f8:	4d 93       	st	X+, r20
    79fa:	5c 93       	st	X, r21
    79fc:	1d 97       	sbiw	r26, 0x0d	; 13
		fp->fptr = 0;						/* File pointer */
    79fe:	f2 01       	movw	r30, r4
    7a00:	16 82       	std	Z+6, r1	; 0x06
    7a02:	17 82       	std	Z+7, r1	; 0x07
    7a04:	10 86       	std	Z+8, r1	; 0x08
    7a06:	11 86       	std	Z+9, r1	; 0x09
		fp->dsect = 0;
    7a08:	56 96       	adiw	r26, 0x16	; 22
    7a0a:	1d 92       	st	X+, r1
    7a0c:	1d 92       	st	X+, r1
    7a0e:	1d 92       	st	X+, r1
    7a10:	1c 92       	st	X, r1
    7a12:	59 97       	sbiw	r26, 0x19	; 25
#if _USE_FASTSEEK
		fp->cltbl = 0;						/* No cluster link map table */
#endif
		fp->fs = dj.fs; fp->id = dj.fs->id;	/* Validate file object */
    7a14:	11 96       	adiw	r26, 0x01	; 1
    7a16:	9c 92       	st	X, r9
    7a18:	8e 92       	st	-X, r8
    7a1a:	ed 85       	ldd	r30, Y+13	; 0x0d
    7a1c:	fe 85       	ldd	r31, Y+14	; 0x0e
    7a1e:	86 81       	ldd	r24, Z+6	; 0x06
    7a20:	97 81       	ldd	r25, Z+7	; 0x07
    7a22:	13 96       	adiw	r26, 0x03	; 3
    7a24:	9c 93       	st	X, r25
    7a26:	8e 93       	st	-X, r24
    7a28:	12 97       	sbiw	r26, 0x02	; 2
    7a2a:	39 cf       	rjmp	.-398    	; 0x789e <f_open+0x86>
				if (dir[DIR_Attr] & (AM_RDO | AM_DIR))	/* Cannot overwrite it (R/O or DIR) */
					res = FR_DENIED;
			}
		}
		if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
			dw = get_fattime();					/* Created time */
    7a2c:	0e 94 4c 4e 	call	0x9c98	; 0x9c98 <get_fattime>
			ST_DWORD(dir+DIR_CrtTime, dw);
    7a30:	f5 01       	movw	r30, r10
    7a32:	66 87       	std	Z+14, r22	; 0x0e
    7a34:	27 2f       	mov	r18, r23
    7a36:	33 27       	eor	r19, r19
    7a38:	27 87       	std	Z+15, r18	; 0x0f
    7a3a:	9c 01       	movw	r18, r24
    7a3c:	44 27       	eor	r20, r20
    7a3e:	55 27       	eor	r21, r21
    7a40:	20 8b       	std	Z+16, r18	; 0x10
    7a42:	69 2f       	mov	r22, r25
    7a44:	77 27       	eor	r23, r23
    7a46:	88 27       	eor	r24, r24
    7a48:	99 27       	eor	r25, r25
    7a4a:	61 8b       	std	Z+17, r22	; 0x11
			dir[DIR_Attr] = 0;					/* Reset attribute */
    7a4c:	13 86       	std	Z+11, r1	; 0x0b
			ST_DWORD(dir+DIR_FileSize, 0);		/* size = 0 */
    7a4e:	14 8e       	std	Z+28, r1	; 0x1c
    7a50:	15 8e       	std	Z+29, r1	; 0x1d
    7a52:	16 8e       	std	Z+30, r1	; 0x1e
    7a54:	17 8e       	std	Z+31, r1	; 0x1f
			cl = LD_CLUST(dir);					/* Get start cluster */
    7a56:	95 89       	ldd	r25, Z+21	; 0x15
    7a58:	80 e0       	ldi	r24, 0x00	; 0
    7a5a:	24 89       	ldd	r18, Z+20	; 0x14
    7a5c:	30 e0       	ldi	r19, 0x00	; 0
    7a5e:	82 2b       	or	r24, r18
    7a60:	93 2b       	or	r25, r19
    7a62:	a0 e0       	ldi	r26, 0x00	; 0
    7a64:	b0 e0       	ldi	r27, 0x00	; 0
    7a66:	ac 01       	movw	r20, r24
    7a68:	33 27       	eor	r19, r19
    7a6a:	22 27       	eor	r18, r18
    7a6c:	29 a7       	std	Y+41, r18	; 0x29
    7a6e:	3a a7       	std	Y+42, r19	; 0x2a
    7a70:	4b a7       	std	Y+43, r20	; 0x2b
    7a72:	5c a7       	std	Y+44, r21	; 0x2c
    7a74:	93 8d       	ldd	r25, Z+27	; 0x1b
    7a76:	80 e0       	ldi	r24, 0x00	; 0
    7a78:	22 8d       	ldd	r18, Z+26	; 0x1a
    7a7a:	30 e0       	ldi	r19, 0x00	; 0
    7a7c:	82 2b       	or	r24, r18
    7a7e:	93 2b       	or	r25, r19
    7a80:	a0 e0       	ldi	r26, 0x00	; 0
    7a82:	b0 e0       	ldi	r27, 0x00	; 0
    7a84:	29 a5       	ldd	r18, Y+41	; 0x29
    7a86:	3a a5       	ldd	r19, Y+42	; 0x2a
    7a88:	4b a5       	ldd	r20, Y+43	; 0x2b
    7a8a:	5c a5       	ldd	r21, Y+44	; 0x2c
    7a8c:	28 2b       	or	r18, r24
    7a8e:	39 2b       	or	r19, r25
    7a90:	4a 2b       	or	r20, r26
    7a92:	5b 2b       	or	r21, r27
    7a94:	29 a7       	std	Y+41, r18	; 0x29
    7a96:	3a a7       	std	Y+42, r19	; 0x2a
    7a98:	4b a7       	std	Y+43, r20	; 0x2b
    7a9a:	5c a7       	std	Y+44, r21	; 0x2c
			ST_CLUST(dir, 0);					/* cluster = 0 */
    7a9c:	12 8e       	std	Z+26, r1	; 0x1a
    7a9e:	13 8e       	std	Z+27, r1	; 0x1b
    7aa0:	14 8a       	std	Z+20, r1	; 0x14
    7aa2:	15 8a       	std	Z+21, r1	; 0x15
			dj.fs->wflag = 1;
    7aa4:	8d 84       	ldd	r8, Y+13	; 0x0d
    7aa6:	9e 84       	ldd	r9, Y+14	; 0x0e
    7aa8:	81 e0       	ldi	r24, 0x01	; 1
    7aaa:	d4 01       	movw	r26, r8
    7aac:	14 96       	adiw	r26, 0x04	; 4
    7aae:	8c 93       	st	X, r24
    7ab0:	14 97       	sbiw	r26, 0x04	; 4
			if (cl) {							/* Remove the cluster chain if exist */
    7ab2:	21 15       	cp	r18, r1
    7ab4:	31 05       	cpc	r19, r1
    7ab6:	41 05       	cpc	r20, r1
    7ab8:	51 05       	cpc	r21, r1
    7aba:	09 f4       	brne	.+2      	; 0x7abe <f_open+0x2a6>
    7abc:	3c cf       	rjmp	.-392    	; 0x7936 <f_open+0x11e>
				dw = dj.fs->winsect;
    7abe:	9a 96       	adiw	r26, 0x2a	; 42
    7ac0:	2d 91       	ld	r18, X+
    7ac2:	3d 91       	ld	r19, X+
    7ac4:	4d 91       	ld	r20, X+
    7ac6:	5c 91       	ld	r21, X
    7ac8:	9d 97       	sbiw	r26, 0x2d	; 45
    7aca:	2d a3       	std	Y+37, r18	; 0x25
    7acc:	3e a3       	std	Y+38, r19	; 0x26
    7ace:	4f a3       	std	Y+39, r20	; 0x27
    7ad0:	58 a7       	std	Y+40, r21	; 0x28
	DWORD nxt;
#if _USE_ERASE
	DWORD scl = clst, ecl = clst, resion[2];
#endif

	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
    7ad2:	29 a5       	ldd	r18, Y+41	; 0x29
    7ad4:	3a a5       	ldd	r19, Y+42	; 0x2a
    7ad6:	4b a5       	ldd	r20, Y+43	; 0x2b
    7ad8:	5c a5       	ldd	r21, Y+44	; 0x2c
    7ada:	21 30       	cpi	r18, 0x01	; 1
    7adc:	31 05       	cpc	r19, r1
    7ade:	41 05       	cpc	r20, r1
    7ae0:	51 05       	cpc	r21, r1
    7ae2:	09 f4       	brne	.+2      	; 0x7ae6 <f_open+0x2ce>
    7ae4:	a6 c0       	rjmp	.+332    	; 0x7c32 <f_open+0x41a>
    7ae6:	56 96       	adiw	r26, 0x16	; 22
    7ae8:	8d 91       	ld	r24, X+
    7aea:	9d 91       	ld	r25, X+
    7aec:	0d 90       	ld	r0, X+
    7aee:	bc 91       	ld	r27, X
    7af0:	a0 2d       	mov	r26, r0
    7af2:	28 17       	cp	r18, r24
    7af4:	39 07       	cpc	r19, r25
    7af6:	4a 07       	cpc	r20, r26
    7af8:	5b 07       	cpc	r21, r27
    7afa:	08 f0       	brcs	.+2      	; 0x7afe <f_open+0x2e6>
    7afc:	9a c0       	rjmp	.+308    	; 0x7c32 <f_open+0x41a>
    7afe:	2d a7       	std	Y+45, r18	; 0x2d
    7b00:	2a a4       	ldd	r2, Y+42	; 0x2a
    7b02:	0b a5       	ldd	r16, Y+43	; 0x2b
    7b04:	1c a5       	ldd	r17, Y+44	; 0x2c
    7b06:	41 c0       	rjmp	.+130    	; 0x7b8a <f_open+0x372>
	} else {
		res = FR_OK;
		while (clst < fs->n_fatent) {			/* Not a last link? */
			nxt = get_fat(fs, clst);			/* Get cluster status */
			if (nxt == 0) break;				/* Empty cluster? */
			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
    7b08:	61 30       	cpi	r22, 0x01	; 1
    7b0a:	71 05       	cpc	r23, r1
    7b0c:	81 05       	cpc	r24, r1
    7b0e:	91 05       	cpc	r25, r1
    7b10:	09 f4       	brne	.+2      	; 0x7b14 <f_open+0x2fc>
    7b12:	8f c0       	rjmp	.+286    	; 0x7c32 <f_open+0x41a>
			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
    7b14:	6f 3f       	cpi	r22, 0xFF	; 255
    7b16:	4f ef       	ldi	r20, 0xFF	; 255
    7b18:	74 07       	cpc	r23, r20
    7b1a:	4f ef       	ldi	r20, 0xFF	; 255
    7b1c:	84 07       	cpc	r24, r20
    7b1e:	4f ef       	ldi	r20, 0xFF	; 255
    7b20:	94 07       	cpc	r25, r20
    7b22:	09 f4       	brne	.+2      	; 0x7b26 <f_open+0x30e>
    7b24:	b8 c0       	rjmp	.+368    	; 0x7c96 <f_open+0x47e>
			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
    7b26:	c4 01       	movw	r24, r8
    7b28:	4d a5       	ldd	r20, Y+45	; 0x2d
    7b2a:	52 2d       	mov	r21, r2
    7b2c:	b8 01       	movw	r22, r16
    7b2e:	00 e0       	ldi	r16, 0x00	; 0
    7b30:	10 e0       	ldi	r17, 0x00	; 0
    7b32:	20 e0       	ldi	r18, 0x00	; 0
    7b34:	30 e0       	ldi	r19, 0x00	; 0
    7b36:	0e 94 07 27 	call	0x4e0e	; 0x4e0e <put_fat>
    7b3a:	18 2f       	mov	r17, r24
			if (res != FR_OK) break;
    7b3c:	88 23       	and	r24, r24
    7b3e:	09 f0       	breq	.+2      	; 0x7b42 <f_open+0x32a>
    7b40:	ae ce       	rjmp	.-676    	; 0x789e <f_open+0x86>
			if (fs->free_clust != 0xFFFFFFFF) {	/* Update FSInfo */
    7b42:	f4 01       	movw	r30, r8
    7b44:	86 85       	ldd	r24, Z+14	; 0x0e
    7b46:	97 85       	ldd	r25, Z+15	; 0x0f
    7b48:	a0 89       	ldd	r26, Z+16	; 0x10
    7b4a:	b1 89       	ldd	r27, Z+17	; 0x11
    7b4c:	8f 3f       	cpi	r24, 0xFF	; 255
    7b4e:	ff ef       	ldi	r31, 0xFF	; 255
    7b50:	9f 07       	cpc	r25, r31
    7b52:	ff ef       	ldi	r31, 0xFF	; 255
    7b54:	af 07       	cpc	r26, r31
    7b56:	ff ef       	ldi	r31, 0xFF	; 255
    7b58:	bf 07       	cpc	r27, r31
    7b5a:	51 f0       	breq	.+20     	; 0x7b70 <f_open+0x358>
				fs->free_clust++;
    7b5c:	01 96       	adiw	r24, 0x01	; 1
    7b5e:	a1 1d       	adc	r26, r1
    7b60:	b1 1d       	adc	r27, r1
    7b62:	f4 01       	movw	r30, r8
    7b64:	86 87       	std	Z+14, r24	; 0x0e
    7b66:	97 87       	std	Z+15, r25	; 0x0f
    7b68:	a0 8b       	std	Z+16, r26	; 0x10
    7b6a:	b1 8b       	std	Z+17, r27	; 0x11
				fs->fsi_flag = 1;
    7b6c:	21 e0       	ldi	r18, 0x01	; 1
    7b6e:	25 83       	std	Z+5, r18	; 0x05
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
		res = FR_INT_ERR;

	} else {
		res = FR_OK;
		while (clst < fs->n_fatent) {			/* Not a last link? */
    7b70:	f4 01       	movw	r30, r8
    7b72:	86 89       	ldd	r24, Z+22	; 0x16
    7b74:	97 89       	ldd	r25, Z+23	; 0x17
    7b76:	a0 8d       	ldd	r26, Z+24	; 0x18
    7b78:	b1 8d       	ldd	r27, Z+25	; 0x19
    7b7a:	c8 16       	cp	r12, r24
    7b7c:	d9 06       	cpc	r13, r25
    7b7e:	ea 06       	cpc	r14, r26
    7b80:	fb 06       	cpc	r15, r27
    7b82:	88 f4       	brcc	.+34     	; 0x7ba6 <f_open+0x38e>
    7b84:	cd a6       	std	Y+45, r12	; 0x2d
    7b86:	2d 2c       	mov	r2, r13
    7b88:	87 01       	movw	r16, r14
			nxt = get_fat(fs, clst);			/* Get cluster status */
    7b8a:	c4 01       	movw	r24, r8
    7b8c:	4d a5       	ldd	r20, Y+45	; 0x2d
    7b8e:	52 2d       	mov	r21, r2
    7b90:	b8 01       	movw	r22, r16
    7b92:	0e 94 1d 28 	call	0x503a	; 0x503a <get_fat>
    7b96:	6b 01       	movw	r12, r22
    7b98:	7c 01       	movw	r14, r24
			if (nxt == 0) break;				/* Empty cluster? */
    7b9a:	61 15       	cp	r22, r1
    7b9c:	71 05       	cpc	r23, r1
    7b9e:	81 05       	cpc	r24, r1
    7ba0:	91 05       	cpc	r25, r1
    7ba2:	09 f0       	breq	.+2      	; 0x7ba6 <f_open+0x38e>
    7ba4:	b1 cf       	rjmp	.-158    	; 0x7b08 <f_open+0x2f0>
			dj.fs->wflag = 1;
			if (cl) {							/* Remove the cluster chain if exist */
				dw = dj.fs->winsect;
				res = remove_chain(dj.fs, cl);
				if (res == FR_OK) {
					dj.fs->last_clust = cl - 1;	/* Reuse the cluster hole */
    7ba6:	ed 85       	ldd	r30, Y+13	; 0x0d
    7ba8:	fe 85       	ldd	r31, Y+14	; 0x0e
    7baa:	29 a5       	ldd	r18, Y+41	; 0x29
    7bac:	3a a5       	ldd	r19, Y+42	; 0x2a
    7bae:	4b a5       	ldd	r20, Y+43	; 0x2b
    7bb0:	5c a5       	ldd	r21, Y+44	; 0x2c
    7bb2:	21 50       	subi	r18, 0x01	; 1
    7bb4:	30 40       	sbci	r19, 0x00	; 0
    7bb6:	40 40       	sbci	r20, 0x00	; 0
    7bb8:	50 40       	sbci	r21, 0x00	; 0
    7bba:	22 87       	std	Z+10, r18	; 0x0a
    7bbc:	33 87       	std	Z+11, r19	; 0x0b
    7bbe:	44 87       	std	Z+12, r20	; 0x0c
    7bc0:	55 87       	std	Z+13, r21	; 0x0d
					res = move_window(dj.fs, dw);
    7bc2:	cf 01       	movw	r24, r30
    7bc4:	4d a1       	ldd	r20, Y+37	; 0x25
    7bc6:	5e a1       	ldd	r21, Y+38	; 0x26
    7bc8:	6f a1       	ldd	r22, Y+39	; 0x27
    7bca:	78 a5       	ldd	r23, Y+40	; 0x28
    7bcc:	0e 94 8b 26 	call	0x4d16	; 0x4d16 <move_window>
    7bd0:	18 2f       	mov	r17, r24
				if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
					res = FR_DENIED;
			}
		}
	}
	if (res == FR_OK) {
    7bd2:	88 23       	and	r24, r24
    7bd4:	09 f0       	breq	.+2      	; 0x7bd8 <f_open+0x3c0>
    7bd6:	63 ce       	rjmp	.-826    	; 0x789e <f_open+0x86>
	else {	/* Open an existing file */
		if (res == FR_OK) {						/* Follow succeeded */
			if (dir[DIR_Attr] & AM_DIR) {		/* It is a directory */
				res = FR_NO_FILE;
			} else {
				if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
    7bd8:	88 e0       	ldi	r24, 0x08	; 8
    7bda:	e8 2e       	mov	r14, r24
    7bdc:	f1 2c       	mov	r15, r1
    7bde:	e6 20       	and	r14, r6
    7be0:	f7 20       	and	r15, r7
    7be2:	8d 84       	ldd	r8, Y+13	; 0x0d
    7be4:	9e 84       	ldd	r9, Y+14	; 0x0e
    7be6:	a8 ce       	rjmp	.-688    	; 0x7938 <f_open+0x120>
			} while (res == FR_OK && --ne);
		}
	}

#else	/* Non LFN configuration */
	res = dir_sdi(dj, 0);
    7be8:	c7 01       	movw	r24, r14
    7bea:	60 e0       	ldi	r22, 0x00	; 0
    7bec:	70 e0       	ldi	r23, 0x00	; 0
    7bee:	0e 94 30 29 	call	0x5260	; 0x5260 <dir_sdi>
    7bf2:	18 2f       	mov	r17, r24
	if (res == FR_OK) {
    7bf4:	88 23       	and	r24, r24
    7bf6:	09 f0       	breq	.+2      	; 0x7bfa <f_open+0x3e2>
    7bf8:	52 ce       	rjmp	.-860    	; 0x789e <f_open+0x86>
		do {	/* Find a blank entry for the SFN */
			res = move_window(dj->fs, dj->sect);
    7bfa:	4b 8d       	ldd	r20, Y+27	; 0x1b
    7bfc:	5c 8d       	ldd	r21, Y+28	; 0x1c
    7bfe:	6d 8d       	ldd	r22, Y+29	; 0x1d
    7c00:	7e 8d       	ldd	r23, Y+30	; 0x1e
    7c02:	8d 85       	ldd	r24, Y+13	; 0x0d
    7c04:	9e 85       	ldd	r25, Y+14	; 0x0e
    7c06:	0e 94 8b 26 	call	0x4d16	; 0x4d16 <move_window>
    7c0a:	18 2f       	mov	r17, r24
			if (res != FR_OK) break;
    7c0c:	88 23       	and	r24, r24
    7c0e:	09 f0       	breq	.+2      	; 0x7c12 <f_open+0x3fa>
    7c10:	46 ce       	rjmp	.-884    	; 0x789e <f_open+0x86>
			c = *dj->dir;
    7c12:	ef 8d       	ldd	r30, Y+31	; 0x1f
    7c14:	f8 a1       	ldd	r31, Y+32	; 0x20
    7c16:	e0 81       	ld	r30, Z
			if (c == 0xE5 || c == 0) break;	/* Is it a blank entry? */
    7c18:	e5 3e       	cpi	r30, 0xE5	; 229
    7c1a:	69 f0       	breq	.+26     	; 0x7c36 <f_open+0x41e>
    7c1c:	ee 23       	and	r30, r30
    7c1e:	59 f0       	breq	.+22     	; 0x7c36 <f_open+0x41e>
			res = dir_next(dj, 1);			/* Next entry with table stretch */
    7c20:	c7 01       	movw	r24, r14
    7c22:	61 e0       	ldi	r22, 0x01	; 1
    7c24:	70 e0       	ldi	r23, 0x00	; 0
    7c26:	0e 94 97 2e 	call	0x5d2e	; 0x5d2e <dir_next>
    7c2a:	18 2f       	mov	r17, r24
		} while (res == FR_OK);
    7c2c:	88 23       	and	r24, r24
    7c2e:	29 f3       	breq	.-54     	; 0x7bfa <f_open+0x3e2>
    7c30:	36 ce       	rjmp	.-916    	; 0x789e <f_open+0x86>
				if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
					res = FR_DENIED;
			}
		}
	}
	if (res == FR_OK) {
    7c32:	12 e0       	ldi	r17, 0x02	; 2
    7c34:	34 ce       	rjmp	.-920    	; 0x789e <f_open+0x86>
		} while (res == FR_OK);
	}
#endif

	if (res == FR_OK) {		/* Initialize the SFN entry */
		res = move_window(dj->fs, dj->sect);
    7c36:	4b 8d       	ldd	r20, Y+27	; 0x1b
    7c38:	5c 8d       	ldd	r21, Y+28	; 0x1c
    7c3a:	6d 8d       	ldd	r22, Y+29	; 0x1d
    7c3c:	7e 8d       	ldd	r23, Y+30	; 0x1e
    7c3e:	8d 85       	ldd	r24, Y+13	; 0x0d
    7c40:	9e 85       	ldd	r25, Y+14	; 0x0e
    7c42:	0e 94 8b 26 	call	0x4d16	; 0x4d16 <move_window>
    7c46:	18 2f       	mov	r17, r24
		if (res == FR_OK) {
    7c48:	88 23       	and	r24, r24
    7c4a:	09 f0       	breq	.+2      	; 0x7c4e <f_open+0x436>
    7c4c:	28 ce       	rjmp	.-944    	; 0x789e <f_open+0x86>
			dir = dj->dir;
    7c4e:	af 8d       	ldd	r26, Y+31	; 0x1f
    7c50:	b8 a1       	ldd	r27, Y+32	; 0x20
    7c52:	fd 01       	movw	r30, r26
    7c54:	8f e1       	ldi	r24, 0x1F	; 31
    7c56:	90 e0       	ldi	r25, 0x00	; 0
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
		*d++ = (BYTE)val;
    7c58:	11 92       	st	Z+, r1
/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
    7c5a:	01 97       	sbiw	r24, 0x01	; 1
    7c5c:	2f ef       	ldi	r18, 0xFF	; 255
    7c5e:	8f 3f       	cpi	r24, 0xFF	; 255
    7c60:	92 07       	cpc	r25, r18
    7c62:	d1 f7       	brne	.-12     	; 0x7c58 <f_open+0x440>
	if (res == FR_OK) {		/* Initialize the SFN entry */
		res = move_window(dj->fs, dj->sect);
		if (res == FR_OK) {
			dir = dj->dir;
			mem_set(dir, 0, 32);		/* Clean the entry */
			mem_cpy(dir, dj->fn, 11);	/* Put SFN */
    7c64:	89 a1       	ldd	r24, Y+33	; 0x21
    7c66:	9a a1       	ldd	r25, Y+34	; 0x22
    7c68:	9c 01       	movw	r18, r24
    7c6a:	f9 01       	movw	r30, r18
    7c6c:	2a e0       	ldi	r18, 0x0A	; 10
    7c6e:	30 e0       	ldi	r19, 0x00	; 0
		d += sizeof(int); s += sizeof(int);
		cnt -= sizeof(int);
	}
#endif
	while (cnt--)
		*d++ = *s++;
    7c70:	81 91       	ld	r24, Z+
    7c72:	8d 93       	st	X+, r24
		*(int*)d = *(int*)s;
		d += sizeof(int); s += sizeof(int);
		cnt -= sizeof(int);
	}
#endif
	while (cnt--)
    7c74:	21 50       	subi	r18, 0x01	; 1
    7c76:	30 40       	sbci	r19, 0x00	; 0
    7c78:	4f ef       	ldi	r20, 0xFF	; 255
    7c7a:	2f 3f       	cpi	r18, 0xFF	; 255
    7c7c:	34 07       	cpc	r19, r20
    7c7e:	c1 f7       	brne	.-16     	; 0x7c70 <f_open+0x458>
			mem_set(dir, 0, 32);		/* Clean the entry */
			mem_cpy(dir, dj->fn, 11);	/* Put SFN */
#if _USE_LFN
			dir[DIR_NTres] = *(dj->fn+NS) & (NS_BODY | NS_EXT);	/* Put NT flag */
#endif
			dj->fs->wflag = 1;
    7c80:	ed 85       	ldd	r30, Y+13	; 0x0d
    7c82:	fe 85       	ldd	r31, Y+14	; 0x0e
    7c84:	81 e0       	ldi	r24, 0x01	; 1
    7c86:	84 83       	std	Z+4, r24	; 0x04
#if _FS_SHARE
				res = enq_lock(dj.fs) ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
#else
				res = dir_register(&dj);
#endif
			mode |= FA_CREATE_ALWAYS;		/* File is created */
    7c88:	58 e0       	ldi	r21, 0x08	; 8
    7c8a:	35 2a       	or	r3, r21
			dir = dj.dir;					/* New entry */
    7c8c:	af 8c       	ldd	r10, Y+31	; 0x1f
    7c8e:	b8 a0       	ldd	r11, Y+32	; 0x20
    7c90:	63 2c       	mov	r6, r3
    7c92:	77 24       	eor	r7, r7
    7c94:	47 ce       	rjmp	.-882    	; 0x7924 <f_open+0x10c>
				if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
					res = FR_DENIED;
			}
		}
	}
	if (res == FR_OK) {
    7c96:	11 e0       	ldi	r17, 0x01	; 1
    7c98:	02 ce       	rjmp	.-1020   	; 0x789e <f_open+0x86>

00007c9a <f_sync>:
/*-----------------------------------------------------------------------*/

FRESULT f_sync (
	FIL *fp		/* Pointer to the file object */
)
{
    7c9a:	0f 93       	push	r16
    7c9c:	1f 93       	push	r17
    7c9e:	cf 93       	push	r28
    7ca0:	df 93       	push	r29
    7ca2:	ec 01       	movw	r28, r24
	FRESULT res;
	DWORD tim;
	BYTE *dir;


	res = validate(fp->fs, fp->id);		/* Check validity of the object */
    7ca4:	6a 81       	ldd	r22, Y+2	; 0x02
    7ca6:	7b 81       	ldd	r23, Y+3	; 0x03
    7ca8:	88 81       	ld	r24, Y
    7caa:	99 81       	ldd	r25, Y+1	; 0x01
    7cac:	0e 94 75 26 	call	0x4cea	; 0x4cea <validate>
    7cb0:	98 2f       	mov	r25, r24
	if (res == FR_OK) {
    7cb2:	88 23       	and	r24, r24
    7cb4:	19 f4       	brne	.+6      	; 0x7cbc <f_sync+0x22>
		if (fp->flag & FA__WRITTEN) {	/* Has the file been written? */
    7cb6:	8c 81       	ldd	r24, Y+4	; 0x04
    7cb8:	85 fd       	sbrc	r24, 5
    7cba:	06 c0       	rjmp	.+12     	; 0x7cc8 <f_sync+0x2e>
			}
		}
	}

	LEAVE_FF(fp->fs, res);
}
    7cbc:	89 2f       	mov	r24, r25
    7cbe:	df 91       	pop	r29
    7cc0:	cf 91       	pop	r28
    7cc2:	1f 91       	pop	r17
    7cc4:	0f 91       	pop	r16
    7cc6:	08 95       	ret
					LEAVE_FF(fp->fs, FR_DISK_ERR);
				fp->flag &= ~FA__DIRTY;
			}
#endif
			/* Update the directory entry */
			res = move_window(fp->fs, fp->dir_sect);
    7cc8:	4a 8d       	ldd	r20, Y+26	; 0x1a
    7cca:	5b 8d       	ldd	r21, Y+27	; 0x1b
    7ccc:	6c 8d       	ldd	r22, Y+28	; 0x1c
    7cce:	7d 8d       	ldd	r23, Y+29	; 0x1d
    7cd0:	88 81       	ld	r24, Y
    7cd2:	99 81       	ldd	r25, Y+1	; 0x01
    7cd4:	0e 94 8b 26 	call	0x4d16	; 0x4d16 <move_window>
    7cd8:	98 2f       	mov	r25, r24
			if (res == FR_OK) {
    7cda:	88 23       	and	r24, r24
    7cdc:	79 f7       	brne	.-34     	; 0x7cbc <f_sync+0x22>
				dir = fp->dir_ptr;
    7cde:	0e 8d       	ldd	r16, Y+30	; 0x1e
    7ce0:	1f 8d       	ldd	r17, Y+31	; 0x1f
				dir[DIR_Attr] |= AM_ARC;					/* Set archive bit */
    7ce2:	f8 01       	movw	r30, r16
    7ce4:	83 85       	ldd	r24, Z+11	; 0x0b
    7ce6:	80 62       	ori	r24, 0x20	; 32
    7ce8:	83 87       	std	Z+11, r24	; 0x0b
				ST_DWORD(dir+DIR_FileSize, fp->fsize);		/* Update file size */
    7cea:	8a 85       	ldd	r24, Y+10	; 0x0a
    7cec:	84 8f       	std	Z+28, r24	; 0x1c
    7cee:	8b 85       	ldd	r24, Y+11	; 0x0b
    7cf0:	85 8f       	std	Z+29, r24	; 0x1d
    7cf2:	8a 85       	ldd	r24, Y+10	; 0x0a
    7cf4:	9b 85       	ldd	r25, Y+11	; 0x0b
    7cf6:	ac 85       	ldd	r26, Y+12	; 0x0c
    7cf8:	bd 85       	ldd	r27, Y+13	; 0x0d
    7cfa:	cd 01       	movw	r24, r26
    7cfc:	aa 27       	eor	r26, r26
    7cfe:	bb 27       	eor	r27, r27
    7d00:	86 8f       	std	Z+30, r24	; 0x1e
    7d02:	8a 85       	ldd	r24, Y+10	; 0x0a
    7d04:	9b 85       	ldd	r25, Y+11	; 0x0b
    7d06:	ac 85       	ldd	r26, Y+12	; 0x0c
    7d08:	bd 85       	ldd	r27, Y+13	; 0x0d
    7d0a:	8b 2f       	mov	r24, r27
    7d0c:	99 27       	eor	r25, r25
    7d0e:	aa 27       	eor	r26, r26
    7d10:	bb 27       	eor	r27, r27
    7d12:	87 8f       	std	Z+31, r24	; 0x1f
				ST_CLUST(dir, fp->org_clust);				/* Update start cluster */
    7d14:	8e 85       	ldd	r24, Y+14	; 0x0e
    7d16:	82 8f       	std	Z+26, r24	; 0x1a
    7d18:	8f 85       	ldd	r24, Y+15	; 0x0f
    7d1a:	83 8f       	std	Z+27, r24	; 0x1b
    7d1c:	8e 85       	ldd	r24, Y+14	; 0x0e
    7d1e:	9f 85       	ldd	r25, Y+15	; 0x0f
    7d20:	a8 89       	ldd	r26, Y+16	; 0x10
    7d22:	b9 89       	ldd	r27, Y+17	; 0x11
    7d24:	cd 01       	movw	r24, r26
    7d26:	aa 27       	eor	r26, r26
    7d28:	bb 27       	eor	r27, r27
    7d2a:	84 8b       	std	Z+20, r24	; 0x14
    7d2c:	8e 85       	ldd	r24, Y+14	; 0x0e
    7d2e:	9f 85       	ldd	r25, Y+15	; 0x0f
    7d30:	a8 89       	ldd	r26, Y+16	; 0x10
    7d32:	b9 89       	ldd	r27, Y+17	; 0x11
    7d34:	cd 01       	movw	r24, r26
    7d36:	aa 27       	eor	r26, r26
    7d38:	bb 27       	eor	r27, r27
    7d3a:	89 2f       	mov	r24, r25
    7d3c:	99 27       	eor	r25, r25
    7d3e:	85 8b       	std	Z+21, r24	; 0x15
				tim = get_fattime();						/* Update updated time */
    7d40:	0e 94 4c 4e 	call	0x9c98	; 0x9c98 <get_fattime>
				ST_DWORD(dir+DIR_WrtTime, tim);
    7d44:	f8 01       	movw	r30, r16
    7d46:	66 8b       	std	Z+22, r22	; 0x16
    7d48:	27 2f       	mov	r18, r23
    7d4a:	33 27       	eor	r19, r19
    7d4c:	27 8b       	std	Z+23, r18	; 0x17
    7d4e:	9c 01       	movw	r18, r24
    7d50:	44 27       	eor	r20, r20
    7d52:	55 27       	eor	r21, r21
    7d54:	20 8f       	std	Z+24, r18	; 0x18
    7d56:	69 2f       	mov	r22, r25
    7d58:	77 27       	eor	r23, r23
    7d5a:	88 27       	eor	r24, r24
    7d5c:	99 27       	eor	r25, r25
    7d5e:	61 8f       	std	Z+25, r22	; 0x19
				fp->flag &= ~FA__WRITTEN;
    7d60:	8c 81       	ldd	r24, Y+4	; 0x04
    7d62:	8f 7d       	andi	r24, 0xDF	; 223
    7d64:	8c 83       	std	Y+4, r24	; 0x04
				fp->fs->wflag = 1;
    7d66:	e8 81       	ld	r30, Y
    7d68:	f9 81       	ldd	r31, Y+1	; 0x01
    7d6a:	81 e0       	ldi	r24, 0x01	; 1
    7d6c:	84 83       	std	Z+4, r24	; 0x04
				res = sync(fp->fs);
    7d6e:	09 90       	ld	r0, Y+
    7d70:	d8 81       	ld	r29, Y
    7d72:	c0 2d       	mov	r28, r0
)
{
	FRESULT res;


	res = move_window(fs, 0);
    7d74:	ce 01       	movw	r24, r28
    7d76:	40 e0       	ldi	r20, 0x00	; 0
    7d78:	50 e0       	ldi	r21, 0x00	; 0
    7d7a:	60 e0       	ldi	r22, 0x00	; 0
    7d7c:	70 e0       	ldi	r23, 0x00	; 0
    7d7e:	0e 94 8b 26 	call	0x4d16	; 0x4d16 <move_window>
    7d82:	98 2f       	mov	r25, r24
	if (res == FR_OK) {
    7d84:	88 23       	and	r24, r24
    7d86:	09 f0       	breq	.+2      	; 0x7d8a <f_sync+0xf0>
    7d88:	99 cf       	rjmp	.-206    	; 0x7cbc <f_sync+0x22>
		/* Update FSInfo sector if needed */
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
    7d8a:	88 81       	ld	r24, Y
    7d8c:	83 30       	cpi	r24, 0x03	; 3
    7d8e:	51 f0       	breq	.+20     	; 0x7da4 <f_sync+0x10a>
			ST_DWORD(fs->win+FSI_Nxt_Free, fs->last_clust);
			disk_write(fs->drv, fs->win, fs->fsi_sector, 1);
			fs->fsi_flag = 0;
		}
		/* Make sure that no pending write process in the physical drive */
		if (disk_ioctl(fs->drv, CTRL_SYNC, (void*)0) != RES_OK)
    7d90:	89 81       	ldd	r24, Y+1	; 0x01
    7d92:	60 e0       	ldi	r22, 0x00	; 0
    7d94:	40 e0       	ldi	r20, 0x00	; 0
    7d96:	50 e0       	ldi	r21, 0x00	; 0
    7d98:	0e 94 6d 25 	call	0x4ada	; 0x4ada <disk_ioctl>
    7d9c:	81 11       	cpse	r24, r1
    7d9e:	81 e0       	ldi	r24, 0x01	; 1
    7da0:	98 2f       	mov	r25, r24
    7da2:	8c cf       	rjmp	.-232    	; 0x7cbc <f_sync+0x22>


	res = move_window(fs, 0);
	if (res == FR_OK) {
		/* Update FSInfo sector if needed */
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
    7da4:	8d 81       	ldd	r24, Y+5	; 0x05
    7da6:	88 23       	and	r24, r24
    7da8:	99 f3       	breq	.-26     	; 0x7d90 <f_sync+0xf6>
			fs->winsect = 0;
    7daa:	1a a6       	std	Y+42, r1	; 0x2a
    7dac:	1b a6       	std	Y+43, r1	; 0x2b
    7dae:	1c a6       	std	Y+44, r1	; 0x2c
    7db0:	1d a6       	std	Y+45, r1	; 0x2d
}

/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;
    7db2:	be 01       	movw	r22, r28
    7db4:	62 5d       	subi	r22, 0xD2	; 210
    7db6:	7f 4f       	sbci	r23, 0xFF	; 255
    7db8:	fb 01       	movw	r30, r22
    7dba:	8f ef       	ldi	r24, 0xFF	; 255
    7dbc:	91 e0       	ldi	r25, 0x01	; 1

	while (cnt--)
		*d++ = (BYTE)val;
    7dbe:	11 92       	st	Z+, r1
/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
    7dc0:	01 97       	sbiw	r24, 0x01	; 1
    7dc2:	2f ef       	ldi	r18, 0xFF	; 255
    7dc4:	8f 3f       	cpi	r24, 0xFF	; 255
    7dc6:	92 07       	cpc	r25, r18
    7dc8:	d1 f7       	brne	.-12     	; 0x7dbe <f_sync+0x124>
	if (res == FR_OK) {
		/* Update FSInfo sector if needed */
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
			fs->winsect = 0;
			mem_set(fs->win, 0, 512);
			ST_WORD(fs->win+BS_55AA, 0xAA55);
    7dca:	c4 5d       	subi	r28, 0xD4	; 212
    7dcc:	dd 4f       	sbci	r29, 0xFD	; 253
    7dce:	85 e5       	ldi	r24, 0x55	; 85
    7dd0:	89 93       	st	Y+, r24
    7dd2:	8a ea       	ldi	r24, 0xAA	; 170
    7dd4:	88 83       	st	Y, r24
    7dd6:	cd 52       	subi	r28, 0x2D	; 45
    7dd8:	d2 40       	sbci	r29, 0x02	; 2
			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
    7dda:	82 e5       	ldi	r24, 0x52	; 82
    7ddc:	8e a7       	std	Y+46, r24	; 0x2e
    7dde:	8f a7       	std	Y+47, r24	; 0x2f
    7de0:	21 e6       	ldi	r18, 0x61	; 97
    7de2:	28 ab       	std	Y+48, r18	; 0x30
    7de4:	91 e4       	ldi	r25, 0x41	; 65
    7de6:	99 ab       	std	Y+49, r25	; 0x31
			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
    7de8:	ce 5e       	subi	r28, 0xEE	; 238
    7dea:	dd 4f       	sbci	r29, 0xFD	; 253
    7dec:	82 e7       	ldi	r24, 0x72	; 114
    7dee:	89 93       	st	Y+, r24
    7df0:	89 93       	st	Y+, r24
    7df2:	99 93       	st	Y+, r25
    7df4:	28 83       	st	Y, r18
    7df6:	c5 51       	subi	r28, 0x15	; 21
    7df8:	d2 40       	sbci	r29, 0x02	; 2
			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
    7dfa:	8e 85       	ldd	r24, Y+14	; 0x0e
    7dfc:	ca 5e       	subi	r28, 0xEA	; 234
    7dfe:	dd 4f       	sbci	r29, 0xFD	; 253
    7e00:	88 83       	st	Y, r24
    7e02:	c6 51       	subi	r28, 0x16	; 22
    7e04:	d2 40       	sbci	r29, 0x02	; 2
    7e06:	8f 85       	ldd	r24, Y+15	; 0x0f
    7e08:	c9 5e       	subi	r28, 0xE9	; 233
    7e0a:	dd 4f       	sbci	r29, 0xFD	; 253
    7e0c:	88 83       	st	Y, r24
    7e0e:	c7 51       	subi	r28, 0x17	; 23
    7e10:	d2 40       	sbci	r29, 0x02	; 2
    7e12:	8e 85       	ldd	r24, Y+14	; 0x0e
    7e14:	9f 85       	ldd	r25, Y+15	; 0x0f
    7e16:	a8 89       	ldd	r26, Y+16	; 0x10
    7e18:	b9 89       	ldd	r27, Y+17	; 0x11
    7e1a:	9d 01       	movw	r18, r26
    7e1c:	44 27       	eor	r20, r20
    7e1e:	55 27       	eor	r21, r21
    7e20:	c8 5e       	subi	r28, 0xE8	; 232
    7e22:	dd 4f       	sbci	r29, 0xFD	; 253
    7e24:	28 83       	st	Y, r18
    7e26:	21 96       	adiw	r28, 0x01	; 1
    7e28:	8b 2f       	mov	r24, r27
    7e2a:	99 27       	eor	r25, r25
    7e2c:	aa 27       	eor	r26, r26
    7e2e:	bb 27       	eor	r27, r27
    7e30:	88 83       	st	Y, r24
    7e32:	c9 51       	subi	r28, 0x19	; 25
    7e34:	d2 40       	sbci	r29, 0x02	; 2
			ST_DWORD(fs->win+FSI_Nxt_Free, fs->last_clust);
    7e36:	8a 85       	ldd	r24, Y+10	; 0x0a
    7e38:	c6 5e       	subi	r28, 0xE6	; 230
    7e3a:	dd 4f       	sbci	r29, 0xFD	; 253
    7e3c:	88 83       	st	Y, r24
    7e3e:	ca 51       	subi	r28, 0x1A	; 26
    7e40:	d2 40       	sbci	r29, 0x02	; 2
    7e42:	8b 85       	ldd	r24, Y+11	; 0x0b
    7e44:	c5 5e       	subi	r28, 0xE5	; 229
    7e46:	dd 4f       	sbci	r29, 0xFD	; 253
    7e48:	88 83       	st	Y, r24
    7e4a:	cb 51       	subi	r28, 0x1B	; 27
    7e4c:	d2 40       	sbci	r29, 0x02	; 2
    7e4e:	8a 85       	ldd	r24, Y+10	; 0x0a
    7e50:	9b 85       	ldd	r25, Y+11	; 0x0b
    7e52:	ac 85       	ldd	r26, Y+12	; 0x0c
    7e54:	bd 85       	ldd	r27, Y+13	; 0x0d
    7e56:	9d 01       	movw	r18, r26
    7e58:	44 27       	eor	r20, r20
    7e5a:	55 27       	eor	r21, r21
    7e5c:	c4 5e       	subi	r28, 0xE4	; 228
    7e5e:	dd 4f       	sbci	r29, 0xFD	; 253
    7e60:	28 83       	st	Y, r18
    7e62:	21 96       	adiw	r28, 0x01	; 1
    7e64:	8b 2f       	mov	r24, r27
    7e66:	99 27       	eor	r25, r25
    7e68:	aa 27       	eor	r26, r26
    7e6a:	bb 27       	eor	r27, r27
    7e6c:	88 83       	st	Y, r24
    7e6e:	cd 51       	subi	r28, 0x1D	; 29
    7e70:	d2 40       	sbci	r29, 0x02	; 2
			disk_write(fs->drv, fs->win, fs->fsi_sector, 1);
    7e72:	2a 89       	ldd	r18, Y+18	; 0x12
    7e74:	3b 89       	ldd	r19, Y+19	; 0x13
    7e76:	4c 89       	ldd	r20, Y+20	; 0x14
    7e78:	5d 89       	ldd	r21, Y+21	; 0x15
    7e7a:	89 81       	ldd	r24, Y+1	; 0x01
    7e7c:	01 e0       	ldi	r16, 0x01	; 1
    7e7e:	0e 94 f5 24 	call	0x49ea	; 0x49ea <disk_write>
			fs->fsi_flag = 0;
    7e82:	1d 82       	std	Y+5, r1	; 0x05
    7e84:	85 cf       	rjmp	.-246    	; 0x7d90 <f_sync+0xf6>

00007e86 <f_close>:
/*-----------------------------------------------------------------------*/

FRESULT f_close (
	FIL *fp		/* Pointer to the file object to be closed */
)
{
    7e86:	cf 93       	push	r28
    7e88:	df 93       	push	r29
    7e8a:	ec 01       	movw	r28, r24
	res = validate(fs, fp->id);
	if (res == FR_OK) fp->fs = 0;	/* Discard file object */
	LEAVE_FF(fs, res);

#else
	res = f_sync(fp);		/* Flush cached data */
    7e8c:	0e 94 4d 3e 	call	0x7c9a	; 0x7c9a <f_sync>
#else
		res = dec_lock(fp->lockid);
#endif
	}
#endif
	if (res == FR_OK) fp->fs = 0;	/* Discard file object */
    7e90:	88 23       	and	r24, r24
    7e92:	11 f4       	brne	.+4      	; 0x7e98 <f_close+0x12>
    7e94:	19 82       	std	Y+1, r1	; 0x01
    7e96:	18 82       	st	Y, r1
	return res;
#endif
}
    7e98:	df 91       	pop	r29
    7e9a:	cf 91       	pop	r28
    7e9c:	08 95       	ret

00007e9e <MPL3115A2_write8>:
    @param d the byte to write
*/
/**************************************************************************/

// Write to MPL3115A2 sensor
void MPL3115A2_write8(uint8_t address, uint8_t data_) {
    7e9e:	0f 93       	push	r16
    7ea0:	1f 93       	push	r17
    7ea2:	18 2f       	mov	r17, r24
    7ea4:	06 2f       	mov	r16, r22
  i2c_start(_MPL3115A2_W_ADDRESS);  // send byte via I2C  (device address + W)
    7ea6:	80 ec       	ldi	r24, 0xC0	; 192
    7ea8:	0e 94 95 14 	call	0x292a	; 0x292a <i2c_start>
  i2c_write(address);               // send byte (address of the location)
    7eac:	81 2f       	mov	r24, r17
    7eae:	0e 94 ee 14 	call	0x29dc	; 0x29dc <i2c_write>
  i2c_write(data_);                 // send data (data to be written)
    7eb2:	80 2f       	mov	r24, r16
    7eb4:	0e 94 ee 14 	call	0x29dc	; 0x29dc <i2c_write>
  i2c_stop();                    // issue I2C stop signal
    7eb8:	0e 94 e6 14 	call	0x29cc	; 0x29cc <i2c_stop>
}
    7ebc:	1f 91       	pop	r17
    7ebe:	0f 91       	pop	r16
    7ec0:	08 95       	ret

00007ec2 <MPL3115A2_setSeaPressure>:
/*!
    @brief  Set the local sea level barometric pressure
    @param pascal the pressure to use as the baseline
*/
/**************************************************************************/
void MPL3115A2_setSeaPressure(float pascal) {
    7ec2:	ef 92       	push	r14
    7ec4:	ff 92       	push	r15
    7ec6:	0f 93       	push	r16
    7ec8:	1f 93       	push	r17
  uint16_t bar = pascal/2;
    7eca:	20 e0       	ldi	r18, 0x00	; 0
    7ecc:	30 e0       	ldi	r19, 0x00	; 0
    7ece:	40 e0       	ldi	r20, 0x00	; 0
    7ed0:	5f e3       	ldi	r21, 0x3F	; 63
    7ed2:	0e 94 fe 7e 	call	0xfdfc	; 0xfdfc <__mulsf3>
    7ed6:	0e 94 b6 7d 	call	0xfb6c	; 0xfb6c <__fixunssfsi>
    7eda:	7b 01       	movw	r14, r22
    7edc:	8c 01       	movw	r16, r24
  i2c_start(_MPL3115A2_W_ADDRESS);  
    7ede:	80 ec       	ldi	r24, 0xC0	; 192
    7ee0:	0e 94 95 14 	call	0x292a	; 0x292a <i2c_start>
  i2c_write((uint8_t)MPL3115A2_BAR_IN_MSB);              
    7ee4:	84 e1       	ldi	r24, 0x14	; 20
    7ee6:	0e 94 ee 14 	call	0x29dc	; 0x29dc <i2c_write>
  i2c_write((uint8_t)(bar>>8));
    7eea:	8f 2d       	mov	r24, r15
    7eec:	0e 94 ee 14 	call	0x29dc	; 0x29dc <i2c_write>
  i2c_write((uint8_t)bar);               
    7ef0:	8e 2d       	mov	r24, r14
    7ef2:	0e 94 ee 14 	call	0x29dc	; 0x29dc <i2c_write>
  i2c_stop();                    
    7ef6:	0e 94 e6 14 	call	0x29cc	; 0x29cc <i2c_stop>
}
    7efa:	1f 91       	pop	r17
    7efc:	0f 91       	pop	r16
    7efe:	ff 90       	pop	r15
    7f00:	ef 90       	pop	r14
    7f02:	08 95       	ret

00007f04 <MPL3115A2_read8>:
    @return the read data byte
*/
/**************************************************************************/

// Read from MPL3115A2 sensor
uint8_t MPL3115A2_read8(uint8_t address) {
    7f04:	1f 93       	push	r17
    7f06:	18 2f       	mov	r17, r24
  uint8_t tmp = 0;

  i2c_start(_MPL3115A2_W_ADDRESS);   // send byte via I2C (device address + W)
    7f08:	80 ec       	ldi	r24, 0xC0	; 192
    7f0a:	0e 94 95 14 	call	0x292a	; 0x292a <i2c_start>
  i2c_write(address);               // send byte (data address)
    7f0e:	81 2f       	mov	r24, r17
    7f10:	0e 94 ee 14 	call	0x29dc	; 0x29dc <i2c_write>
 
  i2c_rep_start(_MPL3115A2_R_ADDRESS);          // issue I2C signal repeated start
    7f14:	81 ec       	ldi	r24, 0xC1	; 193
    7f16:	0e 94 e3 14 	call	0x29c6	; 0x29c6 <i2c_rep_start>
  tmp = i2c_readNak();       // Read the data (NO acknowledge)
    7f1a:	0e 94 0a 15 	call	0x2a14	; 0x2a14 <i2c_readNak>
    7f1e:	18 2f       	mov	r17, r24
  i2c_stop();                    // issue I2C stop signal
    7f20:	0e 94 e6 14 	call	0x29cc	; 0x29cc <i2c_stop>

  return tmp;
}
    7f24:	81 2f       	mov	r24, r17
    7f26:	1f 91       	pop	r17
    7f28:	08 95       	ret

00007f2a <MPL3115A2_getTemperature>:
/*!
    @brief  Gets the floating-point temperature in Centigrade
    @return temperature reading in Centigrade as a floating-point value
*/
/**************************************************************************/
float MPL3115A2_getTemperature() {
    7f2a:	0f 93       	push	r16
    7f2c:	1f 93       	push	r17
  int16_t t;

  uint8_t sta = 0;
  while (! (sta & MPL3115A2_REGISTER_STATUS_TDR)) {
    sta = MPL3115A2_read8(MPL3115A2_REGISTER_STATUS);
    7f2e:	80 e0       	ldi	r24, 0x00	; 0
    7f30:	0e 94 82 3f 	call	0x7f04	; 0x7f04 <MPL3115A2_read8>
    7f34:	18 2f       	mov	r17, r24
    //_delay_ms(10);
	chThdSleepMilliseconds(10);
    7f36:	68 ec       	ldi	r22, 0xC8	; 200
    7f38:	70 e0       	ldi	r23, 0x00	; 0
    7f3a:	80 e0       	ldi	r24, 0x00	; 0
    7f3c:	90 e0       	ldi	r25, 0x00	; 0
    7f3e:	0e 94 f4 08 	call	0x11e8	; 0x11e8 <chThdSleep>
/**************************************************************************/
float MPL3115A2_getTemperature() {
  int16_t t;

  uint8_t sta = 0;
  while (! (sta & MPL3115A2_REGISTER_STATUS_TDR)) {
    7f42:	11 ff       	sbrs	r17, 1
    7f44:	f4 cf       	rjmp	.-24     	; 0x7f2e <MPL3115A2_getTemperature+0x4>
    sta = MPL3115A2_read8(MPL3115A2_REGISTER_STATUS);
    //_delay_ms(10);
	chThdSleepMilliseconds(10);
  }
  
  t = MPL3115A2_read8(MPL3115A2_REGISTER_TEMP_MSB); // receive DATA
    7f46:	84 e0       	ldi	r24, 0x04	; 4
    7f48:	0e 94 82 3f 	call	0x7f04	; 0x7f04 <MPL3115A2_read8>
  t <<= 8;
    7f4c:	18 2f       	mov	r17, r24
    7f4e:	00 e0       	ldi	r16, 0x00	; 0
  t |= MPL3115A2_read8(MPL3115A2_REGISTER_TEMP_LSB); // receive DATA
    7f50:	85 e0       	ldi	r24, 0x05	; 5
    7f52:	0e 94 82 3f 	call	0x7f04	; 0x7f04 <MPL3115A2_read8>
    7f56:	28 2f       	mov	r18, r24
    7f58:	30 e0       	ldi	r19, 0x00	; 0
    7f5a:	20 2b       	or	r18, r16
    7f5c:	31 2b       	or	r19, r17
  t >>= 4;
    7f5e:	35 95       	asr	r19
    7f60:	27 95       	ror	r18
    7f62:	35 95       	asr	r19
    7f64:	27 95       	ror	r18
    7f66:	35 95       	asr	r19
    7f68:	27 95       	ror	r18
    7f6a:	35 95       	asr	r19
    7f6c:	27 95       	ror	r18
  
  if (t & 0x800) {
    7f6e:	33 fd       	sbrc	r19, 3
    t |= 0xF000;
    7f70:	30 6f       	ori	r19, 0xF0	; 240
  }

  float temp = t;
    7f72:	b9 01       	movw	r22, r18
    7f74:	88 27       	eor	r24, r24
    7f76:	77 fd       	sbrc	r23, 7
    7f78:	80 95       	com	r24
    7f7a:	98 2f       	mov	r25, r24
    7f7c:	0e 94 e4 7d 	call	0xfbc8	; 0xfbc8 <__floatsisf>
    7f80:	20 e0       	ldi	r18, 0x00	; 0
    7f82:	30 e0       	ldi	r19, 0x00	; 0
    7f84:	40 e8       	ldi	r20, 0x80	; 128
    7f86:	5d e3       	ldi	r21, 0x3D	; 61
    7f88:	0e 94 fe 7e 	call	0xfdfc	; 0xfdfc <__mulsf3>
  temp /= 16.0;
  return temp;
}
    7f8c:	1f 91       	pop	r17
    7f8e:	0f 91       	pop	r16
    7f90:	08 95       	ret

00007f92 <MPL3115A2_getAltitude>:
/*!
    @brief  Gets the floating-point altitude value
    @return altitude reading as a floating-point value
*/
/**************************************************************************/
float MPL3115A2_getAltitude() {
    7f92:	af 92       	push	r10
    7f94:	bf 92       	push	r11
    7f96:	cf 92       	push	r12
    7f98:	df 92       	push	r13
    7f9a:	ef 92       	push	r14
    7f9c:	ff 92       	push	r15
    7f9e:	0f 93       	push	r16
    7fa0:	1f 93       	push	r17
    7fa2:	06 c0       	rjmp	.+12     	; 0x7fb0 <MPL3115A2_getAltitude+0x1e>
  int32_t alt;

  while(MPL3115A2_read8(MPL3115A2_CTRL_REG1) & MPL3115A2_CTRL_REG1_OST) {
  //_delay_ms(10);
  chThdSleepMilliseconds(10);
    7fa4:	68 ec       	ldi	r22, 0xC8	; 200
    7fa6:	70 e0       	ldi	r23, 0x00	; 0
    7fa8:	80 e0       	ldi	r24, 0x00	; 0
    7faa:	90 e0       	ldi	r25, 0x00	; 0
    7fac:	0e 94 f4 08 	call	0x11e8	; 0x11e8 <chThdSleep>
*/
/**************************************************************************/
float MPL3115A2_getAltitude() {
  int32_t alt;

  while(MPL3115A2_read8(MPL3115A2_CTRL_REG1) & MPL3115A2_CTRL_REG1_OST) {
    7fb0:	86 e2       	ldi	r24, 0x26	; 38
    7fb2:	0e 94 82 3f 	call	0x7f04	; 0x7f04 <MPL3115A2_read8>
    7fb6:	81 fd       	sbrc	r24, 1
    7fb8:	f5 cf       	rjmp	.-22     	; 0x7fa4 <MPL3115A2_getAltitude+0x12>
  //_delay_ms(10);
  chThdSleepMilliseconds(10);
  }

  _ctrl_reg1.bit.ALT = 1;
    7fba:	60 91 54 0a 	lds	r22, 0x0A54
    7fbe:	60 68       	ori	r22, 0x80	; 128
    7fc0:	60 93 54 0a 	sts	0x0A54, r22
  MPL3115A2_write8(MPL3115A2_CTRL_REG1, _ctrl_reg1.reg);
    7fc4:	86 e2       	ldi	r24, 0x26	; 38
    7fc6:	0e 94 4f 3f 	call	0x7e9e	; 0x7e9e <MPL3115A2_write8>

  _ctrl_reg1.bit.OST = 1;
    7fca:	60 91 54 0a 	lds	r22, 0x0A54
    7fce:	62 60       	ori	r22, 0x02	; 2
    7fd0:	60 93 54 0a 	sts	0x0A54, r22
  MPL3115A2_write8(MPL3115A2_CTRL_REG1, _ctrl_reg1.reg);
    7fd4:	86 e2       	ldi	r24, 0x26	; 38
    7fd6:	0e 94 4f 3f 	call	0x7e9e	; 0x7e9e <MPL3115A2_write8>

  uint8_t sta = 0;
  while (! (sta & MPL3115A2_REGISTER_STATUS_PDR)) {
    sta = MPL3115A2_read8(MPL3115A2_REGISTER_STATUS);
    7fda:	80 e0       	ldi	r24, 0x00	; 0
    7fdc:	0e 94 82 3f 	call	0x7f04	; 0x7f04 <MPL3115A2_read8>
    7fe0:	18 2f       	mov	r17, r24
    //_delay_ms(10);
	chThdSleepMilliseconds(10);
    7fe2:	68 ec       	ldi	r22, 0xC8	; 200
    7fe4:	70 e0       	ldi	r23, 0x00	; 0
    7fe6:	80 e0       	ldi	r24, 0x00	; 0
    7fe8:	90 e0       	ldi	r25, 0x00	; 0
    7fea:	0e 94 f4 08 	call	0x11e8	; 0x11e8 <chThdSleep>

  _ctrl_reg1.bit.OST = 1;
  MPL3115A2_write8(MPL3115A2_CTRL_REG1, _ctrl_reg1.reg);

  uint8_t sta = 0;
  while (! (sta & MPL3115A2_REGISTER_STATUS_PDR)) {
    7fee:	12 ff       	sbrs	r17, 2
    7ff0:	f4 cf       	rjmp	.-24     	; 0x7fda <MPL3115A2_getAltitude+0x48>
    sta = MPL3115A2_read8(MPL3115A2_REGISTER_STATUS);
    //_delay_ms(10);
	chThdSleepMilliseconds(10);
  }
  
  alt  = ((uint32_t)MPL3115A2_read8(MPL3115A2_REGISTER_PRESSURE_MSB)) << 24; // receive DATA
    7ff2:	81 e0       	ldi	r24, 0x01	; 1
    7ff4:	0e 94 82 3f 	call	0x7f04	; 0x7f04 <MPL3115A2_read8>
    7ff8:	a8 2e       	mov	r10, r24
  alt |= ((uint32_t)MPL3115A2_read8(MPL3115A2_REGISTER_PRESSURE_CSB)) << 16; // receive DATA
    7ffa:	82 e0       	ldi	r24, 0x02	; 2
    7ffc:	0e 94 82 3f 	call	0x7f04	; 0x7f04 <MPL3115A2_read8>
    8000:	e8 2e       	mov	r14, r24
  alt |= ((uint32_t)MPL3115A2_read8(MPL3115A2_REGISTER_PRESSURE_LSB)) << 8; // receive DATA
    8002:	83 e0       	ldi	r24, 0x03	; 3
    8004:	0e 94 82 3f 	call	0x7f04	; 0x7f04 <MPL3115A2_read8>

  float altitude = alt;
    8008:	ff 24       	eor	r15, r15
    800a:	00 e0       	ldi	r16, 0x00	; 0
    800c:	10 e0       	ldi	r17, 0x00	; 0
    800e:	87 01       	movw	r16, r14
    8010:	ff 24       	eor	r15, r15
    8012:	ee 24       	eor	r14, r14
    8014:	bb 24       	eor	r11, r11
    8016:	cc 24       	eor	r12, r12
    8018:	dd 24       	eor	r13, r13
    801a:	da 2c       	mov	r13, r10
    801c:	cc 24       	eor	r12, r12
    801e:	bb 24       	eor	r11, r11
    8020:	aa 24       	eor	r10, r10
    8022:	ea 28       	or	r14, r10
    8024:	fb 28       	or	r15, r11
    8026:	0c 29       	or	r16, r12
    8028:	1d 29       	or	r17, r13
    802a:	90 e0       	ldi	r25, 0x00	; 0
    802c:	a0 e0       	ldi	r26, 0x00	; 0
    802e:	b0 e0       	ldi	r27, 0x00	; 0
    8030:	ba 2f       	mov	r27, r26
    8032:	a9 2f       	mov	r26, r25
    8034:	98 2f       	mov	r25, r24
    8036:	88 27       	eor	r24, r24
    8038:	e8 2a       	or	r14, r24
    803a:	f9 2a       	or	r15, r25
    803c:	0a 2b       	or	r16, r26
    803e:	1b 2b       	or	r17, r27
    8040:	c8 01       	movw	r24, r16
    8042:	b7 01       	movw	r22, r14
    8044:	0e 94 e4 7d 	call	0xfbc8	; 0xfbc8 <__floatsisf>
    8048:	20 e0       	ldi	r18, 0x00	; 0
    804a:	30 e0       	ldi	r19, 0x00	; 0
    804c:	40 e8       	ldi	r20, 0x80	; 128
    804e:	57 e3       	ldi	r21, 0x37	; 55
    8050:	0e 94 fe 7e 	call	0xfdfc	; 0xfdfc <__mulsf3>
  altitude /= 65536.0;
  return altitude;
}
    8054:	1f 91       	pop	r17
    8056:	0f 91       	pop	r16
    8058:	ff 90       	pop	r15
    805a:	ef 90       	pop	r14
    805c:	df 90       	pop	r13
    805e:	cf 90       	pop	r12
    8060:	bf 90       	pop	r11
    8062:	af 90       	pop	r10
    8064:	08 95       	ret

00008066 <MPL3115A2_getPressure>:
/*!
    @brief  Gets the floating-point pressure level in kPa
    @return altitude reading as a floating point value
*/
/**************************************************************************/
float MPL3115A2_getPressure() {
    8066:	ef 92       	push	r14
    8068:	ff 92       	push	r15
    806a:	0f 93       	push	r16
    806c:	1f 93       	push	r17
    806e:	06 c0       	rjmp	.+12     	; 0x807c <MPL3115A2_getPressure+0x16>
  uint32_t pressure;

  while(MPL3115A2_read8(MPL3115A2_CTRL_REG1) & MPL3115A2_CTRL_REG1_OST) {
  //_delay_ms(10);
  chThdSleepMilliseconds(10);
    8070:	68 ec       	ldi	r22, 0xC8	; 200
    8072:	70 e0       	ldi	r23, 0x00	; 0
    8074:	80 e0       	ldi	r24, 0x00	; 0
    8076:	90 e0       	ldi	r25, 0x00	; 0
    8078:	0e 94 f4 08 	call	0x11e8	; 0x11e8 <chThdSleep>
*/
/**************************************************************************/
float MPL3115A2_getPressure() {
  uint32_t pressure;

  while(MPL3115A2_read8(MPL3115A2_CTRL_REG1) & MPL3115A2_CTRL_REG1_OST) {
    807c:	86 e2       	ldi	r24, 0x26	; 38
    807e:	0e 94 82 3f 	call	0x7f04	; 0x7f04 <MPL3115A2_read8>
    8082:	81 fd       	sbrc	r24, 1
    8084:	f5 cf       	rjmp	.-22     	; 0x8070 <MPL3115A2_getPressure+0xa>
  //_delay_ms(10);
  chThdSleepMilliseconds(10);
  }

  _ctrl_reg1.bit.ALT = 0;
    8086:	60 91 54 0a 	lds	r22, 0x0A54
    808a:	6f 77       	andi	r22, 0x7F	; 127
    808c:	60 93 54 0a 	sts	0x0A54, r22
  MPL3115A2_write8(MPL3115A2_CTRL_REG1, _ctrl_reg1.reg);
    8090:	86 e2       	ldi	r24, 0x26	; 38
    8092:	0e 94 4f 3f 	call	0x7e9e	; 0x7e9e <MPL3115A2_write8>

  _ctrl_reg1.bit.OST = 1;
    8096:	60 91 54 0a 	lds	r22, 0x0A54
    809a:	62 60       	ori	r22, 0x02	; 2
    809c:	60 93 54 0a 	sts	0x0A54, r22
  MPL3115A2_write8(MPL3115A2_CTRL_REG1, _ctrl_reg1.reg);
    80a0:	86 e2       	ldi	r24, 0x26	; 38
    80a2:	0e 94 4f 3f 	call	0x7e9e	; 0x7e9e <MPL3115A2_write8>

  uint8_t sta = 0;
  while (! (sta & MPL3115A2_REGISTER_STATUS_PDR)) {
    sta = MPL3115A2_read8(MPL3115A2_REGISTER_STATUS);
    80a6:	80 e0       	ldi	r24, 0x00	; 0
    80a8:	0e 94 82 3f 	call	0x7f04	; 0x7f04 <MPL3115A2_read8>
    80ac:	18 2f       	mov	r17, r24
    //_delay_ms(10);
	chThdSleepMilliseconds(10);
    80ae:	68 ec       	ldi	r22, 0xC8	; 200
    80b0:	70 e0       	ldi	r23, 0x00	; 0
    80b2:	80 e0       	ldi	r24, 0x00	; 0
    80b4:	90 e0       	ldi	r25, 0x00	; 0
    80b6:	0e 94 f4 08 	call	0x11e8	; 0x11e8 <chThdSleep>

  _ctrl_reg1.bit.OST = 1;
  MPL3115A2_write8(MPL3115A2_CTRL_REG1, _ctrl_reg1.reg);

  uint8_t sta = 0;
  while (! (sta & MPL3115A2_REGISTER_STATUS_PDR)) {
    80ba:	12 ff       	sbrs	r17, 2
    80bc:	f4 cf       	rjmp	.-24     	; 0x80a6 <MPL3115A2_getPressure+0x40>
    sta = MPL3115A2_read8(MPL3115A2_REGISTER_STATUS);
    //_delay_ms(10);
	chThdSleepMilliseconds(10);
  }
  pressure = MPL3115A2_read8(MPL3115A2_REGISTER_PRESSURE_MSB); // receive DATA
    80be:	81 e0       	ldi	r24, 0x01	; 1
    80c0:	0e 94 82 3f 	call	0x7f04	; 0x7f04 <MPL3115A2_read8>
    80c4:	e8 2e       	mov	r14, r24
    80c6:	ff 24       	eor	r15, r15
    80c8:	00 e0       	ldi	r16, 0x00	; 0
    80ca:	10 e0       	ldi	r17, 0x00	; 0
  pressure <<= 8;
    80cc:	10 2f       	mov	r17, r16
    80ce:	0f 2d       	mov	r16, r15
    80d0:	fe 2c       	mov	r15, r14
    80d2:	ee 24       	eor	r14, r14
  pressure |= MPL3115A2_read8(MPL3115A2_REGISTER_PRESSURE_CSB); // receive DATA
    80d4:	82 e0       	ldi	r24, 0x02	; 2
    80d6:	0e 94 82 3f 	call	0x7f04	; 0x7f04 <MPL3115A2_read8>
    80da:	90 e0       	ldi	r25, 0x00	; 0
    80dc:	a0 e0       	ldi	r26, 0x00	; 0
    80de:	b0 e0       	ldi	r27, 0x00	; 0
    80e0:	e8 2a       	or	r14, r24
    80e2:	f9 2a       	or	r15, r25
    80e4:	0a 2b       	or	r16, r26
    80e6:	1b 2b       	or	r17, r27
  pressure <<= 8;
    80e8:	10 2f       	mov	r17, r16
    80ea:	0f 2d       	mov	r16, r15
    80ec:	fe 2c       	mov	r15, r14
    80ee:	ee 24       	eor	r14, r14
  pressure |= MPL3115A2_read8(MPL3115A2_REGISTER_PRESSURE_LSB); // receive DATA
    80f0:	83 e0       	ldi	r24, 0x03	; 3
    80f2:	0e 94 82 3f 	call	0x7f04	; 0x7f04 <MPL3115A2_read8>
    80f6:	90 e0       	ldi	r25, 0x00	; 0
    80f8:	a0 e0       	ldi	r26, 0x00	; 0
    80fa:	b0 e0       	ldi	r27, 0x00	; 0
    80fc:	e8 2a       	or	r14, r24
    80fe:	f9 2a       	or	r15, r25
    8100:	0a 2b       	or	r16, r26
    8102:	1b 2b       	or	r17, r27
  pressure >>= 4;

  float baro = pressure;
    8104:	54 e0       	ldi	r21, 0x04	; 4
    8106:	16 95       	lsr	r17
    8108:	07 95       	ror	r16
    810a:	f7 94       	ror	r15
    810c:	e7 94       	ror	r14
    810e:	5a 95       	dec	r21
    8110:	d1 f7       	brne	.-12     	; 0x8106 <MPL3115A2_getPressure+0xa0>
    8112:	c8 01       	movw	r24, r16
    8114:	b7 01       	movw	r22, r14
    8116:	0e 94 e2 7d 	call	0xfbc4	; 0xfbc4 <__floatunsisf>
    811a:	20 e0       	ldi	r18, 0x00	; 0
    811c:	30 e0       	ldi	r19, 0x00	; 0
    811e:	40 e8       	ldi	r20, 0x80	; 128
    8120:	5e e3       	ldi	r21, 0x3E	; 62
    8122:	0e 94 fe 7e 	call	0xfdfc	; 0xfdfc <__mulsf3>
  baro /= 4.0;
  return baro;
}
    8126:	1f 91       	pop	r17
    8128:	0f 91       	pop	r16
    812a:	ff 90       	pop	r15
    812c:	ef 90       	pop	r14
    812e:	08 95       	ret

00008130 <MPL3115A2_init>:
    @return true on successful startup, false otherwise
*/
/**************************************************************************/
uint8_t MPL3115A2_init(void) {
  
  uint8_t whoami =  MPL3115A2_read8(MPL3115A2_WHOAMI);
    8130:	8c e0       	ldi	r24, 0x0C	; 12
    8132:	0e 94 82 3f 	call	0x7f04	; 0x7f04 <MPL3115A2_read8>
  if (whoami != 0xC4) {
    8136:	84 3c       	cpi	r24, 0xC4	; 196
    8138:	11 f0       	breq	.+4      	; 0x813e <MPL3115A2_init+0xe>
    813a:	80 e0       	ldi	r24, 0x00	; 0
    813c:	08 95       	ret
    return (0);
  }

  MPL3115A2_write8(MPL3115A2_CTRL_REG1, MPL3115A2_CTRL_REG1_RST);
    813e:	86 e2       	ldi	r24, 0x26	; 38
    8140:	64 e0       	ldi	r22, 0x04	; 4
    8142:	0e 94 4f 3f 	call	0x7e9e	; 0x7e9e <MPL3115A2_write8>
  //_delay_ms(10);
  chThdSleepMilliseconds(10);
    8146:	68 ec       	ldi	r22, 0xC8	; 200
    8148:	70 e0       	ldi	r23, 0x00	; 0
    814a:	80 e0       	ldi	r24, 0x00	; 0
    814c:	90 e0       	ldi	r25, 0x00	; 0
    814e:	0e 94 f4 08 	call	0x11e8	; 0x11e8 <chThdSleep>
    8152:	06 c0       	rjmp	.+12     	; 0x8160 <MPL3115A2_init+0x30>

  while(MPL3115A2_read8(MPL3115A2_CTRL_REG1) & MPL3115A2_CTRL_REG1_RST) {
  //_delay_ms(10);
  chThdSleepMilliseconds(10);
    8154:	68 ec       	ldi	r22, 0xC8	; 200
    8156:	70 e0       	ldi	r23, 0x00	; 0
    8158:	80 e0       	ldi	r24, 0x00	; 0
    815a:	90 e0       	ldi	r25, 0x00	; 0
    815c:	0e 94 f4 08 	call	0x11e8	; 0x11e8 <chThdSleep>

  MPL3115A2_write8(MPL3115A2_CTRL_REG1, MPL3115A2_CTRL_REG1_RST);
  //_delay_ms(10);
  chThdSleepMilliseconds(10);

  while(MPL3115A2_read8(MPL3115A2_CTRL_REG1) & MPL3115A2_CTRL_REG1_RST) {
    8160:	86 e2       	ldi	r24, 0x26	; 38
    8162:	0e 94 82 3f 	call	0x7f04	; 0x7f04 <MPL3115A2_read8>
    8166:	82 fd       	sbrc	r24, 2
    8168:	f5 cf       	rjmp	.-22     	; 0x8154 <MPL3115A2_init+0x24>
  //_delay_ms(10);
  chThdSleepMilliseconds(10);
  }

  _ctrl_reg1.reg = MPL3115A2_CTRL_REG1_OS8 | MPL3115A2_CTRL_REG1_ALT;
    816a:	88 e9       	ldi	r24, 0x98	; 152
    816c:	80 93 54 0a 	sts	0x0A54, r24

  MPL3115A2_write8(MPL3115A2_CTRL_REG1, _ctrl_reg1.reg);
    8170:	86 e2       	ldi	r24, 0x26	; 38
    8172:	68 e9       	ldi	r22, 0x98	; 152
    8174:	0e 94 4f 3f 	call	0x7e9e	; 0x7e9e <MPL3115A2_write8>

  MPL3115A2_write8(MPL3115A2_PT_DATA_CFG, 
    8178:	83 e1       	ldi	r24, 0x13	; 19
    817a:	67 e0       	ldi	r22, 0x07	; 7
    817c:	0e 94 4f 3f 	call	0x7e9e	; 0x7e9e <MPL3115A2_write8>
    8180:	81 e0       	ldi	r24, 0x01	; 1
	 MPL3115A2_PT_DATA_CFG_TDEFE |
	 MPL3115A2_PT_DATA_CFG_PDEFE |
	 MPL3115A2_PT_DATA_CFG_DREM);
  return (1);
}
    8182:	08 95       	ret

00008184 <L3GD20_read8>:
  i2c_stop();                    // issue I2C stop signal
}


// Reads an L3GD20 register
uint8_t L3GD20_read8(uint8_t reg) {
    8184:	1f 93       	push	r17
    8186:	18 2f       	mov	r17, r24
  uint8_t tmp = 0;
  i2c_start(_L3GD20_W_ADDRESS);   // send byte via I2C (device address + W)
    8188:	86 ed       	ldi	r24, 0xD6	; 214
    818a:	0e 94 95 14 	call	0x292a	; 0x292a <i2c_start>
  i2c_write(reg);               // send byte (data address)
    818e:	81 2f       	mov	r24, r17
    8190:	0e 94 ee 14 	call	0x29dc	; 0x29dc <i2c_write>
  i2c_rep_start(_L3GD20_R_ADDRESS);          // issue I2C signal repeated start
    8194:	87 ed       	ldi	r24, 0xD7	; 215
    8196:	0e 94 e3 14 	call	0x29c6	; 0x29c6 <i2c_rep_start>
  tmp = i2c_readNak();       // Read the data (NO acknowledge)
    819a:	0e 94 0a 15 	call	0x2a14	; 0x2a14 <i2c_readNak>
    819e:	18 2f       	mov	r17, r24
  i2c_stop();                    // issue I2C stop signal
    81a0:	0e 94 e6 14 	call	0x29cc	; 0x29cc <i2c_stop>

  return tmp;
}
    81a4:	81 2f       	mov	r24, r17
    81a6:	1f 91       	pop	r17
    81a8:	08 95       	ret

000081aa <L3GD20_read>:


// Reads the 3 gyro channels and stores them in vector g
void L3GD20_read(void)
{
    81aa:	9f 92       	push	r9
    81ac:	af 92       	push	r10
    81ae:	bf 92       	push	r11
    81b0:	cf 92       	push	r12
    81b2:	df 92       	push	r13
    81b4:	ef 92       	push	r14
    81b6:	ff 92       	push	r15
    81b8:	0f 93       	push	r16
    81ba:	1f 93       	push	r17

  uint8_t xlg = L3GD20_read8(OUT_X_L);
    81bc:	88 e2       	ldi	r24, 0x28	; 40
    81be:	0e 94 c2 40 	call	0x8184	; 0x8184 <L3GD20_read8>
    81c2:	08 2f       	mov	r16, r24
  uint8_t xhg = L3GD20_read8(OUT_X_H);
    81c4:	89 e2       	ldi	r24, 0x29	; 41
    81c6:	0e 94 c2 40 	call	0x8184	; 0x8184 <L3GD20_read8>
    81ca:	b8 2e       	mov	r11, r24
  uint8_t ylg = L3GD20_read8(OUT_Y_L);
    81cc:	8a e2       	ldi	r24, 0x2A	; 42
    81ce:	0e 94 c2 40 	call	0x8184	; 0x8184 <L3GD20_read8>
    81d2:	e8 2e       	mov	r14, r24
  uint8_t yhg = L3GD20_read8(OUT_Y_H);
    81d4:	8b e2       	ldi	r24, 0x2B	; 43
    81d6:	0e 94 c2 40 	call	0x8184	; 0x8184 <L3GD20_read8>
    81da:	a8 2e       	mov	r10, r24
  uint8_t zlg = L3GD20_read8(OUT_Z_L);
    81dc:	8c e2       	ldi	r24, 0x2C	; 44
    81de:	0e 94 c2 40 	call	0x8184	; 0x8184 <L3GD20_read8>
    81e2:	c8 2e       	mov	r12, r24
  uint8_t zhg = L3GD20_read8(OUT_Z_H);
    81e4:	8d e2       	ldi	r24, 0x2D	; 45
    81e6:	0e 94 c2 40 	call	0x8184	; 0x8184 <L3GD20_read8>
    81ea:	98 2e       	mov	r9, r24

  // combine high and low bytes
  g.x = (float)(xhg << 8 | xlg);
    81ec:	7b 2d       	mov	r23, r11
    81ee:	60 e0       	ldi	r22, 0x00	; 0
    81f0:	10 e0       	ldi	r17, 0x00	; 0
    81f2:	60 2b       	or	r22, r16
    81f4:	71 2b       	or	r23, r17
    81f6:	88 27       	eor	r24, r24
    81f8:	77 fd       	sbrc	r23, 7
    81fa:	80 95       	com	r24
    81fc:	98 2f       	mov	r25, r24
    81fe:	0e 94 e4 7d 	call	0xfbc8	; 0xfbc8 <__floatsisf>
    8202:	60 93 56 0a 	sts	0x0A56, r22
    8206:	70 93 57 0a 	sts	0x0A57, r23
    820a:	80 93 58 0a 	sts	0x0A58, r24
    820e:	90 93 59 0a 	sts	0x0A59, r25
  g.y = (float)(yhg << 8 | ylg);
    8212:	7a 2d       	mov	r23, r10
    8214:	60 e0       	ldi	r22, 0x00	; 0
    8216:	ff 24       	eor	r15, r15
    8218:	6e 29       	or	r22, r14
    821a:	7f 29       	or	r23, r15
    821c:	88 27       	eor	r24, r24
    821e:	77 fd       	sbrc	r23, 7
    8220:	80 95       	com	r24
    8222:	98 2f       	mov	r25, r24
    8224:	0e 94 e4 7d 	call	0xfbc8	; 0xfbc8 <__floatsisf>
    8228:	60 93 5a 0a 	sts	0x0A5A, r22
    822c:	70 93 5b 0a 	sts	0x0A5B, r23
    8230:	80 93 5c 0a 	sts	0x0A5C, r24
    8234:	90 93 5d 0a 	sts	0x0A5D, r25
  g.z = (float)(zhg << 8 | zlg);
    8238:	79 2d       	mov	r23, r9
    823a:	60 e0       	ldi	r22, 0x00	; 0
    823c:	dd 24       	eor	r13, r13
    823e:	6c 29       	or	r22, r12
    8240:	7d 29       	or	r23, r13
    8242:	88 27       	eor	r24, r24
    8244:	77 fd       	sbrc	r23, 7
    8246:	80 95       	com	r24
    8248:	98 2f       	mov	r25, r24
    824a:	0e 94 e4 7d 	call	0xfbc8	; 0xfbc8 <__floatsisf>
    824e:	60 93 5e 0a 	sts	0x0A5E, r22
    8252:	70 93 5f 0a 	sts	0x0A5F, r23
    8256:	80 93 60 0a 	sts	0x0A60, r24
    825a:	90 93 61 0a 	sts	0x0A61, r25
}
    825e:	1f 91       	pop	r17
    8260:	0f 91       	pop	r16
    8262:	ff 90       	pop	r15
    8264:	ef 90       	pop	r14
    8266:	df 90       	pop	r13
    8268:	cf 90       	pop	r12
    826a:	bf 90       	pop	r11
    826c:	af 90       	pop	r10
    826e:	9f 90       	pop	r9
    8270:	08 95       	ret

00008272 <L3GD20_write8>:
  // DR = 01 (200 Hz ODR); BW = 10 (50 Hz bandwidth); PD = 1 (normal mode); Zen = Yen = Xen = 1 (all axes enabled)
  L3GD20_write8(CTRL_REG1, 0x6F);
}

// Writes an L3GD20 register
void L3GD20_write8(uint8_t reg, uint8_t data_) {
    8272:	0f 93       	push	r16
    8274:	1f 93       	push	r17
    8276:	18 2f       	mov	r17, r24
    8278:	06 2f       	mov	r16, r22
  i2c_start(_L3GD20_W_ADDRESS);  // send byte via I2C  (device address + W)
    827a:	86 ed       	ldi	r24, 0xD6	; 214
    827c:	0e 94 95 14 	call	0x292a	; 0x292a <i2c_start>
  i2c_write(reg);               // send byte (address of the location)
    8280:	81 2f       	mov	r24, r17
    8282:	0e 94 ee 14 	call	0x29dc	; 0x29dc <i2c_write>
  i2c_write(data_);                 // send data (data to be written)
    8286:	80 2f       	mov	r24, r16
    8288:	0e 94 ee 14 	call	0x29dc	; 0x29dc <i2c_write>
  i2c_stop();                    // issue I2C stop signal
    828c:	0e 94 e6 14 	call	0x29cc	; 0x29cc <i2c_stop>
}
    8290:	1f 91       	pop	r17
    8292:	0f 91       	pop	r16
    8294:	08 95       	ret

00008296 <L3GD20_enableDefault>:
void L3GD20_enableDefault(void)
{
  
  // 0x00 = 0b00000000
  // FS = 00 (+/- 250 dps full scale)
  L3GD20_write8(CTRL_REG4, 0x00);
    8296:	83 e2       	ldi	r24, 0x23	; 35
    8298:	60 e0       	ldi	r22, 0x00	; 0
    829a:	0e 94 39 41 	call	0x8272	; 0x8272 <L3GD20_write8>
  
  // 0x6F = 0b01101111
  // DR = 01 (200 Hz ODR); BW = 10 (50 Hz bandwidth); PD = 1 (normal mode); Zen = Yen = Xen = 1 (all axes enabled)
  L3GD20_write8(CTRL_REG1, 0x6F);
    829e:	80 e2       	ldi	r24, 0x20	; 32
    82a0:	6f e6       	ldi	r22, 0x6F	; 111
    82a2:	0e 94 39 41 	call	0x8272	; 0x8272 <L3GD20_write8>
}
    82a6:	08 95       	ret

000082a8 <vector_cross>:
#include "vector.h"
#include <math.h>


void vector_cross(const vector_t *a, const vector_t *b, vector_t *out)
{
    82a8:	8f 92       	push	r8
    82aa:	9f 92       	push	r9
    82ac:	af 92       	push	r10
    82ae:	bf 92       	push	r11
    82b0:	cf 92       	push	r12
    82b2:	df 92       	push	r13
    82b4:	ef 92       	push	r14
    82b6:	ff 92       	push	r15
    82b8:	0f 93       	push	r16
    82ba:	1f 93       	push	r17
    82bc:	6c 01       	movw	r12, r24
    82be:	5b 01       	movw	r10, r22
    82c0:	4a 01       	movw	r8, r20
  out->x = (a->y * b->z) - (a->z * b->y);
    82c2:	fc 01       	movw	r30, r24
    82c4:	64 81       	ldd	r22, Z+4	; 0x04
    82c6:	75 81       	ldd	r23, Z+5	; 0x05
    82c8:	86 81       	ldd	r24, Z+6	; 0x06
    82ca:	97 81       	ldd	r25, Z+7	; 0x07
    82cc:	f5 01       	movw	r30, r10
    82ce:	20 85       	ldd	r18, Z+8	; 0x08
    82d0:	31 85       	ldd	r19, Z+9	; 0x09
    82d2:	42 85       	ldd	r20, Z+10	; 0x0a
    82d4:	53 85       	ldd	r21, Z+11	; 0x0b
    82d6:	0e 94 fe 7e 	call	0xfdfc	; 0xfdfc <__mulsf3>
    82da:	7b 01       	movw	r14, r22
    82dc:	8c 01       	movw	r16, r24
    82de:	f6 01       	movw	r30, r12
    82e0:	60 85       	ldd	r22, Z+8	; 0x08
    82e2:	71 85       	ldd	r23, Z+9	; 0x09
    82e4:	82 85       	ldd	r24, Z+10	; 0x0a
    82e6:	93 85       	ldd	r25, Z+11	; 0x0b
    82e8:	f5 01       	movw	r30, r10
    82ea:	24 81       	ldd	r18, Z+4	; 0x04
    82ec:	35 81       	ldd	r19, Z+5	; 0x05
    82ee:	46 81       	ldd	r20, Z+6	; 0x06
    82f0:	57 81       	ldd	r21, Z+7	; 0x07
    82f2:	0e 94 fe 7e 	call	0xfdfc	; 0xfdfc <__mulsf3>
    82f6:	9b 01       	movw	r18, r22
    82f8:	ac 01       	movw	r20, r24
    82fa:	c8 01       	movw	r24, r16
    82fc:	b7 01       	movw	r22, r14
    82fe:	0e 94 83 7c 	call	0xf906	; 0xf906 <__subsf3>
    8302:	f4 01       	movw	r30, r8
    8304:	60 83       	st	Z, r22
    8306:	71 83       	std	Z+1, r23	; 0x01
    8308:	82 83       	std	Z+2, r24	; 0x02
    830a:	93 83       	std	Z+3, r25	; 0x03
  out->y = (a->z * b->x) - (a->x * b->z);
    830c:	f6 01       	movw	r30, r12
    830e:	60 85       	ldd	r22, Z+8	; 0x08
    8310:	71 85       	ldd	r23, Z+9	; 0x09
    8312:	82 85       	ldd	r24, Z+10	; 0x0a
    8314:	93 85       	ldd	r25, Z+11	; 0x0b
    8316:	f5 01       	movw	r30, r10
    8318:	20 81       	ld	r18, Z
    831a:	31 81       	ldd	r19, Z+1	; 0x01
    831c:	42 81       	ldd	r20, Z+2	; 0x02
    831e:	53 81       	ldd	r21, Z+3	; 0x03
    8320:	0e 94 fe 7e 	call	0xfdfc	; 0xfdfc <__mulsf3>
    8324:	7b 01       	movw	r14, r22
    8326:	8c 01       	movw	r16, r24
    8328:	f6 01       	movw	r30, r12
    832a:	60 81       	ld	r22, Z
    832c:	71 81       	ldd	r23, Z+1	; 0x01
    832e:	82 81       	ldd	r24, Z+2	; 0x02
    8330:	93 81       	ldd	r25, Z+3	; 0x03
    8332:	f5 01       	movw	r30, r10
    8334:	20 85       	ldd	r18, Z+8	; 0x08
    8336:	31 85       	ldd	r19, Z+9	; 0x09
    8338:	42 85       	ldd	r20, Z+10	; 0x0a
    833a:	53 85       	ldd	r21, Z+11	; 0x0b
    833c:	0e 94 fe 7e 	call	0xfdfc	; 0xfdfc <__mulsf3>
    8340:	9b 01       	movw	r18, r22
    8342:	ac 01       	movw	r20, r24
    8344:	c8 01       	movw	r24, r16
    8346:	b7 01       	movw	r22, r14
    8348:	0e 94 83 7c 	call	0xf906	; 0xf906 <__subsf3>
    834c:	f4 01       	movw	r30, r8
    834e:	64 83       	std	Z+4, r22	; 0x04
    8350:	75 83       	std	Z+5, r23	; 0x05
    8352:	86 83       	std	Z+6, r24	; 0x06
    8354:	97 83       	std	Z+7, r25	; 0x07
  out->z = (a->x * b->y) - (a->y * b->x);
    8356:	f6 01       	movw	r30, r12
    8358:	60 81       	ld	r22, Z
    835a:	71 81       	ldd	r23, Z+1	; 0x01
    835c:	82 81       	ldd	r24, Z+2	; 0x02
    835e:	93 81       	ldd	r25, Z+3	; 0x03
    8360:	f5 01       	movw	r30, r10
    8362:	24 81       	ldd	r18, Z+4	; 0x04
    8364:	35 81       	ldd	r19, Z+5	; 0x05
    8366:	46 81       	ldd	r20, Z+6	; 0x06
    8368:	57 81       	ldd	r21, Z+7	; 0x07
    836a:	0e 94 fe 7e 	call	0xfdfc	; 0xfdfc <__mulsf3>
    836e:	7b 01       	movw	r14, r22
    8370:	8c 01       	movw	r16, r24
    8372:	f6 01       	movw	r30, r12
    8374:	64 81       	ldd	r22, Z+4	; 0x04
    8376:	75 81       	ldd	r23, Z+5	; 0x05
    8378:	86 81       	ldd	r24, Z+6	; 0x06
    837a:	97 81       	ldd	r25, Z+7	; 0x07
    837c:	f5 01       	movw	r30, r10
    837e:	20 81       	ld	r18, Z
    8380:	31 81       	ldd	r19, Z+1	; 0x01
    8382:	42 81       	ldd	r20, Z+2	; 0x02
    8384:	53 81       	ldd	r21, Z+3	; 0x03
    8386:	0e 94 fe 7e 	call	0xfdfc	; 0xfdfc <__mulsf3>
    838a:	9b 01       	movw	r18, r22
    838c:	ac 01       	movw	r20, r24
    838e:	c8 01       	movw	r24, r16
    8390:	b7 01       	movw	r22, r14
    8392:	0e 94 83 7c 	call	0xf906	; 0xf906 <__subsf3>
    8396:	f4 01       	movw	r30, r8
    8398:	60 87       	std	Z+8, r22	; 0x08
    839a:	71 87       	std	Z+9, r23	; 0x09
    839c:	82 87       	std	Z+10, r24	; 0x0a
    839e:	93 87       	std	Z+11, r25	; 0x0b
}
    83a0:	1f 91       	pop	r17
    83a2:	0f 91       	pop	r16
    83a4:	ff 90       	pop	r15
    83a6:	ef 90       	pop	r14
    83a8:	df 90       	pop	r13
    83aa:	cf 90       	pop	r12
    83ac:	bf 90       	pop	r11
    83ae:	af 90       	pop	r10
    83b0:	9f 90       	pop	r9
    83b2:	8f 90       	pop	r8
    83b4:	08 95       	ret

000083b6 <vector_dot>:

float vector_dot(const vector_t *a, const vector_t *b)
{
    83b6:	af 92       	push	r10
    83b8:	bf 92       	push	r11
    83ba:	cf 92       	push	r12
    83bc:	df 92       	push	r13
    83be:	ef 92       	push	r14
    83c0:	ff 92       	push	r15
    83c2:	0f 93       	push	r16
    83c4:	1f 93       	push	r17
    83c6:	6c 01       	movw	r12, r24
    83c8:	5b 01       	movw	r10, r22
    83ca:	fc 01       	movw	r30, r24
    83cc:	60 81       	ld	r22, Z
    83ce:	71 81       	ldd	r23, Z+1	; 0x01
    83d0:	82 81       	ldd	r24, Z+2	; 0x02
    83d2:	93 81       	ldd	r25, Z+3	; 0x03
    83d4:	f5 01       	movw	r30, r10
    83d6:	20 81       	ld	r18, Z
    83d8:	31 81       	ldd	r19, Z+1	; 0x01
    83da:	42 81       	ldd	r20, Z+2	; 0x02
    83dc:	53 81       	ldd	r21, Z+3	; 0x03
    83de:	0e 94 fe 7e 	call	0xfdfc	; 0xfdfc <__mulsf3>
    83e2:	7b 01       	movw	r14, r22
    83e4:	8c 01       	movw	r16, r24
    83e6:	f6 01       	movw	r30, r12
    83e8:	64 81       	ldd	r22, Z+4	; 0x04
    83ea:	75 81       	ldd	r23, Z+5	; 0x05
    83ec:	86 81       	ldd	r24, Z+6	; 0x06
    83ee:	97 81       	ldd	r25, Z+7	; 0x07
    83f0:	f5 01       	movw	r30, r10
    83f2:	24 81       	ldd	r18, Z+4	; 0x04
    83f4:	35 81       	ldd	r19, Z+5	; 0x05
    83f6:	46 81       	ldd	r20, Z+6	; 0x06
    83f8:	57 81       	ldd	r21, Z+7	; 0x07
    83fa:	0e 94 fe 7e 	call	0xfdfc	; 0xfdfc <__mulsf3>
    83fe:	9b 01       	movw	r18, r22
    8400:	ac 01       	movw	r20, r24
    8402:	c8 01       	movw	r24, r16
    8404:	b7 01       	movw	r22, r14
    8406:	0e 94 84 7c 	call	0xf908	; 0xf908 <__addsf3>
    840a:	7b 01       	movw	r14, r22
    840c:	8c 01       	movw	r16, r24
    840e:	f6 01       	movw	r30, r12
    8410:	60 85       	ldd	r22, Z+8	; 0x08
    8412:	71 85       	ldd	r23, Z+9	; 0x09
    8414:	82 85       	ldd	r24, Z+10	; 0x0a
    8416:	93 85       	ldd	r25, Z+11	; 0x0b
    8418:	f5 01       	movw	r30, r10
    841a:	20 85       	ldd	r18, Z+8	; 0x08
    841c:	31 85       	ldd	r19, Z+9	; 0x09
    841e:	42 85       	ldd	r20, Z+10	; 0x0a
    8420:	53 85       	ldd	r21, Z+11	; 0x0b
    8422:	0e 94 fe 7e 	call	0xfdfc	; 0xfdfc <__mulsf3>
    8426:	9b 01       	movw	r18, r22
    8428:	ac 01       	movw	r20, r24
    842a:	c8 01       	movw	r24, r16
    842c:	b7 01       	movw	r22, r14
    842e:	0e 94 84 7c 	call	0xf908	; 0xf908 <__addsf3>
  return (a->x * b->x) + (a->y * b->y) + (a->z * b->z);
}
    8432:	1f 91       	pop	r17
    8434:	0f 91       	pop	r16
    8436:	ff 90       	pop	r15
    8438:	ef 90       	pop	r14
    843a:	df 90       	pop	r13
    843c:	cf 90       	pop	r12
    843e:	bf 90       	pop	r11
    8440:	af 90       	pop	r10
    8442:	08 95       	ret

00008444 <vector_normalize>:

void vector_normalize(vector_t *a)
{
    8444:	2f 92       	push	r2
    8446:	3f 92       	push	r3
    8448:	4f 92       	push	r4
    844a:	5f 92       	push	r5
    844c:	6f 92       	push	r6
    844e:	7f 92       	push	r7
    8450:	8f 92       	push	r8
    8452:	9f 92       	push	r9
    8454:	af 92       	push	r10
    8456:	bf 92       	push	r11
    8458:	cf 92       	push	r12
    845a:	df 92       	push	r13
    845c:	ef 92       	push	r14
    845e:	ff 92       	push	r15
    8460:	0f 93       	push	r16
    8462:	1f 93       	push	r17
    8464:	cf 93       	push	r28
    8466:	df 93       	push	r29
    8468:	ec 01       	movw	r28, r24
  out->z = (a->x * b->y) - (a->y * b->x);
}

float vector_dot(const vector_t *a, const vector_t *b)
{
  return (a->x * b->x) + (a->y * b->y) + (a->z * b->z);
    846a:	a8 80       	ld	r10, Y
    846c:	b9 80       	ldd	r11, Y+1	; 0x01
    846e:	ca 80       	ldd	r12, Y+2	; 0x02
    8470:	db 80       	ldd	r13, Y+3	; 0x03
    8472:	6c 80       	ldd	r6, Y+4	; 0x04
    8474:	7d 80       	ldd	r7, Y+5	; 0x05
    8476:	8e 80       	ldd	r8, Y+6	; 0x06
    8478:	9f 80       	ldd	r9, Y+7	; 0x07
    847a:	28 84       	ldd	r2, Y+8	; 0x08
    847c:	39 84       	ldd	r3, Y+9	; 0x09
    847e:	4a 84       	ldd	r4, Y+10	; 0x0a
    8480:	5b 84       	ldd	r5, Y+11	; 0x0b
}

void vector_normalize(vector_t *a)
{
  float mag = sqrt(vector_dot(a,a));
    8482:	c6 01       	movw	r24, r12
    8484:	b5 01       	movw	r22, r10
    8486:	a6 01       	movw	r20, r12
    8488:	95 01       	movw	r18, r10
    848a:	0e 94 fe 7e 	call	0xfdfc	; 0xfdfc <__mulsf3>
    848e:	7b 01       	movw	r14, r22
    8490:	8c 01       	movw	r16, r24
    8492:	c4 01       	movw	r24, r8
    8494:	b3 01       	movw	r22, r6
    8496:	a4 01       	movw	r20, r8
    8498:	93 01       	movw	r18, r6
    849a:	0e 94 fe 7e 	call	0xfdfc	; 0xfdfc <__mulsf3>
    849e:	9b 01       	movw	r18, r22
    84a0:	ac 01       	movw	r20, r24
    84a2:	c8 01       	movw	r24, r16
    84a4:	b7 01       	movw	r22, r14
    84a6:	0e 94 84 7c 	call	0xf908	; 0xf908 <__addsf3>
    84aa:	7b 01       	movw	r14, r22
    84ac:	8c 01       	movw	r16, r24
    84ae:	c2 01       	movw	r24, r4
    84b0:	b1 01       	movw	r22, r2
    84b2:	a2 01       	movw	r20, r4
    84b4:	91 01       	movw	r18, r2
    84b6:	0e 94 fe 7e 	call	0xfdfc	; 0xfdfc <__mulsf3>
    84ba:	9b 01       	movw	r18, r22
    84bc:	ac 01       	movw	r20, r24
    84be:	c8 01       	movw	r24, r16
    84c0:	b7 01       	movw	r22, r14
    84c2:	0e 94 84 7c 	call	0xf908	; 0xf908 <__addsf3>
    84c6:	0e 94 65 7f 	call	0xfeca	; 0xfeca <sqrt>
    84ca:	7b 01       	movw	r14, r22
    84cc:	8c 01       	movw	r16, r24
  a->x /= mag;
    84ce:	c6 01       	movw	r24, r12
    84d0:	b5 01       	movw	r22, r10
    84d2:	a8 01       	movw	r20, r16
    84d4:	97 01       	movw	r18, r14
    84d6:	0e 94 4e 7d 	call	0xfa9c	; 0xfa9c <__divsf3>
    84da:	68 83       	st	Y, r22
    84dc:	79 83       	std	Y+1, r23	; 0x01
    84de:	8a 83       	std	Y+2, r24	; 0x02
    84e0:	9b 83       	std	Y+3, r25	; 0x03
  a->y /= mag;
    84e2:	c4 01       	movw	r24, r8
    84e4:	b3 01       	movw	r22, r6
    84e6:	a8 01       	movw	r20, r16
    84e8:	97 01       	movw	r18, r14
    84ea:	0e 94 4e 7d 	call	0xfa9c	; 0xfa9c <__divsf3>
    84ee:	6c 83       	std	Y+4, r22	; 0x04
    84f0:	7d 83       	std	Y+5, r23	; 0x05
    84f2:	8e 83       	std	Y+6, r24	; 0x06
    84f4:	9f 83       	std	Y+7, r25	; 0x07
  a->z /= mag;
    84f6:	c2 01       	movw	r24, r4
    84f8:	b1 01       	movw	r22, r2
    84fa:	a8 01       	movw	r20, r16
    84fc:	97 01       	movw	r18, r14
    84fe:	0e 94 4e 7d 	call	0xfa9c	; 0xfa9c <__divsf3>
    8502:	68 87       	std	Y+8, r22	; 0x08
    8504:	79 87       	std	Y+9, r23	; 0x09
    8506:	8a 87       	std	Y+10, r24	; 0x0a
    8508:	9b 87       	std	Y+11, r25	; 0x0b
}
    850a:	df 91       	pop	r29
    850c:	cf 91       	pop	r28
    850e:	1f 91       	pop	r17
    8510:	0f 91       	pop	r16
    8512:	ff 90       	pop	r15
    8514:	ef 90       	pop	r14
    8516:	df 90       	pop	r13
    8518:	cf 90       	pop	r12
    851a:	bf 90       	pop	r11
    851c:	af 90       	pop	r10
    851e:	9f 90       	pop	r9
    8520:	8f 90       	pop	r8
    8522:	7f 90       	pop	r7
    8524:	6f 90       	pop	r6
    8526:	5f 90       	pop	r5
    8528:	4f 90       	pop	r4
    852a:	3f 90       	pop	r3
    852c:	2f 90       	pop	r2
    852e:	08 95       	ret

00008530 <bcd_to_decimal>:
#include "DS3231.h"
#include "i2cmaster.h"                                                     
 
 unsigned char bcd_to_decimal(unsigned char d)                
 {                                                                                          
    8530:	28 2f       	mov	r18, r24
    8532:	22 95       	swap	r18
    8534:	2f 70       	andi	r18, 0x0F	; 15
    8536:	30 e0       	ldi	r19, 0x00	; 0
    8538:	a9 01       	movw	r20, r18
    853a:	44 0f       	add	r20, r20
    853c:	55 1f       	adc	r21, r21
    853e:	44 0f       	add	r20, r20
    8540:	55 1f       	adc	r21, r21
    8542:	44 0f       	add	r20, r20
    8544:	55 1f       	adc	r21, r21
    8546:	22 0f       	add	r18, r18
    8548:	33 1f       	adc	r19, r19
    854a:	42 0f       	add	r20, r18
    854c:	53 1f       	adc	r21, r19
    854e:	8f 70       	andi	r24, 0x0F	; 15
    return ((d & 0x0F) + (((d & 0xF0) >> 4) * 10)); 
 }                                
    8550:	84 0f       	add	r24, r20
    8552:	08 95       	ret

00008554 <decimal_to_bcd>:

 unsigned char decimal_to_bcd(unsigned char d) 
 { 
    8554:	28 2f       	mov	r18, r24
    8556:	6a e0       	ldi	r22, 0x0A	; 10
    8558:	0e 94 da 7f 	call	0xffb4	; 0xffb4 <__udivmodqi4>
    855c:	48 2f       	mov	r20, r24
    855e:	50 e0       	ldi	r21, 0x00	; 0
    8560:	42 95       	swap	r20
    8562:	52 95       	swap	r21
    8564:	50 7f       	andi	r21, 0xF0	; 240
    8566:	54 27       	eor	r21, r20
    8568:	40 7f       	andi	r20, 0xF0	; 240
    856a:	54 27       	eor	r21, r20
    856c:	82 2f       	mov	r24, r18
    856e:	0e 94 da 7f 	call	0xffb4	; 0xffb4 <__udivmodqi4>
    8572:	89 2f       	mov	r24, r25
    8574:	8f 70       	andi	r24, 0x0F	; 15
   return (((d / 10) << 4) & 0xF0) | ((d % 10) & 0x0F); 
 }                                                    
    8576:	84 2b       	or	r24, r20
    8578:	08 95       	ret

0000857a <DS3231_write8>:




 void DS3231_write8(unsigned char address, unsigned char value)    
 {  
    857a:	0f 93       	push	r16
    857c:	1f 93       	push	r17
    857e:	18 2f       	mov	r17, r24
    8580:	06 2f       	mov	r16, r22
    i2c_start(_DS3231_Write_addr); 
    8582:	80 ed       	ldi	r24, 0xD0	; 208
    8584:	0e 94 95 14 	call	0x292a	; 0x292a <i2c_start>
    i2c_write(address); 
    8588:	81 2f       	mov	r24, r17
    858a:	0e 94 ee 14 	call	0x29dc	; 0x29dc <i2c_write>
    i2c_write(value);    
    858e:	80 2f       	mov	r24, r16
    8590:	0e 94 ee 14 	call	0x29dc	; 0x29dc <i2c_write>
    i2c_stop(); 
    8594:	0e 94 e6 14 	call	0x29cc	; 0x29cc <i2c_stop>
 }  
    8598:	1f 91       	pop	r17
    859a:	0f 91       	pop	r16
    859c:	08 95       	ret

0000859e <DS3231_setDate>:
                   }  
          }    
 }                                                  

 void DS3231_setDate(unsigned char daySet, unsigned char dateSet, unsigned char monthSet, unsigned char yearSet) 
 {          
    859e:	ff 92       	push	r15
    85a0:	0f 93       	push	r16
    85a2:	1f 93       	push	r17
    85a4:	16 2f       	mov	r17, r22
    85a6:	04 2f       	mov	r16, r20
    85a8:	f2 2e       	mov	r15, r18
    DS3231_write8(dayREG, (decimal_to_bcd(daySet)));            
    85aa:	0e 94 aa 42 	call	0x8554	; 0x8554 <decimal_to_bcd>
    85ae:	68 2f       	mov	r22, r24
    85b0:	83 e0       	ldi	r24, 0x03	; 3
    85b2:	0e 94 bd 42 	call	0x857a	; 0x857a <DS3231_write8>
    DS3231_write8(dateREG, (decimal_to_bcd(dateSet)));  
    85b6:	81 2f       	mov	r24, r17
    85b8:	0e 94 aa 42 	call	0x8554	; 0x8554 <decimal_to_bcd>
    85bc:	68 2f       	mov	r22, r24
    85be:	84 e0       	ldi	r24, 0x04	; 4
    85c0:	0e 94 bd 42 	call	0x857a	; 0x857a <DS3231_write8>
    DS3231_write8(monthREG, (decimal_to_bcd(monthSet))); 
    85c4:	80 2f       	mov	r24, r16
    85c6:	0e 94 aa 42 	call	0x8554	; 0x8554 <decimal_to_bcd>
    85ca:	68 2f       	mov	r22, r24
    85cc:	85 e0       	ldi	r24, 0x05	; 5
    85ce:	0e 94 bd 42 	call	0x857a	; 0x857a <DS3231_write8>
    DS3231_write8(yearREG, (decimal_to_bcd(yearSet)));    
    85d2:	8f 2d       	mov	r24, r15
    85d4:	0e 94 aa 42 	call	0x8554	; 0x8554 <decimal_to_bcd>
    85d8:	68 2f       	mov	r22, r24
    85da:	86 e0       	ldi	r24, 0x06	; 6
    85dc:	0e 94 bd 42 	call	0x857a	; 0x857a <DS3231_write8>
 } 
    85e0:	1f 91       	pop	r17
    85e2:	0f 91       	pop	r16
    85e4:	ff 90       	pop	r15
    85e6:	08 95       	ret

000085e8 <DS3231_setTime>:
    *p4 = bcd_to_decimal(*p4);                    
 } 

                                                     
 void DS3231_setTime(unsigned char hSet, unsigned char mSet, unsigned char sSet, short am_pm_state, short hour_format)  
 {                                                                                                              
    85e8:	ef 92       	push	r14
    85ea:	ff 92       	push	r15
    85ec:	0f 93       	push	r16
    85ee:	1f 93       	push	r17
    85f0:	cf 93       	push	r28
    85f2:	df 93       	push	r29
    85f4:	e8 2e       	mov	r14, r24
    85f6:	f6 2e       	mov	r15, r22
    85f8:	84 2f       	mov	r24, r20
    85fa:	e9 01       	movw	r28, r18
          unsigned char tmp = 0; 
          DS3231_write8(secondREG, (decimal_to_bcd(sSet))); 
    85fc:	0e 94 aa 42 	call	0x8554	; 0x8554 <decimal_to_bcd>
    8600:	68 2f       	mov	r22, r24
    8602:	80 e0       	ldi	r24, 0x00	; 0
    8604:	0e 94 bd 42 	call	0x857a	; 0x857a <DS3231_write8>
          DS3231_write8(minuteREG, (decimal_to_bcd(mSet)));        
    8608:	8f 2d       	mov	r24, r15
    860a:	0e 94 aa 42 	call	0x8554	; 0x8554 <decimal_to_bcd>
    860e:	68 2f       	mov	r22, r24
    8610:	81 e0       	ldi	r24, 0x01	; 1
    8612:	0e 94 bd 42 	call	0x857a	; 0x857a <DS3231_write8>
          switch(hour_format) 
    8616:	01 30       	cpi	r16, 0x01	; 1
    8618:	11 05       	cpc	r17, r1
    861a:	79 f0       	breq	.+30     	; 0x863a <DS3231_setTime+0x52>
                            break; 
                   }                                              
                   
                   default: 
                   { 
                    DS3231_write8(hourREG, (0x3F & (decimal_to_bcd(hSet)))); 
    861c:	8e 2d       	mov	r24, r14
    861e:	0e 94 aa 42 	call	0x8554	; 0x8554 <decimal_to_bcd>
    8622:	68 2f       	mov	r22, r24
    8624:	6f 73       	andi	r22, 0x3F	; 63
    8626:	82 e0       	ldi	r24, 0x02	; 2
    8628:	0e 94 bd 42 	call	0x857a	; 0x857a <DS3231_write8>
                    break; 
                   }  
          }    
 }                                                  
    862c:	df 91       	pop	r29
    862e:	cf 91       	pop	r28
    8630:	1f 91       	pop	r17
    8632:	0f 91       	pop	r16
    8634:	ff 90       	pop	r15
    8636:	ef 90       	pop	r14
    8638:	08 95       	ret
          DS3231_write8(minuteREG, (decimal_to_bcd(mSet)));        
          switch(hour_format) 
          { 
                   case 1: 
                   {        
                            switch(am_pm_state) 
    863a:	21 97       	sbiw	r28, 0x01	; 1
    863c:	89 f0       	breq	.+34     	; 0x8660 <DS3231_setTime+0x78>
    863e:	10 e4       	ldi	r17, 0x40	; 64
                                     {    
                                              tmp = 0x40; 
                                              break; 
                                     } 
                            }                            
                            DS3231_write8(hourREG, ((tmp | (0x1F & (decimal_to_bcd(hSet))))));                    
    8640:	8e 2d       	mov	r24, r14
    8642:	0e 94 aa 42 	call	0x8554	; 0x8554 <decimal_to_bcd>
    8646:	8f 71       	andi	r24, 0x1F	; 31
    8648:	18 2b       	or	r17, r24
    864a:	82 e0       	ldi	r24, 0x02	; 2
    864c:	61 2f       	mov	r22, r17
    864e:	0e 94 bd 42 	call	0x857a	; 0x857a <DS3231_write8>
                   { 
                    DS3231_write8(hourREG, (0x3F & (decimal_to_bcd(hSet)))); 
                    break; 
                   }  
          }    
 }                                                  
    8652:	df 91       	pop	r29
    8654:	cf 91       	pop	r28
    8656:	1f 91       	pop	r17
    8658:	0f 91       	pop	r16
    865a:	ff 90       	pop	r15
    865c:	ef 90       	pop	r14
    865e:	08 95       	ret
          DS3231_write8(minuteREG, (decimal_to_bcd(mSet)));        
          switch(hour_format) 
          { 
                   case 1: 
                   {        
                            switch(am_pm_state) 
    8660:	10 e6       	ldi	r17, 0x60	; 96
    8662:	ee cf       	rjmp	.-36     	; 0x8640 <DS3231_setTime+0x58>

00008664 <DS3231_read8>:
 { 
   return (((d / 10) << 4) & 0xF0) | ((d % 10) & 0x0F); 
 }                                                    

 unsigned char DS3231_read8(unsigned char address) 
 {                                      
    8664:	1f 93       	push	r17
    8666:	18 2f       	mov	r17, r24
    unsigned char value = 0;                                                       
    i2c_start(_DS3231_Write_addr);      
    8668:	80 ed       	ldi	r24, 0xD0	; 208
    866a:	0e 94 95 14 	call	0x292a	; 0x292a <i2c_start>
    i2c_write(address);                             
    866e:	81 2f       	mov	r24, r17
    8670:	0e 94 ee 14 	call	0x29dc	; 0x29dc <i2c_write>
    i2c_rep_start(_DS3231_Read_addr);    
    8674:	81 ed       	ldi	r24, 0xD1	; 209
    8676:	0e 94 e3 14 	call	0x29c6	; 0x29c6 <i2c_rep_start>
    value = i2c_readNak();                      
    867a:	0e 94 0a 15 	call	0x2a14	; 0x2a14 <i2c_readNak>
    867e:	18 2f       	mov	r17, r24
    i2c_stop();                  
    8680:	0e 94 e6 14 	call	0x29cc	; 0x29cc <i2c_stop>
    return value; 
 }                      
    8684:	81 2f       	mov	r24, r17
    8686:	1f 91       	pop	r17
    8688:	08 95       	ret

0000868a <DS3231_getTemp>:
 {          
    return (DS3231_read8(statusREG));    
 } 
 
 float DS3231_getTemp()                                                  
 { 
    868a:	af 92       	push	r10
    868c:	bf 92       	push	r11
    868e:	cf 92       	push	r12
    8690:	df 92       	push	r13
    8692:	ef 92       	push	r14
    8694:	ff 92       	push	r15
    8696:	0f 93       	push	r16
    8698:	1f 93       	push	r17
    register float t = 0.0; 
    unsigned char lowByte = 0; 
    signed char highByte = 0; 
    lowByte = DS3231_read8(tempLSBREG); 
    869a:	82 e1       	ldi	r24, 0x12	; 18
    869c:	0e 94 32 43 	call	0x8664	; 0x8664 <DS3231_read8>
    86a0:	e8 2e       	mov	r14, r24
    highByte = DS3231_read8(tempMSBREG);  
    86a2:	81 e1       	ldi	r24, 0x11	; 17
    86a4:	0e 94 32 43 	call	0x8664	; 0x8664 <DS3231_read8>
    86a8:	a8 2e       	mov	r10, r24
    lowByte >>= 6;                  
    lowByte &= 0x03;      
    t = ((float)lowByte);  
    86aa:	e2 94       	swap	r14
    86ac:	e6 94       	lsr	r14
    86ae:	e6 94       	lsr	r14
    86b0:	e3 e0       	ldi	r30, 0x03	; 3
    86b2:	ee 22       	and	r14, r30
    86b4:	ff 24       	eor	r15, r15
    86b6:	00 e0       	ldi	r16, 0x00	; 0
    86b8:	10 e0       	ldi	r17, 0x00	; 0
    86ba:	c8 01       	movw	r24, r16
    86bc:	b7 01       	movw	r22, r14
    86be:	0e 94 e2 7d 	call	0xfbc4	; 0xfbc4 <__floatunsisf>
    t *= 0.25;      
    86c2:	20 e0       	ldi	r18, 0x00	; 0
    86c4:	30 e0       	ldi	r19, 0x00	; 0
    86c6:	40 e8       	ldi	r20, 0x80	; 128
    86c8:	5e e3       	ldi	r21, 0x3E	; 62
    86ca:	0e 94 fe 7e 	call	0xfdfc	; 0xfdfc <__mulsf3>
    86ce:	7b 01       	movw	r14, r22
    86d0:	8c 01       	movw	r16, r24
    86d2:	bb 24       	eor	r11, r11
    86d4:	a7 fc       	sbrc	r10, 7
    86d6:	b0 94       	com	r11
    86d8:	cb 2c       	mov	r12, r11
    86da:	db 2c       	mov	r13, r11
    86dc:	c6 01       	movw	r24, r12
    86de:	b5 01       	movw	r22, r10
    86e0:	0e 94 e4 7d 	call	0xfbc8	; 0xfbc8 <__floatsisf>
    86e4:	a8 01       	movw	r20, r16
    86e6:	97 01       	movw	r18, r14
    86e8:	0e 94 84 7c 	call	0xf908	; 0xf908 <__addsf3>
    t += highByte;          
    return t; 
    86ec:	1f 91       	pop	r17
    86ee:	0f 91       	pop	r16
    86f0:	ff 90       	pop	r15
    86f2:	ef 90       	pop	r14
    86f4:	df 90       	pop	r13
    86f6:	cf 90       	pop	r12
    86f8:	bf 90       	pop	r11
    86fa:	af 90       	pop	r10
    86fc:	08 95       	ret

000086fe <DS3231_getStatus>:
    DS3231_write8(yearREG, (decimal_to_bcd(yearSet)));    
 } 

unsigned char DS3231_getStatus(void) 
 {          
    return (DS3231_read8(statusREG));    
    86fe:	8f e0       	ldi	r24, 0x0F	; 15
    8700:	0e 94 32 43 	call	0x8664	; 0x8664 <DS3231_read8>
 } 
    8704:	08 95       	ret

00008706 <DS3231_getDate>:
                   } 
          }  
 }                                  
   
 void DS3231_getDate(unsigned char *p4, unsigned char *p3, unsigned char *p2, unsigned char *p1) 
 { 
    8706:	af 92       	push	r10
    8708:	bf 92       	push	r11
    870a:	cf 92       	push	r12
    870c:	df 92       	push	r13
    870e:	ef 92       	push	r14
    8710:	ff 92       	push	r15
    8712:	0f 93       	push	r16
    8714:	1f 93       	push	r17
    8716:	5c 01       	movw	r10, r24
    8718:	6b 01       	movw	r12, r22
    871a:	7a 01       	movw	r14, r20
    871c:	89 01       	movw	r16, r18
    *p1 = DS3231_read8(yearREG); 
    871e:	86 e0       	ldi	r24, 0x06	; 6
    8720:	0e 94 32 43 	call	0x8664	; 0x8664 <DS3231_read8>
    *p1 = bcd_to_decimal(*p1);                  
    8724:	28 2f       	mov	r18, r24
    8726:	22 95       	swap	r18
    8728:	2f 70       	andi	r18, 0x0F	; 15
    872a:	30 e0       	ldi	r19, 0x00	; 0
    872c:	a9 01       	movw	r20, r18
    872e:	44 0f       	add	r20, r20
    8730:	55 1f       	adc	r21, r21
    8732:	44 0f       	add	r20, r20
    8734:	55 1f       	adc	r21, r21
    8736:	44 0f       	add	r20, r20
    8738:	55 1f       	adc	r21, r21
    873a:	22 0f       	add	r18, r18
    873c:	33 1f       	adc	r19, r19
    873e:	42 0f       	add	r20, r18
    8740:	53 1f       	adc	r21, r19
    8742:	8f 70       	andi	r24, 0x0F	; 15
    8744:	84 0f       	add	r24, r20
    8746:	f8 01       	movw	r30, r16
    8748:	80 83       	st	Z, r24
    *p2 = (0x1F & DS3231_read8(monthREG)); 
    874a:	85 e0       	ldi	r24, 0x05	; 5
    874c:	0e 94 32 43 	call	0x8664	; 0x8664 <DS3231_read8>
    8750:	28 2f       	mov	r18, r24
    8752:	2f 71       	andi	r18, 0x1F	; 31
    *p2 = bcd_to_decimal(*p2);                                
    8754:	22 95       	swap	r18
    8756:	2f 70       	andi	r18, 0x0F	; 15
    8758:	30 e0       	ldi	r19, 0x00	; 0
    875a:	a9 01       	movw	r20, r18
    875c:	44 0f       	add	r20, r20
    875e:	55 1f       	adc	r21, r21
    8760:	44 0f       	add	r20, r20
    8762:	55 1f       	adc	r21, r21
    8764:	44 0f       	add	r20, r20
    8766:	55 1f       	adc	r21, r21
    8768:	22 0f       	add	r18, r18
    876a:	33 1f       	adc	r19, r19
    876c:	42 0f       	add	r20, r18
    876e:	53 1f       	adc	r21, r19
    8770:	8f 70       	andi	r24, 0x0F	; 15
    8772:	84 0f       	add	r24, r20
    8774:	f7 01       	movw	r30, r14
    8776:	80 83       	st	Z, r24
    *p3 = (0x3F & DS3231_read8(dateREG)); 
    8778:	84 e0       	ldi	r24, 0x04	; 4
    877a:	0e 94 32 43 	call	0x8664	; 0x8664 <DS3231_read8>
    877e:	28 2f       	mov	r18, r24
    8780:	2f 73       	andi	r18, 0x3F	; 63
    *p3 = bcd_to_decimal(*p3);    
    8782:	22 95       	swap	r18
    8784:	2f 70       	andi	r18, 0x0F	; 15
    8786:	30 e0       	ldi	r19, 0x00	; 0
    8788:	a9 01       	movw	r20, r18
    878a:	44 0f       	add	r20, r20
    878c:	55 1f       	adc	r21, r21
    878e:	44 0f       	add	r20, r20
    8790:	55 1f       	adc	r21, r21
    8792:	44 0f       	add	r20, r20
    8794:	55 1f       	adc	r21, r21
    8796:	22 0f       	add	r18, r18
    8798:	33 1f       	adc	r19, r19
    879a:	42 0f       	add	r20, r18
    879c:	53 1f       	adc	r21, r19
    879e:	8f 70       	andi	r24, 0x0F	; 15
    87a0:	84 0f       	add	r24, r20
    87a2:	f6 01       	movw	r30, r12
    87a4:	80 83       	st	Z, r24
    *p4 = (0x07 & DS3231_read8(dayREG));    
    87a6:	83 e0       	ldi	r24, 0x03	; 3
    87a8:	0e 94 32 43 	call	0x8664	; 0x8664 <DS3231_read8>
    *p4 = bcd_to_decimal(*p4);                    
    87ac:	87 70       	andi	r24, 0x07	; 7
    87ae:	f5 01       	movw	r30, r10
    87b0:	80 83       	st	Z, r24
 } 
    87b2:	1f 91       	pop	r17
    87b4:	0f 91       	pop	r16
    87b6:	ff 90       	pop	r15
    87b8:	ef 90       	pop	r14
    87ba:	df 90       	pop	r13
    87bc:	cf 90       	pop	r12
    87be:	bf 90       	pop	r11
    87c0:	af 90       	pop	r10
    87c2:	08 95       	ret

000087c4 <DS3231_getTime>:
    DS3231_write8(statusREG, (DS3231_read8(statusREG) & 0xF7)); //disable 32khz output
 }                        


 void DS3231_getTime(unsigned char *p3, unsigned char *p2, unsigned char *p1, short *p0, short hour_format) 
 {                        
    87c4:	af 92       	push	r10
    87c6:	bf 92       	push	r11
    87c8:	cf 92       	push	r12
    87ca:	df 92       	push	r13
    87cc:	ef 92       	push	r14
    87ce:	ff 92       	push	r15
    87d0:	0f 93       	push	r16
    87d2:	1f 93       	push	r17
    87d4:	cf 93       	push	r28
    87d6:	df 93       	push	r29
    87d8:	5c 01       	movw	r10, r24
    87da:	6b 01       	movw	r12, r22
    87dc:	7a 01       	movw	r14, r20
    87de:	e9 01       	movw	r28, r18
          unsigned char tmp = 0; 
          *p1 = DS3231_read8(secondREG); 
    87e0:	80 e0       	ldi	r24, 0x00	; 0
    87e2:	0e 94 32 43 	call	0x8664	; 0x8664 <DS3231_read8>
          *p1 = bcd_to_decimal(*p1); 
    87e6:	28 2f       	mov	r18, r24
    87e8:	22 95       	swap	r18
    87ea:	2f 70       	andi	r18, 0x0F	; 15
    87ec:	30 e0       	ldi	r19, 0x00	; 0
    87ee:	a9 01       	movw	r20, r18
    87f0:	44 0f       	add	r20, r20
    87f2:	55 1f       	adc	r21, r21
    87f4:	44 0f       	add	r20, r20
    87f6:	55 1f       	adc	r21, r21
    87f8:	44 0f       	add	r20, r20
    87fa:	55 1f       	adc	r21, r21
    87fc:	22 0f       	add	r18, r18
    87fe:	33 1f       	adc	r19, r19
    8800:	42 0f       	add	r20, r18
    8802:	53 1f       	adc	r21, r19
    8804:	8f 70       	andi	r24, 0x0F	; 15
    8806:	84 0f       	add	r24, r20
    8808:	f7 01       	movw	r30, r14
    880a:	80 83       	st	Z, r24
          *p2 = DS3231_read8(minuteREG); 
    880c:	81 e0       	ldi	r24, 0x01	; 1
    880e:	0e 94 32 43 	call	0x8664	; 0x8664 <DS3231_read8>
          *p2 = bcd_to_decimal(*p2); 
    8812:	28 2f       	mov	r18, r24
    8814:	22 95       	swap	r18
    8816:	2f 70       	andi	r18, 0x0F	; 15
    8818:	30 e0       	ldi	r19, 0x00	; 0
    881a:	a9 01       	movw	r20, r18
    881c:	44 0f       	add	r20, r20
    881e:	55 1f       	adc	r21, r21
    8820:	44 0f       	add	r20, r20
    8822:	55 1f       	adc	r21, r21
    8824:	44 0f       	add	r20, r20
    8826:	55 1f       	adc	r21, r21
    8828:	22 0f       	add	r18, r18
    882a:	33 1f       	adc	r19, r19
    882c:	42 0f       	add	r20, r18
    882e:	53 1f       	adc	r21, r19
    8830:	8f 70       	andi	r24, 0x0F	; 15
    8832:	84 0f       	add	r24, r20
    8834:	f6 01       	movw	r30, r12
    8836:	80 83       	st	Z, r24
          switch(hour_format) 
    8838:	01 30       	cpi	r16, 0x01	; 1
    883a:	11 05       	cpc	r17, r1
    883c:	11 f1       	breq	.+68     	; 0x8882 <DS3231_getTime+0xbe>
                            *p3 = bcd_to_decimal(*p3);                            
                            break;      
                   }    
                   default: 
                   { 
                            *p3 = (0x3F & DS3231_read8(hourREG));            
    883e:	82 e0       	ldi	r24, 0x02	; 2
    8840:	0e 94 32 43 	call	0x8664	; 0x8664 <DS3231_read8>
    8844:	28 2f       	mov	r18, r24
    8846:	2f 73       	andi	r18, 0x3F	; 63
                            *p3 = bcd_to_decimal(*p3);    
    8848:	22 95       	swap	r18
    884a:	2f 70       	andi	r18, 0x0F	; 15
    884c:	30 e0       	ldi	r19, 0x00	; 0
    884e:	a9 01       	movw	r20, r18
    8850:	44 0f       	add	r20, r20
    8852:	55 1f       	adc	r21, r21
    8854:	44 0f       	add	r20, r20
    8856:	55 1f       	adc	r21, r21
    8858:	44 0f       	add	r20, r20
    885a:	55 1f       	adc	r21, r21
    885c:	22 0f       	add	r18, r18
    885e:	33 1f       	adc	r19, r19
    8860:	42 0f       	add	r20, r18
    8862:	53 1f       	adc	r21, r19
    8864:	8f 70       	andi	r24, 0x0F	; 15
    8866:	84 0f       	add	r24, r20
    8868:	f5 01       	movw	r30, r10
    886a:	80 83       	st	Z, r24
                            break;      
                   } 
          }  
 }                                  
    886c:	df 91       	pop	r29
    886e:	cf 91       	pop	r28
    8870:	1f 91       	pop	r17
    8872:	0f 91       	pop	r16
    8874:	ff 90       	pop	r15
    8876:	ef 90       	pop	r14
    8878:	df 90       	pop	r13
    887a:	cf 90       	pop	r12
    887c:	bf 90       	pop	r11
    887e:	af 90       	pop	r10
    8880:	08 95       	ret
          *p2 = bcd_to_decimal(*p2); 
          switch(hour_format) 
          {                                              
                   case 1:          
                   {          
                            tmp = DS3231_read8(hourREG); 
    8882:	82 e0       	ldi	r24, 0x02	; 2
    8884:	0e 94 32 43 	call	0x8664	; 0x8664 <DS3231_read8>
                            tmp &= 0x20; 
                            *p0 = (short)(tmp >> 5);              
    8888:	80 72       	andi	r24, 0x20	; 32
    888a:	82 95       	swap	r24
    888c:	86 95       	lsr	r24
    888e:	87 70       	andi	r24, 0x07	; 7
    8890:	88 83       	st	Y, r24
    8892:	19 82       	std	Y+1, r1	; 0x01
                            *p3 = (0x1F & DS3231_read8(hourREG)); 
    8894:	82 e0       	ldi	r24, 0x02	; 2
    8896:	0e 94 32 43 	call	0x8664	; 0x8664 <DS3231_read8>
    889a:	28 2f       	mov	r18, r24
    889c:	2f 71       	andi	r18, 0x1F	; 31
    889e:	d4 cf       	rjmp	.-88     	; 0x8848 <DS3231_getTime+0x84>

000088a0 <DS3231_init>:
 }  


 void DS3231_init() 
 {                                    
    DS3231_write8(controlREG, 0x00); 
    88a0:	8e e0       	ldi	r24, 0x0E	; 14
    88a2:	60 e0       	ldi	r22, 0x00	; 0
    88a4:	0e 94 bd 42 	call	0x857a	; 0x857a <DS3231_write8>
	//DS3231_write8(statusREG, 0x08);  
    DS3231_write8(statusREG, (DS3231_read8(statusREG) & 0xF7)); //disable 32khz output
    88a8:	8f e0       	ldi	r24, 0x0F	; 15
    88aa:	0e 94 32 43 	call	0x8664	; 0x8664 <DS3231_read8>
    88ae:	68 2f       	mov	r22, r24
    88b0:	67 7f       	andi	r22, 0xF7	; 247
    88b2:	8f e0       	ldi	r24, 0x0F	; 15
    88b4:	0e 94 bd 42 	call	0x857a	; 0x857a <DS3231_write8>
 }                        
    88b8:	08 95       	ret

000088ba <LSM303_heading_calc>:
form a basis for the horizontal plane. The From vector is projected
into the horizontal plane and the angle between the projected vector
and horizontal north is returned.
*/
float LSM303_heading_calc(vector_t from)
{
    88ba:	af 92       	push	r10
    88bc:	bf 92       	push	r11
    88be:	cf 92       	push	r12
    88c0:	df 92       	push	r13
    88c2:	ef 92       	push	r14
    88c4:	ff 92       	push	r15
    88c6:	0f 93       	push	r16
    88c8:	1f 93       	push	r17
    88ca:	df 93       	push	r29
    88cc:	cf 93       	push	r28
    88ce:	cd b7       	in	r28, 0x3d	; 61
    88d0:	de b7       	in	r29, 0x3e	; 62
    88d2:	e0 97       	sbiw	r28, 0x30	; 48
    88d4:	0f b6       	in	r0, 0x3f	; 63
    88d6:	f8 94       	cli
    88d8:	de bf       	out	0x3e, r29	; 62
    88da:	0f be       	out	0x3f, r0	; 63
    88dc:	cd bf       	out	0x3d, r28	; 61
    88de:	ed a2       	std	Y+37, r14	; 0x25
    88e0:	fe a2       	std	Y+38, r15	; 0x26
    88e2:	0f a3       	std	Y+39, r16	; 0x27
    88e4:	18 a7       	std	Y+40, r17	; 0x28
    88e6:	29 a7       	std	Y+41, r18	; 0x29
    88e8:	3a a7       	std	Y+42, r19	; 0x2a
    88ea:	4b a7       	std	Y+43, r20	; 0x2b
    88ec:	5c a7       	std	Y+44, r21	; 0x2c
    88ee:	6d a7       	std	Y+45, r22	; 0x2d
    88f0:	7e a7       	std	Y+46, r23	; 0x2e
    88f2:	8f a7       	std	Y+47, r24	; 0x2f
    88f4:	98 ab       	std	Y+48, r25	; 0x30
    vector_t temp_m = {m.x, m.y, m.z};
    88f6:	e0 90 8a 0a 	lds	r14, 0x0A8A
    88fa:	f0 90 8b 0a 	lds	r15, 0x0A8B
    88fe:	00 91 8c 0a 	lds	r16, 0x0A8C
    8902:	10 91 8d 0a 	lds	r17, 0x0A8D
    8906:	a0 90 8e 0a 	lds	r10, 0x0A8E
    890a:	b0 90 8f 0a 	lds	r11, 0x0A8F
    890e:	c0 90 90 0a 	lds	r12, 0x0A90
    8912:	d0 90 91 0a 	lds	r13, 0x0A91

    // subtract offset (average of min and max) from magnetometer readings
    temp_m.x -= (m_min.x + m_max.x) / 2;
    8916:	60 91 62 0a 	lds	r22, 0x0A62
    891a:	70 91 63 0a 	lds	r23, 0x0A63
    891e:	80 91 64 0a 	lds	r24, 0x0A64
    8922:	90 91 65 0a 	lds	r25, 0x0A65
    8926:	20 91 7a 0a 	lds	r18, 0x0A7A
    892a:	30 91 7b 0a 	lds	r19, 0x0A7B
    892e:	40 91 7c 0a 	lds	r20, 0x0A7C
    8932:	50 91 7d 0a 	lds	r21, 0x0A7D
    8936:	0e 94 84 7c 	call	0xf908	; 0xf908 <__addsf3>
    893a:	20 e0       	ldi	r18, 0x00	; 0
    893c:	30 e0       	ldi	r19, 0x00	; 0
    893e:	40 e0       	ldi	r20, 0x00	; 0
    8940:	5f eb       	ldi	r21, 0xBF	; 191
    8942:	0e 94 fe 7e 	call	0xfdfc	; 0xfdfc <__mulsf3>
    8946:	9b 01       	movw	r18, r22
    8948:	ac 01       	movw	r20, r24
    894a:	60 91 86 0a 	lds	r22, 0x0A86
    894e:	70 91 87 0a 	lds	r23, 0x0A87
    8952:	80 91 88 0a 	lds	r24, 0x0A88
    8956:	90 91 89 0a 	lds	r25, 0x0A89
    895a:	0e 94 84 7c 	call	0xf908	; 0xf908 <__addsf3>
    895e:	69 83       	std	Y+1, r22	; 0x01
    8960:	7a 83       	std	Y+2, r23	; 0x02
    8962:	8b 83       	std	Y+3, r24	; 0x03
    8964:	9c 83       	std	Y+4, r25	; 0x04
    temp_m.y -= (m_min.y + m_max.y) / 2;
    8966:	60 91 66 0a 	lds	r22, 0x0A66
    896a:	70 91 67 0a 	lds	r23, 0x0A67
    896e:	80 91 68 0a 	lds	r24, 0x0A68
    8972:	90 91 69 0a 	lds	r25, 0x0A69
    8976:	20 91 7e 0a 	lds	r18, 0x0A7E
    897a:	30 91 7f 0a 	lds	r19, 0x0A7F
    897e:	40 91 80 0a 	lds	r20, 0x0A80
    8982:	50 91 81 0a 	lds	r21, 0x0A81
    8986:	0e 94 84 7c 	call	0xf908	; 0xf908 <__addsf3>
    898a:	20 e0       	ldi	r18, 0x00	; 0
    898c:	30 e0       	ldi	r19, 0x00	; 0
    898e:	40 e0       	ldi	r20, 0x00	; 0
    8990:	5f eb       	ldi	r21, 0xBF	; 191
    8992:	0e 94 fe 7e 	call	0xfdfc	; 0xfdfc <__mulsf3>
    8996:	9b 01       	movw	r18, r22
    8998:	ac 01       	movw	r20, r24
    899a:	c8 01       	movw	r24, r16
    899c:	b7 01       	movw	r22, r14
    899e:	0e 94 84 7c 	call	0xf908	; 0xf908 <__addsf3>
    89a2:	6d 83       	std	Y+5, r22	; 0x05
    89a4:	7e 83       	std	Y+6, r23	; 0x06
    89a6:	8f 83       	std	Y+7, r24	; 0x07
    89a8:	98 87       	std	Y+8, r25	; 0x08
    temp_m.z -= (m_min.z + m_max.z) / 2;
    89aa:	60 91 6a 0a 	lds	r22, 0x0A6A
    89ae:	70 91 6b 0a 	lds	r23, 0x0A6B
    89b2:	80 91 6c 0a 	lds	r24, 0x0A6C
    89b6:	90 91 6d 0a 	lds	r25, 0x0A6D
    89ba:	20 91 82 0a 	lds	r18, 0x0A82
    89be:	30 91 83 0a 	lds	r19, 0x0A83
    89c2:	40 91 84 0a 	lds	r20, 0x0A84
    89c6:	50 91 85 0a 	lds	r21, 0x0A85
    89ca:	0e 94 84 7c 	call	0xf908	; 0xf908 <__addsf3>
    89ce:	20 e0       	ldi	r18, 0x00	; 0
    89d0:	30 e0       	ldi	r19, 0x00	; 0
    89d2:	40 e0       	ldi	r20, 0x00	; 0
    89d4:	5f eb       	ldi	r21, 0xBF	; 191
    89d6:	0e 94 fe 7e 	call	0xfdfc	; 0xfdfc <__mulsf3>
    89da:	9b 01       	movw	r18, r22
    89dc:	ac 01       	movw	r20, r24
    89de:	c6 01       	movw	r24, r12
    89e0:	b5 01       	movw	r22, r10
    89e2:	0e 94 84 7c 	call	0xf908	; 0xf908 <__addsf3>
    89e6:	69 87       	std	Y+9, r22	; 0x09
    89e8:	7a 87       	std	Y+10, r23	; 0x0a
    89ea:	8b 87       	std	Y+11, r24	; 0x0b
    89ec:	9c 87       	std	Y+12, r25	; 0x0c

    // compute E and N
    vector_t E;
    vector_t N;
    vector_cross(&temp_m, &a, &E);
    89ee:	8e 01       	movw	r16, r28
    89f0:	03 5f       	subi	r16, 0xF3	; 243
    89f2:	1f 4f       	sbci	r17, 0xFF	; 255
    89f4:	ce 01       	movw	r24, r28
    89f6:	01 96       	adiw	r24, 0x01	; 1
    89f8:	6e e6       	ldi	r22, 0x6E	; 110
    89fa:	7a e0       	ldi	r23, 0x0A	; 10
    89fc:	a8 01       	movw	r20, r16
    89fe:	0e 94 54 41 	call	0x82a8	; 0x82a8 <vector_cross>
    vector_normalize(&E);
    8a02:	c8 01       	movw	r24, r16
    8a04:	0e 94 22 42 	call	0x8444	; 0x8444 <vector_normalize>
    vector_cross(&a, &E, &N);
    8a08:	99 e1       	ldi	r25, 0x19	; 25
    8a0a:	c9 2e       	mov	r12, r25
    8a0c:	d1 2c       	mov	r13, r1
    8a0e:	cc 0e       	add	r12, r28
    8a10:	dd 1e       	adc	r13, r29
    8a12:	8e e6       	ldi	r24, 0x6E	; 110
    8a14:	9a e0       	ldi	r25, 0x0A	; 10
    8a16:	b8 01       	movw	r22, r16
    8a18:	a6 01       	movw	r20, r12
    8a1a:	0e 94 54 41 	call	0x82a8	; 0x82a8 <vector_cross>
    vector_normalize(&N);
    8a1e:	c6 01       	movw	r24, r12
    8a20:	0e 94 22 42 	call	0x8444	; 0x8444 <vector_normalize>

    // compute heading
    float heading = atan2(vector_dot(&E, &from), vector_dot(&N, &from)) * 180 / PI;
    8a24:	85 e2       	ldi	r24, 0x25	; 37
    8a26:	a8 2e       	mov	r10, r24
    8a28:	b1 2c       	mov	r11, r1
    8a2a:	ac 0e       	add	r10, r28
    8a2c:	bd 1e       	adc	r11, r29
    8a2e:	c8 01       	movw	r24, r16
    8a30:	b5 01       	movw	r22, r10
    8a32:	0e 94 db 41 	call	0x83b6	; 0x83b6 <vector_dot>
    8a36:	7b 01       	movw	r14, r22
    8a38:	8c 01       	movw	r16, r24
    8a3a:	c6 01       	movw	r24, r12
    8a3c:	b5 01       	movw	r22, r10
    8a3e:	0e 94 db 41 	call	0x83b6	; 0x83b6 <vector_dot>
    8a42:	9b 01       	movw	r18, r22
    8a44:	ac 01       	movw	r20, r24
    8a46:	c8 01       	movw	r24, r16
    8a48:	b7 01       	movw	r22, r14
    8a4a:	0e 94 f7 7c 	call	0xf9ee	; 0xf9ee <atan2>
    8a4e:	20 e0       	ldi	r18, 0x00	; 0
    8a50:	30 e0       	ldi	r19, 0x00	; 0
    8a52:	44 e3       	ldi	r20, 0x34	; 52
    8a54:	53 e4       	ldi	r21, 0x43	; 67
    8a56:	0e 94 fe 7e 	call	0xfdfc	; 0xfdfc <__mulsf3>
    8a5a:	2a ed       	ldi	r18, 0xDA	; 218
    8a5c:	3f e0       	ldi	r19, 0x0F	; 15
    8a5e:	49 e4       	ldi	r20, 0x49	; 73
    8a60:	50 e4       	ldi	r21, 0x40	; 64
    8a62:	0e 94 4e 7d 	call	0xfa9c	; 0xfa9c <__divsf3>
    8a66:	7b 01       	movw	r14, r22
    8a68:	8c 01       	movw	r16, r24
    if (heading < 0) heading += 360;
    8a6a:	20 e0       	ldi	r18, 0x00	; 0
    8a6c:	30 e0       	ldi	r19, 0x00	; 0
    8a6e:	40 e0       	ldi	r20, 0x00	; 0
    8a70:	50 e0       	ldi	r21, 0x00	; 0
    8a72:	0e 94 4a 7d 	call	0xfa94	; 0xfa94 <__cmpsf2>
    8a76:	88 23       	and	r24, r24
    8a78:	54 f4       	brge	.+20     	; 0x8a8e <LSM303_heading_calc+0x1d4>
    8a7a:	c8 01       	movw	r24, r16
    8a7c:	b7 01       	movw	r22, r14
    8a7e:	20 e0       	ldi	r18, 0x00	; 0
    8a80:	30 e0       	ldi	r19, 0x00	; 0
    8a82:	44 eb       	ldi	r20, 0xB4	; 180
    8a84:	53 e4       	ldi	r21, 0x43	; 67
    8a86:	0e 94 84 7c 	call	0xf908	; 0xf908 <__addsf3>
    8a8a:	7b 01       	movw	r14, r22
    8a8c:	8c 01       	movw	r16, r24
    return heading;
}
    8a8e:	b7 01       	movw	r22, r14
    8a90:	c8 01       	movw	r24, r16
    8a92:	e0 96       	adiw	r28, 0x30	; 48
    8a94:	0f b6       	in	r0, 0x3f	; 63
    8a96:	f8 94       	cli
    8a98:	de bf       	out	0x3e, r29	; 62
    8a9a:	0f be       	out	0x3f, r0	; 63
    8a9c:	cd bf       	out	0x3d, r28	; 61
    8a9e:	cf 91       	pop	r28
    8aa0:	df 91       	pop	r29
    8aa2:	1f 91       	pop	r17
    8aa4:	0f 91       	pop	r16
    8aa6:	ff 90       	pop	r15
    8aa8:	ef 90       	pop	r14
    8aaa:	df 90       	pop	r13
    8aac:	cf 90       	pop	r12
    8aae:	bf 90       	pop	r11
    8ab0:	af 90       	pop	r10
    8ab2:	08 95       	ret

00008ab4 <LSM303_heading>:
PCB, in the direction of the top of the text on the silkscreen.
This is the +X axis on the Pololu LSM303D carrier and the -Y axis on
the Pololu LSM303DLHC, LSM303DLM, and LSM303DLH carriers.
*/
float LSM303_heading(void)
{
    8ab4:	ef 92       	push	r14
    8ab6:	ff 92       	push	r15
    8ab8:	0f 93       	push	r16
    8aba:	1f 93       	push	r17
    8abc:	df 93       	push	r29
    8abe:	cf 93       	push	r28
    8ac0:	cd b7       	in	r28, 0x3d	; 61
    8ac2:	de b7       	in	r29, 0x3e	; 62
    8ac4:	2c 97       	sbiw	r28, 0x0c	; 12
    8ac6:	0f b6       	in	r0, 0x3f	; 63
    8ac8:	f8 94       	cli
    8aca:	de bf       	out	0x3e, r29	; 62
    8acc:	0f be       	out	0x3f, r0	; 63
    8ace:	cd bf       	out	0x3d, r28	; 61
    return LSM303_heading_calc((vector_t){1, 0, 0});
    8ad0:	de 01       	movw	r26, r28
    8ad2:	11 96       	adiw	r26, 0x01	; 1
    8ad4:	e6 ed       	ldi	r30, 0xD6	; 214
    8ad6:	f3 e0       	ldi	r31, 0x03	; 3
    8ad8:	8c e0       	ldi	r24, 0x0C	; 12
    8ada:	01 90       	ld	r0, Z+
    8adc:	0d 92       	st	X+, r0
    8ade:	81 50       	subi	r24, 0x01	; 1
    8ae0:	e1 f7       	brne	.-8      	; 0x8ada <LSM303_heading+0x26>
    8ae2:	e9 80       	ldd	r14, Y+1	; 0x01
    8ae4:	fa 80       	ldd	r15, Y+2	; 0x02
    8ae6:	0b 81       	ldd	r16, Y+3	; 0x03
    8ae8:	1c 81       	ldd	r17, Y+4	; 0x04
    8aea:	2d 81       	ldd	r18, Y+5	; 0x05
    8aec:	3e 81       	ldd	r19, Y+6	; 0x06
    8aee:	4f 81       	ldd	r20, Y+7	; 0x07
    8af0:	58 85       	ldd	r21, Y+8	; 0x08
    8af2:	69 85       	ldd	r22, Y+9	; 0x09
    8af4:	7a 85       	ldd	r23, Y+10	; 0x0a
    8af6:	8b 85       	ldd	r24, Y+11	; 0x0b
    8af8:	9c 85       	ldd	r25, Y+12	; 0x0c
    8afa:	0e 94 5d 44 	call	0x88ba	; 0x88ba <LSM303_heading_calc>
}
    8afe:	2c 96       	adiw	r28, 0x0c	; 12
    8b00:	0f b6       	in	r0, 0x3f	; 63
    8b02:	f8 94       	cli
    8b04:	de bf       	out	0x3e, r29	; 62
    8b06:	0f be       	out	0x3f, r0	; 63
    8b08:	cd bf       	out	0x3d, r28	; 61
    8b0a:	cf 91       	pop	r28
    8b0c:	df 91       	pop	r29
    8b0e:	1f 91       	pop	r17
    8b10:	0f 91       	pop	r16
    8b12:	ff 90       	pop	r15
    8b14:	ef 90       	pop	r14
    8b16:	08 95       	ret

00008b18 <LSM303_read8>:
  i2c_stop();
}

// Reads an accelerometer register
uint8_t LSM303_read8(uint8_t reg)
{
    8b18:	1f 93       	push	r17
    8b1a:	18 2f       	mov	r17, r24
  uint8_t value;
  
  i2c_start(_LSM303_W_ADDRESS);
    8b1c:	8a e3       	ldi	r24, 0x3A	; 58
    8b1e:	0e 94 95 14 	call	0x292a	; 0x292a <i2c_start>
  i2c_write(reg);
    8b22:	81 2f       	mov	r24, r17
    8b24:	0e 94 ee 14 	call	0x29dc	; 0x29dc <i2c_write>
  i2c_rep_start(_LSM303_R_ADDRESS);
    8b28:	8b e3       	ldi	r24, 0x3B	; 59
    8b2a:	0e 94 e3 14 	call	0x29c6	; 0x29c6 <i2c_rep_start>
  value = i2c_readNak(); 
    8b2e:	0e 94 0a 15 	call	0x2a14	; 0x2a14 <i2c_readNak>
    8b32:	18 2f       	mov	r17, r24
  i2c_stop();
    8b34:	0e 94 e6 14 	call	0x29cc	; 0x29cc <i2c_stop>

  return value;
}
    8b38:	81 2f       	mov	r24, r17
    8b3a:	1f 91       	pop	r17
    8b3c:	08 95       	ret

00008b3e <LSM303_readMag>:
  a.z = ACC_CAL* (double)((int16_t)(zha << 8 | zla));
}

// Reads the 3 magnetometer channels and stores them in vector m
void LSM303_readMag(void)
{
    8b3e:	9f 92       	push	r9
    8b40:	af 92       	push	r10
    8b42:	bf 92       	push	r11
    8b44:	cf 92       	push	r12
    8b46:	df 92       	push	r13
    8b48:	ef 92       	push	r14
    8b4a:	ff 92       	push	r15
    8b4c:	0f 93       	push	r16
    8b4e:	1f 93       	push	r17

  uint8_t xlm, xhm, ylm, yhm, zlm, zhm;

    xlm = LSM303_read8(OUT_X_L_M);
    8b50:	88 e0       	ldi	r24, 0x08	; 8
    8b52:	0e 94 8c 45 	call	0x8b18	; 0x8b18 <LSM303_read8>
    8b56:	08 2f       	mov	r16, r24
    xhm = LSM303_read8(OUT_X_H_M);
    8b58:	89 e0       	ldi	r24, 0x09	; 9
    8b5a:	0e 94 8c 45 	call	0x8b18	; 0x8b18 <LSM303_read8>
    8b5e:	b8 2e       	mov	r11, r24
    ylm = LSM303_read8(OUT_Y_L_M);
    8b60:	8a e0       	ldi	r24, 0x0A	; 10
    8b62:	0e 94 8c 45 	call	0x8b18	; 0x8b18 <LSM303_read8>
    8b66:	e8 2e       	mov	r14, r24
    yhm = LSM303_read8(OUT_Y_H_M);
    8b68:	8b e0       	ldi	r24, 0x0B	; 11
    8b6a:	0e 94 8c 45 	call	0x8b18	; 0x8b18 <LSM303_read8>
    8b6e:	a8 2e       	mov	r10, r24
    zlm = LSM303_read8(OUT_Z_L_M);
    8b70:	8c e0       	ldi	r24, 0x0C	; 12
    8b72:	0e 94 8c 45 	call	0x8b18	; 0x8b18 <LSM303_read8>
    8b76:	c8 2e       	mov	r12, r24
    zhm = LSM303_read8(OUT_Z_H_M);
    8b78:	8d e0       	ldi	r24, 0x0D	; 13
    8b7a:	0e 94 8c 45 	call	0x8b18	; 0x8b18 <LSM303_read8>
    8b7e:	98 2e       	mov	r9, r24

  // combine high and low bytes
  m.x = MAG_CAL* (double)((int16_t)(xhm << 8 | xlm));
    8b80:	7b 2d       	mov	r23, r11
    8b82:	60 e0       	ldi	r22, 0x00	; 0
    8b84:	10 e0       	ldi	r17, 0x00	; 0
    8b86:	60 2b       	or	r22, r16
    8b88:	71 2b       	or	r23, r17
    8b8a:	88 27       	eor	r24, r24
    8b8c:	77 fd       	sbrc	r23, 7
    8b8e:	80 95       	com	r24
    8b90:	98 2f       	mov	r25, r24
    8b92:	0e 94 e4 7d 	call	0xfbc8	; 0xfbc8 <__floatsisf>
    8b96:	2a e0       	ldi	r18, 0x0A	; 10
    8b98:	37 ed       	ldi	r19, 0xD7	; 215
    8b9a:	43 e2       	ldi	r20, 0x23	; 35
    8b9c:	5e e3       	ldi	r21, 0x3E	; 62
    8b9e:	0e 94 fe 7e 	call	0xfdfc	; 0xfdfc <__mulsf3>
    8ba2:	60 93 86 0a 	sts	0x0A86, r22
    8ba6:	70 93 87 0a 	sts	0x0A87, r23
    8baa:	80 93 88 0a 	sts	0x0A88, r24
    8bae:	90 93 89 0a 	sts	0x0A89, r25
  m.y = MAG_CAL* (double)((int16_t)(yhm << 8 | ylm));
    8bb2:	7a 2d       	mov	r23, r10
    8bb4:	60 e0       	ldi	r22, 0x00	; 0
    8bb6:	ff 24       	eor	r15, r15
    8bb8:	6e 29       	or	r22, r14
    8bba:	7f 29       	or	r23, r15
    8bbc:	88 27       	eor	r24, r24
    8bbe:	77 fd       	sbrc	r23, 7
    8bc0:	80 95       	com	r24
    8bc2:	98 2f       	mov	r25, r24
    8bc4:	0e 94 e4 7d 	call	0xfbc8	; 0xfbc8 <__floatsisf>
    8bc8:	2a e0       	ldi	r18, 0x0A	; 10
    8bca:	37 ed       	ldi	r19, 0xD7	; 215
    8bcc:	43 e2       	ldi	r20, 0x23	; 35
    8bce:	5e e3       	ldi	r21, 0x3E	; 62
    8bd0:	0e 94 fe 7e 	call	0xfdfc	; 0xfdfc <__mulsf3>
    8bd4:	60 93 8a 0a 	sts	0x0A8A, r22
    8bd8:	70 93 8b 0a 	sts	0x0A8B, r23
    8bdc:	80 93 8c 0a 	sts	0x0A8C, r24
    8be0:	90 93 8d 0a 	sts	0x0A8D, r25
  m.z = MAG_CAL* (double)((int16_t)(zhm << 8 | zlm));
    8be4:	79 2d       	mov	r23, r9
    8be6:	60 e0       	ldi	r22, 0x00	; 0
    8be8:	dd 24       	eor	r13, r13
    8bea:	6c 29       	or	r22, r12
    8bec:	7d 29       	or	r23, r13
    8bee:	88 27       	eor	r24, r24
    8bf0:	77 fd       	sbrc	r23, 7
    8bf2:	80 95       	com	r24
    8bf4:	98 2f       	mov	r25, r24
    8bf6:	0e 94 e4 7d 	call	0xfbc8	; 0xfbc8 <__floatsisf>
    8bfa:	2a e0       	ldi	r18, 0x0A	; 10
    8bfc:	37 ed       	ldi	r19, 0xD7	; 215
    8bfe:	43 e2       	ldi	r20, 0x23	; 35
    8c00:	5e e3       	ldi	r21, 0x3E	; 62
    8c02:	0e 94 fe 7e 	call	0xfdfc	; 0xfdfc <__mulsf3>
    8c06:	60 93 8e 0a 	sts	0x0A8E, r22
    8c0a:	70 93 8f 0a 	sts	0x0A8F, r23
    8c0e:	80 93 90 0a 	sts	0x0A90, r24
    8c12:	90 93 91 0a 	sts	0x0A91, r25
}
    8c16:	1f 91       	pop	r17
    8c18:	0f 91       	pop	r16
    8c1a:	ff 90       	pop	r15
    8c1c:	ef 90       	pop	r14
    8c1e:	df 90       	pop	r13
    8c20:	cf 90       	pop	r12
    8c22:	bf 90       	pop	r11
    8c24:	af 90       	pop	r10
    8c26:	9f 90       	pop	r9
    8c28:	08 95       	ret

00008c2a <LSM303_readAcc>:
1009 mg = 1.009 g.
*/

// Reads the 3 accelerometer channels and stores them in vector a
void LSM303_readAcc(void)
{
    8c2a:	9f 92       	push	r9
    8c2c:	af 92       	push	r10
    8c2e:	bf 92       	push	r11
    8c30:	cf 92       	push	r12
    8c32:	df 92       	push	r13
    8c34:	ef 92       	push	r14
    8c36:	ff 92       	push	r15
    8c38:	0f 93       	push	r16
    8c3a:	1f 93       	push	r17
 
  uint8_t xla = LSM303_read8(OUT_X_L_A);
    8c3c:	88 e2       	ldi	r24, 0x28	; 40
    8c3e:	0e 94 8c 45 	call	0x8b18	; 0x8b18 <LSM303_read8>
    8c42:	08 2f       	mov	r16, r24
  uint8_t xha = LSM303_read8(OUT_X_H_A);
    8c44:	89 e2       	ldi	r24, 0x29	; 41
    8c46:	0e 94 8c 45 	call	0x8b18	; 0x8b18 <LSM303_read8>
    8c4a:	b8 2e       	mov	r11, r24
  uint8_t yla = LSM303_read8(OUT_Y_L_A);
    8c4c:	8a e2       	ldi	r24, 0x2A	; 42
    8c4e:	0e 94 8c 45 	call	0x8b18	; 0x8b18 <LSM303_read8>
    8c52:	e8 2e       	mov	r14, r24
  uint8_t yha = LSM303_read8(OUT_Y_H_A);
    8c54:	8b e2       	ldi	r24, 0x2B	; 43
    8c56:	0e 94 8c 45 	call	0x8b18	; 0x8b18 <LSM303_read8>
    8c5a:	a8 2e       	mov	r10, r24
  uint8_t zla = LSM303_read8(OUT_Z_L_A);
    8c5c:	8c e2       	ldi	r24, 0x2C	; 44
    8c5e:	0e 94 8c 45 	call	0x8b18	; 0x8b18 <LSM303_read8>
    8c62:	c8 2e       	mov	r12, r24
  uint8_t zha = LSM303_read8(OUT_Z_H_A);
    8c64:	8d e2       	ldi	r24, 0x2D	; 45
    8c66:	0e 94 8c 45 	call	0x8b18	; 0x8b18 <LSM303_read8>
    8c6a:	98 2e       	mov	r9, r24

  // combine high and low bytes
  // This no longer drops the lowest 4 bits of the readings from the DLH/DLM/DLHC, which are always 0
  // (12-bit resolution, left-aligned). The D has 16-bit resolution
  a.x = ACC_CAL* (double)((int16_t)(xha << 8 | xla));
    8c6c:	7b 2d       	mov	r23, r11
    8c6e:	60 e0       	ldi	r22, 0x00	; 0
    8c70:	10 e0       	ldi	r17, 0x00	; 0
    8c72:	60 2b       	or	r22, r16
    8c74:	71 2b       	or	r23, r17
    8c76:	88 27       	eor	r24, r24
    8c78:	77 fd       	sbrc	r23, 7
    8c7a:	80 95       	com	r24
    8c7c:	98 2f       	mov	r25, r24
    8c7e:	0e 94 e4 7d 	call	0xfbc8	; 0xfbc8 <__floatsisf>
    8c82:	20 e4       	ldi	r18, 0x40	; 64
    8c84:	3a ed       	ldi	r19, 0xDA	; 218
    8c86:	4f e7       	ldi	r20, 0x7F	; 127
    8c88:	58 e3       	ldi	r21, 0x38	; 56
    8c8a:	0e 94 fe 7e 	call	0xfdfc	; 0xfdfc <__mulsf3>
    8c8e:	60 93 6e 0a 	sts	0x0A6E, r22
    8c92:	70 93 6f 0a 	sts	0x0A6F, r23
    8c96:	80 93 70 0a 	sts	0x0A70, r24
    8c9a:	90 93 71 0a 	sts	0x0A71, r25
  a.y = ACC_CAL* (double)((int16_t)(yha << 8 | yla));
    8c9e:	7a 2d       	mov	r23, r10
    8ca0:	60 e0       	ldi	r22, 0x00	; 0
    8ca2:	ff 24       	eor	r15, r15
    8ca4:	6e 29       	or	r22, r14
    8ca6:	7f 29       	or	r23, r15
    8ca8:	88 27       	eor	r24, r24
    8caa:	77 fd       	sbrc	r23, 7
    8cac:	80 95       	com	r24
    8cae:	98 2f       	mov	r25, r24
    8cb0:	0e 94 e4 7d 	call	0xfbc8	; 0xfbc8 <__floatsisf>
    8cb4:	20 e4       	ldi	r18, 0x40	; 64
    8cb6:	3a ed       	ldi	r19, 0xDA	; 218
    8cb8:	4f e7       	ldi	r20, 0x7F	; 127
    8cba:	58 e3       	ldi	r21, 0x38	; 56
    8cbc:	0e 94 fe 7e 	call	0xfdfc	; 0xfdfc <__mulsf3>
    8cc0:	60 93 72 0a 	sts	0x0A72, r22
    8cc4:	70 93 73 0a 	sts	0x0A73, r23
    8cc8:	80 93 74 0a 	sts	0x0A74, r24
    8ccc:	90 93 75 0a 	sts	0x0A75, r25
  a.z = ACC_CAL* (double)((int16_t)(zha << 8 | zla));
    8cd0:	79 2d       	mov	r23, r9
    8cd2:	60 e0       	ldi	r22, 0x00	; 0
    8cd4:	dd 24       	eor	r13, r13
    8cd6:	6c 29       	or	r22, r12
    8cd8:	7d 29       	or	r23, r13
    8cda:	88 27       	eor	r24, r24
    8cdc:	77 fd       	sbrc	r23, 7
    8cde:	80 95       	com	r24
    8ce0:	98 2f       	mov	r25, r24
    8ce2:	0e 94 e4 7d 	call	0xfbc8	; 0xfbc8 <__floatsisf>
    8ce6:	20 e4       	ldi	r18, 0x40	; 64
    8ce8:	3a ed       	ldi	r19, 0xDA	; 218
    8cea:	4f e7       	ldi	r20, 0x7F	; 127
    8cec:	58 e3       	ldi	r21, 0x38	; 56
    8cee:	0e 94 fe 7e 	call	0xfdfc	; 0xfdfc <__mulsf3>
    8cf2:	60 93 76 0a 	sts	0x0A76, r22
    8cf6:	70 93 77 0a 	sts	0x0A77, r23
    8cfa:	80 93 78 0a 	sts	0x0A78, r24
    8cfe:	90 93 79 0a 	sts	0x0A79, r25
}
    8d02:	1f 91       	pop	r17
    8d04:	0f 91       	pop	r16
    8d06:	ff 90       	pop	r15
    8d08:	ef 90       	pop	r14
    8d0a:	df 90       	pop	r13
    8d0c:	cf 90       	pop	r12
    8d0e:	bf 90       	pop	r11
    8d10:	af 90       	pop	r10
    8d12:	9f 90       	pop	r9
    8d14:	08 95       	ret

00008d16 <LSM303_read>:
}

// Reads all 6 channels of the LSM303 and stores them in the object variables
void LSM303_read(void)
{
  LSM303_readAcc();
    8d16:	0e 94 15 46 	call	0x8c2a	; 0x8c2a <LSM303_readAcc>
  LSM303_readMag();
    8d1a:	0e 94 9f 45 	call	0x8b3e	; 0x8b3e <LSM303_readMag>
}
    8d1e:	08 95       	ret

00008d20 <LSM303_write8>:
    LSM303_write8(CTRL7, 0x00);
}

// Writes an accelerometer register
void LSM303_write8(uint8_t reg, uint8_t value)
{
    8d20:	0f 93       	push	r16
    8d22:	1f 93       	push	r17
    8d24:	18 2f       	mov	r17, r24
    8d26:	06 2f       	mov	r16, r22
  i2c_start(_LSM303_W_ADDRESS);
    8d28:	8a e3       	ldi	r24, 0x3A	; 58
    8d2a:	0e 94 95 14 	call	0x292a	; 0x292a <i2c_start>
  i2c_write(reg);
    8d2e:	81 2f       	mov	r24, r17
    8d30:	0e 94 ee 14 	call	0x29dc	; 0x29dc <i2c_write>
  i2c_write(value);
    8d34:	80 2f       	mov	r24, r16
    8d36:	0e 94 ee 14 	call	0x29dc	; 0x29dc <i2c_write>
  i2c_stop();
    8d3a:	0e 94 e6 14 	call	0x29cc	; 0x29cc <i2c_stop>
}
    8d3e:	1f 91       	pop	r17
    8d40:	0f 91       	pop	r16
    8d42:	08 95       	ret

00008d44 <LSM303_enableDefault>:
{
	// Accelerometer

    // 0x00 = 0b00000000
    // AFS = 0 (+/- 2 g full scale)
    LSM303_write8(CTRL2, 0x00);
    8d44:	81 e2       	ldi	r24, 0x21	; 33
    8d46:	60 e0       	ldi	r22, 0x00	; 0
    8d48:	0e 94 90 46 	call	0x8d20	; 0x8d20 <LSM303_write8>

    // 0x57 = 0b01010111
    // AODR = 0001 (3 Hz ODR); AZEN = AYEN = AXEN = 1 (all axes enabled)
    LSM303_write8(CTRL1, 0x17);
    8d4c:	80 e2       	ldi	r24, 0x20	; 32
    8d4e:	67 e1       	ldi	r22, 0x17	; 23
    8d50:	0e 94 90 46 	call	0x8d20	; 0x8d20 <LSM303_write8>
    These values lead to an assumed magnetometer bias of 0.
    Use the Calibrate example program to determine appropriate values
    for your particular unit. The Heading example demonstrates how to
    adjust these values in your own sketch.
    */
	m_min.x = m_min.y = m_min.z = -1* MAG_CAL* 32767;
    8d54:	82 ec       	ldi	r24, 0xC2	; 194
    8d56:	95 ed       	ldi	r25, 0xD5	; 213
    8d58:	a3 ea       	ldi	r26, 0xA3	; 163
    8d5a:	b5 ec       	ldi	r27, 0xC5	; 197
    8d5c:	80 93 6a 0a 	sts	0x0A6A, r24
    8d60:	90 93 6b 0a 	sts	0x0A6B, r25
    8d64:	a0 93 6c 0a 	sts	0x0A6C, r26
    8d68:	b0 93 6d 0a 	sts	0x0A6D, r27
    8d6c:	80 93 66 0a 	sts	0x0A66, r24
    8d70:	90 93 67 0a 	sts	0x0A67, r25
    8d74:	a0 93 68 0a 	sts	0x0A68, r26
    8d78:	b0 93 69 0a 	sts	0x0A69, r27
    8d7c:	80 93 62 0a 	sts	0x0A62, r24
    8d80:	90 93 63 0a 	sts	0x0A63, r25
    8d84:	a0 93 64 0a 	sts	0x0A64, r26
    8d88:	b0 93 65 0a 	sts	0x0A65, r27
	m_max.x = m_max.y = m_max.z = MAG_CAL* 32767;
    8d8c:	82 ec       	ldi	r24, 0xC2	; 194
    8d8e:	95 ed       	ldi	r25, 0xD5	; 213
    8d90:	a3 ea       	ldi	r26, 0xA3	; 163
    8d92:	b5 e4       	ldi	r27, 0x45	; 69
    8d94:	80 93 82 0a 	sts	0x0A82, r24
    8d98:	90 93 83 0a 	sts	0x0A83, r25
    8d9c:	a0 93 84 0a 	sts	0x0A84, r26
    8da0:	b0 93 85 0a 	sts	0x0A85, r27
    8da4:	80 93 7e 0a 	sts	0x0A7E, r24
    8da8:	90 93 7f 0a 	sts	0x0A7F, r25
    8dac:	a0 93 80 0a 	sts	0x0A80, r26
    8db0:	b0 93 81 0a 	sts	0x0A81, r27
    8db4:	80 93 7a 0a 	sts	0x0A7A, r24
    8db8:	90 93 7b 0a 	sts	0x0A7B, r25
    8dbc:	a0 93 7c 0a 	sts	0x0A7C, r26
    8dc0:	b0 93 7d 0a 	sts	0x0A7D, r27

    // 0x64 = 0b01100100
    // M_RES = 11 (high resolution mode); M_ODR = 001 (6.25 Hz ODR)
    LSM303_write8(CTRL5, 0x64);
    8dc4:	84 e2       	ldi	r24, 0x24	; 36
    8dc6:	64 e6       	ldi	r22, 0x64	; 100
    8dc8:	0e 94 90 46 	call	0x8d20	; 0x8d20 <LSM303_write8>

    // 0x20 = 0b00100000
    // MFS = 01 (+/- 4 gauss full scale)
    LSM303_write8(CTRL6, 0x20);
    8dcc:	85 e2       	ldi	r24, 0x25	; 37
    8dce:	60 e2       	ldi	r22, 0x20	; 32
    8dd0:	0e 94 90 46 	call	0x8d20	; 0x8d20 <LSM303_write8>

    // 0x00 = 0b00000000
    // MLP = 0 (low power mode off); MD = 00 (continuous-conversion mode)
    LSM303_write8(CTRL7, 0x00);
    8dd4:	86 e2       	ldi	r24, 0x26	; 38
    8dd6:	60 e0       	ldi	r22, 0x00	; 0
    8dd8:	0e 94 90 46 	call	0x8d20	; 0x8d20 <LSM303_write8>
}
    8ddc:	08 95       	ret

00008dde <checkForBeat>:
**********************************************/

//  Heart Rate Monitor functions takes a sample value and the sample number
//  Returns true if a beat is detected
//  A running average of four samples is recommended for display on the screen.
uint8_t checkForBeat(int32_t *output_buffer, int32_t *avg_estimate, int32_t sample, struct HR_algo_state* HR_state) {
    8dde:	2f 92       	push	r2
    8de0:	3f 92       	push	r3
    8de2:	4f 92       	push	r4
    8de4:	5f 92       	push	r5
    8de6:	6f 92       	push	r6
    8de8:	7f 92       	push	r7
    8dea:	8f 92       	push	r8
    8dec:	9f 92       	push	r9
    8dee:	af 92       	push	r10
    8df0:	bf 92       	push	r11
    8df2:	cf 92       	push	r12
    8df4:	df 92       	push	r13
    8df6:	ef 92       	push	r14
    8df8:	ff 92       	push	r15
    8dfa:	0f 93       	push	r16
    8dfc:	1f 93       	push	r17
    8dfe:	cf 93       	push	r28
    8e00:	df 93       	push	r29
    8e02:	1c 01       	movw	r2, r24
    8e04:	7b 01       	movw	r14, r22
    8e06:	48 01       	movw	r8, r16
  uint8_t beatDetected = 0;
  uint8_t i = 0;
  int32_t z = 0;
  *avg_estimate = 0L;
    8e08:	db 01       	movw	r26, r22
    8e0a:	1d 92       	st	X+, r1
    8e0c:	1d 92       	st	X+, r1
    8e0e:	1d 92       	st	X+, r1
    8e10:	1c 92       	st	X, r1
    8e12:	13 97       	sbiw	r26, 0x03	; 3

  //  Save current state
  output_buffer[2] = output_buffer[1];
    8e14:	ec 01       	movw	r28, r24
    8e16:	8c 81       	ldd	r24, Y+4	; 0x04
    8e18:	9d 81       	ldd	r25, Y+5	; 0x05
    8e1a:	ae 81       	ldd	r26, Y+6	; 0x06
    8e1c:	bf 81       	ldd	r27, Y+7	; 0x07
    8e1e:	f1 01       	movw	r30, r2
    8e20:	80 87       	std	Z+8, r24	; 0x08
    8e22:	91 87       	std	Z+9, r25	; 0x09
    8e24:	a2 87       	std	Z+10, r26	; 0x0a
    8e26:	b3 87       	std	Z+11, r27	; 0x0b
  output_buffer[1] = output_buffer[0];
    8e28:	80 81       	ld	r24, Z
    8e2a:	91 81       	ldd	r25, Z+1	; 0x01
    8e2c:	a2 81       	ldd	r26, Z+2	; 0x02
    8e2e:	b3 81       	ldd	r27, Z+3	; 0x03
    8e30:	8c 83       	std	Y+4, r24	; 0x04
    8e32:	9d 83       	std	Y+5, r25	; 0x05
    8e34:	ae 83       	std	Y+6, r26	; 0x06
    8e36:	bf 83       	std	Y+7, r27	; 0x07
  
  HR_state->xbuf_DC[HR_state->offset_DC] = sample;
    8e38:	d8 01       	movw	r26, r16
    8e3a:	1d 96       	adiw	r26, 0x0d	; 13
    8e3c:	ec 91       	ld	r30, X
    8e3e:	f0 e0       	ldi	r31, 0x00	; 0
    8e40:	ee 0f       	add	r30, r30
    8e42:	ff 1f       	adc	r31, r31
    8e44:	ee 0f       	add	r30, r30
    8e46:	ff 1f       	adc	r31, r31
    8e48:	e0 0f       	add	r30, r16
    8e4a:	f1 1f       	adc	r31, r17
    8e4c:	27 87       	std	Z+15, r18	; 0x0f
    8e4e:	30 8b       	std	Z+16, r19	; 0x10
    8e50:	41 8b       	std	Z+17, r20	; 0x11
    8e52:	52 8b       	std	Z+18, r21	; 0x12
  
  HR_state->abuf_DC[HR_state->offset_DC] = 0L;
    8e54:	8f 01       	movw	r16, r30
    8e56:	01 57       	subi	r16, 0x71	; 113
    8e58:	1f 4f       	sbci	r17, 0xFF	; 255
    8e5a:	e8 01       	movw	r28, r16
    8e5c:	18 82       	st	Y, r1
    8e5e:	19 82       	std	Y+1, r1	; 0x01
    8e60:	1a 82       	std	Y+2, r1	; 0x02
    8e62:	1b 82       	std	Y+3, r1	; 0x03
    8e64:	f4 01       	movw	r30, r8
    8e66:	b4 01       	movw	r22, r8
    8e68:	60 58       	subi	r22, 0x80	; 128
    8e6a:	7f 4f       	sbci	r23, 0xFF	; 255
  
  /*****  Strip out the DC *********/
  for (i = 0 ; i < FILT_AV ; i++) {
	HR_state->abuf_DC[HR_state->offset_DC] += HR_state->xbuf_DC[i];
    8e6c:	28 81       	ld	r18, Y
    8e6e:	39 81       	ldd	r19, Y+1	; 0x01
    8e70:	4a 81       	ldd	r20, Y+2	; 0x02
    8e72:	5b 81       	ldd	r21, Y+3	; 0x03
    8e74:	87 85       	ldd	r24, Z+15	; 0x0f
    8e76:	90 89       	ldd	r25, Z+16	; 0x10
    8e78:	a1 89       	ldd	r26, Z+17	; 0x11
    8e7a:	b2 89       	ldd	r27, Z+18	; 0x12
    8e7c:	28 0f       	add	r18, r24
    8e7e:	39 1f       	adc	r19, r25
    8e80:	4a 1f       	adc	r20, r26
    8e82:	5b 1f       	adc	r21, r27
    8e84:	28 83       	st	Y, r18
    8e86:	39 83       	std	Y+1, r19	; 0x01
    8e88:	4a 83       	std	Y+2, r20	; 0x02
    8e8a:	5b 83       	std	Y+3, r21	; 0x03
    8e8c:	34 96       	adiw	r30, 0x04	; 4
  HR_state->xbuf_DC[HR_state->offset_DC] = sample;
  
  HR_state->abuf_DC[HR_state->offset_DC] = 0L;
  
  /*****  Strip out the DC *********/
  for (i = 0 ; i < FILT_AV ; i++) {
    8e8e:	e6 17       	cp	r30, r22
    8e90:	f7 07       	cpc	r31, r23
    8e92:	61 f7       	brne	.-40     	; 0x8e6c <checkForBeat+0x8e>
	HR_state->abuf_DC[HR_state->offset_DC] += HR_state->xbuf_DC[i];
  }
  HR_state->abuf_DC[HR_state->offset_DC] = (HR_state->abuf_DC[HR_state->offset_DC])>>LOG_2_FILT_AV;
    8e94:	85 e0       	ldi	r24, 0x05	; 5
    8e96:	55 95       	asr	r21
    8e98:	47 95       	ror	r20
    8e9a:	37 95       	ror	r19
    8e9c:	27 95       	ror	r18
    8e9e:	8a 95       	dec	r24
    8ea0:	d1 f7       	brne	.-12     	; 0x8e96 <checkForBeat+0xb8>
    8ea2:	f8 01       	movw	r30, r16
    8ea4:	20 83       	st	Z, r18
    8ea6:	31 83       	std	Z+1, r19	; 0x01
    8ea8:	42 83       	std	Z+2, r20	; 0x02
    8eaa:	53 83       	std	Z+3, r21	; 0x03
    8eac:	d7 01       	movw	r26, r14
    8eae:	2d 91       	ld	r18, X+
    8eb0:	3d 91       	ld	r19, X+
    8eb2:	4d 91       	ld	r20, X+
    8eb4:	5c 91       	ld	r21, X
    8eb6:	f4 01       	movw	r30, r8
    8eb8:	e1 57       	subi	r30, 0x71	; 113
    8eba:	ff 4f       	sbci	r31, 0xFF	; 255
    8ebc:	60 e0       	ldi	r22, 0x00	; 0
  
  for (i = 0 ; i < FILT_AV ; i++) {
	*avg_estimate += HR_state->abuf_DC[i];
    8ebe:	81 91       	ld	r24, Z+
    8ec0:	91 91       	ld	r25, Z+
    8ec2:	a1 91       	ld	r26, Z+
    8ec4:	b1 91       	ld	r27, Z+
    8ec6:	28 0f       	add	r18, r24
    8ec8:	39 1f       	adc	r19, r25
    8eca:	4a 1f       	adc	r20, r26
    8ecc:	5b 1f       	adc	r21, r27
    8ece:	e7 01       	movw	r28, r14
    8ed0:	28 83       	st	Y, r18
    8ed2:	39 83       	std	Y+1, r19	; 0x01
    8ed4:	4a 83       	std	Y+2, r20	; 0x02
    8ed6:	5b 83       	std	Y+3, r21	; 0x03
  for (i = 0 ; i < FILT_AV ; i++) {
	HR_state->abuf_DC[HR_state->offset_DC] += HR_state->xbuf_DC[i];
  }
  HR_state->abuf_DC[HR_state->offset_DC] = (HR_state->abuf_DC[HR_state->offset_DC])>>LOG_2_FILT_AV;
  
  for (i = 0 ; i < FILT_AV ; i++) {
    8ed8:	6f 5f       	subi	r22, 0xFF	; 255
    8eda:	60 32       	cpi	r22, 0x20	; 32
    8edc:	81 f7       	brne	.-32     	; 0x8ebe <checkForBeat+0xe0>
	*avg_estimate += HR_state->abuf_DC[i];
  }
  *avg_estimate = *avg_estimate>>LOG_2_FILT_AV;
    8ede:	b5 e0       	ldi	r27, 0x05	; 5
    8ee0:	55 95       	asr	r21
    8ee2:	47 95       	ror	r20
    8ee4:	37 95       	ror	r19
    8ee6:	27 95       	ror	r18
    8ee8:	ba 95       	dec	r27
    8eea:	d1 f7       	brne	.-12     	; 0x8ee0 <checkForBeat+0x102>
    8eec:	f7 01       	movw	r30, r14
    8eee:	20 83       	st	Z, r18
    8ef0:	31 83       	std	Z+1, r19	; 0x01
    8ef2:	42 83       	std	Z+2, r20	; 0x02
    8ef4:	53 83       	std	Z+3, r21	; 0x03

  output_buffer[0] = (*avg_estimate - HR_state->xbuf_DC[(HR_state->offset_DC+1)%FILT_AV])<<2 ; 
    8ef6:	d4 01       	movw	r26, r8
    8ef8:	1d 96       	adiw	r26, 0x0d	; 13
    8efa:	ec 91       	ld	r30, X
    8efc:	f0 e0       	ldi	r31, 0x00	; 0
    8efe:	31 96       	adiw	r30, 0x01	; 1
    8f00:	ef 71       	andi	r30, 0x1F	; 31
    8f02:	f0 70       	andi	r31, 0x00	; 0
    8f04:	ee 0f       	add	r30, r30
    8f06:	ff 1f       	adc	r31, r31
    8f08:	ee 0f       	add	r30, r30
    8f0a:	ff 1f       	adc	r31, r31
    8f0c:	e8 0d       	add	r30, r8
    8f0e:	f9 1d       	adc	r31, r9
    8f10:	87 85       	ldd	r24, Z+15	; 0x0f
    8f12:	90 89       	ldd	r25, Z+16	; 0x10
    8f14:	a1 89       	ldd	r26, Z+17	; 0x11
    8f16:	b2 89       	ldd	r27, Z+18	; 0x12
    8f18:	28 1b       	sub	r18, r24
    8f1a:	39 0b       	sbc	r19, r25
    8f1c:	4a 0b       	sbc	r20, r26
    8f1e:	5b 0b       	sbc	r21, r27
    8f20:	22 0f       	add	r18, r18
    8f22:	33 1f       	adc	r19, r19
    8f24:	44 1f       	adc	r20, r20
    8f26:	55 1f       	adc	r21, r21
    8f28:	22 0f       	add	r18, r18
    8f2a:	33 1f       	adc	r19, r19
    8f2c:	44 1f       	adc	r20, r20
    8f2e:	55 1f       	adc	r21, r21
    8f30:	e1 01       	movw	r28, r2
    8f32:	28 83       	st	Y, r18
    8f34:	39 83       	std	Y+1, r19	; 0x01
    8f36:	4a 83       	std	Y+2, r20	; 0x02
    8f38:	5b 83       	std	Y+3, r21	; 0x03
  HR_state->offset_DC++;
  HR_state->offset_DC %= FILT_AV; //Wrap condition
    8f3a:	f4 01       	movw	r30, r8
    8f3c:	85 85       	ldd	r24, Z+13	; 0x0d
    8f3e:	8f 5f       	subi	r24, 0xFF	; 255
    8f40:	8f 71       	andi	r24, 0x1F	; 31
    8f42:	85 87       	std	Z+13, r24	; 0x0d
  /*****  Strip out the DC *********/
  
  /*****  Low Pass FIR Filter *********/
  HR_state->cbuf[HR_state->offset_filt] = output_buffer[0];
    8f44:	56 84       	ldd	r5, Z+14	; 0x0e
    8f46:	a5 2c       	mov	r10, r5
    8f48:	bb 24       	eor	r11, r11
    8f4a:	f5 01       	movw	r30, r10
    8f4c:	ee 0f       	add	r30, r30
    8f4e:	ff 1f       	adc	r31, r31
    8f50:	ee 0f       	add	r30, r30
    8f52:	ff 1f       	adc	r31, r31
    8f54:	e8 0d       	add	r30, r8
    8f56:	f9 1d       	adc	r31, r9
    8f58:	e1 5f       	subi	r30, 0xF1	; 241
    8f5a:	fe 4f       	sbci	r31, 0xFE	; 254
    8f5c:	88 81       	ld	r24, Y
    8f5e:	99 81       	ldd	r25, Y+1	; 0x01
    8f60:	aa 81       	ldd	r26, Y+2	; 0x02
    8f62:	bb 81       	ldd	r27, Y+3	; 0x03
    8f64:	80 83       	st	Z, r24
    8f66:	91 83       	std	Z+1, r25	; 0x01
    8f68:	a2 83       	std	Z+2, r26	; 0x02
    8f6a:	b3 83       	std	Z+3, r27	; 0x03
  z = FIRCoeffs[11] * HR_state->cbuf[(HR_state->offset_filt - 11) & 0x1F];
    8f6c:	f5 01       	movw	r30, r10
    8f6e:	3b 97       	sbiw	r30, 0x0b	; 11
    8f70:	ef 71       	andi	r30, 0x1F	; 31
    8f72:	f0 70       	andi	r31, 0x00	; 0
    8f74:	ee 0f       	add	r30, r30
    8f76:	ff 1f       	adc	r31, r31
    8f78:	ee 0f       	add	r30, r30
    8f7a:	ff 1f       	adc	r31, r31
    8f7c:	e8 0d       	add	r30, r8
    8f7e:	f9 1d       	adc	r31, r9
    8f80:	e1 5f       	subi	r30, 0xF1	; 241
    8f82:	fe 4f       	sbci	r31, 0xFE	; 254
    8f84:	60 81       	ld	r22, Z
    8f86:	71 81       	ldd	r23, Z+1	; 0x01
    8f88:	82 81       	ldd	r24, Z+2	; 0x02
    8f8a:	93 81       	ldd	r25, Z+3	; 0x03
    8f8c:	2c ee       	ldi	r18, 0xEC	; 236
    8f8e:	34 e1       	ldi	r19, 0x14	; 20
    8f90:	40 e0       	ldi	r20, 0x00	; 0
    8f92:	50 e0       	ldi	r21, 0x00	; 0
    8f94:	0e 94 bb 7f 	call	0xff76	; 0xff76 <__mulsi3>
    8f98:	7b 01       	movw	r14, r22
    8f9a:	8c 01       	movw	r16, r24
    8f9c:	42 ee       	ldi	r20, 0xE2	; 226
    8f9e:	c4 2e       	mov	r12, r20
    8fa0:	43 e0       	ldi	r20, 0x03	; 3
    8fa2:	d4 2e       	mov	r13, r20
    8fa4:	c0 e0       	ldi	r28, 0x00	; 0
    8fa6:	d0 e0       	ldi	r29, 0x00	; 0
  
  for (uint8_t i = 0 ; i < 11 ; i++)
  {
    z += FIRCoeffs[i] *(HR_state->cbuf[(HR_state->offset_filt - i) & 0x1F] + HR_state->cbuf[(HR_state->offset_filt - 22 + i) & 0x1F]);
    8fa8:	3a ee       	ldi	r19, 0xEA	; 234
    8faa:	63 2e       	mov	r6, r19
    8fac:	3f ef       	ldi	r19, 0xFF	; 255
    8fae:	73 2e       	mov	r7, r19
    8fb0:	6a 0c       	add	r6, r10
    8fb2:	7b 1c       	adc	r7, r11
    8fb4:	d3 01       	movw	r26, r6
    8fb6:	ac 0f       	add	r26, r28
    8fb8:	bd 1f       	adc	r27, r29
    8fba:	af 71       	andi	r26, 0x1F	; 31
    8fbc:	b0 70       	andi	r27, 0x00	; 0
    8fbe:	aa 0f       	add	r26, r26
    8fc0:	bb 1f       	adc	r27, r27
    8fc2:	aa 0f       	add	r26, r26
    8fc4:	bb 1f       	adc	r27, r27
    8fc6:	a8 0d       	add	r26, r8
    8fc8:	b9 1d       	adc	r27, r9
    8fca:	a1 5f       	subi	r26, 0xF1	; 241
    8fcc:	be 4f       	sbci	r27, 0xFE	; 254
    8fce:	f5 01       	movw	r30, r10
    8fd0:	ec 1b       	sub	r30, r28
    8fd2:	fd 0b       	sbc	r31, r29
    8fd4:	ef 71       	andi	r30, 0x1F	; 31
    8fd6:	f0 70       	andi	r31, 0x00	; 0
    8fd8:	ee 0f       	add	r30, r30
    8fda:	ff 1f       	adc	r31, r31
    8fdc:	ee 0f       	add	r30, r30
    8fde:	ff 1f       	adc	r31, r31
    8fe0:	e8 0d       	add	r30, r8
    8fe2:	f9 1d       	adc	r31, r9
    8fe4:	e1 5f       	subi	r30, 0xF1	; 241
    8fe6:	fe 4f       	sbci	r31, 0xFE	; 254
    8fe8:	6d 91       	ld	r22, X+
    8fea:	7d 91       	ld	r23, X+
    8fec:	8d 91       	ld	r24, X+
    8fee:	9c 91       	ld	r25, X
    8ff0:	20 81       	ld	r18, Z
    8ff2:	31 81       	ldd	r19, Z+1	; 0x01
    8ff4:	42 81       	ldd	r20, Z+2	; 0x02
    8ff6:	53 81       	ldd	r21, Z+3	; 0x03
    8ff8:	62 0f       	add	r22, r18
    8ffa:	73 1f       	adc	r23, r19
    8ffc:	84 1f       	adc	r24, r20
    8ffe:	95 1f       	adc	r25, r21
    9000:	d6 01       	movw	r26, r12
    9002:	2d 91       	ld	r18, X+
    9004:	3d 91       	ld	r19, X+
    9006:	4d 91       	ld	r20, X+
    9008:	5d 91       	ld	r21, X+
    900a:	6d 01       	movw	r12, r26
    900c:	0e 94 bb 7f 	call	0xff76	; 0xff76 <__mulsi3>
    9010:	e6 0e       	add	r14, r22
    9012:	f7 1e       	adc	r15, r23
    9014:	08 1f       	adc	r16, r24
    9016:	19 1f       	adc	r17, r25
    9018:	21 96       	adiw	r28, 0x01	; 1
  
  /*****  Low Pass FIR Filter *********/
  HR_state->cbuf[HR_state->offset_filt] = output_buffer[0];
  z = FIRCoeffs[11] * HR_state->cbuf[(HR_state->offset_filt - 11) & 0x1F];
  
  for (uint8_t i = 0 ; i < 11 ; i++)
    901a:	cb 30       	cpi	r28, 0x0B	; 11
    901c:	d1 05       	cpc	r29, r1
    901e:	51 f6       	brne	.-108    	; 0x8fb4 <checkForBeat+0x1d6>
  {
    z += FIRCoeffs[i] *(HR_state->cbuf[(HR_state->offset_filt - i) & 0x1F] + HR_state->cbuf[(HR_state->offset_filt - 22 + i) & 0x1F]);
  }

  HR_state->offset_filt++;
  HR_state->offset_filt %= 32; //Wrap condition
    9020:	53 94       	inc	r5
    9022:	bf e1       	ldi	r27, 0x1F	; 31
    9024:	5b 22       	and	r5, r27
    9026:	e4 01       	movw	r28, r8
    9028:	5e 86       	std	Y+14, r5	; 0x0e
	
  output_buffer[0] = (z>>8);//the original
  output_buffer[0] *= -1;//the original	
    902a:	bb 27       	eor	r27, r27
    902c:	17 fd       	sbrc	r17, 7
    902e:	ba 95       	dec	r27
    9030:	a1 2f       	mov	r26, r17
    9032:	90 2f       	mov	r25, r16
    9034:	8f 2d       	mov	r24, r15
    9036:	aa 24       	eor	r10, r10
    9038:	bb 24       	eor	r11, r11
    903a:	65 01       	movw	r12, r10
    903c:	a8 1a       	sub	r10, r24
    903e:	b9 0a       	sbc	r11, r25
    9040:	ca 0a       	sbc	r12, r26
    9042:	db 0a       	sbc	r13, r27
    9044:	f1 01       	movw	r30, r2
    9046:	a0 82       	st	Z, r10
    9048:	b1 82       	std	Z+1, r11	; 0x01
    904a:	c2 82       	std	Z+2, r12	; 0x02
    904c:	d3 82       	std	Z+3, r13	; 0x03
  /*****  Low Pass FIR Filter *********/

  /*****  Actual Algorithm *********/
  if ((output_buffer[2]  == output_buffer[1]) && (output_buffer[1] < output_buffer[0])) {
    904e:	e0 84       	ldd	r14, Z+8	; 0x08
    9050:	f1 84       	ldd	r15, Z+9	; 0x09
    9052:	02 85       	ldd	r16, Z+10	; 0x0a
    9054:	13 85       	ldd	r17, Z+11	; 0x0b
    9056:	d8 01       	movw	r26, r16
    9058:	c7 01       	movw	r24, r14
    905a:	24 81       	ldd	r18, Z+4	; 0x04
    905c:	35 81       	ldd	r19, Z+5	; 0x05
    905e:	46 81       	ldd	r20, Z+6	; 0x06
    9060:	57 81       	ldd	r21, Z+7	; 0x07
    9062:	29 01       	movw	r4, r18
    9064:	3a 01       	movw	r6, r20
    9066:	e2 16       	cp	r14, r18
    9068:	f3 06       	cpc	r15, r19
    906a:	04 07       	cpc	r16, r20
    906c:	15 07       	cpc	r17, r21
    906e:	09 f4       	brne	.+2      	; 0x9072 <checkForBeat+0x294>
    9070:	b3 c0       	rjmp	.+358    	; 0x91d8 <checkForBeat+0x3fa>
		 HR_state->peak_max = output_buffer[1];
	}
  }
  
  //dot-up-flat
  if ((output_buffer[2] < output_buffer[1]) && (output_buffer[1] == output_buffer[0])) {
    9072:	e2 16       	cp	r14, r18
    9074:	f3 06       	cpc	r15, r19
    9076:	04 07       	cpc	r16, r20
    9078:	15 07       	cpc	r17, r21
    907a:	5c f5       	brge	.+86     	; 0x90d2 <checkForBeat+0x2f4>
    907c:	f1 01       	movw	r30, r2
    907e:	80 81       	ld	r24, Z
    9080:	91 81       	ldd	r25, Z+1	; 0x01
    9082:	a2 81       	ldd	r26, Z+2	; 0x02
    9084:	b3 81       	ldd	r27, Z+3	; 0x03
    9086:	82 17       	cp	r24, r18
    9088:	93 07       	cpc	r25, r19
    908a:	a4 07       	cpc	r26, r20
    908c:	b5 07       	cpc	r27, r21
    908e:	09 f4       	brne	.+2      	; 0x9092 <checkForBeat+0x2b4>
    9090:	e8 c0       	rjmp	.+464    	; 0x9262 <checkForBeat+0x484>
	 HR_state->maybe_peak = 1;
  }
  
  //dot-up-down
  if ((output_buffer[2]  < output_buffer[1]) && (output_buffer[1] > output_buffer[0]) && (output_buffer[1] >0)) {
    9092:	82 17       	cp	r24, r18
    9094:	93 07       	cpc	r25, r19
    9096:	a4 07       	cpc	r26, r20
    9098:	b5 07       	cpc	r27, r21
    909a:	0c f0       	brlt	.+2      	; 0x909e <checkForBeat+0x2c0>
    909c:	7b c0       	rjmp	.+246    	; 0x9194 <checkForBeat+0x3b6>
    909e:	12 16       	cp	r1, r18
    90a0:	13 06       	cpc	r1, r19
    90a2:	14 06       	cpc	r1, r20
    90a4:	15 06       	cpc	r1, r21
    90a6:	0c f0       	brlt	.+2      	; 0x90aa <checkForBeat+0x2cc>
    90a8:	75 c0       	rjmp	.+234    	; 0x9194 <checkForBeat+0x3b6>
	 HR_state->peak_detect = 1;
    90aa:	81 e0       	ldi	r24, 0x01	; 1
    90ac:	e4 01       	movw	r28, r8
    90ae:	8a 83       	std	Y+2, r24	; 0x02
	 HR_state->peak_max = output_buffer[1];
    90b0:	f1 01       	movw	r30, r2
    90b2:	84 81       	ldd	r24, Z+4	; 0x04
    90b4:	95 81       	ldd	r25, Z+5	; 0x05
    90b6:	a6 81       	ldd	r26, Z+6	; 0x06
    90b8:	b7 81       	ldd	r27, Z+7	; 0x07
    90ba:	89 87       	std	Y+9, r24	; 0x09
    90bc:	9a 87       	std	Y+10, r25	; 0x0a
    90be:	ab 87       	std	Y+11, r26	; 0x0b
    90c0:	bc 87       	std	Y+12, r27	; 0x0c
    90c2:	80 85       	ldd	r24, Z+8	; 0x08
    90c4:	91 85       	ldd	r25, Z+9	; 0x09
    90c6:	a2 85       	ldd	r26, Z+10	; 0x0a
    90c8:	b3 85       	ldd	r27, Z+11	; 0x0b
    90ca:	44 80       	ldd	r4, Z+4	; 0x04
    90cc:	55 80       	ldd	r5, Z+5	; 0x05
    90ce:	66 80       	ldd	r6, Z+6	; 0x06
    90d0:	77 80       	ldd	r7, Z+7	; 0x07
  }
  
  //dot-down-up
  if ((output_buffer[2]  > output_buffer[1]) && (output_buffer[1] < output_buffer[0])) {
    90d2:	48 16       	cp	r4, r24
    90d4:	59 06       	cpc	r5, r25
    90d6:	6a 06       	cpc	r6, r26
    90d8:	7b 06       	cpc	r7, r27
    90da:	74 f5       	brge	.+92     	; 0x9138 <checkForBeat+0x35a>
    90dc:	f1 01       	movw	r30, r2
    90de:	80 81       	ld	r24, Z
    90e0:	91 81       	ldd	r25, Z+1	; 0x01
    90e2:	a2 81       	ldd	r26, Z+2	; 0x02
    90e4:	b3 81       	ldd	r27, Z+3	; 0x03
    90e6:	48 16       	cp	r4, r24
    90e8:	59 06       	cpc	r5, r25
    90ea:	6a 06       	cpc	r6, r26
    90ec:	7b 06       	cpc	r7, r27
    90ee:	f4 f4       	brge	.+60     	; 0x912c <checkForBeat+0x34e>
	 HR_state->valley_detect = 1;
    90f0:	81 e0       	ldi	r24, 0x01	; 1
    90f2:	d4 01       	movw	r26, r8
    90f4:	13 96       	adiw	r26, 0x03	; 3
    90f6:	8c 93       	st	X, r24
	 HR_state->valley_min = output_buffer[1];
    90f8:	84 81       	ldd	r24, Z+4	; 0x04
    90fa:	95 81       	ldd	r25, Z+5	; 0x05
    90fc:	a6 81       	ldd	r26, Z+6	; 0x06
    90fe:	b7 81       	ldd	r27, Z+7	; 0x07
    9100:	e4 01       	movw	r28, r8
    9102:	8d 83       	std	Y+5, r24	; 0x05
    9104:	9e 83       	std	Y+6, r25	; 0x06
    9106:	af 83       	std	Y+7, r26	; 0x07
    9108:	b8 87       	std	Y+8, r27	; 0x08
  }
  
  //dot-down-flat
  if ((output_buffer[2]  > output_buffer[1]) && (output_buffer[1] == output_buffer[0])) {
    910a:	44 80       	ldd	r4, Z+4	; 0x04
    910c:	55 80       	ldd	r5, Z+5	; 0x05
    910e:	66 80       	ldd	r6, Z+6	; 0x06
    9110:	77 80       	ldd	r7, Z+7	; 0x07
    9112:	80 85       	ldd	r24, Z+8	; 0x08
    9114:	91 85       	ldd	r25, Z+9	; 0x09
    9116:	a2 85       	ldd	r26, Z+10	; 0x0a
    9118:	b3 85       	ldd	r27, Z+11	; 0x0b
    911a:	48 16       	cp	r4, r24
    911c:	59 06       	cpc	r5, r25
    911e:	6a 06       	cpc	r6, r26
    9120:	7b 06       	cpc	r7, r27
    9122:	54 f4       	brge	.+20     	; 0x9138 <checkForBeat+0x35a>
    9124:	80 81       	ld	r24, Z
    9126:	91 81       	ldd	r25, Z+1	; 0x01
    9128:	a2 81       	ldd	r26, Z+2	; 0x02
    912a:	b3 81       	ldd	r27, Z+3	; 0x03
    912c:	84 15       	cp	r24, r4
    912e:	95 05       	cpc	r25, r5
    9130:	a6 05       	cpc	r26, r6
    9132:	b7 05       	cpc	r27, r7
    9134:	09 f4       	brne	.+2      	; 0x9138 <checkForBeat+0x35a>
    9136:	91 c0       	rjmp	.+290    	; 0x925a <checkForBeat+0x47c>
	 HR_state->maybe_valley = 1;
  }
  
  //  special: detect fiar (five-in-a-row going up)
  if ( HR_state->fiar < FIAR_PARAM) {
    9138:	d4 01       	movw	r26, r8
    913a:	14 96       	adiw	r26, 0x04	; 4
    913c:	6c 91       	ld	r22, X
    913e:	66 30       	cpi	r22, 0x06	; 6
    9140:	88 f4       	brcc	.+34     	; 0x9164 <checkForBeat+0x386>
	if (output_buffer[1] <= output_buffer[0]) {
    9142:	e1 01       	movw	r28, r2
    9144:	2c 81       	ldd	r18, Y+4	; 0x04
    9146:	3d 81       	ldd	r19, Y+5	; 0x05
    9148:	4e 81       	ldd	r20, Y+6	; 0x06
    914a:	5f 81       	ldd	r21, Y+7	; 0x07
    914c:	88 81       	ld	r24, Y
    914e:	99 81       	ldd	r25, Y+1	; 0x01
    9150:	aa 81       	ldd	r26, Y+2	; 0x02
    9152:	bb 81       	ldd	r27, Y+3	; 0x03
    9154:	82 17       	cp	r24, r18
    9156:	93 07       	cpc	r25, r19
    9158:	a4 07       	cpc	r26, r20
    915a:	b5 07       	cpc	r27, r21
    915c:	04 f1       	brlt	.+64     	; 0x919e <checkForBeat+0x3c0>
		 HR_state->fiar++;
    915e:	6f 5f       	subi	r22, 0xFF	; 255
    9160:	f4 01       	movw	r30, r8
    9162:	64 83       	std	Z+4, r22	; 0x04
		}
	}
  }
  
  //  if detected peak
  if ( HR_state->peak_detect ==1) {
    9164:	e4 01       	movw	r28, r8
    9166:	8a 81       	ldd	r24, Y+2	; 0x02
    9168:	81 30       	cpi	r24, 0x01	; 1
    916a:	11 f1       	breq	.+68     	; 0x91b0 <checkForBeat+0x3d2>
    916c:	80 e0       	ldi	r24, 0x00	; 0
	 //HR_state->valley_min = 0;
	 //HR_state->peak_max = 0;
  }//detect peak
 
 return(beatDetected);
}
    916e:	df 91       	pop	r29
    9170:	cf 91       	pop	r28
    9172:	1f 91       	pop	r17
    9174:	0f 91       	pop	r16
    9176:	ff 90       	pop	r15
    9178:	ef 90       	pop	r14
    917a:	df 90       	pop	r13
    917c:	cf 90       	pop	r12
    917e:	bf 90       	pop	r11
    9180:	af 90       	pop	r10
    9182:	9f 90       	pop	r9
    9184:	8f 90       	pop	r8
    9186:	7f 90       	pop	r7
    9188:	6f 90       	pop	r6
    918a:	5f 90       	pop	r5
    918c:	4f 90       	pop	r4
    918e:	3f 90       	pop	r3
    9190:	2f 90       	pop	r2
    9192:	08 95       	ret
  if ((output_buffer[2] < output_buffer[1]) && (output_buffer[1] == output_buffer[0])) {
	 HR_state->maybe_peak = 1;
  }
  
  //dot-up-down
  if ((output_buffer[2]  < output_buffer[1]) && (output_buffer[1] > output_buffer[0]) && (output_buffer[1] >0)) {
    9194:	d8 01       	movw	r26, r16
    9196:	c7 01       	movw	r24, r14
    9198:	29 01       	movw	r4, r18
    919a:	3a 01       	movw	r6, r20
    919c:	9a cf       	rjmp	.-204    	; 0x90d2 <checkForBeat+0x2f4>
  if ( HR_state->fiar < FIAR_PARAM) {
	if (output_buffer[1] <= output_buffer[0]) {
		 HR_state->fiar++;
	} // detect fiar
	else {
		if (HR_state->fiar >0){
    919e:	66 23       	and	r22, r22
    91a0:	09 f3       	breq	.-62     	; 0x9164 <checkForBeat+0x386>
			 HR_state->fiar = 0;
    91a2:	d4 01       	movw	r26, r8
    91a4:	14 96       	adiw	r26, 0x04	; 4
    91a6:	1c 92       	st	X, r1
		}
	}
  }
  
  //  if detected peak
  if ( HR_state->peak_detect ==1) {
    91a8:	e4 01       	movw	r28, r8
    91aa:	8a 81       	ldd	r24, Y+2	; 0x02
    91ac:	81 30       	cpi	r24, 0x01	; 1
    91ae:	f1 f6       	brne	.-68     	; 0x916c <checkForBeat+0x38e>
	// check whether its a valid beat
	if(( HR_state->valley_detect ==1) && ( HR_state->fiar == FIAR_PARAM) && (( HR_state->peak_max -  HR_state->valley_min) > 75L) && (( HR_state->peak_max -  HR_state->valley_min) < 2500000L)) {
    91b0:	f4 01       	movw	r30, r8
    91b2:	83 81       	ldd	r24, Z+3	; 0x03
    91b4:	81 30       	cpi	r24, 0x01	; 1
    91b6:	09 f4       	brne	.+2      	; 0x91ba <checkForBeat+0x3dc>
    91b8:	74 c0       	rjmp	.+232    	; 0x92a2 <checkForBeat+0x4c4>
    91ba:	80 e0       	ldi	r24, 0x00	; 0
      //Heart beat!!!
      beatDetected = 1;
    }
	//peak was detected, so no matter what, reset everything
	 HR_state->maybe_peak = 0;
    91bc:	d4 01       	movw	r26, r8
    91be:	1c 92       	st	X, r1
	 HR_state->maybe_valley = 0;
    91c0:	11 96       	adiw	r26, 0x01	; 1
    91c2:	1c 92       	st	X, r1
    91c4:	11 97       	sbiw	r26, 0x01	; 1
	 HR_state->peak_detect = 0;
    91c6:	12 96       	adiw	r26, 0x02	; 2
    91c8:	1c 92       	st	X, r1
    91ca:	12 97       	sbiw	r26, 0x02	; 2
	 HR_state->valley_detect = 0;
    91cc:	13 96       	adiw	r26, 0x03	; 3
    91ce:	1c 92       	st	X, r1
    91d0:	13 97       	sbiw	r26, 0x03	; 3
	 HR_state->fiar = 0;
    91d2:	14 96       	adiw	r26, 0x04	; 4
    91d4:	1c 92       	st	X, r1
    91d6:	cb cf       	rjmp	.-106    	; 0x916e <checkForBeat+0x390>
  output_buffer[0] = (z>>8);//the original
  output_buffer[0] *= -1;//the original	
  /*****  Low Pass FIR Filter *********/

  /*****  Actual Algorithm *********/
  if ((output_buffer[2]  == output_buffer[1]) && (output_buffer[1] < output_buffer[0])) {
    91d8:	ea 14       	cp	r14, r10
    91da:	fb 04       	cpc	r15, r11
    91dc:	0c 05       	cpc	r16, r12
    91de:	1d 05       	cpc	r17, r13
    91e0:	1c f5       	brge	.+70     	; 0x9228 <checkForBeat+0x44a>
	if ( HR_state->maybe_valley==1) {
    91e2:	89 81       	ldd	r24, Y+1	; 0x01
    91e4:	81 30       	cpi	r24, 0x01	; 1
    91e6:	09 f4       	brne	.+2      	; 0x91ea <checkForBeat+0x40c>
    91e8:	a6 c0       	rjmp	.+332    	; 0x9336 <checkForBeat+0x558>
		 HR_state->valley_detect = 1;
		 HR_state->valley_min = output_buffer[1];
		 HR_state->maybe_valley = 0;
	}	
	if ( HR_state->maybe_peak==1) {
    91ea:	f4 01       	movw	r30, r8
    91ec:	80 81       	ld	r24, Z
    91ee:	81 30       	cpi	r24, 0x01	; 1
    91f0:	09 f4       	brne	.+2      	; 0x91f4 <checkForBeat+0x416>
    91f2:	9f c0       	rjmp	.+318    	; 0x9332 <checkForBeat+0x554>
		 HR_state->maybe_peak = 0;
	}
  }
  
  //dot-flat-down
  if ((output_buffer[2]  == output_buffer[1]) && (output_buffer[1] > output_buffer[0])) {
    91f4:	d1 01       	movw	r26, r2
    91f6:	18 96       	adiw	r26, 0x08	; 8
    91f8:	ed 90       	ld	r14, X+
    91fa:	fd 90       	ld	r15, X+
    91fc:	0d 91       	ld	r16, X+
    91fe:	1c 91       	ld	r17, X
    9200:	1b 97       	sbiw	r26, 0x0b	; 11
    9202:	d8 01       	movw	r26, r16
    9204:	c7 01       	movw	r24, r14
    9206:	e1 01       	movw	r28, r2
    9208:	2c 81       	ldd	r18, Y+4	; 0x04
    920a:	3d 81       	ldd	r19, Y+5	; 0x05
    920c:	4e 81       	ldd	r20, Y+6	; 0x06
    920e:	5f 81       	ldd	r21, Y+7	; 0x07
    9210:	29 01       	movw	r4, r18
    9212:	3a 01       	movw	r6, r20
    9214:	e2 16       	cp	r14, r18
    9216:	f3 06       	cpc	r15, r19
    9218:	04 07       	cpc	r16, r20
    921a:	15 07       	cpc	r17, r21
    921c:	09 f0       	breq	.+2      	; 0x9220 <checkForBeat+0x442>
    921e:	29 cf       	rjmp	.-430    	; 0x9072 <checkForBeat+0x294>
    9220:	a8 80       	ld	r10, Y
    9222:	b9 80       	ldd	r11, Y+1	; 0x01
    9224:	ca 80       	ldd	r12, Y+2	; 0x02
    9226:	db 80       	ldd	r13, Y+3	; 0x03
    9228:	ae 14       	cp	r10, r14
    922a:	bf 04       	cpc	r11, r15
    922c:	c0 06       	cpc	r12, r16
    922e:	d1 06       	cpc	r13, r17
    9230:	7c f4       	brge	.+30     	; 0x9250 <checkForBeat+0x472>
	if ( HR_state->maybe_valley ==1) {
    9232:	f4 01       	movw	r30, r8
    9234:	81 81       	ldd	r24, Z+1	; 0x01
    9236:	81 30       	cpi	r24, 0x01	; 1
    9238:	09 f4       	brne	.+2      	; 0x923c <checkForBeat+0x45e>
    923a:	72 c0       	rjmp	.+228    	; 0x9320 <checkForBeat+0x542>
		 HR_state->maybe_valley = 0;
	}	
	if (( HR_state->maybe_peak==1)&&(output_buffer[1] >0)) {
    923c:	e4 01       	movw	r28, r8
    923e:	88 81       	ld	r24, Y
    9240:	81 30       	cpi	r24, 0x01	; 1
    9242:	09 f4       	brne	.+2      	; 0x9246 <checkForBeat+0x468>
    9244:	4d c0       	rjmp	.+154    	; 0x92e0 <checkForBeat+0x502>
    9246:	f1 01       	movw	r30, r2
    9248:	e0 84       	ldd	r14, Z+8	; 0x08
    924a:	f1 84       	ldd	r15, Z+9	; 0x09
    924c:	02 85       	ldd	r16, Z+10	; 0x0a
    924e:	13 85       	ldd	r17, Z+11	; 0x0b
    9250:	d8 01       	movw	r26, r16
    9252:	c7 01       	movw	r24, r14
    9254:	29 01       	movw	r4, r18
    9256:	3a 01       	movw	r6, r20
    9258:	0c cf       	rjmp	.-488    	; 0x9072 <checkForBeat+0x294>
	 HR_state->valley_min = output_buffer[1];
  }
  
  //dot-down-flat
  if ((output_buffer[2]  > output_buffer[1]) && (output_buffer[1] == output_buffer[0])) {
	 HR_state->maybe_valley = 1;
    925a:	81 e0       	ldi	r24, 0x01	; 1
    925c:	f4 01       	movw	r30, r8
    925e:	81 83       	std	Z+1, r24	; 0x01
    9260:	6b cf       	rjmp	.-298    	; 0x9138 <checkForBeat+0x35a>
	}
  }
  
  //dot-up-flat
  if ((output_buffer[2] < output_buffer[1]) && (output_buffer[1] == output_buffer[0])) {
	 HR_state->maybe_peak = 1;
    9262:	81 e0       	ldi	r24, 0x01	; 1
    9264:	d4 01       	movw	r26, r8
    9266:	8c 93       	st	X, r24
  }
  
  //dot-up-down
  if ((output_buffer[2]  < output_buffer[1]) && (output_buffer[1] > output_buffer[0]) && (output_buffer[1] >0)) {
    9268:	e0 84       	ldd	r14, Z+8	; 0x08
    926a:	f1 84       	ldd	r15, Z+9	; 0x09
    926c:	02 85       	ldd	r16, Z+10	; 0x0a
    926e:	13 85       	ldd	r17, Z+11	; 0x0b
    9270:	d8 01       	movw	r26, r16
    9272:	c7 01       	movw	r24, r14
    9274:	24 81       	ldd	r18, Z+4	; 0x04
    9276:	35 81       	ldd	r19, Z+5	; 0x05
    9278:	46 81       	ldd	r20, Z+6	; 0x06
    927a:	57 81       	ldd	r21, Z+7	; 0x07
    927c:	29 01       	movw	r4, r18
    927e:	3a 01       	movw	r6, r20
    9280:	e2 16       	cp	r14, r18
    9282:	f3 06       	cpc	r15, r19
    9284:	04 07       	cpc	r16, r20
    9286:	15 07       	cpc	r17, r21
    9288:	0c f0       	brlt	.+2      	; 0x928c <checkForBeat+0x4ae>
    928a:	23 cf       	rjmp	.-442    	; 0x90d2 <checkForBeat+0x2f4>
    928c:	80 81       	ld	r24, Z
    928e:	91 81       	ldd	r25, Z+1	; 0x01
    9290:	a2 81       	ldd	r26, Z+2	; 0x02
    9292:	b3 81       	ldd	r27, Z+3	; 0x03
    9294:	82 17       	cp	r24, r18
    9296:	93 07       	cpc	r25, r19
    9298:	a4 07       	cpc	r26, r20
    929a:	b5 07       	cpc	r27, r21
    929c:	0c f4       	brge	.+2      	; 0x92a0 <checkForBeat+0x4c2>
    929e:	ff ce       	rjmp	.-514    	; 0x909e <checkForBeat+0x2c0>
    92a0:	79 cf       	rjmp	.-270    	; 0x9194 <checkForBeat+0x3b6>
  }
  
  //  if detected peak
  if ( HR_state->peak_detect ==1) {
	// check whether its a valid beat
	if(( HR_state->valley_detect ==1) && ( HR_state->fiar == FIAR_PARAM) && (( HR_state->peak_max -  HR_state->valley_min) > 75L) && (( HR_state->peak_max -  HR_state->valley_min) < 2500000L)) {
    92a2:	84 81       	ldd	r24, Z+4	; 0x04
    92a4:	86 30       	cpi	r24, 0x06	; 6
    92a6:	09 f0       	breq	.+2      	; 0x92aa <checkForBeat+0x4cc>
    92a8:	88 cf       	rjmp	.-240    	; 0x91ba <checkForBeat+0x3dc>
    92aa:	21 85       	ldd	r18, Z+9	; 0x09
    92ac:	32 85       	ldd	r19, Z+10	; 0x0a
    92ae:	43 85       	ldd	r20, Z+11	; 0x0b
    92b0:	54 85       	ldd	r21, Z+12	; 0x0c
    92b2:	85 81       	ldd	r24, Z+5	; 0x05
    92b4:	96 81       	ldd	r25, Z+6	; 0x06
    92b6:	a7 81       	ldd	r26, Z+7	; 0x07
    92b8:	b0 85       	ldd	r27, Z+8	; 0x08
    92ba:	28 1b       	sub	r18, r24
    92bc:	39 0b       	sbc	r19, r25
    92be:	4a 0b       	sbc	r20, r26
    92c0:	5b 0b       	sbc	r21, r27
    92c2:	2c 34       	cpi	r18, 0x4C	; 76
    92c4:	31 05       	cpc	r19, r1
    92c6:	41 05       	cpc	r20, r1
    92c8:	51 05       	cpc	r21, r1
    92ca:	0c f4       	brge	.+2      	; 0x92ce <checkForBeat+0x4f0>
    92cc:	76 cf       	rjmp	.-276    	; 0x91ba <checkForBeat+0x3dc>
    92ce:	80 e0       	ldi	r24, 0x00	; 0
    92d0:	20 5a       	subi	r18, 0xA0	; 160
    92d2:	35 42       	sbci	r19, 0x25	; 37
    92d4:	46 42       	sbci	r20, 0x26	; 38
    92d6:	50 40       	sbci	r21, 0x00	; 0
    92d8:	0c f0       	brlt	.+2      	; 0x92dc <checkForBeat+0x4fe>
    92da:	70 cf       	rjmp	.-288    	; 0x91bc <checkForBeat+0x3de>
    92dc:	81 e0       	ldi	r24, 0x01	; 1
    92de:	6e cf       	rjmp	.-292    	; 0x91bc <checkForBeat+0x3de>
  //dot-flat-down
  if ((output_buffer[2]  == output_buffer[1]) && (output_buffer[1] > output_buffer[0])) {
	if ( HR_state->maybe_valley ==1) {
		 HR_state->maybe_valley = 0;
	}	
	if (( HR_state->maybe_peak==1)&&(output_buffer[1] >0)) {
    92e0:	29 01       	movw	r4, r18
    92e2:	3a 01       	movw	r6, r20
    92e4:	12 16       	cp	r1, r18
    92e6:	13 06       	cpc	r1, r19
    92e8:	14 06       	cpc	r1, r20
    92ea:	15 06       	cpc	r1, r21
    92ec:	7c f5       	brge	.+94     	; 0x934c <checkForBeat+0x56e>
		 HR_state->maybe_peak = 0;
    92ee:	e4 01       	movw	r28, r8
    92f0:	18 82       	st	Y, r1
		 HR_state->peak_detect = 1;
    92f2:	8a 83       	std	Y+2, r24	; 0x02
		 HR_state->peak_max = output_buffer[1];
    92f4:	f1 01       	movw	r30, r2
    92f6:	84 81       	ldd	r24, Z+4	; 0x04
    92f8:	95 81       	ldd	r25, Z+5	; 0x05
    92fa:	a6 81       	ldd	r26, Z+6	; 0x06
    92fc:	b7 81       	ldd	r27, Z+7	; 0x07
    92fe:	89 87       	std	Y+9, r24	; 0x09
    9300:	9a 87       	std	Y+10, r25	; 0x0a
    9302:	ab 87       	std	Y+11, r26	; 0x0b
    9304:	bc 87       	std	Y+12, r27	; 0x0c
    9306:	e0 84       	ldd	r14, Z+8	; 0x08
    9308:	f1 84       	ldd	r15, Z+9	; 0x09
    930a:	02 85       	ldd	r16, Z+10	; 0x0a
    930c:	13 85       	ldd	r17, Z+11	; 0x0b
    930e:	d8 01       	movw	r26, r16
    9310:	c7 01       	movw	r24, r14
    9312:	24 81       	ldd	r18, Z+4	; 0x04
    9314:	35 81       	ldd	r19, Z+5	; 0x05
    9316:	46 81       	ldd	r20, Z+6	; 0x06
    9318:	57 81       	ldd	r21, Z+7	; 0x07
    931a:	29 01       	movw	r4, r18
    931c:	3a 01       	movw	r6, r20
    931e:	a9 ce       	rjmp	.-686    	; 0x9072 <checkForBeat+0x294>
  }
  
  //dot-flat-down
  if ((output_buffer[2]  == output_buffer[1]) && (output_buffer[1] > output_buffer[0])) {
	if ( HR_state->maybe_valley ==1) {
		 HR_state->maybe_valley = 0;
    9320:	11 82       	std	Z+1, r1	; 0x01
    9322:	d1 01       	movw	r26, r2
    9324:	14 96       	adiw	r26, 0x04	; 4
    9326:	2d 91       	ld	r18, X+
    9328:	3d 91       	ld	r19, X+
    932a:	4d 91       	ld	r20, X+
    932c:	5c 91       	ld	r21, X
    932e:	17 97       	sbiw	r26, 0x07	; 7
    9330:	85 cf       	rjmp	.-246    	; 0x923c <checkForBeat+0x45e>
		 HR_state->valley_detect = 1;
		 HR_state->valley_min = output_buffer[1];
		 HR_state->maybe_valley = 0;
	}	
	if ( HR_state->maybe_peak==1) {
		 HR_state->maybe_peak = 0;
    9332:	10 82       	st	Z, r1
    9334:	5f cf       	rjmp	.-322    	; 0x91f4 <checkForBeat+0x416>
  /*****  Low Pass FIR Filter *********/

  /*****  Actual Algorithm *********/
  if ((output_buffer[2]  == output_buffer[1]) && (output_buffer[1] < output_buffer[0])) {
	if ( HR_state->maybe_valley==1) {
		 HR_state->valley_detect = 1;
    9336:	8b 83       	std	Y+3, r24	; 0x03
		 HR_state->valley_min = output_buffer[1];
    9338:	84 81       	ldd	r24, Z+4	; 0x04
    933a:	95 81       	ldd	r25, Z+5	; 0x05
    933c:	a6 81       	ldd	r26, Z+6	; 0x06
    933e:	b7 81       	ldd	r27, Z+7	; 0x07
    9340:	8d 83       	std	Y+5, r24	; 0x05
    9342:	9e 83       	std	Y+6, r25	; 0x06
    9344:	af 83       	std	Y+7, r26	; 0x07
    9346:	b8 87       	std	Y+8, r27	; 0x08
		 HR_state->maybe_valley = 0;
    9348:	19 82       	std	Y+1, r1	; 0x01
    934a:	4f cf       	rjmp	.-354    	; 0x91ea <checkForBeat+0x40c>
  //dot-flat-down
  if ((output_buffer[2]  == output_buffer[1]) && (output_buffer[1] > output_buffer[0])) {
	if ( HR_state->maybe_valley ==1) {
		 HR_state->maybe_valley = 0;
	}	
	if (( HR_state->maybe_peak==1)&&(output_buffer[1] >0)) {
    934c:	d1 01       	movw	r26, r2
    934e:	18 96       	adiw	r26, 0x08	; 8
    9350:	ed 90       	ld	r14, X+
    9352:	fd 90       	ld	r15, X+
    9354:	0d 91       	ld	r16, X+
    9356:	1c 91       	ld	r17, X
    9358:	1b 97       	sbiw	r26, 0x0b	; 11
    935a:	d8 01       	movw	r26, r16
    935c:	c7 01       	movw	r24, r14
    935e:	89 ce       	rjmp	.-750    	; 0x9072 <checkForBeat+0x294>

00009360 <MAX30105_getRevisionID>:
  MAX30105_revisionID = MAX30105_read8(MAX30105_REVISIONID);
}

uint8_t MAX30105_getRevisionID(void) {
  return MAX30105_revisionID;
}
    9360:	80 91 94 0a 	lds	r24, 0x0A94
    9364:	08 95       	ret

00009366 <MAX30105_available>:
// Data Collection
//

//Tell caller how many samples are available
uint8_t MAX30105_available(void)
{
    9366:	80 91 9d 0a 	lds	r24, 0x0A9D
    936a:	90 91 9e 0a 	lds	r25, 0x0A9E
  uint8_t numberOfSamples = sense.head - sense.tail;
  if (numberOfSamples < 0) numberOfSamples += STORAGE_SIZE;

  return (numberOfSamples);
}
    936e:	89 1b       	sub	r24, r25
    9370:	08 95       	ret

00009372 <MAX30105_getFIFORed>:
}
*/

//Report the next Red value in the FIFO
uint32_t MAX30105_getFIFORed(void)
{
    9372:	e0 91 9e 0a 	lds	r30, 0x0A9E
    9376:	f0 e0       	ldi	r31, 0x00	; 0
    9378:	ee 0f       	add	r30, r30
    937a:	ff 1f       	adc	r31, r31
    937c:	ee 0f       	add	r30, r30
    937e:	ff 1f       	adc	r31, r31
    9380:	eb 56       	subi	r30, 0x6B	; 107
    9382:	f5 4f       	sbci	r31, 0xF5	; 245
    9384:	60 81       	ld	r22, Z
    9386:	71 81       	ldd	r23, Z+1	; 0x01
  return (sense.red[sense.tail]);
}
    9388:	82 81       	ldd	r24, Z+2	; 0x02
    938a:	93 81       	ldd	r25, Z+3	; 0x03
    938c:	08 95       	ret

0000938e <MAX30105_getFIFOIR>:

//Report the next IR value in the FIFO
uint32_t MAX30105_getFIFOIR(void)
{
    938e:	e0 91 9e 0a 	lds	r30, 0x0A9E
    9392:	f0 e0       	ldi	r31, 0x00	; 0
    9394:	ee 0f       	add	r30, r30
    9396:	ff 1f       	adc	r31, r31
    9398:	ee 0f       	add	r30, r30
    939a:	ff 1f       	adc	r31, r31
    939c:	e7 56       	subi	r30, 0x67	; 103
    939e:	f5 4f       	sbci	r31, 0xF5	; 245
    93a0:	60 81       	ld	r22, Z
    93a2:	71 81       	ldd	r23, Z+1	; 0x01
  return (sense.IR[sense.tail]);
}
    93a4:	82 81       	ldd	r24, Z+2	; 0x02
    93a6:	93 81       	ldd	r25, Z+3	; 0x03
    93a8:	08 95       	ret

000093aa <MAX30105_nextSample>:
*/

//Advance the tail
void MAX30105_nextSample(void)
{
  if(MAX30105_available()) //Only advance the tail if new data is available
    93aa:	90 91 9d 0a 	lds	r25, 0x0A9D
    93ae:	80 91 9e 0a 	lds	r24, 0x0A9E
    93b2:	98 17       	cp	r25, r24
    93b4:	11 f0       	breq	.+4      	; 0x93ba <MAX30105_nextSample+0x10>
  {
    sense.tail++;
    sense.tail %= STORAGE_SIZE; //Wrap condition
    93b6:	10 92 9e 0a 	sts	0x0A9E, r1
    93ba:	08 95       	ret

000093bc <MAX30105_write8>:
  i2c_stop();                    // issue I2C stop signal
  return tmp;
}


void MAX30105_write8(uint8_t reg, uint8_t value) {
    93bc:	0f 93       	push	r16
    93be:	1f 93       	push	r17
    93c0:	18 2f       	mov	r17, r24
    93c2:	06 2f       	mov	r16, r22
  i2c_start(_MAX30105_W_ADDRESS);// send byte via I2C  (device address + W)
    93c4:	8e ea       	ldi	r24, 0xAE	; 174
    93c6:	0e 94 95 14 	call	0x292a	; 0x292a <i2c_start>
  i2c_write(reg);// send byte (address of the location)
    93ca:	81 2f       	mov	r24, r17
    93cc:	0e 94 ee 14 	call	0x29dc	; 0x29dc <i2c_write>
  i2c_write(value);// send data (data to be written)
    93d0:	80 2f       	mov	r24, r16
    93d2:	0e 94 ee 14 	call	0x29dc	; 0x29dc <i2c_write>
  i2c_stop();// issue I2C stop signal
    93d6:	0e 94 e6 14 	call	0x29cc	; 0x29cc <i2c_stop>
}
    93da:	1f 91       	pop	r17
    93dc:	0f 91       	pop	r16
    93de:	08 95       	ret

000093e0 <MAX30105_setPROXINTTHRESH>:

  return (temp);
}

// Set the PROX_INT_THRESHold
void MAX30105_setPROXINTTHRESH(uint8_t val) {
    93e0:	68 2f       	mov	r22, r24
  MAX30105_write8(MAX30105_PROXINTTHRESH, val);
    93e2:	80 e3       	ldi	r24, 0x30	; 48
    93e4:	0e 94 de 49 	call	0x93bc	; 0x93bc <MAX30105_write8>
}
    93e8:	08 95       	ret

000093ea <MAX30105_clearFIFO>:
}

//Resets all points to start in a known state
//Page 15 recommends clearing FIFO before beginning a read
void MAX30105_clearFIFO(void) {
  MAX30105_write8(MAX30105_FIFOWRITEPTR, 0);
    93ea:	84 e0       	ldi	r24, 0x04	; 4
    93ec:	60 e0       	ldi	r22, 0x00	; 0
    93ee:	0e 94 de 49 	call	0x93bc	; 0x93bc <MAX30105_write8>
  MAX30105_write8(MAX30105_FIFOOVERFLOW, 0);
    93f2:	85 e0       	ldi	r24, 0x05	; 5
    93f4:	60 e0       	ldi	r22, 0x00	; 0
    93f6:	0e 94 de 49 	call	0x93bc	; 0x93bc <MAX30105_write8>
  MAX30105_write8(MAX30105_FIFOREADPTR, 0);
    93fa:	86 e0       	ldi	r24, 0x06	; 6
    93fc:	60 e0       	ldi	r22, 0x00	; 0
    93fe:	0e 94 de 49 	call	0x93bc	; 0x93bc <MAX30105_write8>
}
    9402:	08 95       	ret

00009404 <MAX30105_disableSlots>:
  }
}

//Clears all slot assignments
void MAX30105_disableSlots(void) {
  MAX30105_write8(MAX30105_MULTILEDCONFIG1, 0);
    9404:	81 e1       	ldi	r24, 0x11	; 17
    9406:	60 e0       	ldi	r22, 0x00	; 0
    9408:	0e 94 de 49 	call	0x93bc	; 0x93bc <MAX30105_write8>
  MAX30105_write8(MAX30105_MULTILEDCONFIG2, 0);
    940c:	82 e1       	ldi	r24, 0x12	; 18
    940e:	60 e0       	ldi	r22, 0x00	; 0
    9410:	0e 94 de 49 	call	0x93bc	; 0x93bc <MAX30105_write8>
}
    9414:	08 95       	ret

00009416 <MAX30105_setProximityThreshold>:

void MAX30105_setPulseAmplitudeProximity(uint8_t amplitude) {
  MAX30105_write8(MAX30105_LED_PROX_AMP, amplitude);
}

void MAX30105_setProximityThreshold(uint8_t threshMSB) {
    9416:	68 2f       	mov	r22, r24
  // Set the IR ADC count that will trigger the beginning of particle-sensing mode.
  // The threshMSB signifies only the 8 most significant-bits of the ADC count.
  // See datasheet, page 24.
  MAX30105_write8(MAX30105_PROXINTTHRESH, threshMSB);
    9418:	80 e3       	ldi	r24, 0x30	; 48
    941a:	0e 94 de 49 	call	0x93bc	; 0x93bc <MAX30105_write8>
}
    941e:	08 95       	ret

00009420 <MAX30105_setPulseAmplitudeProximity>:
void MAX30105_setPulseAmplitudeGreen(uint8_t amplitude) {
  MAX30105_write8(MAX30105_LED3_PULSEAMP, amplitude);
}
*/

void MAX30105_setPulseAmplitudeProximity(uint8_t amplitude) {
    9420:	68 2f       	mov	r22, r24
  MAX30105_write8(MAX30105_LED_PROX_AMP, amplitude);
    9422:	80 e1       	ldi	r24, 0x10	; 16
    9424:	0e 94 de 49 	call	0x93bc	; 0x93bc <MAX30105_write8>
}
    9428:	08 95       	ret

0000942a <MAX30105_setPulseAmplitudeIR>:
// See datasheet, page 21
void MAX30105_setPulseAmplitudeRed(uint8_t amplitude) {
  MAX30105_write8(MAX30105_LED1_PULSEAMP, amplitude);
}

void MAX30105_setPulseAmplitudeIR(uint8_t amplitude) {
    942a:	68 2f       	mov	r22, r24
  MAX30105_write8(MAX30105_LED2_PULSEAMP, amplitude);
    942c:	8d e0       	ldi	r24, 0x0D	; 13
    942e:	0e 94 de 49 	call	0x93bc	; 0x93bc <MAX30105_write8>
}
    9432:	08 95       	ret

00009434 <MAX30105_setPulseAmplitudeRed>:
  MAX30105_bitMask(MAX30105_PARTICLECONFIG, MAX30105_PULSEWIDTH_MASK, pulseWidth);
}

// NOTE: Amplitude values: 0x00 = 0mA, 0x7F = 25.4mA, 0xFF = 50mA (typical)
// See datasheet, page 21
void MAX30105_setPulseAmplitudeRed(uint8_t amplitude) {
    9434:	68 2f       	mov	r22, r24
  MAX30105_write8(MAX30105_LED1_PULSEAMP, amplitude);
    9436:	8c e0       	ldi	r24, 0x0C	; 12
    9438:	0e 94 de 49 	call	0x93bc	; 0x93bc <MAX30105_write8>
}
    943c:	08 95       	ret

0000943e <MAX30105_read8>:
}

//
// Low-level I2C Communication
//
uint8_t MAX30105_read8(uint8_t reg) {
    943e:	1f 93       	push	r17
    9440:	18 2f       	mov	r17, r24
  uint8_t tmp = 0;
  i2c_start(_MAX30105_W_ADDRESS);// send byte via I2C  (device address + W)
    9442:	8e ea       	ldi	r24, 0xAE	; 174
    9444:	0e 94 95 14 	call	0x292a	; 0x292a <i2c_start>
  i2c_write(reg);// send byte (address of the location)
    9448:	81 2f       	mov	r24, r17
    944a:	0e 94 ee 14 	call	0x29dc	; 0x29dc <i2c_write>
  i2c_rep_start(_MAX30105_R_ADDRESS);// issue I2C signal repeated start
    944e:	8f ea       	ldi	r24, 0xAF	; 175
    9450:	0e 94 e3 14 	call	0x29c6	; 0x29c6 <i2c_rep_start>
    delay(1);
    if (tries++ > 200) break;
  }
  if (tries == 200) return (0); //Fail
  */
  tmp = i2c_readNak();       // Read the data (NO acknowledge)
    9454:	0e 94 0a 15 	call	0x2a14	; 0x2a14 <i2c_readNak>
    9458:	18 2f       	mov	r17, r24
  i2c_stop();                    // issue I2C stop signal
    945a:	0e 94 e6 14 	call	0x29cc	; 0x29cc <i2c_stop>
  return tmp;
}
    945e:	81 2f       	mov	r24, r17
    9460:	1f 91       	pop	r17
    9462:	08 95       	ret

00009464 <MAX30105_bitMask>:
	}	
}

//Given a register, read it, mask it, and then set the thing
void MAX30105_bitMask(uint8_t reg, uint8_t mask, uint8_t thing)
{
    9464:	ff 92       	push	r15
    9466:	0f 93       	push	r16
    9468:	1f 93       	push	r17
    946a:	18 2f       	mov	r17, r24
    946c:	06 2f       	mov	r16, r22
    946e:	f4 2e       	mov	r15, r20
  // Grab current register context
  uint8_t originalContents = MAX30105_read8(reg);
    9470:	0e 94 1f 4a 	call	0x943e	; 0x943e <MAX30105_read8>

  // Zero-out the portions of the register we're interested in
  originalContents = originalContents & mask;

  // Change contents
  MAX30105_write8(reg, originalContents | thing);
    9474:	08 23       	and	r16, r24
    9476:	f0 2a       	or	r15, r16
    9478:	81 2f       	mov	r24, r17
    947a:	6f 2d       	mov	r22, r15
    947c:	0e 94 de 49 	call	0x93bc	; 0x93bc <MAX30105_write8>
}
    9480:	1f 91       	pop	r17
    9482:	0f 91       	pop	r16
    9484:	ff 90       	pop	r15
    9486:	08 95       	ret

00009488 <MAX30105_setFIFOAlmostFull>:
}

//Set number of samples to trigger the almost full interrupt (Page 18)
//Power on default is 32 samples
//Note it is reverse: 0x00 is 32 samples, 0x0F is 17 samples
void MAX30105_setFIFOAlmostFull(uint8_t numberOfSamples) {
    9488:	48 2f       	mov	r20, r24
  MAX30105_bitMask(MAX30105_FIFOCONFIG, MAX30105_A_FULL_MASK, numberOfSamples);
    948a:	88 e0       	ldi	r24, 0x08	; 8
    948c:	60 ef       	ldi	r22, 0xF0	; 240
    948e:	0e 94 32 4a 	call	0x9464	; 0x9464 <MAX30105_bitMask>
}
    9492:	08 95       	ret

00009494 <MAX30105_disableFIFORollover>:
  MAX30105_bitMask(MAX30105_FIFOCONFIG, MAX30105_ROLLOVER_MASK, MAX30105_ROLLOVER_ENABLE);
}

//Disable roll over if FIFO over flows
void MAX30105_disableFIFORollover(void) {
  MAX30105_bitMask(MAX30105_FIFOCONFIG, MAX30105_ROLLOVER_MASK, MAX30105_ROLLOVER_DISABLE);
    9494:	88 e0       	ldi	r24, 0x08	; 8
    9496:	6f ee       	ldi	r22, 0xEF	; 239
    9498:	40 e0       	ldi	r20, 0x00	; 0
    949a:	0e 94 32 4a 	call	0x9464	; 0x9464 <MAX30105_bitMask>
}
    949e:	08 95       	ret

000094a0 <MAX30105_enableFIFORollover>:
  MAX30105_write8(MAX30105_FIFOREADPTR, 0);
}

//Enable roll over if FIFO over flows
void MAX30105_enableFIFORollover(void) {
  MAX30105_bitMask(MAX30105_FIFOCONFIG, MAX30105_ROLLOVER_MASK, MAX30105_ROLLOVER_ENABLE);
    94a0:	88 e0       	ldi	r24, 0x08	; 8
    94a2:	6f ee       	ldi	r22, 0xEF	; 239
    94a4:	40 e1       	ldi	r20, 0x10	; 16
    94a6:	0e 94 32 4a 	call	0x9464	; 0x9464 <MAX30105_bitMask>
}
    94aa:	08 95       	ret

000094ac <MAX30105_setFIFOAverage>:
//
// FIFO Configuration
//

//Set sample average (Table 3, Page 18)
void MAX30105_setFIFOAverage(uint8_t numberOfSamples) {
    94ac:	48 2f       	mov	r20, r24
  MAX30105_bitMask(MAX30105_FIFOCONFIG, MAX30105_SAMPLEAVG_MASK, numberOfSamples);
    94ae:	88 e0       	ldi	r24, 0x08	; 8
    94b0:	6f e1       	ldi	r22, 0x1F	; 31
    94b2:	0e 94 32 4a 	call	0x9464	; 0x9464 <MAX30105_bitMask>
}
    94b6:	08 95       	ret

000094b8 <MAX30105_enableSlot>:

//Given a slot number assign a thing to it
//Devices are SLOT_RED_LED or SLOT_RED_PILOT (proximity)
//Assigning a SLOT_RED_LED will pulse LED
//Assigning a SLOT_RED_PILOT will ??
void MAX30105_enableSlot(uint8_t slotNumber, uint8_t device) {
    94b8:	46 2f       	mov	r20, r22

//  uint8_t originalContents;

  switch (slotNumber) {
    94ba:	82 30       	cpi	r24, 0x02	; 2
    94bc:	a9 f0       	breq	.+42     	; 0x94e8 <MAX30105_enableSlot+0x30>
    94be:	83 30       	cpi	r24, 0x03	; 3
    94c0:	28 f0       	brcs	.+10     	; 0x94cc <MAX30105_enableSlot+0x14>
    94c2:	83 30       	cpi	r24, 0x03	; 3
    94c4:	c1 f0       	breq	.+48     	; 0x94f6 <MAX30105_enableSlot+0x3e>
    94c6:	84 30       	cpi	r24, 0x04	; 4
    94c8:	41 f0       	breq	.+16     	; 0x94da <MAX30105_enableSlot+0x22>
    94ca:	08 95       	ret
    94cc:	81 30       	cpi	r24, 0x01	; 1
    94ce:	e9 f7       	brne	.-6      	; 0x94ca <MAX30105_enableSlot+0x12>
    case (1):
      MAX30105_bitMask(MAX30105_MULTILEDCONFIG1, MAX30105_SLOT1_MASK, device);
    94d0:	81 e1       	ldi	r24, 0x11	; 17
    94d2:	68 ef       	ldi	r22, 0xF8	; 248
    94d4:	0e 94 32 4a 	call	0x9464	; 0x9464 <MAX30105_bitMask>
    94d8:	08 95       	ret
      break;
    case (3):
      MAX30105_bitMask(MAX30105_MULTILEDCONFIG2, MAX30105_SLOT3_MASK, device);
      break;
    case (4):
      MAX30105_bitMask(MAX30105_MULTILEDCONFIG2, MAX30105_SLOT4_MASK, device << 4);
    94da:	42 95       	swap	r20
    94dc:	40 7f       	andi	r20, 0xF0	; 240
    94de:	82 e1       	ldi	r24, 0x12	; 18
    94e0:	6f e8       	ldi	r22, 0x8F	; 143
    94e2:	0e 94 32 4a 	call	0x9464	; 0x9464 <MAX30105_bitMask>
    94e6:	08 95       	ret
  switch (slotNumber) {
    case (1):
      MAX30105_bitMask(MAX30105_MULTILEDCONFIG1, MAX30105_SLOT1_MASK, device);
      break;
    case (2):
      MAX30105_bitMask(MAX30105_MULTILEDCONFIG1, MAX30105_SLOT2_MASK, device << 4);
    94e8:	42 95       	swap	r20
    94ea:	40 7f       	andi	r20, 0xF0	; 240
    94ec:	81 e1       	ldi	r24, 0x11	; 17
    94ee:	6f e8       	ldi	r22, 0x8F	; 143
    94f0:	0e 94 32 4a 	call	0x9464	; 0x9464 <MAX30105_bitMask>
    94f4:	08 95       	ret
      break;
    case (3):
      MAX30105_bitMask(MAX30105_MULTILEDCONFIG2, MAX30105_SLOT3_MASK, device);
    94f6:	82 e1       	ldi	r24, 0x12	; 18
    94f8:	68 ef       	ldi	r22, 0xF8	; 248
    94fa:	0e 94 32 4a 	call	0x9464	; 0x9464 <MAX30105_bitMask>
    94fe:	08 95       	ret

00009500 <MAX30105_setPulseWidth>:
void MAX30105_setSampleRate(uint8_t sampleRate) {
  // sampleRate: one of MAX30105_SAMPLERATE_50, _100, _200, _400, _800, _1000, _1600, _3200
  MAX30105_bitMask(MAX30105_PARTICLECONFIG, MAX30105_SAMPLERATE_MASK, sampleRate);
}

void MAX30105_setPulseWidth(uint8_t pulseWidth) {
    9500:	48 2f       	mov	r20, r24
  // pulseWidth: one of MAX30105_PULSEWIDTH_69, _188, _215, _411
  MAX30105_bitMask(MAX30105_PARTICLECONFIG, MAX30105_PULSEWIDTH_MASK, pulseWidth);
    9502:	8a e0       	ldi	r24, 0x0A	; 10
    9504:	6c ef       	ldi	r22, 0xFC	; 252
    9506:	0e 94 32 4a 	call	0x9464	; 0x9464 <MAX30105_bitMask>
}
    950a:	08 95       	ret

0000950c <MAX30105_setSampleRate>:
void MAX30105_setADCRange(uint8_t adcRange) {
  // adcRange: one of MAX30105_ADCRANGE_2048, _4096, _8192, _16384
  MAX30105_bitMask(MAX30105_PARTICLECONFIG, MAX30105_ADCRANGE_MASK, adcRange);
}

void MAX30105_setSampleRate(uint8_t sampleRate) {
    950c:	48 2f       	mov	r20, r24
  // sampleRate: one of MAX30105_SAMPLERATE_50, _100, _200, _400, _800, _1000, _1600, _3200
  MAX30105_bitMask(MAX30105_PARTICLECONFIG, MAX30105_SAMPLERATE_MASK, sampleRate);
    950e:	8a e0       	ldi	r24, 0x0A	; 10
    9510:	63 ee       	ldi	r22, 0xE3	; 227
    9512:	0e 94 32 4a 	call	0x9464	; 0x9464 <MAX30105_bitMask>
}
    9516:	08 95       	ret

00009518 <MAX30105_setADCRange>:
  // Set which LEDs are used for sampling -- Red only, RED+IR only, or custom.
  // See datasheet, page 19
  MAX30105_bitMask(MAX30105_MODECONFIG, MAX30105_MODE_MASK, mode);
}

void MAX30105_setADCRange(uint8_t adcRange) {
    9518:	48 2f       	mov	r20, r24
  // adcRange: one of MAX30105_ADCRANGE_2048, _4096, _8192, _16384
  MAX30105_bitMask(MAX30105_PARTICLECONFIG, MAX30105_ADCRANGE_MASK, adcRange);
    951a:	8a e0       	ldi	r24, 0x0A	; 10
    951c:	6f e9       	ldi	r22, 0x9F	; 159
    951e:	0e 94 32 4a 	call	0x9464	; 0x9464 <MAX30105_bitMask>
}
    9522:	08 95       	ret

00009524 <MAX30105_setLEDMode>:
void MAX30105_wakeUp(void) {
  // Pull IC out of low power mode (datasheet pg. 19)
  MAX30105_bitMask(MAX30105_MODECONFIG, MAX30105_SHUTDOWN_MASK, MAX30105_WAKEUP);
}

void MAX30105_setLEDMode(uint8_t mode) {
    9524:	48 2f       	mov	r20, r24
  // Set which LEDs are used for sampling -- Red only, RED+IR only, or custom.
  // See datasheet, page 19
  MAX30105_bitMask(MAX30105_MODECONFIG, MAX30105_MODE_MASK, mode);
    9526:	89 e0       	ldi	r24, 0x09	; 9
    9528:	68 ef       	ldi	r22, 0xF8	; 248
    952a:	0e 94 32 4a 	call	0x9464	; 0x9464 <MAX30105_bitMask>
}
    952e:	08 95       	ret

00009530 <MAX30105_wakeUp>:
  MAX30105_bitMask(MAX30105_MODECONFIG, MAX30105_SHUTDOWN_MASK, MAX30105_SHUTDOWN);
}

void MAX30105_wakeUp(void) {
  // Pull IC out of low power mode (datasheet pg. 19)
  MAX30105_bitMask(MAX30105_MODECONFIG, MAX30105_SHUTDOWN_MASK, MAX30105_WAKEUP);
    9530:	89 e0       	ldi	r24, 0x09	; 9
    9532:	6f e7       	ldi	r22, 0x7F	; 127
    9534:	40 e0       	ldi	r20, 0x00	; 0
    9536:	0e 94 32 4a 	call	0x9464	; 0x9464 <MAX30105_bitMask>
}
    953a:	08 95       	ret

0000953c <MAX30105_shutDown>:

void MAX30105_shutDown(void) {
  // Put IC into low power mode (datasheet pg. 19)
  // During shutdown the IC will continue to respond to I2C commands but will
  // not update with or take new readings (such as temperature)
  MAX30105_bitMask(MAX30105_MODECONFIG, MAX30105_SHUTDOWN_MASK, MAX30105_SHUTDOWN);
    953c:	89 e0       	ldi	r24, 0x09	; 9
    953e:	6f e7       	ldi	r22, 0x7F	; 127
    9540:	40 e8       	ldi	r20, 0x80	; 128
    9542:	0e 94 32 4a 	call	0x9464	; 0x9464 <MAX30105_bitMask>
}
    9546:	08 95       	ret

00009548 <MAX30105_disableDIETEMPRDY>:

void MAX30105_enableDIETEMPRDY(void) {
  MAX30105_bitMask(MAX30105_INTENABLE2, MAX30105_INT_DIE_TEMP_RDY_MASK, MAX30105_INT_DIE_TEMP_RDY_ENABLE);
}
void MAX30105_disableDIETEMPRDY(void) {
  MAX30105_bitMask(MAX30105_INTENABLE2, MAX30105_INT_DIE_TEMP_RDY_MASK, MAX30105_INT_DIE_TEMP_RDY_DISABLE);
    9548:	83 e0       	ldi	r24, 0x03	; 3
    954a:	6d ef       	ldi	r22, 0xFD	; 253
    954c:	40 e0       	ldi	r20, 0x00	; 0
    954e:	0e 94 32 4a 	call	0x9464	; 0x9464 <MAX30105_bitMask>
}
    9552:	08 95       	ret

00009554 <MAX30105_enableDIETEMPRDY>:
void MAX30105_disablePROXINT(void) {
  MAX30105_bitMask(MAX30105_INTENABLE1, MAX30105_INT_PROX_INT_MASK, MAX30105_INT_PROX_INT_DISABLE);
}

void MAX30105_enableDIETEMPRDY(void) {
  MAX30105_bitMask(MAX30105_INTENABLE2, MAX30105_INT_DIE_TEMP_RDY_MASK, MAX30105_INT_DIE_TEMP_RDY_ENABLE);
    9554:	83 e0       	ldi	r24, 0x03	; 3
    9556:	6d ef       	ldi	r22, 0xFD	; 253
    9558:	42 e0       	ldi	r20, 0x02	; 2
    955a:	0e 94 32 4a 	call	0x9464	; 0x9464 <MAX30105_bitMask>
}
    955e:	08 95       	ret

00009560 <MAX30105_disablePROXINT>:

void MAX30105_enablePROXINT(void) {
  MAX30105_bitMask(MAX30105_INTENABLE1, MAX30105_INT_PROX_INT_MASK, MAX30105_INT_PROX_INT_ENABLE);
}
void MAX30105_disablePROXINT(void) {
  MAX30105_bitMask(MAX30105_INTENABLE1, MAX30105_INT_PROX_INT_MASK, MAX30105_INT_PROX_INT_DISABLE);
    9560:	82 e0       	ldi	r24, 0x02	; 2
    9562:	6f ee       	ldi	r22, 0xEF	; 239
    9564:	40 e0       	ldi	r20, 0x00	; 0
    9566:	0e 94 32 4a 	call	0x9464	; 0x9464 <MAX30105_bitMask>
}
    956a:	08 95       	ret

0000956c <MAX30105_enablePROXINT>:
void MAX30105_disableALCOVF(void) {
  MAX30105_bitMask(MAX30105_INTENABLE1, MAX30105_INT_ALC_OVF_MASK, MAX30105_INT_ALC_OVF_DISABLE);
}

void MAX30105_enablePROXINT(void) {
  MAX30105_bitMask(MAX30105_INTENABLE1, MAX30105_INT_PROX_INT_MASK, MAX30105_INT_PROX_INT_ENABLE);
    956c:	82 e0       	ldi	r24, 0x02	; 2
    956e:	6f ee       	ldi	r22, 0xEF	; 239
    9570:	40 e1       	ldi	r20, 0x10	; 16
    9572:	0e 94 32 4a 	call	0x9464	; 0x9464 <MAX30105_bitMask>
}
    9576:	08 95       	ret

00009578 <MAX30105_disableALCOVF>:

void MAX30105_enableALCOVF(void) {
  MAX30105_bitMask(MAX30105_INTENABLE1, MAX30105_INT_ALC_OVF_MASK, MAX30105_INT_ALC_OVF_ENABLE);
}
void MAX30105_disableALCOVF(void) {
  MAX30105_bitMask(MAX30105_INTENABLE1, MAX30105_INT_ALC_OVF_MASK, MAX30105_INT_ALC_OVF_DISABLE);
    9578:	82 e0       	ldi	r24, 0x02	; 2
    957a:	6f ed       	ldi	r22, 0xDF	; 223
    957c:	40 e0       	ldi	r20, 0x00	; 0
    957e:	0e 94 32 4a 	call	0x9464	; 0x9464 <MAX30105_bitMask>
}
    9582:	08 95       	ret

00009584 <MAX30105_enableALCOVF>:
void MAX30105_disableDATARDY(void) {
  MAX30105_bitMask(MAX30105_INTENABLE1, MAX30105_INT_DATA_RDY_MASK, MAX30105_INT_DATA_RDY_DISABLE);
}

void MAX30105_enableALCOVF(void) {
  MAX30105_bitMask(MAX30105_INTENABLE1, MAX30105_INT_ALC_OVF_MASK, MAX30105_INT_ALC_OVF_ENABLE);
    9584:	82 e0       	ldi	r24, 0x02	; 2
    9586:	6f ed       	ldi	r22, 0xDF	; 223
    9588:	40 e2       	ldi	r20, 0x20	; 32
    958a:	0e 94 32 4a 	call	0x9464	; 0x9464 <MAX30105_bitMask>
}
    958e:	08 95       	ret

00009590 <MAX30105_disableDATARDY>:

void MAX30105_enableDATARDY(void) {
  MAX30105_bitMask(MAX30105_INTENABLE1, MAX30105_INT_DATA_RDY_MASK, MAX30105_INT_DATA_RDY_ENABLE);
}
void MAX30105_disableDATARDY(void) {
  MAX30105_bitMask(MAX30105_INTENABLE1, MAX30105_INT_DATA_RDY_MASK, MAX30105_INT_DATA_RDY_DISABLE);
    9590:	82 e0       	ldi	r24, 0x02	; 2
    9592:	6f eb       	ldi	r22, 0xBF	; 191
    9594:	40 e0       	ldi	r20, 0x00	; 0
    9596:	0e 94 32 4a 	call	0x9464	; 0x9464 <MAX30105_bitMask>
}
    959a:	08 95       	ret

0000959c <MAX30105_enableDATARDY>:
void MAX30105_disableAFULL(void) {
  MAX30105_bitMask(MAX30105_INTENABLE1, MAX30105_INT_A_FULL_MASK, MAX30105_INT_A_FULL_DISABLE);
}

void MAX30105_enableDATARDY(void) {
  MAX30105_bitMask(MAX30105_INTENABLE1, MAX30105_INT_DATA_RDY_MASK, MAX30105_INT_DATA_RDY_ENABLE);
    959c:	82 e0       	ldi	r24, 0x02	; 2
    959e:	6f eb       	ldi	r22, 0xBF	; 191
    95a0:	40 e4       	ldi	r20, 0x40	; 64
    95a2:	0e 94 32 4a 	call	0x9464	; 0x9464 <MAX30105_bitMask>
}
    95a6:	08 95       	ret

000095a8 <MAX30105_disableAFULL>:

void MAX30105_enableAFULL(void) {
  MAX30105_bitMask(MAX30105_INTENABLE1, MAX30105_INT_A_FULL_MASK, MAX30105_INT_A_FULL_ENABLE);
}
void MAX30105_disableAFULL(void) {
  MAX30105_bitMask(MAX30105_INTENABLE1, MAX30105_INT_A_FULL_MASK, MAX30105_INT_A_FULL_DISABLE);
    95a8:	82 e0       	ldi	r24, 0x02	; 2
    95aa:	6f e7       	ldi	r22, 0x7F	; 127
    95ac:	40 e0       	ldi	r20, 0x00	; 0
    95ae:	0e 94 32 4a 	call	0x9464	; 0x9464 <MAX30105_bitMask>
}
    95b2:	08 95       	ret

000095b4 <MAX30105_enableAFULL>:
uint8_t MAX30105_getINT2(void) {
  return (MAX30105_read8(MAX30105_INTSTAT2));
}

void MAX30105_enableAFULL(void) {
  MAX30105_bitMask(MAX30105_INTENABLE1, MAX30105_INT_A_FULL_MASK, MAX30105_INT_A_FULL_ENABLE);
    95b4:	82 e0       	ldi	r24, 0x02	; 2
    95b6:	6f e7       	ldi	r22, 0x7F	; 127
    95b8:	40 e8       	ldi	r20, 0x80	; 128
    95ba:	0e 94 32 4a 	call	0x9464	; 0x9464 <MAX30105_bitMask>
}
    95be:	08 95       	ret

000095c0 <MAX30105_readRevisionID>:
uint8_t MAX30105_readPartID(void) {
  return MAX30105_read8(MAX30105_PARTID);
}

void MAX30105_readRevisionID(void) {
  MAX30105_revisionID = MAX30105_read8(MAX30105_REVISIONID);
    95c0:	8e ef       	ldi	r24, 0xFE	; 254
    95c2:	0e 94 1f 4a 	call	0x943e	; 0x943e <MAX30105_read8>
    95c6:	80 93 94 0a 	sts	0x0A94, r24
}
    95ca:	08 95       	ret

000095cc <MAX30105_readPartID>:

//
// Device ID and Revision
//
uint8_t MAX30105_readPartID(void) {
  return MAX30105_read8(MAX30105_PARTID);
    95cc:	8f ef       	ldi	r24, 0xFF	; 255
    95ce:	0e 94 1f 4a 	call	0x943e	; 0x943e <MAX30105_read8>
}
    95d2:	08 95       	ret

000095d4 <MAX30105_init>:

uint8_t MAX30105_init(void) {

  // Step 1: Initial Communciation and Verification
  // Check that a MAX30105 is connected
  if (!MAX30105_readPartID() == MAX_30105_EXPECTEDPARTID) {
    95d4:	0e 94 e6 4a 	call	0x95cc	; 0x95cc <MAX30105_readPartID>
    // This may mean there is a physical connectivity problem (broken wire, unpowered, etc).
    return 0;
  }

  // Populate revision ID
  MAX30105_readRevisionID();
    95d8:	0e 94 e0 4a 	call	0x95c0	; 0x95c0 <MAX30105_readRevisionID>

  return 1;
}
    95dc:	81 e0       	ldi	r24, 0x01	; 1
    95de:	08 95       	ret

000095e0 <MAX30105_getReadPointer>:
  return (MAX30105_read8(MAX30105_FIFOWRITEPTR));
}

//Read the FIFO Read Pointer
uint8_t MAX30105_getReadPointer(void) {
  return (MAX30105_read8(MAX30105_FIFOREADPTR));
    95e0:	86 e0       	ldi	r24, 0x06	; 6
    95e2:	0e 94 1f 4a 	call	0x943e	; 0x943e <MAX30105_read8>
}
    95e6:	08 95       	ret

000095e8 <MAX30105_getWritePointer>:
  MAX30105_bitMask(MAX30105_FIFOCONFIG, MAX30105_A_FULL_MASK, numberOfSamples);
}

//Read the FIFO Write Pointer
uint8_t MAX30105_getWritePointer(void) {
  return (MAX30105_read8(MAX30105_FIFOWRITEPTR));
    95e8:	84 e0       	ldi	r24, 0x04	; 4
    95ea:	0e 94 1f 4a 	call	0x943e	; 0x943e <MAX30105_read8>
}
    95ee:	08 95       	ret

000095f0 <MAX30105_getINT2>:
//Begin Interrupt configuration
uint8_t MAX30105_getINT1(void) {
  return (MAX30105_read8(MAX30105_INTSTAT1));
}
uint8_t MAX30105_getINT2(void) {
  return (MAX30105_read8(MAX30105_INTSTAT2));
    95f0:	81 e0       	ldi	r24, 0x01	; 1
    95f2:	0e 94 1f 4a 	call	0x943e	; 0x943e <MAX30105_read8>
}
    95f6:	08 95       	ret

000095f8 <MAX30105_getINT1>:
// Configuration
//

//Begin Interrupt configuration
uint8_t MAX30105_getINT1(void) {
  return (MAX30105_read8(MAX30105_INTSTAT1));
    95f8:	80 e0       	ldi	r24, 0x00	; 0
    95fa:	0e 94 1f 4a 	call	0x943e	; 0x943e <MAX30105_read8>
}
    95fe:	08 95       	ret

00009600 <MAX30105_check>:
//Polls the sensor for new data
//Call regularly
//If new data is available, it updates the head and tail in the main struct
//Returns number of new samples obtained
uint16_t MAX30105_check(void)
{
    9600:	9f 92       	push	r9
    9602:	af 92       	push	r10
    9604:	bf 92       	push	r11
    9606:	cf 92       	push	r12
    9608:	df 92       	push	r13
    960a:	ef 92       	push	r14
    960c:	ff 92       	push	r15
    960e:	0f 93       	push	r16
    9610:	1f 93       	push	r17
    9612:	df 93       	push	r29
    9614:	cf 93       	push	r28
    9616:	cd b7       	in	r28, 0x3d	; 61
    9618:	de b7       	in	r29, 0x3e	; 62
    961a:	28 97       	sbiw	r28, 0x08	; 8
    961c:	0f b6       	in	r0, 0x3f	; 63
    961e:	f8 94       	cli
    9620:	de bf       	out	0x3e, r29	; 62
    9622:	0f be       	out	0x3f, r0	; 63
    9624:	cd bf       	out	0x3d, r28	; 61
  //Read register FIDO_DATA in (3-byte * number of active LED) chunks
  //Until FIFO_RD_PTR = FIFO_WR_PTR

  uint8_t readPointer = MAX30105_getReadPointer();
    9626:	0e 94 f0 4a 	call	0x95e0	; 0x95e0 <MAX30105_getReadPointer>
    962a:	18 2f       	mov	r17, r24
  uint8_t writePointer = MAX30105_getWritePointer();
    962c:	0e 94 f4 4a 	call	0x95e8	; 0x95e8 <MAX30105_getWritePointer>
  uint8_t temp[sizeof(uint32_t)]; //Array of 4 bytes that we will convert into long
  uint32_t tempLong;
  int numberOfSamples = 0;

  //Do we have new data?
  if (readPointer != writePointer)
    9630:	18 17       	cp	r17, r24
    9632:	09 f4       	brne	.+2      	; 0x9636 <MAX30105_check+0x36>
    9634:	2f c1       	rjmp	.+606    	; 0x9894 <MAX30105_check+0x294>
  {
    //Calculate the number of readings we need to get from sensor
    numberOfSamples = writePointer - readPointer;
    9636:	c8 2e       	mov	r12, r24
    9638:	dd 24       	eor	r13, r13
    963a:	c1 1a       	sub	r12, r17
    963c:	d1 08       	sbc	r13, r1
    if (numberOfSamples < 0) numberOfSamples += 32; //Wrap condition
    963e:	d7 fc       	sbrc	r13, 7
    9640:	2c c1       	rjmp	.+600    	; 0x989a <MAX30105_check+0x29a>

    //We now have the number of readings, now calc bytes to read
    //For this example we are just doing Red and IR (3 bytes each)
    int bytesLeftToRead = numberOfSamples * MAX30105_activeLEDs * 3;
    9642:	80 91 92 0a 	lds	r24, 0x0A92
    9646:	23 e0       	ldi	r18, 0x03	; 3
    9648:	82 9f       	mul	r24, r18
    964a:	c0 01       	movw	r24, r0
    964c:	11 24       	eor	r1, r1
    964e:	8c 9d       	mul	r24, r12
    9650:	70 01       	movw	r14, r0
    9652:	8d 9d       	mul	r24, r13
    9654:	f0 0c       	add	r15, r0
    9656:	9c 9d       	mul	r25, r12
    9658:	f0 0c       	add	r15, r0
    965a:	11 24       	eor	r1, r1

    //Get ready to read a burst of data from the FIFO register
    i2c_start(_MAX30105_W_ADDRESS);
    965c:	8e ea       	ldi	r24, 0xAE	; 174
    965e:	0e 94 95 14 	call	0x292a	; 0x292a <i2c_start>
    i2c_write(MAX30105_FIFODATA);
    9662:	87 e0       	ldi	r24, 0x07	; 7
    9664:	0e 94 ee 14 	call	0x29dc	; 0x29dc <i2c_write>
//    _i2cPort->endTransmission();

    //We may need to read as many as 288 bytes so we read in blocks no larger than I2C_BUFFER_LENGTH
    //I2C_BUFFER_LENGTH changes based on the platform. 64 bytes for SAMD21, 32 bytes for Uno.
    //Wire.requestFrom() is limited to BUFFER_LENGTH which is 32 on the Uno
    while (bytesLeftToRead > 0)
    9668:	1e 14       	cp	r1, r14
    966a:	1f 04       	cpc	r1, r15
    966c:	0c f0       	brlt	.+2      	; 0x9670 <MAX30105_check+0x70>
    966e:	76 c0       	rjmp	.+236    	; 0x975c <MAX30105_check+0x15c>
      {
        //If toGet is 32 this is bad because we read 6 bytes (Red+IR * 3 = 6) at a time
        //32 % 6 = 2 left over. We don't want to request 32 bytes, we want to request 30.
        //32 % 9 (Red+IR+GREEN) = 5 left over. We want to request 27.

        toGet = I2C_BUFFER_LENGTH - (I2C_BUFFER_LENGTH % (MAX30105_activeLEDs * 3)); //Trim toGet to be a multiple of the samples we need to read
    9670:	f3 e0       	ldi	r31, 0x03	; 3
    9672:	9f 2e       	mov	r9, r31
    9674:	e0 e2       	ldi	r30, 0x20	; 32
    9676:	ae 2e       	mov	r10, r30
    9678:	b1 2c       	mov	r11, r1
    //I2C_BUFFER_LENGTH changes based on the platform. 64 bytes for SAMD21, 32 bytes for Uno.
    //Wire.requestFrom() is limited to BUFFER_LENGTH which is 32 on the Uno
    while (bytesLeftToRead > 0)
    {
      int toGet = bytesLeftToRead;
      if (toGet > I2C_BUFFER_LENGTH)
    967a:	91 e2       	ldi	r25, 0x21	; 33
    967c:	e9 16       	cp	r14, r25
    967e:	f1 04       	cpc	r15, r1
    9680:	0c f0       	brlt	.+2      	; 0x9684 <MAX30105_check+0x84>
    9682:	80 c0       	rjmp	.+256    	; 0x9784 <MAX30105_check+0x184>
    9684:	87 01       	movw	r16, r14
    9686:	ee 24       	eor	r14, r14
    9688:	ff 24       	eor	r15, r15
      }

      bytesLeftToRead -= toGet;

      //Request toGet number of bytes from sensor
	  i2c_rep_start(_MAX30105_R_ADDRESS);// issue I2C signal repeated start
    968a:	8f ea       	ldi	r24, 0xAF	; 175
    968c:	0e 94 e3 14 	call	0x29c6	; 0x29c6 <i2c_rep_start>
//      _i2cPort->requestFrom(MAX30105_ADDRESS, toGet);
      
      while (toGet > 1) //use toGet > 1
    9690:	02 30       	cpi	r16, 0x02	; 2
    9692:	11 05       	cpc	r17, r1
    9694:	0c f4       	brge	.+2      	; 0x9698 <MAX30105_check+0x98>
    9696:	8b c0       	rjmp	.+278    	; 0x97ae <MAX30105_check+0x1ae>
      {
        sense.head++; //Advance the head of the storage struct
        sense.head %= STORAGE_SIZE; //Wrap condition
    9698:	10 92 9d 0a 	sts	0x0A9D, r1

        //Burst read three bytes - RED
        temp[3] = 0;
    969c:	1c 82       	std	Y+4, r1	; 0x04
        temp[2] = i2c_readAck();
    969e:	0e 94 00 15 	call	0x2a00	; 0x2a00 <i2c_readAck>
    96a2:	8b 83       	std	Y+3, r24	; 0x03
        temp[1] = i2c_readAck();
    96a4:	0e 94 00 15 	call	0x2a00	; 0x2a00 <i2c_readAck>
    96a8:	8a 83       	std	Y+2, r24	; 0x02
        temp[0] = i2c_readAck();
    96aa:	0e 94 00 15 	call	0x2a00	; 0x2a00 <i2c_readAck>
    96ae:	89 83       	std	Y+1, r24	; 0x01

        //Convert array to long
        memcpy(&tempLong, temp, sizeof(tempLong));
		
		tempLong &= 0x3FFFF; //Zero out all but 18 bits
    96b0:	89 81       	ldd	r24, Y+1	; 0x01
    96b2:	9a 81       	ldd	r25, Y+2	; 0x02
    96b4:	ab 81       	ldd	r26, Y+3	; 0x03
    96b6:	bc 81       	ldd	r27, Y+4	; 0x04
    96b8:	a3 70       	andi	r26, 0x03	; 3
    96ba:	b0 70       	andi	r27, 0x00	; 0
    96bc:	8d 83       	std	Y+5, r24	; 0x05
    96be:	9e 83       	std	Y+6, r25	; 0x06
    96c0:	af 83       	std	Y+7, r26	; 0x07
    96c2:	b8 87       	std	Y+8, r27	; 0x08

        sense.red[sense.head] = tempLong; //Store this reading into the sense array
    96c4:	e0 91 9d 0a 	lds	r30, 0x0A9D
    96c8:	f0 e0       	ldi	r31, 0x00	; 0
    96ca:	ee 0f       	add	r30, r30
    96cc:	ff 1f       	adc	r31, r31
    96ce:	ee 0f       	add	r30, r30
    96d0:	ff 1f       	adc	r31, r31
    96d2:	eb 56       	subi	r30, 0x6B	; 107
    96d4:	f5 4f       	sbci	r31, 0xF5	; 245
    96d6:	80 83       	st	Z, r24
    96d8:	91 83       	std	Z+1, r25	; 0x01
    96da:	a2 83       	std	Z+2, r26	; 0x02
    96dc:	b3 83       	std	Z+3, r27	; 0x03

        if (MAX30105_activeLEDs > 1)
    96de:	40 91 92 0a 	lds	r20, 0x0A92
    96e2:	42 30       	cpi	r20, 0x02	; 2
    96e4:	18 f1       	brcs	.+70     	; 0x972c <MAX30105_check+0x12c>
        {
          //Burst read three more bytes - IR
          temp[3] = 0;
    96e6:	1c 82       	std	Y+4, r1	; 0x04
          temp[2] = i2c_readAck();
    96e8:	0e 94 00 15 	call	0x2a00	; 0x2a00 <i2c_readAck>
    96ec:	8b 83       	std	Y+3, r24	; 0x03
          temp[1] = i2c_readAck();
    96ee:	0e 94 00 15 	call	0x2a00	; 0x2a00 <i2c_readAck>
    96f2:	8a 83       	std	Y+2, r24	; 0x02
          temp[0] = i2c_readAck();
    96f4:	0e 94 00 15 	call	0x2a00	; 0x2a00 <i2c_readAck>
    96f8:	89 83       	std	Y+1, r24	; 0x01

          //Convert array to long
          memcpy(&tempLong, temp, sizeof(tempLong));

		  tempLong &= 0x3FFFF; //Zero out all but 18 bits
    96fa:	89 81       	ldd	r24, Y+1	; 0x01
    96fc:	9a 81       	ldd	r25, Y+2	; 0x02
    96fe:	ab 81       	ldd	r26, Y+3	; 0x03
    9700:	bc 81       	ldd	r27, Y+4	; 0x04
    9702:	a3 70       	andi	r26, 0x03	; 3
    9704:	b0 70       	andi	r27, 0x00	; 0
    9706:	8d 83       	std	Y+5, r24	; 0x05
    9708:	9e 83       	std	Y+6, r25	; 0x06
    970a:	af 83       	std	Y+7, r26	; 0x07
    970c:	b8 87       	std	Y+8, r27	; 0x08
          
		  sense.IR[sense.head] = tempLong;
    970e:	e0 91 9d 0a 	lds	r30, 0x0A9D
    9712:	f0 e0       	ldi	r31, 0x00	; 0
    9714:	ee 0f       	add	r30, r30
    9716:	ff 1f       	adc	r31, r31
    9718:	ee 0f       	add	r30, r30
    971a:	ff 1f       	adc	r31, r31
    971c:	e7 56       	subi	r30, 0x67	; 103
    971e:	f5 4f       	sbci	r31, 0xF5	; 245
    9720:	80 83       	st	Z, r24
    9722:	91 83       	std	Z+1, r25	; 0x01
    9724:	a2 83       	std	Z+2, r26	; 0x02
    9726:	b3 83       	std	Z+3, r27	; 0x03
    9728:	40 91 92 0a 	lds	r20, 0x0A92
		  tempLong &= 0x3FFFF; //Zero out all but 18 bits

          sense.green[sense.head] = tempLong;
        }
		*/
        toGet -= MAX30105_activeLEDs * 3;
    972c:	24 2f       	mov	r18, r20
    972e:	30 e0       	ldi	r19, 0x00	; 0
    9730:	c9 01       	movw	r24, r18
    9732:	88 0f       	add	r24, r24
    9734:	99 1f       	adc	r25, r25
    9736:	82 0f       	add	r24, r18
    9738:	93 1f       	adc	r25, r19
    973a:	08 1b       	sub	r16, r24
    973c:	19 0b       	sbc	r17, r25

      //Request toGet number of bytes from sensor
	  i2c_rep_start(_MAX30105_R_ADDRESS);// issue I2C signal repeated start
//      _i2cPort->requestFrom(MAX30105_ADDRESS, toGet);
      
      while (toGet > 1) //use toGet > 1
    973e:	02 30       	cpi	r16, 0x02	; 2
    9740:	11 05       	cpc	r17, r1
    9742:	0c f0       	brlt	.+2      	; 0x9746 <MAX30105_check+0x146>
    9744:	a9 cf       	rjmp	.-174    	; 0x9698 <MAX30105_check+0x98>
	  
	    
		// now get the last sample!!!!!!
		
	    sense.head++; //Advance the head of the storage struct
        sense.head %= STORAGE_SIZE; //Wrap condition
    9746:	10 92 9d 0a 	sts	0x0A9D, r1

		if (MAX30105_activeLEDs == 1) {
    974a:	41 30       	cpi	r20, 0x01	; 1
    974c:	b1 f1       	breq	.+108    	; 0x97ba <MAX30105_check+0x1ba>
			tempLong &= 0x3FFFF; //Zero out all but 18 bits

			sense.red[sense.head] = tempLong; //Store this reading into the sense array
        }
        
		if (MAX30105_activeLEDs == 2)
    974e:	42 30       	cpi	r20, 0x02	; 2
    9750:	09 f4       	brne	.+2      	; 0x9754 <MAX30105_check+0x154>
    9752:	5b c0       	rjmp	.+182    	; 0x980a <MAX30105_check+0x20a>
//    _i2cPort->endTransmission();

    //We may need to read as many as 288 bytes so we read in blocks no larger than I2C_BUFFER_LENGTH
    //I2C_BUFFER_LENGTH changes based on the platform. 64 bytes for SAMD21, 32 bytes for Uno.
    //Wire.requestFrom() is limited to BUFFER_LENGTH which is 32 on the Uno
    while (bytesLeftToRead > 0)
    9754:	e1 14       	cp	r14, r1
    9756:	f1 04       	cpc	r15, r1
    9758:	09 f0       	breq	.+2      	; 0x975c <MAX30105_check+0x15c>
    975a:	8f cf       	rjmp	.-226    	; 0x967a <MAX30105_check+0x7a>
    975c:	96 01       	movw	r18, r12
	

  } //End readPtr != writePtr

  return (numberOfSamples); //Let the world know how much new data we found
}
    975e:	c9 01       	movw	r24, r18
    9760:	28 96       	adiw	r28, 0x08	; 8
    9762:	0f b6       	in	r0, 0x3f	; 63
    9764:	f8 94       	cli
    9766:	de bf       	out	0x3e, r29	; 62
    9768:	0f be       	out	0x3f, r0	; 63
    976a:	cd bf       	out	0x3d, r28	; 61
    976c:	cf 91       	pop	r28
    976e:	df 91       	pop	r29
    9770:	1f 91       	pop	r17
    9772:	0f 91       	pop	r16
    9774:	ff 90       	pop	r15
    9776:	ef 90       	pop	r14
    9778:	df 90       	pop	r13
    977a:	cf 90       	pop	r12
    977c:	bf 90       	pop	r11
    977e:	af 90       	pop	r10
    9780:	9f 90       	pop	r9
    9782:	08 95       	ret
      {
        //If toGet is 32 this is bad because we read 6 bytes (Red+IR * 3 = 6) at a time
        //32 % 6 = 2 left over. We don't want to request 32 bytes, we want to request 30.
        //32 % 9 (Red+IR+GREEN) = 5 left over. We want to request 27.

        toGet = I2C_BUFFER_LENGTH - (I2C_BUFFER_LENGTH % (MAX30105_activeLEDs * 3)); //Trim toGet to be a multiple of the samples we need to read
    9784:	60 91 92 0a 	lds	r22, 0x0A92
    9788:	69 9d       	mul	r22, r9
    978a:	b0 01       	movw	r22, r0
    978c:	11 24       	eor	r1, r1
    978e:	80 e2       	ldi	r24, 0x20	; 32
    9790:	90 e0       	ldi	r25, 0x00	; 0
    9792:	0e 94 fa 7f 	call	0xfff4	; 0xfff4 <__divmodhi4>
    9796:	85 01       	movw	r16, r10
    9798:	08 1b       	sub	r16, r24
    979a:	19 0b       	sbc	r17, r25
    979c:	e0 1a       	sub	r14, r16
    979e:	f1 0a       	sbc	r15, r17
      }

      bytesLeftToRead -= toGet;

      //Request toGet number of bytes from sensor
	  i2c_rep_start(_MAX30105_R_ADDRESS);// issue I2C signal repeated start
    97a0:	8f ea       	ldi	r24, 0xAF	; 175
    97a2:	0e 94 e3 14 	call	0x29c6	; 0x29c6 <i2c_rep_start>
//      _i2cPort->requestFrom(MAX30105_ADDRESS, toGet);
      
      while (toGet > 1) //use toGet > 1
    97a6:	02 30       	cpi	r16, 0x02	; 2
    97a8:	11 05       	cpc	r17, r1
    97aa:	0c f0       	brlt	.+2      	; 0x97ae <MAX30105_check+0x1ae>
    97ac:	75 cf       	rjmp	.-278    	; 0x9698 <MAX30105_check+0x98>
    97ae:	40 91 92 0a 	lds	r20, 0x0A92
	  
	    
		// now get the last sample!!!!!!
		
	    sense.head++; //Advance the head of the storage struct
        sense.head %= STORAGE_SIZE; //Wrap condition
    97b2:	10 92 9d 0a 	sts	0x0A9D, r1

		if (MAX30105_activeLEDs == 1) {
    97b6:	41 30       	cpi	r20, 0x01	; 1
    97b8:	51 f6       	brne	.-108    	; 0x974e <MAX30105_check+0x14e>
			//Burst read three bytes - RED
			temp[3] = 0;
    97ba:	1c 82       	std	Y+4, r1	; 0x04
			temp[2] = i2c_readAck();
    97bc:	0e 94 00 15 	call	0x2a00	; 0x2a00 <i2c_readAck>
    97c0:	8b 83       	std	Y+3, r24	; 0x03
			temp[1] = i2c_readAck();
    97c2:	0e 94 00 15 	call	0x2a00	; 0x2a00 <i2c_readAck>
    97c6:	8a 83       	std	Y+2, r24	; 0x02
			temp[0] = i2c_readNak();
    97c8:	0e 94 0a 15 	call	0x2a14	; 0x2a14 <i2c_readNak>
    97cc:	89 83       	std	Y+1, r24	; 0x01
			i2c_stop();
    97ce:	0e 94 e6 14 	call	0x29cc	; 0x29cc <i2c_stop>

			//Convert array to long
			memcpy(&tempLong, temp, sizeof(tempLong));
		
			tempLong &= 0x3FFFF; //Zero out all but 18 bits
    97d2:	89 81       	ldd	r24, Y+1	; 0x01
    97d4:	9a 81       	ldd	r25, Y+2	; 0x02
    97d6:	ab 81       	ldd	r26, Y+3	; 0x03
    97d8:	bc 81       	ldd	r27, Y+4	; 0x04
    97da:	a3 70       	andi	r26, 0x03	; 3
    97dc:	b0 70       	andi	r27, 0x00	; 0
    97de:	8d 83       	std	Y+5, r24	; 0x05
    97e0:	9e 83       	std	Y+6, r25	; 0x06
    97e2:	af 83       	std	Y+7, r26	; 0x07
    97e4:	b8 87       	std	Y+8, r27	; 0x08

			sense.red[sense.head] = tempLong; //Store this reading into the sense array
    97e6:	e0 91 9d 0a 	lds	r30, 0x0A9D
    97ea:	f0 e0       	ldi	r31, 0x00	; 0
    97ec:	ee 0f       	add	r30, r30
    97ee:	ff 1f       	adc	r31, r31
    97f0:	ee 0f       	add	r30, r30
    97f2:	ff 1f       	adc	r31, r31
    97f4:	eb 56       	subi	r30, 0x6B	; 107
    97f6:	f5 4f       	sbci	r31, 0xF5	; 245
    97f8:	80 83       	st	Z, r24
    97fa:	91 83       	std	Z+1, r25	; 0x01
    97fc:	a2 83       	std	Z+2, r26	; 0x02
    97fe:	b3 83       	std	Z+3, r27	; 0x03
    9800:	40 91 92 0a 	lds	r20, 0x0A92
        }
        
		if (MAX30105_activeLEDs == 2)
    9804:	42 30       	cpi	r20, 0x02	; 2
    9806:	09 f0       	breq	.+2      	; 0x980a <MAX30105_check+0x20a>
    9808:	a5 cf       	rjmp	.-182    	; 0x9754 <MAX30105_check+0x154>
        {
		  //Burst read three bytes - RED
		  temp[3] = 0;
    980a:	1c 82       	std	Y+4, r1	; 0x04
		  temp[2] = i2c_readAck();
    980c:	0e 94 00 15 	call	0x2a00	; 0x2a00 <i2c_readAck>
    9810:	8b 83       	std	Y+3, r24	; 0x03
		  temp[1] = i2c_readAck();
    9812:	0e 94 00 15 	call	0x2a00	; 0x2a00 <i2c_readAck>
    9816:	8a 83       	std	Y+2, r24	; 0x02
		  temp[0] = i2c_readAck();
    9818:	0e 94 00 15 	call	0x2a00	; 0x2a00 <i2c_readAck>
    981c:	89 83       	std	Y+1, r24	; 0x01

		  //Convert array to long
		  memcpy(&tempLong, temp, sizeof(tempLong));
		
		  tempLong &= 0x3FFFF; //Zero out all but 18 bits
    981e:	89 81       	ldd	r24, Y+1	; 0x01
    9820:	9a 81       	ldd	r25, Y+2	; 0x02
    9822:	ab 81       	ldd	r26, Y+3	; 0x03
    9824:	bc 81       	ldd	r27, Y+4	; 0x04
    9826:	a3 70       	andi	r26, 0x03	; 3
    9828:	b0 70       	andi	r27, 0x00	; 0
    982a:	8d 83       	std	Y+5, r24	; 0x05
    982c:	9e 83       	std	Y+6, r25	; 0x06
    982e:	af 83       	std	Y+7, r26	; 0x07
    9830:	b8 87       	std	Y+8, r27	; 0x08

		  sense.red[sense.head] = tempLong; //Store this reading into the sense array
    9832:	e0 91 9d 0a 	lds	r30, 0x0A9D
    9836:	f0 e0       	ldi	r31, 0x00	; 0
    9838:	ee 0f       	add	r30, r30
    983a:	ff 1f       	adc	r31, r31
    983c:	ee 0f       	add	r30, r30
    983e:	ff 1f       	adc	r31, r31
    9840:	eb 56       	subi	r30, 0x6B	; 107
    9842:	f5 4f       	sbci	r31, 0xF5	; 245
    9844:	80 83       	st	Z, r24
    9846:	91 83       	std	Z+1, r25	; 0x01
    9848:	a2 83       	std	Z+2, r26	; 0x02
    984a:	b3 83       	std	Z+3, r27	; 0x03
	
         //Burst read three more bytes - IR
          temp[3] = 0;
    984c:	1c 82       	std	Y+4, r1	; 0x04
          temp[2] = i2c_readAck();
    984e:	0e 94 00 15 	call	0x2a00	; 0x2a00 <i2c_readAck>
    9852:	8b 83       	std	Y+3, r24	; 0x03
          temp[1] = i2c_readAck();
    9854:	0e 94 00 15 	call	0x2a00	; 0x2a00 <i2c_readAck>
    9858:	8a 83       	std	Y+2, r24	; 0x02
          temp[0] = i2c_readNak();
    985a:	0e 94 0a 15 	call	0x2a14	; 0x2a14 <i2c_readNak>
    985e:	89 83       	std	Y+1, r24	; 0x01
		  i2c_stop();
    9860:	0e 94 e6 14 	call	0x29cc	; 0x29cc <i2c_stop>

          //Convert array to long
          memcpy(&tempLong, temp, sizeof(tempLong));

		  tempLong &= 0x3FFFF; //Zero out all but 18 bits
    9864:	89 81       	ldd	r24, Y+1	; 0x01
    9866:	9a 81       	ldd	r25, Y+2	; 0x02
    9868:	ab 81       	ldd	r26, Y+3	; 0x03
    986a:	bc 81       	ldd	r27, Y+4	; 0x04
    986c:	a3 70       	andi	r26, 0x03	; 3
    986e:	b0 70       	andi	r27, 0x00	; 0
    9870:	8d 83       	std	Y+5, r24	; 0x05
    9872:	9e 83       	std	Y+6, r25	; 0x06
    9874:	af 83       	std	Y+7, r26	; 0x07
    9876:	b8 87       	std	Y+8, r27	; 0x08
          
		  sense.IR[sense.head] = tempLong;
    9878:	e0 91 9d 0a 	lds	r30, 0x0A9D
    987c:	f0 e0       	ldi	r31, 0x00	; 0
    987e:	ee 0f       	add	r30, r30
    9880:	ff 1f       	adc	r31, r31
    9882:	ee 0f       	add	r30, r30
    9884:	ff 1f       	adc	r31, r31
    9886:	e7 56       	subi	r30, 0x67	; 103
    9888:	f5 4f       	sbci	r31, 0xF5	; 245
    988a:	80 83       	st	Z, r24
    988c:	91 83       	std	Z+1, r25	; 0x01
    988e:	a2 83       	std	Z+2, r26	; 0x02
    9890:	b3 83       	std	Z+3, r27	; 0x03
    9892:	60 cf       	rjmp	.-320    	; 0x9754 <MAX30105_check+0x154>
  uint8_t temp[sizeof(uint32_t)]; //Array of 4 bytes that we will convert into long
  uint32_t tempLong;
  int numberOfSamples = 0;

  //Do we have new data?
  if (readPointer != writePointer)
    9894:	20 e0       	ldi	r18, 0x00	; 0
    9896:	30 e0       	ldi	r19, 0x00	; 0
    9898:	62 cf       	rjmp	.-316    	; 0x975e <MAX30105_check+0x15e>
  {
    //Calculate the number of readings we need to get from sensor
    numberOfSamples = writePointer - readPointer;
    if (numberOfSamples < 0) numberOfSamples += 32; //Wrap condition
    989a:	80 e2       	ldi	r24, 0x20	; 32
    989c:	90 e0       	ldi	r25, 0x00	; 0
    989e:	c8 0e       	add	r12, r24
    98a0:	d9 1e       	adc	r13, r25
    98a2:	cf ce       	rjmp	.-610    	; 0x9642 <MAX30105_check+0x42>

000098a4 <MAX30105_safeCheck>:
	if(ST2MS(chVTTimeElapsedSinceX(safeCheck_baseline)) > maxTimeToCheck) return(0);  
	//_delay_ms(1);
	chThdSleepMilliseconds(2);
  }  
  */
	if(MAX30105_check() >= 1) {//We found new data!
    98a4:	0e 94 00 4b 	call	0x9600	; 0x9600 <MAX30105_check>
    98a8:	20 e0       	ldi	r18, 0x00	; 0
    98aa:	89 2b       	or	r24, r25
    98ac:	09 f0       	breq	.+2      	; 0x98b0 <MAX30105_safeCheck+0xc>
    98ae:	21 e0       	ldi	r18, 0x01	; 1
		return(1);
	}
	else {
		return(0);
	}	
}
    98b0:	82 2f       	mov	r24, r18
    98b2:	08 95       	ret

000098b4 <MAX30105_getRedIR>:
    return(0); //Sensor failed to find new data
}

//Report the most recent red value
uint32_t MAX30105_getRedIR(int32_t *data)
{
    98b4:	cf 93       	push	r28
    98b6:	df 93       	push	r29
    98b8:	ec 01       	movw	r28, r24
  //Check the sensor for new data for 250ms
  if(MAX30105_safeCheck(250)) {
    98ba:	8a ef       	ldi	r24, 0xFA	; 250
    98bc:	0e 94 52 4c 	call	0x98a4	; 0x98a4 <MAX30105_safeCheck>
    98c0:	88 23       	and	r24, r24
    98c2:	59 f1       	breq	.+86     	; 0x991a <MAX30105_getRedIR+0x66>
	data[0] = (int32_t) sense.red[sense.head];
    98c4:	e0 91 9d 0a 	lds	r30, 0x0A9D
    98c8:	f0 e0       	ldi	r31, 0x00	; 0
    98ca:	ee 0f       	add	r30, r30
    98cc:	ff 1f       	adc	r31, r31
    98ce:	ee 0f       	add	r30, r30
    98d0:	ff 1f       	adc	r31, r31
    98d2:	eb 56       	subi	r30, 0x6B	; 107
    98d4:	f5 4f       	sbci	r31, 0xF5	; 245
    98d6:	80 81       	ld	r24, Z
    98d8:	91 81       	ldd	r25, Z+1	; 0x01
    98da:	a2 81       	ldd	r26, Z+2	; 0x02
    98dc:	b3 81       	ldd	r27, Z+3	; 0x03
    98de:	88 83       	st	Y, r24
    98e0:	99 83       	std	Y+1, r25	; 0x01
    98e2:	aa 83       	std	Y+2, r26	; 0x02
    98e4:	bb 83       	std	Y+3, r27	; 0x03
	data[1] = (int32_t) sense.IR[sense.head];	
    98e6:	e0 91 9d 0a 	lds	r30, 0x0A9D
    98ea:	f0 e0       	ldi	r31, 0x00	; 0
    98ec:	ee 0f       	add	r30, r30
    98ee:	ff 1f       	adc	r31, r31
    98f0:	ee 0f       	add	r30, r30
    98f2:	ff 1f       	adc	r31, r31
    98f4:	e7 56       	subi	r30, 0x67	; 103
    98f6:	f5 4f       	sbci	r31, 0xF5	; 245
    98f8:	80 81       	ld	r24, Z
    98fa:	91 81       	ldd	r25, Z+1	; 0x01
    98fc:	a2 81       	ldd	r26, Z+2	; 0x02
    98fe:	b3 81       	ldd	r27, Z+3	; 0x03
    9900:	8c 83       	std	Y+4, r24	; 0x04
    9902:	9d 83       	std	Y+5, r25	; 0x05
    9904:	ae 83       	std	Y+6, r26	; 0x06
    9906:	bf 83       	std	Y+7, r27	; 0x07
    9908:	21 e0       	ldi	r18, 0x01	; 1
    990a:	30 e0       	ldi	r19, 0x00	; 0
    990c:	40 e0       	ldi	r20, 0x00	; 0
    990e:	50 e0       	ldi	r21, 0x00	; 0
	return(1UL); //Sensor failed to find new data
  }		
  else {
    return(0UL); //Sensor failed to find new data
  }
}
    9910:	b9 01       	movw	r22, r18
    9912:	ca 01       	movw	r24, r20
    9914:	df 91       	pop	r29
    9916:	cf 91       	pop	r28
    9918:	08 95       	ret

//Report the most recent red value
uint32_t MAX30105_getRedIR(int32_t *data)
{
  //Check the sensor for new data for 250ms
  if(MAX30105_safeCheck(250)) {
    991a:	20 e0       	ldi	r18, 0x00	; 0
    991c:	30 e0       	ldi	r19, 0x00	; 0
    991e:	40 e0       	ldi	r20, 0x00	; 0
    9920:	50 e0       	ldi	r21, 0x00	; 0
	return(1UL); //Sensor failed to find new data
  }		
  else {
    return(0UL); //Sensor failed to find new data
  }
}
    9922:	b9 01       	movw	r22, r18
    9924:	ca 01       	movw	r24, r20
    9926:	df 91       	pop	r29
    9928:	cf 91       	pop	r28
    992a:	08 95       	ret

0000992c <MAX30105_getIR>:

//Report the most recent IR value
uint32_t MAX30105_getIR(void)
{
  //Check the sensor for new data for 250ms
  if(MAX30105_safeCheck(250))
    992c:	8a ef       	ldi	r24, 0xFA	; 250
    992e:	0e 94 52 4c 	call	0x98a4	; 0x98a4 <MAX30105_safeCheck>
    9932:	88 23       	and	r24, r24
    9934:	81 f0       	breq	.+32     	; 0x9956 <MAX30105_getIR+0x2a>
    return (sense.IR[sense.head]);
    9936:	e0 91 9d 0a 	lds	r30, 0x0A9D
    993a:	f0 e0       	ldi	r31, 0x00	; 0
    993c:	ee 0f       	add	r30, r30
    993e:	ff 1f       	adc	r31, r31
    9940:	ee 0f       	add	r30, r30
    9942:	ff 1f       	adc	r31, r31
    9944:	e7 56       	subi	r30, 0x67	; 103
    9946:	f5 4f       	sbci	r31, 0xF5	; 245
    9948:	20 81       	ld	r18, Z
    994a:	31 81       	ldd	r19, Z+1	; 0x01
    994c:	42 81       	ldd	r20, Z+2	; 0x02
    994e:	53 81       	ldd	r21, Z+3	; 0x03
  else
    return(0); //Sensor failed to find new data
}
    9950:	b9 01       	movw	r22, r18
    9952:	ca 01       	movw	r24, r20
    9954:	08 95       	ret

//Report the most recent IR value
uint32_t MAX30105_getIR(void)
{
  //Check the sensor for new data for 250ms
  if(MAX30105_safeCheck(250))
    9956:	20 e0       	ldi	r18, 0x00	; 0
    9958:	30 e0       	ldi	r19, 0x00	; 0
    995a:	40 e0       	ldi	r20, 0x00	; 0
    995c:	50 e0       	ldi	r21, 0x00	; 0
    return (sense.IR[sense.head]);
  else
    return(0); //Sensor failed to find new data
}
    995e:	b9 01       	movw	r22, r18
    9960:	ca 01       	movw	r24, r20
    9962:	08 95       	ret

00009964 <MAX30105_getRed>:

//Report the most recent red value
uint32_t MAX30105_getRed(void)
{
  //Check the sensor for new data for 250ms
  if(MAX30105_safeCheck(250))
    9964:	8a ef       	ldi	r24, 0xFA	; 250
    9966:	0e 94 52 4c 	call	0x98a4	; 0x98a4 <MAX30105_safeCheck>
    996a:	88 23       	and	r24, r24
    996c:	81 f0       	breq	.+32     	; 0x998e <MAX30105_getRed+0x2a>
    return (sense.red[sense.head]);
    996e:	e0 91 9d 0a 	lds	r30, 0x0A9D
    9972:	f0 e0       	ldi	r31, 0x00	; 0
    9974:	ee 0f       	add	r30, r30
    9976:	ff 1f       	adc	r31, r31
    9978:	ee 0f       	add	r30, r30
    997a:	ff 1f       	adc	r31, r31
    997c:	eb 56       	subi	r30, 0x6B	; 107
    997e:	f5 4f       	sbci	r31, 0xF5	; 245
    9980:	20 81       	ld	r18, Z
    9982:	31 81       	ldd	r19, Z+1	; 0x01
    9984:	42 81       	ldd	r20, Z+2	; 0x02
    9986:	53 81       	ldd	r21, Z+3	; 0x03
  else
    return(0); //Sensor failed to find new data
}
    9988:	b9 01       	movw	r22, r18
    998a:	ca 01       	movw	r24, r20
    998c:	08 95       	ret

//Report the most recent red value
uint32_t MAX30105_getRed(void)
{
  //Check the sensor for new data for 250ms
  if(MAX30105_safeCheck(250))
    998e:	20 e0       	ldi	r18, 0x00	; 0
    9990:	30 e0       	ldi	r19, 0x00	; 0
    9992:	40 e0       	ldi	r20, 0x00	; 0
    9994:	50 e0       	ldi	r21, 0x00	; 0
    return (sense.red[sense.head]);
  else
    return(0); //Sensor failed to find new data
}
    9996:	b9 01       	movw	r22, r18
    9998:	ca 01       	movw	r24, r20
    999a:	08 95       	ret

0000999c <MAX30105_readTemperature>:
}


// Die Temperature
// Returns temp in C
float MAX30105_readTemperature() {
    999c:	af 92       	push	r10
    999e:	bf 92       	push	r11
    99a0:	cf 92       	push	r12
    99a2:	df 92       	push	r13
    99a4:	ef 92       	push	r14
    99a6:	ff 92       	push	r15
    99a8:	0f 93       	push	r16
    99aa:	1f 93       	push	r17
  int8_t tempInt = 0;
  uint8_t tempFrac = 0;
  systime_t temperature_baseline;
  
  // Step 1: Config die temperature register to take 1 temperature sample
  MAX30105_write8(MAX30105_DIETEMPCONFIG, 0x01);
    99ac:	81 e2       	ldi	r24, 0x21	; 33
    99ae:	61 e0       	ldi	r22, 0x01	; 1
    99b0:	0e 94 de 49 	call	0x93bc	; 0x93bc <MAX30105_write8>
  }
  //TODO How do we want to fail? With what type of error?
  //? if(millis() - startTime >= 100) return(-999.0);

  // Step 2: Read die temperature register (integer)
  tempInt = MAX30105_read8(MAX30105_DIETEMPINT);
    99b4:	8f e1       	ldi	r24, 0x1F	; 31
    99b6:	0e 94 1f 4a 	call	0x943e	; 0x943e <MAX30105_read8>
    99ba:	e8 2e       	mov	r14, r24
  tempFrac = MAX30105_read8(MAX30105_DIETEMPFRAC);
    99bc:	80 e2       	ldi	r24, 0x20	; 32
    99be:	0e 94 1f 4a 	call	0x943e	; 0x943e <MAX30105_read8>
    99c2:	a8 2e       	mov	r10, r24
    99c4:	ff 24       	eor	r15, r15
    99c6:	e7 fc       	sbrc	r14, 7
    99c8:	f0 94       	com	r15
    99ca:	0f 2d       	mov	r16, r15
    99cc:	1f 2d       	mov	r17, r15
    99ce:	c8 01       	movw	r24, r16
    99d0:	b7 01       	movw	r22, r14
    99d2:	0e 94 e4 7d 	call	0xfbc8	; 0xfbc8 <__floatsisf>
    99d6:	7b 01       	movw	r14, r22
    99d8:	8c 01       	movw	r16, r24
    99da:	bb 24       	eor	r11, r11
    99dc:	cc 24       	eor	r12, r12
    99de:	dd 24       	eor	r13, r13
    99e0:	c6 01       	movw	r24, r12
    99e2:	b5 01       	movw	r22, r10
    99e4:	0e 94 e2 7d 	call	0xfbc4	; 0xfbc4 <__floatunsisf>
    99e8:	20 e0       	ldi	r18, 0x00	; 0
    99ea:	30 e0       	ldi	r19, 0x00	; 0
    99ec:	40 e8       	ldi	r20, 0x80	; 128
    99ee:	5d e3       	ldi	r21, 0x3D	; 61
    99f0:	0e 94 fe 7e 	call	0xfdfc	; 0xfdfc <__mulsf3>
    99f4:	9b 01       	movw	r18, r22
    99f6:	ac 01       	movw	r20, r24
    99f8:	c8 01       	movw	r24, r16
    99fa:	b7 01       	movw	r22, r14
    99fc:	0e 94 84 7c 	call	0xf908	; 0xf908 <__addsf3>

  // Step 3: Calculate temperature (datasheet pg. 23)
 return (float)tempInt + ((float)tempFrac * 0.0625);
 
}
    9a00:	1f 91       	pop	r17
    9a02:	0f 91       	pop	r16
    9a04:	ff 90       	pop	r15
    9a06:	ef 90       	pop	r14
    9a08:	df 90       	pop	r13
    9a0a:	cf 90       	pop	r12
    9a0c:	bf 90       	pop	r11
    9a0e:	af 90       	pop	r10
    9a10:	08 95       	ret

00009a12 <MAX30105_readTemperatureF>:

// Returns die temp in F
float MAX30105_readTemperatureF() {
    9a12:	ef 92       	push	r14
    9a14:	ff 92       	push	r15
    9a16:	0f 93       	push	r16
    9a18:	1f 93       	push	r17
  float temp = MAX30105_readTemperature();
    9a1a:	0e 94 ce 4c 	call	0x999c	; 0x999c <MAX30105_readTemperature>
    9a1e:	7b 01       	movw	r14, r22
    9a20:	8c 01       	movw	r16, r24

  if (temp != -999.0) temp = temp * 1.8 + 32.0;
    9a22:	20 e0       	ldi	r18, 0x00	; 0
    9a24:	30 ec       	ldi	r19, 0xC0	; 192
    9a26:	49 e7       	ldi	r20, 0x79	; 121
    9a28:	54 ec       	ldi	r21, 0xC4	; 196
    9a2a:	0e 94 4a 7d 	call	0xfa94	; 0xfa94 <__cmpsf2>
    9a2e:	88 23       	and	r24, r24
    9a30:	81 f0       	breq	.+32     	; 0x9a52 <MAX30105_readTemperatureF+0x40>
    9a32:	c8 01       	movw	r24, r16
    9a34:	b7 01       	movw	r22, r14
    9a36:	26 e6       	ldi	r18, 0x66	; 102
    9a38:	36 e6       	ldi	r19, 0x66	; 102
    9a3a:	46 ee       	ldi	r20, 0xE6	; 230
    9a3c:	5f e3       	ldi	r21, 0x3F	; 63
    9a3e:	0e 94 fe 7e 	call	0xfdfc	; 0xfdfc <__mulsf3>
    9a42:	20 e0       	ldi	r18, 0x00	; 0
    9a44:	30 e0       	ldi	r19, 0x00	; 0
    9a46:	40 e0       	ldi	r20, 0x00	; 0
    9a48:	52 e4       	ldi	r21, 0x42	; 66
    9a4a:	0e 94 84 7c 	call	0xf908	; 0xf908 <__addsf3>
    9a4e:	7b 01       	movw	r14, r22
    9a50:	8c 01       	movw	r16, r24

  return (temp);
}
    9a52:	b7 01       	movw	r22, r14
    9a54:	c8 01       	movw	r24, r16
    9a56:	1f 91       	pop	r17
    9a58:	0f 91       	pop	r16
    9a5a:	ff 90       	pop	r15
    9a5c:	ef 90       	pop	r14
    9a5e:	08 95       	ret

00009a60 <MAX30105_softReset>:
//End Interrupt configuration

void MAX30105_softReset(void) {
  systime_t softReset_baseline;

  MAX30105_bitMask(MAX30105_MODECONFIG, MAX30105_RESET_MASK, MAX30105_RESET);  
    9a60:	89 e0       	ldi	r24, 0x09	; 9
    9a62:	6f eb       	ldi	r22, 0xBF	; 191
    9a64:	40 e4       	ldi	r20, 0x40	; 64
    9a66:	0e 94 32 4a 	call	0x9464	; 0x9464 <MAX30105_bitMask>
    if ((response & MAX30105_RESET) == 0) break; //We're done!
    //_delay_ms(1); //Let's not over burden the I2C bus
	chThdSleepMilliseconds(1);
  }
  
}
    9a6a:	08 95       	ret

00009a6c <MAX30105_setup>:
// Sample Average = 4
// Mode = MultiLED
// ADC Range = 16384 (62.5pA per LSB)
// Sample rate = 50
//Use the default setup if you are just getting started with the MAX30105 sensor
void MAX30105_setup(uint8_t powerLevel, uint8_t sampleAverage, uint8_t ledMode, int sampleRate, int pulseWidth, int adcRange) {
    9a6c:	af 92       	push	r10
    9a6e:	bf 92       	push	r11
    9a70:	cf 92       	push	r12
    9a72:	df 92       	push	r13
    9a74:	ef 92       	push	r14
    9a76:	ff 92       	push	r15
    9a78:	0f 93       	push	r16
    9a7a:	1f 93       	push	r17
    9a7c:	df 93       	push	r29
    9a7e:	cf 93       	push	r28
    9a80:	0f 92       	push	r0
    9a82:	cd b7       	in	r28, 0x3d	; 61
    9a84:	de b7       	in	r29, 0x3e	; 62
    9a86:	d8 2e       	mov	r13, r24
    9a88:	c4 2e       	mov	r12, r20
    9a8a:	59 01       	movw	r10, r18
  MAX30105_softReset(); //Reset all configuration, threshold, and data registers to POR values
    9a8c:	69 83       	std	Y+1, r22	; 0x01
    9a8e:	0e 94 30 4d 	call	0x9a60	; 0x9a60 <MAX30105_softReset>

  //FIFO Configuration
  //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  //The chip will average multiple samples of same type together if you wish
  if (sampleAverage == 1) MAX30105_setFIFOAverage(MAX30105_SAMPLEAVG_1); //No averaging per FIFO record
    9a92:	89 81       	ldd	r24, Y+1	; 0x01
    9a94:	81 30       	cpi	r24, 0x01	; 1
    9a96:	09 f4       	brne	.+2      	; 0x9a9a <MAX30105_setup+0x2e>
    9a98:	b3 c0       	rjmp	.+358    	; 0x9c00 <MAX30105_setup+0x194>
  else if (sampleAverage == 2) MAX30105_setFIFOAverage(MAX30105_SAMPLEAVG_2);
    9a9a:	82 30       	cpi	r24, 0x02	; 2
    9a9c:	09 f4       	brne	.+2      	; 0x9aa0 <MAX30105_setup+0x34>
    9a9e:	c0 c0       	rjmp	.+384    	; 0x9c20 <MAX30105_setup+0x1b4>
  else if (sampleAverage == 4) MAX30105_setFIFOAverage(MAX30105_SAMPLEAVG_4);
    9aa0:	84 30       	cpi	r24, 0x04	; 4
    9aa2:	49 f0       	breq	.+18     	; 0x9ab6 <MAX30105_setup+0x4a>
  else if (sampleAverage == 8) MAX30105_setFIFOAverage(MAX30105_SAMPLEAVG_8);
    9aa4:	88 30       	cpi	r24, 0x08	; 8
    9aa6:	09 f4       	brne	.+2      	; 0x9aaa <MAX30105_setup+0x3e>
    9aa8:	a3 c0       	rjmp	.+326    	; 0x9bf0 <MAX30105_setup+0x184>
  else if (sampleAverage == 16) MAX30105_setFIFOAverage(MAX30105_SAMPLEAVG_16);
    9aaa:	80 31       	cpi	r24, 0x10	; 16
    9aac:	09 f4       	brne	.+2      	; 0x9ab0 <MAX30105_setup+0x44>
    9aae:	cc c0       	rjmp	.+408    	; 0x9c48 <MAX30105_setup+0x1dc>
  else if (sampleAverage == 32) MAX30105_setFIFOAverage(MAX30105_SAMPLEAVG_32);
    9ab0:	80 32       	cpi	r24, 0x20	; 32
    9ab2:	09 f4       	brne	.+2      	; 0x9ab6 <MAX30105_setup+0x4a>
    9ab4:	b9 c0       	rjmp	.+370    	; 0x9c28 <MAX30105_setup+0x1bc>
  else MAX30105_setFIFOAverage(MAX30105_SAMPLEAVG_4);
    9ab6:	80 e4       	ldi	r24, 0x40	; 64
    9ab8:	0e 94 56 4a 	call	0x94ac	; 0x94ac <MAX30105_setFIFOAverage>

  //setFIFOAlmostFull(2); //Set to 30 samples to trigger an 'Almost Full' interrupt
  MAX30105_enableFIFORollover(); //Allow FIFO to wrap/roll over
    9abc:	0e 94 50 4a 	call	0x94a0	; 0x94a0 <MAX30105_enableFIFORollover>
  //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

  //Mode Configuration
  //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  //if (ledMode == 3) MAX30105_setLEDMode(MAX30105_MODE_MULTILED); //Watch all three LED channels
  if (ledMode == 2) MAX30105_setLEDMode(MAX30105_MODE_REDIRONLY); //Red and IR ... SPO2 MODE*
    9ac0:	82 e0       	ldi	r24, 0x02	; 2
    9ac2:	c8 16       	cp	r12, r24
    9ac4:	09 f4       	brne	.+2      	; 0x9ac8 <MAX30105_setup+0x5c>
    9ac6:	84 c0       	rjmp	.+264    	; 0x9bd0 <MAX30105_setup+0x164>
  else MAX30105_setLEDMode(MAX30105_MODE_REDONLY); //Red only
    9ac8:	82 e0       	ldi	r24, 0x02	; 2
    9aca:	0e 94 92 4a 	call	0x9524	; 0x9524 <MAX30105_setLEDMode>
  MAX30105_activeLEDs = ledMode; //Used to control how many bytes to read from FIFO buffer
    9ace:	c0 92 92 0a 	sts	0x0A92, r12
  //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

  //Particle Sensing Configuration
  //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  if(adcRange < 4096) MAX30105_setADCRange(MAX30105_ADCRANGE_2048); //7.81pA per LSB
    9ad2:	e0 e0       	ldi	r30, 0x00	; 0
    9ad4:	ee 16       	cp	r14, r30
    9ad6:	e0 e1       	ldi	r30, 0x10	; 16
    9ad8:	fe 06       	cpc	r15, r30
    9ada:	94 f0       	brlt	.+36     	; 0x9b00 <MAX30105_setup+0x94>
  else if(adcRange < 8192) MAX30105_setADCRange(MAX30105_ADCRANGE_4096); //15.63pA per LSB
    9adc:	f0 e0       	ldi	r31, 0x00	; 0
    9ade:	ef 16       	cp	r14, r31
    9ae0:	f0 e2       	ldi	r31, 0x20	; 32
    9ae2:	ff 06       	cpc	r15, r31
    9ae4:	0c f4       	brge	.+2      	; 0x9ae8 <MAX30105_setup+0x7c>
    9ae6:	78 c0       	rjmp	.+240    	; 0x9bd8 <MAX30105_setup+0x16c>
  else if(adcRange < 16384) MAX30105_setADCRange(MAX30105_ADCRANGE_8192); //31.25pA per LSB
    9ae8:	80 e0       	ldi	r24, 0x00	; 0
    9aea:	e8 16       	cp	r14, r24
    9aec:	80 e4       	ldi	r24, 0x40	; 64
    9aee:	f8 06       	cpc	r15, r24
    9af0:	0c f4       	brge	.+2      	; 0x9af4 <MAX30105_setup+0x88>
    9af2:	92 c0       	rjmp	.+292    	; 0x9c18 <MAX30105_setup+0x1ac>
  else if(adcRange == 16384) MAX30105_setADCRange(MAX30105_ADCRANGE_16384); //62.5pA per LSB
    9af4:	e0 e0       	ldi	r30, 0x00	; 0
    9af6:	ee 16       	cp	r14, r30
    9af8:	e0 e4       	ldi	r30, 0x40	; 64
    9afa:	fe 06       	cpc	r15, r30
    9afc:	09 f4       	brne	.+2      	; 0x9b00 <MAX30105_setup+0x94>
    9afe:	98 c0       	rjmp	.+304    	; 0x9c30 <MAX30105_setup+0x1c4>
  else MAX30105_setADCRange(MAX30105_ADCRANGE_2048);
    9b00:	80 e0       	ldi	r24, 0x00	; 0
    9b02:	0e 94 8c 4a 	call	0x9518	; 0x9518 <MAX30105_setADCRange>

  if (sampleRate < 100) MAX30105_setSampleRate(MAX30105_SAMPLERATE_50); //Take 50 samples per second
    9b06:	f4 e6       	ldi	r31, 0x64	; 100
    9b08:	af 16       	cp	r10, r31
    9b0a:	b1 04       	cpc	r11, r1
    9b0c:	4c f1       	brlt	.+82     	; 0x9b60 <MAX30105_setup+0xf4>
  else if (sampleRate < 200) MAX30105_setSampleRate(MAX30105_SAMPLERATE_100);
    9b0e:	88 ec       	ldi	r24, 0xC8	; 200
    9b10:	a8 16       	cp	r10, r24
    9b12:	b1 04       	cpc	r11, r1
    9b14:	0c f4       	brge	.+2      	; 0x9b18 <MAX30105_setup+0xac>
    9b16:	64 c0       	rjmp	.+200    	; 0x9be0 <MAX30105_setup+0x174>
  else if (sampleRate < 400) MAX30105_setSampleRate(MAX30105_SAMPLERATE_200);
    9b18:	e0 e9       	ldi	r30, 0x90	; 144
    9b1a:	ae 16       	cp	r10, r30
    9b1c:	e1 e0       	ldi	r30, 0x01	; 1
    9b1e:	be 06       	cpc	r11, r30
    9b20:	0c f4       	brge	.+2      	; 0x9b24 <MAX30105_setup+0xb8>
    9b22:	76 c0       	rjmp	.+236    	; 0x9c10 <MAX30105_setup+0x1a4>
  else if (sampleRate < 800) MAX30105_setSampleRate(MAX30105_SAMPLERATE_400);
    9b24:	f0 e2       	ldi	r31, 0x20	; 32
    9b26:	af 16       	cp	r10, r31
    9b28:	f3 e0       	ldi	r31, 0x03	; 3
    9b2a:	bf 06       	cpc	r11, r31
    9b2c:	0c f4       	brge	.+2      	; 0x9b30 <MAX30105_setup+0xc4>
    9b2e:	88 c0       	rjmp	.+272    	; 0x9c40 <MAX30105_setup+0x1d4>
  else if (sampleRate < 1000) MAX30105_setSampleRate(MAX30105_SAMPLERATE_800);
    9b30:	88 ee       	ldi	r24, 0xE8	; 232
    9b32:	a8 16       	cp	r10, r24
    9b34:	83 e0       	ldi	r24, 0x03	; 3
    9b36:	b8 06       	cpc	r11, r24
    9b38:	0c f4       	brge	.+2      	; 0x9b3c <MAX30105_setup+0xd0>
    9b3a:	5e c0       	rjmp	.+188    	; 0x9bf8 <MAX30105_setup+0x18c>
  else if (sampleRate < 1600) MAX30105_setSampleRate(MAX30105_SAMPLERATE_1000);
    9b3c:	e0 e4       	ldi	r30, 0x40	; 64
    9b3e:	ae 16       	cp	r10, r30
    9b40:	e6 e0       	ldi	r30, 0x06	; 6
    9b42:	be 06       	cpc	r11, r30
    9b44:	0c f4       	brge	.+2      	; 0x9b48 <MAX30105_setup+0xdc>
    9b46:	88 c0       	rjmp	.+272    	; 0x9c58 <MAX30105_setup+0x1ec>
  else if (sampleRate < 3200) MAX30105_setSampleRate(MAX30105_SAMPLERATE_1600);
    9b48:	f0 e8       	ldi	r31, 0x80	; 128
    9b4a:	af 16       	cp	r10, r31
    9b4c:	fc e0       	ldi	r31, 0x0C	; 12
    9b4e:	bf 06       	cpc	r11, r31
    9b50:	0c f4       	brge	.+2      	; 0x9b54 <MAX30105_setup+0xe8>
    9b52:	86 c0       	rjmp	.+268    	; 0x9c60 <MAX30105_setup+0x1f4>
  else if (sampleRate == 3200) MAX30105_setSampleRate(MAX30105_SAMPLERATE_3200);
    9b54:	80 e8       	ldi	r24, 0x80	; 128
    9b56:	a8 16       	cp	r10, r24
    9b58:	8c e0       	ldi	r24, 0x0C	; 12
    9b5a:	b8 06       	cpc	r11, r24
    9b5c:	09 f4       	brne	.+2      	; 0x9b60 <MAX30105_setup+0xf4>
    9b5e:	78 c0       	rjmp	.+240    	; 0x9c50 <MAX30105_setup+0x1e4>
  else MAX30105_setSampleRate(MAX30105_SAMPLERATE_50);
    9b60:	80 e0       	ldi	r24, 0x00	; 0
    9b62:	0e 94 86 4a 	call	0x950c	; 0x950c <MAX30105_setSampleRate>

  //The longer the pulse width the longer range of detection you'll have
  //At 69us and 0.4mA it's about 2 inches
  //At 411us and 0.4mA it's about 6 inches
  if (pulseWidth < 118) MAX30105_setPulseWidth(MAX30105_PULSEWIDTH_69); //Page 26, Gets us 15 bit resolution
    9b66:	06 37       	cpi	r16, 0x76	; 118
    9b68:	11 05       	cpc	r17, r1
    9b6a:	64 f0       	brlt	.+24     	; 0x9b84 <MAX30105_setup+0x118>
  else if (pulseWidth < 215) MAX30105_setPulseWidth(MAX30105_PULSEWIDTH_118); //16 bit resolution
    9b6c:	07 3d       	cpi	r16, 0xD7	; 215
    9b6e:	11 05       	cpc	r17, r1
    9b70:	dc f1       	brlt	.+118    	; 0x9be8 <MAX30105_setup+0x17c>
  else if (pulseWidth < 411) MAX30105_setPulseWidth(MAX30105_PULSEWIDTH_215); //17 bit resolution
    9b72:	e1 e0       	ldi	r30, 0x01	; 1
    9b74:	0b 39       	cpi	r16, 0x9B	; 155
    9b76:	1e 07       	cpc	r17, r30
    9b78:	0c f4       	brge	.+2      	; 0x9b7c <MAX30105_setup+0x110>
    9b7a:	46 c0       	rjmp	.+140    	; 0x9c08 <MAX30105_setup+0x19c>
  else if (pulseWidth == 411) MAX30105_setPulseWidth(MAX30105_PULSEWIDTH_411); //18 bit resolution
    9b7c:	0b 59       	subi	r16, 0x9B	; 155
    9b7e:	11 40       	sbci	r17, 0x01	; 1
    9b80:	09 f4       	brne	.+2      	; 0x9b84 <MAX30105_setup+0x118>
    9b82:	5a c0       	rjmp	.+180    	; 0x9c38 <MAX30105_setup+0x1cc>
  else MAX30105_setPulseWidth(MAX30105_PULSEWIDTH_69);
    9b84:	80 e0       	ldi	r24, 0x00	; 0
    9b86:	0e 94 80 4a 	call	0x9500	; 0x9500 <MAX30105_setPulseWidth>
  //powerLevel = 0x02, 0.4mA - Presence detection of ~4 inch
  //powerLevel = 0x1F, 6.4mA - Presence detection of ~8 inch
  //powerLevel = 0x7F, 25.4mA - Presence detection of ~8 inch
  //powerLevel = 0xFF, 50.0mA - Presence detection of ~12 inch

  MAX30105_setPulseAmplitudeRed(powerLevel-0x08);
    9b8a:	8d 2d       	mov	r24, r13
    9b8c:	88 50       	subi	r24, 0x08	; 8
    9b8e:	0e 94 1a 4a 	call	0x9434	; 0x9434 <MAX30105_setPulseAmplitudeRed>
  MAX30105_setPulseAmplitudeIR(powerLevel);
    9b92:	8d 2d       	mov	r24, r13
    9b94:	0e 94 15 4a 	call	0x942a	; 0x942a <MAX30105_setPulseAmplitudeIR>
//  MAX30105_setPulseAmplitudeGreen(powerLevel);
  MAX30105_setPulseAmplitudeProximity(powerLevel);
    9b98:	8d 2d       	mov	r24, r13
    9b9a:	0e 94 10 4a 	call	0x9420	; 0x9420 <MAX30105_setPulseAmplitudeProximity>
  //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

  //Multi-LED Mode Configuration, Enable the reading of the three LEDs
  //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  MAX30105_enableSlot(1, SLOT_RED_LED);
    9b9e:	81 e0       	ldi	r24, 0x01	; 1
    9ba0:	61 e0       	ldi	r22, 0x01	; 1
    9ba2:	0e 94 5c 4a 	call	0x94b8	; 0x94b8 <MAX30105_enableSlot>
  if (ledMode > 1) MAX30105_enableSlot(2, SLOT_IR_LED);
    9ba6:	81 e0       	ldi	r24, 0x01	; 1
    9ba8:	8c 15       	cp	r24, r12
    9baa:	20 f4       	brcc	.+8      	; 0x9bb4 <MAX30105_setup+0x148>
    9bac:	82 e0       	ldi	r24, 0x02	; 2
    9bae:	62 e0       	ldi	r22, 0x02	; 2
    9bb0:	0e 94 5c 4a 	call	0x94b8	; 0x94b8 <MAX30105_enableSlot>
  //if (ledMode > 2) MAX30105_enableSlot(3, SLOT_GREEN_LED);
  //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  

  MAX30105_clearFIFO(); //Reset the FIFO before we begin checking the sensor
    9bb4:	0e 94 f5 49 	call	0x93ea	; 0x93ea <MAX30105_clearFIFO>
}
    9bb8:	0f 90       	pop	r0
    9bba:	cf 91       	pop	r28
    9bbc:	df 91       	pop	r29
    9bbe:	1f 91       	pop	r17
    9bc0:	0f 91       	pop	r16
    9bc2:	ff 90       	pop	r15
    9bc4:	ef 90       	pop	r14
    9bc6:	df 90       	pop	r13
    9bc8:	cf 90       	pop	r12
    9bca:	bf 90       	pop	r11
    9bcc:	af 90       	pop	r10
    9bce:	08 95       	ret
  //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

  //Mode Configuration
  //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  //if (ledMode == 3) MAX30105_setLEDMode(MAX30105_MODE_MULTILED); //Watch all three LED channels
  if (ledMode == 2) MAX30105_setLEDMode(MAX30105_MODE_REDIRONLY); //Red and IR ... SPO2 MODE*
    9bd0:	83 e0       	ldi	r24, 0x03	; 3
    9bd2:	0e 94 92 4a 	call	0x9524	; 0x9524 <MAX30105_setLEDMode>
    9bd6:	7b cf       	rjmp	.-266    	; 0x9ace <MAX30105_setup+0x62>
  //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

  //Particle Sensing Configuration
  //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  if(adcRange < 4096) MAX30105_setADCRange(MAX30105_ADCRANGE_2048); //7.81pA per LSB
  else if(adcRange < 8192) MAX30105_setADCRange(MAX30105_ADCRANGE_4096); //15.63pA per LSB
    9bd8:	80 e2       	ldi	r24, 0x20	; 32
    9bda:	0e 94 8c 4a 	call	0x9518	; 0x9518 <MAX30105_setADCRange>
    9bde:	93 cf       	rjmp	.-218    	; 0x9b06 <MAX30105_setup+0x9a>
  else if(adcRange < 16384) MAX30105_setADCRange(MAX30105_ADCRANGE_8192); //31.25pA per LSB
  else if(adcRange == 16384) MAX30105_setADCRange(MAX30105_ADCRANGE_16384); //62.5pA per LSB
  else MAX30105_setADCRange(MAX30105_ADCRANGE_2048);

  if (sampleRate < 100) MAX30105_setSampleRate(MAX30105_SAMPLERATE_50); //Take 50 samples per second
  else if (sampleRate < 200) MAX30105_setSampleRate(MAX30105_SAMPLERATE_100);
    9be0:	84 e0       	ldi	r24, 0x04	; 4
    9be2:	0e 94 86 4a 	call	0x950c	; 0x950c <MAX30105_setSampleRate>
    9be6:	bf cf       	rjmp	.-130    	; 0x9b66 <MAX30105_setup+0xfa>

  //The longer the pulse width the longer range of detection you'll have
  //At 69us and 0.4mA it's about 2 inches
  //At 411us and 0.4mA it's about 6 inches
  if (pulseWidth < 118) MAX30105_setPulseWidth(MAX30105_PULSEWIDTH_69); //Page 26, Gets us 15 bit resolution
  else if (pulseWidth < 215) MAX30105_setPulseWidth(MAX30105_PULSEWIDTH_118); //16 bit resolution
    9be8:	81 e0       	ldi	r24, 0x01	; 1
    9bea:	0e 94 80 4a 	call	0x9500	; 0x9500 <MAX30105_setPulseWidth>
    9bee:	cd cf       	rjmp	.-102    	; 0x9b8a <MAX30105_setup+0x11e>
  //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  //The chip will average multiple samples of same type together if you wish
  if (sampleAverage == 1) MAX30105_setFIFOAverage(MAX30105_SAMPLEAVG_1); //No averaging per FIFO record
  else if (sampleAverage == 2) MAX30105_setFIFOAverage(MAX30105_SAMPLEAVG_2);
  else if (sampleAverage == 4) MAX30105_setFIFOAverage(MAX30105_SAMPLEAVG_4);
  else if (sampleAverage == 8) MAX30105_setFIFOAverage(MAX30105_SAMPLEAVG_8);
    9bf0:	80 e6       	ldi	r24, 0x60	; 96
    9bf2:	0e 94 56 4a 	call	0x94ac	; 0x94ac <MAX30105_setFIFOAverage>
    9bf6:	62 cf       	rjmp	.-316    	; 0x9abc <MAX30105_setup+0x50>

  if (sampleRate < 100) MAX30105_setSampleRate(MAX30105_SAMPLERATE_50); //Take 50 samples per second
  else if (sampleRate < 200) MAX30105_setSampleRate(MAX30105_SAMPLERATE_100);
  else if (sampleRate < 400) MAX30105_setSampleRate(MAX30105_SAMPLERATE_200);
  else if (sampleRate < 800) MAX30105_setSampleRate(MAX30105_SAMPLERATE_400);
  else if (sampleRate < 1000) MAX30105_setSampleRate(MAX30105_SAMPLERATE_800);
    9bf8:	80 e1       	ldi	r24, 0x10	; 16
    9bfa:	0e 94 86 4a 	call	0x950c	; 0x950c <MAX30105_setSampleRate>
    9bfe:	b3 cf       	rjmp	.-154    	; 0x9b66 <MAX30105_setup+0xfa>
  MAX30105_softReset(); //Reset all configuration, threshold, and data registers to POR values

  //FIFO Configuration
  //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  //The chip will average multiple samples of same type together if you wish
  if (sampleAverage == 1) MAX30105_setFIFOAverage(MAX30105_SAMPLEAVG_1); //No averaging per FIFO record
    9c00:	80 e0       	ldi	r24, 0x00	; 0
    9c02:	0e 94 56 4a 	call	0x94ac	; 0x94ac <MAX30105_setFIFOAverage>
    9c06:	5a cf       	rjmp	.-332    	; 0x9abc <MAX30105_setup+0x50>
  //The longer the pulse width the longer range of detection you'll have
  //At 69us and 0.4mA it's about 2 inches
  //At 411us and 0.4mA it's about 6 inches
  if (pulseWidth < 118) MAX30105_setPulseWidth(MAX30105_PULSEWIDTH_69); //Page 26, Gets us 15 bit resolution
  else if (pulseWidth < 215) MAX30105_setPulseWidth(MAX30105_PULSEWIDTH_118); //16 bit resolution
  else if (pulseWidth < 411) MAX30105_setPulseWidth(MAX30105_PULSEWIDTH_215); //17 bit resolution
    9c08:	82 e0       	ldi	r24, 0x02	; 2
    9c0a:	0e 94 80 4a 	call	0x9500	; 0x9500 <MAX30105_setPulseWidth>
    9c0e:	bd cf       	rjmp	.-134    	; 0x9b8a <MAX30105_setup+0x11e>
  else if(adcRange == 16384) MAX30105_setADCRange(MAX30105_ADCRANGE_16384); //62.5pA per LSB
  else MAX30105_setADCRange(MAX30105_ADCRANGE_2048);

  if (sampleRate < 100) MAX30105_setSampleRate(MAX30105_SAMPLERATE_50); //Take 50 samples per second
  else if (sampleRate < 200) MAX30105_setSampleRate(MAX30105_SAMPLERATE_100);
  else if (sampleRate < 400) MAX30105_setSampleRate(MAX30105_SAMPLERATE_200);
    9c10:	88 e0       	ldi	r24, 0x08	; 8
    9c12:	0e 94 86 4a 	call	0x950c	; 0x950c <MAX30105_setSampleRate>
    9c16:	a7 cf       	rjmp	.-178    	; 0x9b66 <MAX30105_setup+0xfa>

  //Particle Sensing Configuration
  //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  if(adcRange < 4096) MAX30105_setADCRange(MAX30105_ADCRANGE_2048); //7.81pA per LSB
  else if(adcRange < 8192) MAX30105_setADCRange(MAX30105_ADCRANGE_4096); //15.63pA per LSB
  else if(adcRange < 16384) MAX30105_setADCRange(MAX30105_ADCRANGE_8192); //31.25pA per LSB
    9c18:	80 e4       	ldi	r24, 0x40	; 64
    9c1a:	0e 94 8c 4a 	call	0x9518	; 0x9518 <MAX30105_setADCRange>
    9c1e:	73 cf       	rjmp	.-282    	; 0x9b06 <MAX30105_setup+0x9a>

  //FIFO Configuration
  //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  //The chip will average multiple samples of same type together if you wish
  if (sampleAverage == 1) MAX30105_setFIFOAverage(MAX30105_SAMPLEAVG_1); //No averaging per FIFO record
  else if (sampleAverage == 2) MAX30105_setFIFOAverage(MAX30105_SAMPLEAVG_2);
    9c20:	80 e2       	ldi	r24, 0x20	; 32
    9c22:	0e 94 56 4a 	call	0x94ac	; 0x94ac <MAX30105_setFIFOAverage>
    9c26:	4a cf       	rjmp	.-364    	; 0x9abc <MAX30105_setup+0x50>
  else if (sampleAverage == 4) MAX30105_setFIFOAverage(MAX30105_SAMPLEAVG_4);
  else if (sampleAverage == 8) MAX30105_setFIFOAverage(MAX30105_SAMPLEAVG_8);
  else if (sampleAverage == 16) MAX30105_setFIFOAverage(MAX30105_SAMPLEAVG_16);
  else if (sampleAverage == 32) MAX30105_setFIFOAverage(MAX30105_SAMPLEAVG_32);
    9c28:	80 ea       	ldi	r24, 0xA0	; 160
    9c2a:	0e 94 56 4a 	call	0x94ac	; 0x94ac <MAX30105_setFIFOAverage>
    9c2e:	46 cf       	rjmp	.-372    	; 0x9abc <MAX30105_setup+0x50>
  //Particle Sensing Configuration
  //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  if(adcRange < 4096) MAX30105_setADCRange(MAX30105_ADCRANGE_2048); //7.81pA per LSB
  else if(adcRange < 8192) MAX30105_setADCRange(MAX30105_ADCRANGE_4096); //15.63pA per LSB
  else if(adcRange < 16384) MAX30105_setADCRange(MAX30105_ADCRANGE_8192); //31.25pA per LSB
  else if(adcRange == 16384) MAX30105_setADCRange(MAX30105_ADCRANGE_16384); //62.5pA per LSB
    9c30:	80 e6       	ldi	r24, 0x60	; 96
    9c32:	0e 94 8c 4a 	call	0x9518	; 0x9518 <MAX30105_setADCRange>
    9c36:	67 cf       	rjmp	.-306    	; 0x9b06 <MAX30105_setup+0x9a>
  //At 69us and 0.4mA it's about 2 inches
  //At 411us and 0.4mA it's about 6 inches
  if (pulseWidth < 118) MAX30105_setPulseWidth(MAX30105_PULSEWIDTH_69); //Page 26, Gets us 15 bit resolution
  else if (pulseWidth < 215) MAX30105_setPulseWidth(MAX30105_PULSEWIDTH_118); //16 bit resolution
  else if (pulseWidth < 411) MAX30105_setPulseWidth(MAX30105_PULSEWIDTH_215); //17 bit resolution
  else if (pulseWidth == 411) MAX30105_setPulseWidth(MAX30105_PULSEWIDTH_411); //18 bit resolution
    9c38:	83 e0       	ldi	r24, 0x03	; 3
    9c3a:	0e 94 80 4a 	call	0x9500	; 0x9500 <MAX30105_setPulseWidth>
    9c3e:	a5 cf       	rjmp	.-182    	; 0x9b8a <MAX30105_setup+0x11e>
  else MAX30105_setADCRange(MAX30105_ADCRANGE_2048);

  if (sampleRate < 100) MAX30105_setSampleRate(MAX30105_SAMPLERATE_50); //Take 50 samples per second
  else if (sampleRate < 200) MAX30105_setSampleRate(MAX30105_SAMPLERATE_100);
  else if (sampleRate < 400) MAX30105_setSampleRate(MAX30105_SAMPLERATE_200);
  else if (sampleRate < 800) MAX30105_setSampleRate(MAX30105_SAMPLERATE_400);
    9c40:	8c e0       	ldi	r24, 0x0C	; 12
    9c42:	0e 94 86 4a 	call	0x950c	; 0x950c <MAX30105_setSampleRate>
    9c46:	8f cf       	rjmp	.-226    	; 0x9b66 <MAX30105_setup+0xfa>
  //The chip will average multiple samples of same type together if you wish
  if (sampleAverage == 1) MAX30105_setFIFOAverage(MAX30105_SAMPLEAVG_1); //No averaging per FIFO record
  else if (sampleAverage == 2) MAX30105_setFIFOAverage(MAX30105_SAMPLEAVG_2);
  else if (sampleAverage == 4) MAX30105_setFIFOAverage(MAX30105_SAMPLEAVG_4);
  else if (sampleAverage == 8) MAX30105_setFIFOAverage(MAX30105_SAMPLEAVG_8);
  else if (sampleAverage == 16) MAX30105_setFIFOAverage(MAX30105_SAMPLEAVG_16);
    9c48:	80 e8       	ldi	r24, 0x80	; 128
    9c4a:	0e 94 56 4a 	call	0x94ac	; 0x94ac <MAX30105_setFIFOAverage>
    9c4e:	36 cf       	rjmp	.-404    	; 0x9abc <MAX30105_setup+0x50>
  else if (sampleRate < 400) MAX30105_setSampleRate(MAX30105_SAMPLERATE_200);
  else if (sampleRate < 800) MAX30105_setSampleRate(MAX30105_SAMPLERATE_400);
  else if (sampleRate < 1000) MAX30105_setSampleRate(MAX30105_SAMPLERATE_800);
  else if (sampleRate < 1600) MAX30105_setSampleRate(MAX30105_SAMPLERATE_1000);
  else if (sampleRate < 3200) MAX30105_setSampleRate(MAX30105_SAMPLERATE_1600);
  else if (sampleRate == 3200) MAX30105_setSampleRate(MAX30105_SAMPLERATE_3200);
    9c50:	8c e1       	ldi	r24, 0x1C	; 28
    9c52:	0e 94 86 4a 	call	0x950c	; 0x950c <MAX30105_setSampleRate>
    9c56:	87 cf       	rjmp	.-242    	; 0x9b66 <MAX30105_setup+0xfa>
  if (sampleRate < 100) MAX30105_setSampleRate(MAX30105_SAMPLERATE_50); //Take 50 samples per second
  else if (sampleRate < 200) MAX30105_setSampleRate(MAX30105_SAMPLERATE_100);
  else if (sampleRate < 400) MAX30105_setSampleRate(MAX30105_SAMPLERATE_200);
  else if (sampleRate < 800) MAX30105_setSampleRate(MAX30105_SAMPLERATE_400);
  else if (sampleRate < 1000) MAX30105_setSampleRate(MAX30105_SAMPLERATE_800);
  else if (sampleRate < 1600) MAX30105_setSampleRate(MAX30105_SAMPLERATE_1000);
    9c58:	84 e1       	ldi	r24, 0x14	; 20
    9c5a:	0e 94 86 4a 	call	0x950c	; 0x950c <MAX30105_setSampleRate>
    9c5e:	83 cf       	rjmp	.-250    	; 0x9b66 <MAX30105_setup+0xfa>
  else if (sampleRate < 3200) MAX30105_setSampleRate(MAX30105_SAMPLERATE_1600);
    9c60:	88 e1       	ldi	r24, 0x18	; 24
    9c62:	0e 94 86 4a 	call	0x950c	; 0x950c <MAX30105_setSampleRate>
    9c66:	7f cf       	rjmp	.-258    	; 0x9b66 <MAX30105_setup+0xfa>

00009c68 <fillSize>:

//------------------------------------------------------------------------------
#ifndef __DOXYGEN__
static __attribute__((noinline))
#endif  // __DOXYGEN__
size_t fillSize(uint8_t* bgn, uint8_t* end) {
    9c68:	dc 01       	movw	r26, r24
  uint8_t* p = bgn;
  while (p < end && *p == 0X55) p++;
    9c6a:	86 17       	cp	r24, r22
    9c6c:	97 07       	cpc	r25, r23
    9c6e:	88 f4       	brcc	.+34     	; 0x9c92 <fillSize+0x2a>
    9c70:	8c 91       	ld	r24, X
    9c72:	85 35       	cpi	r24, 0x55	; 85
    9c74:	71 f4       	brne	.+28     	; 0x9c92 <fillSize+0x2a>
    9c76:	fd 01       	movw	r30, r26
    9c78:	03 c0       	rjmp	.+6      	; 0x9c80 <fillSize+0x18>
    9c7a:	80 81       	ld	r24, Z
    9c7c:	85 35       	cpi	r24, 0x55	; 85
    9c7e:	21 f4       	brne	.+8      	; 0x9c88 <fillSize+0x20>
    9c80:	31 96       	adiw	r30, 0x01	; 1
    9c82:	e6 17       	cp	r30, r22
    9c84:	f7 07       	cpc	r31, r23
    9c86:	c8 f3       	brcs	.-14     	; 0x9c7a <fillSize+0x12>
    9c88:	9f 01       	movw	r18, r30
    9c8a:	2a 1b       	sub	r18, r26
    9c8c:	3b 0b       	sbc	r19, r27
  return p - bgn;
}
    9c8e:	c9 01       	movw	r24, r18
    9c90:	08 95       	ret
#ifndef __DOXYGEN__
static __attribute__((noinline))
#endif  // __DOXYGEN__
size_t fillSize(uint8_t* bgn, uint8_t* end) {
  uint8_t* p = bgn;
  while (p < end && *p == 0X55) p++;
    9c92:	20 e0       	ldi	r18, 0x00	; 0
    9c94:	30 e0       	ldi	r19, 0x00	; 0
    9c96:	fb cf       	rjmp	.-10     	; 0x9c8e <fillSize+0x26>

00009c98 <get_fattime>:
			| ((DWORD)rtc.hour << 11)
			| ((DWORD)rtc.min << 5)
			| ((DWORD)rtc.sec >> 1);
	*/
	return 0;
}
    9c98:	60 e0       	ldi	r22, 0x00	; 0
    9c9a:	70 e0       	ldi	r23, 0x00	; 0
    9c9c:	80 e0       	ldi	r24, 0x00	; 0
    9c9e:	90 e0       	ldi	r25, 0x00	; 0
    9ca0:	08 95       	ret

00009ca2 <parse_time>:


/*********************************************************************************
time parser
********************************************************************************/ 
void parse_time(double time_in_min, uint8_t *hours, uint8_t *mins, uint8_t *secs) {
    9ca2:	6f 92       	push	r6
    9ca4:	7f 92       	push	r7
    9ca6:	8f 92       	push	r8
    9ca8:	9f 92       	push	r9
    9caa:	af 92       	push	r10
    9cac:	bf 92       	push	r11
    9cae:	cf 92       	push	r12
    9cb0:	df 92       	push	r13
    9cb2:	ef 92       	push	r14
    9cb4:	ff 92       	push	r15
    9cb6:	0f 93       	push	r16
    9cb8:	1f 93       	push	r17
    9cba:	6b 01       	movw	r12, r22
    9cbc:	7c 01       	movw	r14, r24
    9cbe:	5a 01       	movw	r10, r20
    9cc0:	49 01       	movw	r8, r18
    9cc2:	38 01       	movw	r6, r16
	double temp_min;
	double temp_secs;
	*hours = (uint8_t) (time_in_min/60);
    9cc4:	20 e0       	ldi	r18, 0x00	; 0
    9cc6:	30 e0       	ldi	r19, 0x00	; 0
    9cc8:	40 e7       	ldi	r20, 0x70	; 112
    9cca:	52 e4       	ldi	r21, 0x42	; 66
    9ccc:	0e 94 4e 7d 	call	0xfa9c	; 0xfa9c <__divsf3>
    9cd0:	0e 94 b6 7d 	call	0xfb6c	; 0xfb6c <__fixunssfsi>
    9cd4:	f5 01       	movw	r30, r10
    9cd6:	60 83       	st	Z, r22
	temp_min = time_in_min - (double) 60.0 * (*hours);
    9cd8:	70 e0       	ldi	r23, 0x00	; 0
    9cda:	88 27       	eor	r24, r24
    9cdc:	77 fd       	sbrc	r23, 7
    9cde:	80 95       	com	r24
    9ce0:	98 2f       	mov	r25, r24
    9ce2:	0e 94 e4 7d 	call	0xfbc8	; 0xfbc8 <__floatsisf>
    9ce6:	20 e0       	ldi	r18, 0x00	; 0
    9ce8:	30 e0       	ldi	r19, 0x00	; 0
    9cea:	40 e7       	ldi	r20, 0x70	; 112
    9cec:	52 ec       	ldi	r21, 0xC2	; 194
    9cee:	0e 94 fe 7e 	call	0xfdfc	; 0xfdfc <__mulsf3>
    9cf2:	a7 01       	movw	r20, r14
    9cf4:	96 01       	movw	r18, r12
    9cf6:	0e 94 84 7c 	call	0xf908	; 0xf908 <__addsf3>
    9cfa:	5b 01       	movw	r10, r22
    9cfc:	6c 01       	movw	r12, r24
		*mins = (uint8_t) temp_min;
    9cfe:	0e 94 b6 7d 	call	0xfb6c	; 0xfb6c <__fixunssfsi>
    9d02:	e6 2e       	mov	r14, r22
    9d04:	f4 01       	movw	r30, r8
    9d06:	60 83       	st	Z, r22
	temp_secs = 60.0*temp_min -  60.0 *(double) (*mins);
		*secs = (uint8_t) temp_secs;
    9d08:	c6 01       	movw	r24, r12
    9d0a:	b5 01       	movw	r22, r10
    9d0c:	20 e0       	ldi	r18, 0x00	; 0
    9d0e:	30 e0       	ldi	r19, 0x00	; 0
    9d10:	40 e7       	ldi	r20, 0x70	; 112
    9d12:	52 e4       	ldi	r21, 0x42	; 66
    9d14:	0e 94 fe 7e 	call	0xfdfc	; 0xfdfc <__mulsf3>
    9d18:	5b 01       	movw	r10, r22
    9d1a:	6c 01       	movw	r12, r24
    9d1c:	ff 24       	eor	r15, r15
    9d1e:	00 e0       	ldi	r16, 0x00	; 0
    9d20:	10 e0       	ldi	r17, 0x00	; 0
    9d22:	c8 01       	movw	r24, r16
    9d24:	b7 01       	movw	r22, r14
    9d26:	0e 94 e2 7d 	call	0xfbc4	; 0xfbc4 <__floatunsisf>
    9d2a:	20 e0       	ldi	r18, 0x00	; 0
    9d2c:	30 e0       	ldi	r19, 0x00	; 0
    9d2e:	40 e7       	ldi	r20, 0x70	; 112
    9d30:	52 ec       	ldi	r21, 0xC2	; 194
    9d32:	0e 94 fe 7e 	call	0xfdfc	; 0xfdfc <__mulsf3>
    9d36:	9b 01       	movw	r18, r22
    9d38:	ac 01       	movw	r20, r24
    9d3a:	c6 01       	movw	r24, r12
    9d3c:	b5 01       	movw	r22, r10
    9d3e:	0e 94 84 7c 	call	0xf908	; 0xf908 <__addsf3>
    9d42:	0e 94 b6 7d 	call	0xfb6c	; 0xfb6c <__fixunssfsi>
    9d46:	f3 01       	movw	r30, r6
    9d48:	60 83       	st	Z, r22
}
    9d4a:	1f 91       	pop	r17
    9d4c:	0f 91       	pop	r16
    9d4e:	ff 90       	pop	r15
    9d50:	ef 90       	pop	r14
    9d52:	df 90       	pop	r13
    9d54:	cf 90       	pop	r12
    9d56:	bf 90       	pop	r11
    9d58:	af 90       	pop	r10
    9d5a:	9f 90       	pop	r9
    9d5c:	8f 90       	pop	r8
    9d5e:	7f 90       	pop	r7
    9d60:	6f 90       	pop	r6
    9d62:	08 95       	ret

00009d64 <fill8>:


/*********************************************************************************
* paint a section of memory with 0x55
********************************************************************************/ 
static __attribute__((noinline)) void fill8(uint8_t* bgn, uint8_t* end) {
    9d64:	fc 01       	movw	r30, r24
  while (bgn < end) *bgn++ = 0X55;
    9d66:	86 17       	cp	r24, r22
    9d68:	97 07       	cpc	r25, r23
    9d6a:	28 f4       	brcc	.+10     	; 0x9d76 <fill8+0x12>
    9d6c:	85 e5       	ldi	r24, 0x55	; 85
    9d6e:	81 93       	st	Z+, r24
    9d70:	e6 17       	cp	r30, r22
    9d72:	f7 07       	cpc	r31, r23
    9d74:	e0 f3       	brcs	.-8      	; 0x9d6e <fill8+0xa>
    9d76:	08 95       	ret

00009d78 <nilSemGetCounter>:
 * @brief   Returns the semaphore counter current value.
 * @param[in] sp        pointer to a @p Semaphore structure.
 * @return the value of the semaphore counter.
 * @api
********************************************************************************/ 
cnt_t nilSemGetCounter(semaphore_t *sp) {
    9d78:	fc 01       	movw	r30, r24
    9d7a:	f8 94       	cli
  chSysLock();
  cnt_t cnt = sp->cnt;
    9d7c:	80 81       	ld	r24, Z
    9d7e:	78 94       	sei
  chSysUnlock();
  return cnt;
}
    9d80:	08 95       	ret

00009d82 <nilUnusedStack>:
 * @param[in] nt Task index.
 *
 * @return Number of unused stack bytes.
********************************************************************************/ 
size_t nilUnusedStack(uint8_t nt) {
  const thread_config_t *tcp = &nil_thd_configs[nt];
    9d82:	9a e0       	ldi	r25, 0x0A	; 10
    9d84:	89 9f       	mul	r24, r25
    9d86:	f0 01       	movw	r30, r0
    9d88:	11 24       	eor	r1, r1
    9d8a:	ee 5e       	subi	r30, 0xEE	; 238
    9d8c:	f9 4f       	sbci	r31, 0xF9	; 249
  return fillSize((uint8_t*)tcp->wbase, (uint8_t*)tcp->wend);
    9d8e:	62 81       	ldd	r22, Z+2	; 0x02
    9d90:	73 81       	ldd	r23, Z+3	; 0x03
    9d92:	80 81       	ld	r24, Z
    9d94:	91 81       	ldd	r25, Z+1	; 0x01
    9d96:	0e 94 34 4e 	call	0x9c68	; 0x9c68 <fillSize>
}
    9d9a:	08 95       	ret

00009d9c <nilUnusedHeapIdle>:
*/


// @return Address of first byte after the heap. 
static inline char* heapEnd(void) {
 return __brkval ? __brkval : __malloc_heap_start;
    9d9c:	80 91 b1 32 	lds	r24, 0x32B1
    9da0:	90 91 b2 32 	lds	r25, 0x32B2
    9da4:	00 97       	sbiw	r24, 0x00	; 0
    9da6:	29 f0       	breq	.+10     	; 0x9db2 <nilUnusedHeapIdle+0x16>
 * Determine unused bytes in the heap and idle thread stack area.
 *
 * @return Number of unused bytes.
********************************************************************************/ 
size_t nilUnusedHeapIdle(void) {
  return fillSize((uint8_t*)heapEnd(), (uint8_t*)RAMEND);
    9da8:	6f ef       	ldi	r22, 0xFF	; 255
    9daa:	70 e4       	ldi	r23, 0x40	; 64
    9dac:	0e 94 34 4e 	call	0x9c68	; 0x9c68 <fillSize>
}
    9db0:	08 95       	ret
    9db2:	80 91 f6 06 	lds	r24, 0x06F6
    9db6:	90 91 f7 06 	lds	r25, 0x06F7
 * Determine unused bytes in the heap and idle thread stack area.
 *
 * @return Number of unused bytes.
********************************************************************************/ 
size_t nilUnusedHeapIdle(void) {
  return fillSize((uint8_t*)heapEnd(), (uint8_t*)RAMEND);
    9dba:	6f ef       	ldi	r22, 0xFF	; 255
    9dbc:	70 e4       	ldi	r23, 0x40	; 64
    9dbe:	0e 94 34 4e 	call	0x9c68	; 0x9c68 <fillSize>
}
    9dc2:	08 95       	ret

00009dc4 <nilThdDelay>:
********************************************************************************/ 
void nilThdDelay(systime_t time) {
  //systime_t t0 = port_timer_get_time();
  //while ((port_timer_get_time() - t0) < time) {}
  systime_t t0 = chVTGetSystemTimeX();
  while ((chVTGetSystemTimeX() - t0) < time) {}
    9dc4:	61 15       	cp	r22, r1
    9dc6:	71 05       	cpc	r23, r1
    9dc8:	81 05       	cpc	r24, r1
    9dca:	91 05       	cpc	r25, r1
    9dcc:	09 f4       	brne	.+2      	; 0x9dd0 <nilThdDelay+0xc>
    9dce:	08 95       	ret
    9dd0:	ff cf       	rjmp	.-2      	; 0x9dd0 <nilThdDelay+0xc>

00009dd2 <nilThdDelayUntil>:
    9dd2:	20 91 d2 07 	lds	r18, 0x07D2
    9dd6:	30 91 d3 07 	lds	r19, 0x07D3
    9dda:	40 91 d4 07 	lds	r20, 0x07D4
    9dde:	50 91 d5 07 	lds	r21, 0x07D5
    9de2:	26 17       	cp	r18, r22
    9de4:	37 07       	cpc	r19, r23
    9de6:	48 07       	cpc	r20, r24
    9de8:	59 07       	cpc	r21, r25
    9dea:	09 f4       	brne	.+2      	; 0x9dee <nilThdDelayUntil+0x1c>
    9dec:	08 95       	ret
    9dee:	ff cf       	rjmp	.-2      	; 0x9dee <nilThdDelayUntil+0x1c>

00009df0 <main>:


/*********************************************************************************
 * Application Entry Point
 *********************************************************************************/
int main(void) {
    9df0:	df 93       	push	r29
    9df2:	cf 93       	push	r28
    9df4:	00 d0       	rcall	.+0      	; 0x9df6 <main+0x6>
    9df6:	cd b7       	in	r28, 0x3d	; 61
    9df8:	de b7       	in	r29, 0x3e	; 62
   * - HAL initialization, this also initializes the configured device drivers
   *   and performs the board-specific initializations.
   * - Kernel initialization, the main() function becomes a thread and the
   *   RTOS is active.
   */
  chSemObjectInit(&lcdUSE,1);
    9dfa:	81 e0       	ldi	r24, 0x01	; 1
    9dfc:	80 93 fd 13 	sts	0x13FD, r24
  chSemObjectInit(&sdUSE,1);
    9e00:	80 93 00 26 	sts	0x2600, r24
  chSemObjectInit(&spiUSE,1);
    9e04:	80 93 79 14 	sts	0x1479, r24
  chSemObjectInit(&i2cUSE,1);
    9e08:	80 93 00 14 	sts	0x1400, r24
  chSemObjectInit(&usartUSE,1);
    9e0c:	80 93 c7 30 	sts	0x30C7, r24
  chSemObjectInit(&ButtonPressed,1);
    9e10:	80 93 01 26 	sts	0x2601, r24
  chSemObjectInit(&testTHREAD,1);
    9e14:	80 93 7c 31 	sts	0x317C, r24

/*********************************************************************************
* Fill stacks with 0X55
********************************************************************************/ 
static void nilFillStacks(void) {
  const thread_config_t *tcp = nil_thd_configs;
    9e18:	82 e1       	ldi	r24, 0x12	; 18
    9e1a:	96 e0       	ldi	r25, 0x06	; 6
    9e1c:	9a 83       	std	Y+2, r25	; 0x02
    9e1e:	89 83       	std	Y+1, r24	; 0x01
  
  while (tcp->wend) {
    9e20:	60 91 14 06 	lds	r22, 0x0614
    9e24:	70 91 15 06 	lds	r23, 0x0615
    9e28:	61 15       	cp	r22, r1
    9e2a:	71 05       	cpc	r23, r1
    9e2c:	79 f0       	breq	.+30     	; 0x9e4c <main+0x5c>
    9e2e:	fc 01       	movw	r30, r24
    fill8((uint8_t*)tcp->wbase, (uint8_t*)tcp->wend);
    9e30:	80 81       	ld	r24, Z
    9e32:	91 81       	ldd	r25, Z+1	; 0x01
    9e34:	0e 94 b2 4e 	call	0x9d64	; 0x9d64 <fill8>
    tcp++;
    9e38:	e9 81       	ldd	r30, Y+1	; 0x01
    9e3a:	fa 81       	ldd	r31, Y+2	; 0x02
    9e3c:	3a 96       	adiw	r30, 0x0a	; 10
    9e3e:	fa 83       	std	Y+2, r31	; 0x02
    9e40:	e9 83       	std	Y+1, r30	; 0x01
* Fill stacks with 0X55
********************************************************************************/ 
static void nilFillStacks(void) {
  const thread_config_t *tcp = nil_thd_configs;
  
  while (tcp->wend) {
    9e42:	62 81       	ldd	r22, Z+2	; 0x02
    9e44:	73 81       	ldd	r23, Z+3	; 0x03
    9e46:	61 15       	cp	r22, r1
    9e48:	71 05       	cpc	r23, r1
    9e4a:	91 f7       	brne	.-28     	; 0x9e30 <main+0x40>
    9e4c:	80 91 b1 32 	lds	r24, 0x32B1
    9e50:	90 91 b2 32 	lds	r25, 0x32B2
    9e54:	00 97       	sbiw	r24, 0x00	; 0
    9e56:	51 f0       	breq	.+20     	; 0x9e6c <main+0x7c>
    fill8((uint8_t*)tcp->wbase, (uint8_t*)tcp->wend);
    tcp++;
  }
  // fill heap/idle stack
  fill8((uint8_t*)heapEnd(), (uint8_t*)&tcp - 16);
    9e58:	be 01       	movw	r22, r28
    9e5a:	6f 50       	subi	r22, 0x0F	; 15
    9e5c:	70 40       	sbci	r23, 0x00	; 0
    9e5e:	0e 94 b2 4e 	call	0x9d64	; 0x9d64 <fill8>
  chSemObjectInit(&ButtonPressed,1);
  chSemObjectInit(&testTHREAD,1);

  
  nilFillStacks();
  halInit();
    9e62:	0e 94 f4 0f 	call	0x1fe8	; 0x1fe8 <halInit>
  chSysInit();
    9e66:	0e 94 35 09 	call	0x126a	; 0x126a <chSysInit>
    9e6a:	ff cf       	rjmp	.-2      	; 0x9e6a <main+0x7a>
    9e6c:	80 91 f6 06 	lds	r24, 0x06F6
    9e70:	90 91 f7 06 	lds	r25, 0x06F7
    9e74:	f1 cf       	rjmp	.-30     	; 0x9e58 <main+0x68>

00009e76 <Thread8>:
 * Thread 8 - Print Thread Information
 *********************************************************************************/
THD_FUNCTION(Thread8, arg) {
  (void)arg;
  uint8_t j;
  tp[7] = chThdGetSelfX();
    9e76:	80 91 ce 07 	lds	r24, 0x07CE
    9e7a:	90 91 cf 07 	lds	r25, 0x07CF
    9e7e:	90 93 a5 07 	sts	0x07A5, r25
    9e82:	80 93 a4 07 	sts	0x07A4, r24
    9e86:	0a ec       	ldi	r16, 0xCA	; 202
    9e88:	16 e0       	ldi	r17, 0x06	; 6
    9e8a:	57 ec       	ldi	r21, 0xC7	; 199
    9e8c:	25 2e       	mov	r2, r21
    9e8e:	58 e0       	ldi	r21, 0x08	; 8
    9e90:	35 2e       	mov	r3, r21
    9e92:	43 ec       	ldi	r20, 0xC3	; 195
    9e94:	a4 2e       	mov	r10, r20
    9e96:	48 e0       	ldi	r20, 0x08	; 8
    9e98:	b4 2e       	mov	r11, r20
    9e9a:	30 ec       	ldi	r19, 0xC0	; 192
    9e9c:	63 2e       	mov	r6, r19
    9e9e:	38 e0       	ldi	r19, 0x08	; 8
    9ea0:	73 2e       	mov	r7, r19
    9ea2:	2c eb       	ldi	r18, 0xBC	; 188
    9ea4:	c2 2e       	mov	r12, r18
    9ea6:	28 e0       	ldi	r18, 0x08	; 8
    9ea8:	d2 2e       	mov	r13, r18
    9eaa:	99 eb       	ldi	r25, 0xB9	; 185
    9eac:	49 2e       	mov	r4, r25
    9eae:	98 e0       	ldi	r25, 0x08	; 8
    9eb0:	59 2e       	mov	r5, r25
    9eb2:	85 eb       	ldi	r24, 0xB5	; 181
    9eb4:	e8 2e       	mov	r14, r24
    9eb6:	88 e0       	ldi	r24, 0x08	; 8
    9eb8:	f8 2e       	mov	r15, r24
	fprintf_P(&usart_out,PSTR("THREAD STATUS\r\n"));
	chSemSignal(&usartUSE);	
	
	for  (j = 0; j<NIL_CFG_NUM_THREADS; j++){
		chSemWait(&usartUSE);  
		fprintf_P(&usart_out,PSTR("%3u"), j);
    9eba:	c8 01       	movw	r24, r16
    9ebc:	90 2e       	mov	r9, r16
    9ebe:	89 2e       	mov	r8, r25
   * PA9 and PA10 are routed to USART1.
   */
   
  while (true) {
    /* Waiting for button push to show thread status.*/	
	chEvtWaitAnyTimeout((eventmask_t)1, TIME_INFINITE);
    9ec0:	81 e0       	ldi	r24, 0x01	; 1
    9ec2:	40 e0       	ldi	r20, 0x00	; 0
    9ec4:	50 e0       	ldi	r21, 0x00	; 0
    9ec6:	60 e0       	ldi	r22, 0x00	; 0
    9ec8:	70 e0       	ldi	r23, 0x00	; 0
    9eca:	0e 94 b4 08 	call	0x1168	; 0x1168 <chEvtWaitAnyTimeout>
    
	chSemWait(&usartUSE); 
    9ece:	87 ec       	ldi	r24, 0xC7	; 199
    9ed0:	90 e3       	ldi	r25, 0x30	; 48
    9ed2:	40 e0       	ldi	r20, 0x00	; 0
    9ed4:	50 e0       	ldi	r21, 0x00	; 0
    9ed6:	60 e0       	ldi	r22, 0x00	; 0
    9ed8:	70 e0       	ldi	r23, 0x00	; 0
    9eda:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
	fprintf_P(&usart_out,PSTR("THREAD STATUS\r\n"));
    9ede:	00 d0       	rcall	.+0      	; 0x9ee0 <Thread8+0x6a>
    9ee0:	00 d0       	rcall	.+0      	; 0x9ee2 <Thread8+0x6c>
    9ee2:	ad b7       	in	r26, 0x3d	; 61
    9ee4:	be b7       	in	r27, 0x3e	; 62
    9ee6:	12 96       	adiw	r26, 0x02	; 2
    9ee8:	1c 93       	st	X, r17
    9eea:	0e 93       	st	-X, r16
    9eec:	11 97       	sbiw	r26, 0x01	; 1
    9eee:	14 96       	adiw	r26, 0x04	; 4
    9ef0:	3c 92       	st	X, r3
    9ef2:	2e 92       	st	-X, r2
    9ef4:	13 97       	sbiw	r26, 0x03	; 3
    9ef6:	0e 94 9a 82 	call	0x10534	; 0x10534 <fprintf_P>
	chSemSignal(&usartUSE);	
    9efa:	0f 90       	pop	r0
    9efc:	0f 90       	pop	r0
    9efe:	0f 90       	pop	r0
    9f00:	0f 90       	pop	r0
    9f02:	87 ec       	ldi	r24, 0xC7	; 199
    9f04:	90 e3       	ldi	r25, 0x30	; 48
    9f06:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
    9f0a:	c0 e0       	ldi	r28, 0x00	; 0
    9f0c:	d0 e0       	ldi	r29, 0x00	; 0
	
	for  (j = 0; j<NIL_CFG_NUM_THREADS; j++){
		chSemWait(&usartUSE);  
    9f0e:	87 ec       	ldi	r24, 0xC7	; 199
    9f10:	90 e3       	ldi	r25, 0x30	; 48
    9f12:	40 e0       	ldi	r20, 0x00	; 0
    9f14:	50 e0       	ldi	r21, 0x00	; 0
    9f16:	60 e0       	ldi	r22, 0x00	; 0
    9f18:	70 e0       	ldi	r23, 0x00	; 0
    9f1a:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
		fprintf_P(&usart_out,PSTR("%3u"), j);
    9f1e:	00 d0       	rcall	.+0      	; 0x9f20 <Thread8+0xaa>
    9f20:	00 d0       	rcall	.+0      	; 0x9f22 <Thread8+0xac>
    9f22:	00 d0       	rcall	.+0      	; 0x9f24 <Thread8+0xae>
    9f24:	ed b7       	in	r30, 0x3d	; 61
    9f26:	fe b7       	in	r31, 0x3e	; 62
    9f28:	31 96       	adiw	r30, 0x01	; 1
    9f2a:	ad b7       	in	r26, 0x3d	; 61
    9f2c:	be b7       	in	r27, 0x3e	; 62
    9f2e:	12 96       	adiw	r26, 0x02	; 2
    9f30:	1c 93       	st	X, r17
    9f32:	0e 93       	st	-X, r16
    9f34:	11 97       	sbiw	r26, 0x01	; 1
    9f36:	b3 82       	std	Z+3, r11	; 0x03
    9f38:	a2 82       	std	Z+2, r10	; 0x02
    9f3a:	d5 83       	std	Z+5, r29	; 0x05
    9f3c:	c4 83       	std	Z+4, r28	; 0x04
    9f3e:	0e 94 9a 82 	call	0x10534	; 0x10534 <fprintf_P>
		chSemSignal(&usartUSE);
    9f42:	ed b7       	in	r30, 0x3d	; 61
    9f44:	fe b7       	in	r31, 0x3e	; 62
    9f46:	36 96       	adiw	r30, 0x06	; 6
    9f48:	0f b6       	in	r0, 0x3f	; 63
    9f4a:	f8 94       	cli
    9f4c:	fe bf       	out	0x3e, r31	; 62
    9f4e:	0f be       	out	0x3f, r0	; 63
    9f50:	ed bf       	out	0x3d, r30	; 61
    9f52:	87 ec       	ldi	r24, 0xC7	; 199
    9f54:	90 e3       	ldi	r25, 0x30	; 48
    9f56:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
    9f5a:	21 96       	adiw	r28, 0x01	; 1
    
	chSemWait(&usartUSE); 
	fprintf_P(&usart_out,PSTR("THREAD STATUS\r\n"));
	chSemSignal(&usartUSE);	
	
	for  (j = 0; j<NIL_CFG_NUM_THREADS; j++){
    9f5c:	c0 31       	cpi	r28, 0x10	; 16
    9f5e:	d1 05       	cpc	r29, r1
    9f60:	b1 f6       	brne	.-84     	; 0x9f0e <Thread8+0x98>
		chSemWait(&usartUSE);  
		fprintf_P(&usart_out,PSTR("%3u"), j);
		chSemSignal(&usartUSE);
	}
	
	chSemWait(&usartUSE);  
    9f62:	87 ec       	ldi	r24, 0xC7	; 199
    9f64:	90 e3       	ldi	r25, 0x30	; 48
    9f66:	40 e0       	ldi	r20, 0x00	; 0
    9f68:	50 e0       	ldi	r21, 0x00	; 0
    9f6a:	60 e0       	ldi	r22, 0x00	; 0
    9f6c:	70 e0       	ldi	r23, 0x00	; 0
    9f6e:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
	fprintf_P(&usart_out,PSTR("\r\n"));
    9f72:	00 d0       	rcall	.+0      	; 0x9f74 <Thread8+0xfe>
    9f74:	00 d0       	rcall	.+0      	; 0x9f76 <Thread8+0x100>
    9f76:	ad b7       	in	r26, 0x3d	; 61
    9f78:	be b7       	in	r27, 0x3e	; 62
    9f7a:	11 96       	adiw	r26, 0x01	; 1
    9f7c:	9c 92       	st	X, r9
    9f7e:	11 97       	sbiw	r26, 0x01	; 1
    9f80:	12 96       	adiw	r26, 0x02	; 2
    9f82:	8c 92       	st	X, r8
    9f84:	12 97       	sbiw	r26, 0x02	; 2
    9f86:	14 96       	adiw	r26, 0x04	; 4
    9f88:	7c 92       	st	X, r7
    9f8a:	6e 92       	st	-X, r6
    9f8c:	13 97       	sbiw	r26, 0x03	; 3
    9f8e:	0e 94 9a 82 	call	0x10534	; 0x10534 <fprintf_P>
	chSemSignal(&usartUSE);	
    9f92:	0f 90       	pop	r0
    9f94:	0f 90       	pop	r0
    9f96:	0f 90       	pop	r0
    9f98:	0f 90       	pop	r0
    9f9a:	87 ec       	ldi	r24, 0xC7	; 199
    9f9c:	90 e3       	ldi	r25, 0x30	; 48
    9f9e:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
    9fa2:	c0 e0       	ldi	r28, 0x00	; 0
    9fa4:	d0 e0       	ldi	r29, 0x00	; 0
	
	for  (j = 0; j<NIL_CFG_NUM_THREADS; j++){
		chSemWait(&usartUSE);  
    9fa6:	87 ec       	ldi	r24, 0xC7	; 199
    9fa8:	90 e3       	ldi	r25, 0x30	; 48
    9faa:	40 e0       	ldi	r20, 0x00	; 0
    9fac:	50 e0       	ldi	r21, 0x00	; 0
    9fae:	60 e0       	ldi	r22, 0x00	; 0
    9fb0:	70 e0       	ldi	r23, 0x00	; 0
    9fb2:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
		fprintf_P(&usart_out,PSTR(" --"), j);
    9fb6:	00 d0       	rcall	.+0      	; 0x9fb8 <Thread8+0x142>
    9fb8:	00 d0       	rcall	.+0      	; 0x9fba <Thread8+0x144>
    9fba:	00 d0       	rcall	.+0      	; 0x9fbc <Thread8+0x146>
    9fbc:	ed b7       	in	r30, 0x3d	; 61
    9fbe:	fe b7       	in	r31, 0x3e	; 62
    9fc0:	31 96       	adiw	r30, 0x01	; 1
    9fc2:	ad b7       	in	r26, 0x3d	; 61
    9fc4:	be b7       	in	r27, 0x3e	; 62
    9fc6:	12 96       	adiw	r26, 0x02	; 2
    9fc8:	1c 93       	st	X, r17
    9fca:	0e 93       	st	-X, r16
    9fcc:	11 97       	sbiw	r26, 0x01	; 1
    9fce:	d3 82       	std	Z+3, r13	; 0x03
    9fd0:	c2 82       	std	Z+2, r12	; 0x02
    9fd2:	d5 83       	std	Z+5, r29	; 0x05
    9fd4:	c4 83       	std	Z+4, r28	; 0x04
    9fd6:	0e 94 9a 82 	call	0x10534	; 0x10534 <fprintf_P>
		chSemSignal(&usartUSE);
    9fda:	ed b7       	in	r30, 0x3d	; 61
    9fdc:	fe b7       	in	r31, 0x3e	; 62
    9fde:	36 96       	adiw	r30, 0x06	; 6
    9fe0:	0f b6       	in	r0, 0x3f	; 63
    9fe2:	f8 94       	cli
    9fe4:	fe bf       	out	0x3e, r31	; 62
    9fe6:	0f be       	out	0x3f, r0	; 63
    9fe8:	ed bf       	out	0x3d, r30	; 61
    9fea:	87 ec       	ldi	r24, 0xC7	; 199
    9fec:	90 e3       	ldi	r25, 0x30	; 48
    9fee:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
    9ff2:	21 96       	adiw	r28, 0x01	; 1
	
	chSemWait(&usartUSE);  
	fprintf_P(&usart_out,PSTR("\r\n"));
	chSemSignal(&usartUSE);	
	
	for  (j = 0; j<NIL_CFG_NUM_THREADS; j++){
    9ff4:	c0 31       	cpi	r28, 0x10	; 16
    9ff6:	d1 05       	cpc	r29, r1
    9ff8:	b1 f6       	brne	.-84     	; 0x9fa6 <Thread8+0x130>
		chSemWait(&usartUSE);  
		fprintf_P(&usart_out,PSTR(" --"), j);
		chSemSignal(&usartUSE);
	}
	
	chSemWait(&usartUSE);  
    9ffa:	87 ec       	ldi	r24, 0xC7	; 199
    9ffc:	90 e3       	ldi	r25, 0x30	; 48
    9ffe:	40 e0       	ldi	r20, 0x00	; 0
    a000:	50 e0       	ldi	r21, 0x00	; 0
    a002:	60 e0       	ldi	r22, 0x00	; 0
    a004:	70 e0       	ldi	r23, 0x00	; 0
    a006:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
	fprintf_P(&usart_out,PSTR("\r\n"));
    a00a:	00 d0       	rcall	.+0      	; 0xa00c <Thread8+0x196>
    a00c:	00 d0       	rcall	.+0      	; 0xa00e <Thread8+0x198>
    a00e:	ad b7       	in	r26, 0x3d	; 61
    a010:	be b7       	in	r27, 0x3e	; 62
    a012:	11 96       	adiw	r26, 0x01	; 1
    a014:	9c 92       	st	X, r9
    a016:	11 97       	sbiw	r26, 0x01	; 1
    a018:	12 96       	adiw	r26, 0x02	; 2
    a01a:	8c 92       	st	X, r8
    a01c:	12 97       	sbiw	r26, 0x02	; 2
    a01e:	14 96       	adiw	r26, 0x04	; 4
    a020:	5c 92       	st	X, r5
    a022:	4e 92       	st	-X, r4
    a024:	13 97       	sbiw	r26, 0x03	; 3
    a026:	0e 94 9a 82 	call	0x10534	; 0x10534 <fprintf_P>
	chSemSignal(&usartUSE);	
    a02a:	0f 90       	pop	r0
    a02c:	0f 90       	pop	r0
    a02e:	0f 90       	pop	r0
    a030:	0f 90       	pop	r0
    a032:	87 ec       	ldi	r24, 0xC7	; 199
    a034:	90 e3       	ldi	r25, 0x30	; 48
    a036:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
    a03a:	c6 e9       	ldi	r28, 0x96	; 150
    a03c:	d7 e0       	ldi	r29, 0x07	; 7
 
	for  (j = 0; j<NIL_CFG_NUM_THREADS; j++){
		chSemWait(&usartUSE);  
    a03e:	87 ec       	ldi	r24, 0xC7	; 199
    a040:	90 e3       	ldi	r25, 0x30	; 48
    a042:	40 e0       	ldi	r20, 0x00	; 0
    a044:	50 e0       	ldi	r21, 0x00	; 0
    a046:	60 e0       	ldi	r22, 0x00	; 0
    a048:	70 e0       	ldi	r23, 0x00	; 0
    a04a:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
		fprintf_P(&usart_out,PSTR("%3u"), tp[j]->state);
    a04e:	00 d0       	rcall	.+0      	; 0xa050 <Thread8+0x1da>
    a050:	00 d0       	rcall	.+0      	; 0xa052 <Thread8+0x1dc>
    a052:	00 d0       	rcall	.+0      	; 0xa054 <Thread8+0x1de>
    a054:	ed b7       	in	r30, 0x3d	; 61
    a056:	fe b7       	in	r31, 0x3e	; 62
    a058:	31 96       	adiw	r30, 0x01	; 1
    a05a:	ad b7       	in	r26, 0x3d	; 61
    a05c:	be b7       	in	r27, 0x3e	; 62
    a05e:	12 96       	adiw	r26, 0x02	; 2
    a060:	1c 93       	st	X, r17
    a062:	0e 93       	st	-X, r16
    a064:	11 97       	sbiw	r26, 0x01	; 1
    a066:	f3 82       	std	Z+3, r15	; 0x03
    a068:	e2 82       	std	Z+2, r14	; 0x02
    a06a:	a9 91       	ld	r26, Y+
    a06c:	b9 91       	ld	r27, Y+
    a06e:	12 96       	adiw	r26, 0x02	; 2
    a070:	8c 91       	ld	r24, X
    a072:	84 83       	std	Z+4, r24	; 0x04
    a074:	15 82       	std	Z+5, r1	; 0x05
    a076:	0e 94 9a 82 	call	0x10534	; 0x10534 <fprintf_P>
		//try this at some point
		//fprintf_P(&usart_out,PSTR("THREAD%u: %u \r\n"), j, &nil.threads[j]->state) 
		chSemSignal(&usartUSE);
    a07a:	ed b7       	in	r30, 0x3d	; 61
    a07c:	fe b7       	in	r31, 0x3e	; 62
    a07e:	36 96       	adiw	r30, 0x06	; 6
    a080:	0f b6       	in	r0, 0x3f	; 63
    a082:	f8 94       	cli
    a084:	fe bf       	out	0x3e, r31	; 62
    a086:	0f be       	out	0x3f, r0	; 63
    a088:	ed bf       	out	0x3d, r30	; 61
    a08a:	87 ec       	ldi	r24, 0xC7	; 199
    a08c:	90 e3       	ldi	r25, 0x30	; 48
    a08e:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
	
	chSemWait(&usartUSE);  
	fprintf_P(&usart_out,PSTR("\r\n"));
	chSemSignal(&usartUSE);	
 
	for  (j = 0; j<NIL_CFG_NUM_THREADS; j++){
    a092:	f7 e0       	ldi	r31, 0x07	; 7
    a094:	c6 3b       	cpi	r28, 0xB6	; 182
    a096:	df 07       	cpc	r29, r31
    a098:	91 f6       	brne	.-92     	; 0xa03e <Thread8+0x1c8>
		fprintf_P(&usart_out,PSTR("%3u"), tp[j]->state);
		//try this at some point
		//fprintf_P(&usart_out,PSTR("THREAD%u: %u \r\n"), j, &nil.threads[j]->state) 
		chSemSignal(&usartUSE);
	}
	chSemWait(&usartUSE);  
    a09a:	87 ec       	ldi	r24, 0xC7	; 199
    a09c:	90 e3       	ldi	r25, 0x30	; 48
    a09e:	40 e0       	ldi	r20, 0x00	; 0
    a0a0:	50 e0       	ldi	r21, 0x00	; 0
    a0a2:	60 e0       	ldi	r22, 0x00	; 0
    a0a4:	70 e0       	ldi	r23, 0x00	; 0
    a0a6:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
	fprintf_P(&usart_out,PSTR("\r\n"));
    a0aa:	00 d0       	rcall	.+0      	; 0xa0ac <Thread8+0x236>
    a0ac:	00 d0       	rcall	.+0      	; 0xa0ae <Thread8+0x238>
    a0ae:	ad b7       	in	r26, 0x3d	; 61
    a0b0:	be b7       	in	r27, 0x3e	; 62
    a0b2:	11 96       	adiw	r26, 0x01	; 1
    a0b4:	9c 92       	st	X, r9
    a0b6:	11 97       	sbiw	r26, 0x01	; 1
    a0b8:	12 96       	adiw	r26, 0x02	; 2
    a0ba:	8c 92       	st	X, r8
    a0bc:	12 97       	sbiw	r26, 0x02	; 2
    a0be:	e2 eb       	ldi	r30, 0xB2	; 178
    a0c0:	f8 e0       	ldi	r31, 0x08	; 8
    a0c2:	14 96       	adiw	r26, 0x04	; 4
    a0c4:	fc 93       	st	X, r31
    a0c6:	ee 93       	st	-X, r30
    a0c8:	13 97       	sbiw	r26, 0x03	; 3
    a0ca:	0e 94 9a 82 	call	0x10534	; 0x10534 <fprintf_P>
	chSemSignal(&usartUSE);	
    a0ce:	0f 90       	pop	r0
    a0d0:	0f 90       	pop	r0
    a0d2:	0f 90       	pop	r0
    a0d4:	0f 90       	pop	r0
    a0d6:	87 ec       	ldi	r24, 0xC7	; 199
    a0d8:	90 e3       	ldi	r25, 0x30	; 48
    a0da:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
    a0de:	f0 ce       	rjmp	.-544    	; 0x9ec0 <Thread8+0x4a>

0000a0e0 <showMenu>:
}

/*********************************************************************************
 * Menu Show routine
 *********************************************************************************/
void showMenu(void) {
    a0e0:	cf 92       	push	r12
    a0e2:	df 92       	push	r13
    a0e4:	ef 92       	push	r14
    a0e6:	ff 92       	push	r15
    a0e8:	0f 93       	push	r16
    a0ea:	1f 93       	push	r17
    a0ec:	cf 93       	push	r28
    a0ee:	df 93       	push	r29
	if (switchtype ==1) {//we are scrolling, no need to clear the screen	
    a0f0:	80 91 3f 07 	lds	r24, 0x073F
    a0f4:	81 30       	cpi	r24, 0x01	; 1
    a0f6:	a1 f0       	breq	.+40     	; 0xa120 <showMenu+0x40>
	}
	else {
	chSemWait(&spiUSE);
    a0f8:	89 e7       	ldi	r24, 0x79	; 121
    a0fa:	94 e1       	ldi	r25, 0x14	; 20
    a0fc:	40 e0       	ldi	r20, 0x00	; 0
    a0fe:	50 e0       	ldi	r21, 0x00	; 0
    a100:	60 e0       	ldi	r22, 0x00	; 0
    a102:	70 e0       	ldi	r23, 0x00	; 0
    a104:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
	st7735_fill_rect(0, 0, 160, 128, ST7735_COLOR_BLACK);//lcd_clear();
    a108:	80 e0       	ldi	r24, 0x00	; 0
    a10a:	60 e0       	ldi	r22, 0x00	; 0
    a10c:	40 ea       	ldi	r20, 0xA0	; 160
    a10e:	20 e8       	ldi	r18, 0x80	; 128
    a110:	00 e0       	ldi	r16, 0x00	; 0
    a112:	10 e0       	ldi	r17, 0x00	; 0
    a114:	0e 94 59 16 	call	0x2cb2	; 0x2cb2 <st7735_fill_rect>
	chSemSignal(&spiUSE);
    a118:	89 e7       	ldi	r24, 0x79	; 121
    a11a:	94 e1       	ldi	r25, 0x14	; 20
    a11c:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
	}
	chSemWait(&spiUSE);
    a120:	89 e7       	ldi	r24, 0x79	; 121
    a122:	94 e1       	ldi	r25, 0x14	; 20
    a124:	40 e0       	ldi	r20, 0x00	; 0
    a126:	50 e0       	ldi	r21, 0x00	; 0
    a128:	60 e0       	ldi	r22, 0x00	; 0
    a12a:	70 e0       	ldi	r23, 0x00	; 0
    a12c:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
    st7735_setCursor(5,10);//lcd_goto_xy(1,1);
    a130:	85 e0       	ldi	r24, 0x05	; 5
    a132:	90 e0       	ldi	r25, 0x00	; 0
    a134:	6a e0       	ldi	r22, 0x0A	; 10
    a136:	70 e0       	ldi	r23, 0x00	; 0
    a138:	0e 94 c2 19 	call	0x3384	; 0x3384 <st7735_setCursor>
    fprintf_P(&st7735_out, PSTR("%s"), menutitle[curMenu]);
    a13c:	00 d0       	rcall	.+0      	; 0xa13e <showMenu+0x5e>
    a13e:	00 d0       	rcall	.+0      	; 0xa140 <showMenu+0x60>
    a140:	00 d0       	rcall	.+0      	; 0xa142 <showMenu+0x62>
    a142:	ed b7       	in	r30, 0x3d	; 61
    a144:	fe b7       	in	r31, 0x3e	; 62
    a146:	31 96       	adiw	r30, 0x01	; 1
    a148:	cc eb       	ldi	r28, 0xBC	; 188
    a14a:	d6 e0       	ldi	r29, 0x06	; 6
    a14c:	ad b7       	in	r26, 0x3d	; 61
    a14e:	be b7       	in	r27, 0x3e	; 62
    a150:	12 96       	adiw	r26, 0x02	; 2
    a152:	dc 93       	st	X, r29
    a154:	ce 93       	st	-X, r28
    a156:	11 97       	sbiw	r26, 0x01	; 1
    a158:	88 e0       	ldi	r24, 0x08	; 8
    a15a:	9b e0       	ldi	r25, 0x0B	; 11
    a15c:	93 83       	std	Z+3, r25	; 0x03
    a15e:	82 83       	std	Z+2, r24	; 0x02
    a160:	80 91 31 07 	lds	r24, 0x0731
    a164:	90 91 32 07 	lds	r25, 0x0732
    a168:	88 0f       	add	r24, r24
    a16a:	99 1f       	adc	r25, r25
    a16c:	88 0f       	add	r24, r24
    a16e:	99 1f       	adc	r25, r25
    a170:	9c 01       	movw	r18, r24
    a172:	22 0f       	add	r18, r18
    a174:	33 1f       	adc	r19, r19
    a176:	22 0f       	add	r18, r18
    a178:	33 1f       	adc	r19, r19
    a17a:	82 0f       	add	r24, r18
    a17c:	93 1f       	adc	r25, r19
    a17e:	86 59       	subi	r24, 0x96	; 150
    a180:	93 4e       	sbci	r25, 0xE3	; 227
    a182:	95 83       	std	Z+5, r25	; 0x05
    a184:	84 83       	std	Z+4, r24	; 0x04
    a186:	0e 94 9a 82 	call	0x10534	; 0x10534 <fprintf_P>
	chSemSignal(&spiUSE);
    a18a:	4d b7       	in	r20, 0x3d	; 61
    a18c:	5e b7       	in	r21, 0x3e	; 62
    a18e:	4a 5f       	subi	r20, 0xFA	; 250
    a190:	5f 4f       	sbci	r21, 0xFF	; 255
    a192:	0f b6       	in	r0, 0x3f	; 63
    a194:	f8 94       	cli
    a196:	5e bf       	out	0x3e, r21	; 62
    a198:	0f be       	out	0x3f, r0	; 63
    a19a:	4d bf       	out	0x3d, r20	; 61
    a19c:	89 e7       	ldi	r24, 0x79	; 121
    a19e:	94 e1       	ldi	r25, 0x14	; 20
    a1a0:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
    //print menu content
    while ((menuprintloop < (pageSize)) && (menuitem[curMenu][menuCount][0] != '\0')) {
    a1a4:	80 91 3d 07 	lds	r24, 0x073D
    a1a8:	90 91 3e 07 	lds	r25, 0x073E
    a1ac:	07 97       	sbiw	r24, 0x07	; 7
    a1ae:	0c f0       	brlt	.+2      	; 0xa1b2 <showMenu+0xd2>
    a1b0:	fb c0       	rjmp	.+502    	; 0xa3a8 <showMenu+0x2c8>
    a1b2:	20 91 31 07 	lds	r18, 0x0731
    a1b6:	30 91 32 07 	lds	r19, 0x0732
    a1ba:	e0 91 39 07 	lds	r30, 0x0739
    a1be:	f0 91 3a 07 	lds	r31, 0x073A
    a1c2:	ee 0f       	add	r30, r30
    a1c4:	ff 1f       	adc	r31, r31
    a1c6:	ee 0f       	add	r30, r30
    a1c8:	ff 1f       	adc	r31, r31
    a1ca:	cf 01       	movw	r24, r30
    a1cc:	88 0f       	add	r24, r24
    a1ce:	99 1f       	adc	r25, r25
    a1d0:	88 0f       	add	r24, r24
    a1d2:	99 1f       	adc	r25, r25
    a1d4:	e8 0f       	add	r30, r24
    a1d6:	f9 1f       	adc	r31, r25
    a1d8:	8c e8       	ldi	r24, 0x8C	; 140
    a1da:	90 e0       	ldi	r25, 0x00	; 0
    a1dc:	dc 01       	movw	r26, r24
    a1de:	2a 9f       	mul	r18, r26
    a1e0:	c0 01       	movw	r24, r0
    a1e2:	2b 9f       	mul	r18, r27
    a1e4:	90 0d       	add	r25, r0
    a1e6:	3a 9f       	mul	r19, r26
    a1e8:	90 0d       	add	r25, r0
    a1ea:	11 24       	eor	r1, r1
    a1ec:	e8 0f       	add	r30, r24
    a1ee:	f9 1f       	adc	r31, r25
    a1f0:	e8 50       	subi	r30, 0x08	; 8
    a1f2:	ff 4d       	sbci	r31, 0xDF	; 223
    a1f4:	80 81       	ld	r24, Z
    a1f6:	88 23       	and	r24, r24
    a1f8:	09 f4       	brne	.+2      	; 0xa1fc <showMenu+0x11c>
    a1fa:	d6 c0       	rjmp	.+428    	; 0xa3a8 <showMenu+0x2c8>
		chSemSignal(&spiUSE);
		
        if ((cursorCount + (pageSize*pageScroll)) == menuCount) {
            // item currently indicated by cursor
            chSemWait(&spiUSE);
			fprintf_P(&st7735_out, PSTR(">%s"), menuitem[curMenu][menuCount]);
    a1fc:	a4 e0       	ldi	r26, 0x04	; 4
    a1fe:	ca 2e       	mov	r12, r26
    a200:	ab e0       	ldi	r26, 0x0B	; 11
    a202:	da 2e       	mov	r13, r26
    a204:	0c e8       	ldi	r16, 0x8C	; 140
    a206:	10 e0       	ldi	r17, 0x00	; 0
			 chSemSignal(&spiUSE);
        } else {
            chSemWait(&spiUSE);
			fprintf_P(&st7735_out, PSTR(" %s"), menuitem[curMenu][menuCount]);
    a208:	f0 e0       	ldi	r31, 0x00	; 0
    a20a:	ef 2e       	mov	r14, r31
    a20c:	fb e0       	ldi	r31, 0x0B	; 11
    a20e:	ff 2e       	mov	r15, r31
    a210:	78 c0       	rjmp	.+240    	; 0xa302 <showMenu+0x222>
            // item currently indicated by cursor
            chSemWait(&spiUSE);
			fprintf_P(&st7735_out, PSTR(">%s"), menuitem[curMenu][menuCount]);
			 chSemSignal(&spiUSE);
        } else {
            chSemWait(&spiUSE);
    a212:	89 e7       	ldi	r24, 0x79	; 121
    a214:	94 e1       	ldi	r25, 0x14	; 20
    a216:	40 e0       	ldi	r20, 0x00	; 0
    a218:	50 e0       	ldi	r21, 0x00	; 0
    a21a:	60 e0       	ldi	r22, 0x00	; 0
    a21c:	70 e0       	ldi	r23, 0x00	; 0
    a21e:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
			fprintf_P(&st7735_out, PSTR(" %s"), menuitem[curMenu][menuCount]);
    a222:	00 d0       	rcall	.+0      	; 0xa224 <showMenu+0x144>
    a224:	00 d0       	rcall	.+0      	; 0xa226 <showMenu+0x146>
    a226:	00 d0       	rcall	.+0      	; 0xa228 <showMenu+0x148>
    a228:	ed b7       	in	r30, 0x3d	; 61
    a22a:	fe b7       	in	r31, 0x3e	; 62
    a22c:	31 96       	adiw	r30, 0x01	; 1
    a22e:	ad b7       	in	r26, 0x3d	; 61
    a230:	be b7       	in	r27, 0x3e	; 62
    a232:	12 96       	adiw	r26, 0x02	; 2
    a234:	dc 93       	st	X, r29
    a236:	ce 93       	st	-X, r28
    a238:	11 97       	sbiw	r26, 0x01	; 1
    a23a:	f3 82       	std	Z+3, r15	; 0x03
    a23c:	e2 82       	std	Z+2, r14	; 0x02
    a23e:	80 91 39 07 	lds	r24, 0x0739
    a242:	90 91 3a 07 	lds	r25, 0x073A
    a246:	88 0f       	add	r24, r24
    a248:	99 1f       	adc	r25, r25
    a24a:	88 0f       	add	r24, r24
    a24c:	99 1f       	adc	r25, r25
    a24e:	9c 01       	movw	r18, r24
    a250:	22 0f       	add	r18, r18
    a252:	33 1f       	adc	r19, r19
    a254:	22 0f       	add	r18, r18
    a256:	33 1f       	adc	r19, r19
    a258:	82 0f       	add	r24, r18
    a25a:	93 1f       	adc	r25, r19
    a25c:	20 91 31 07 	lds	r18, 0x0731
    a260:	30 91 32 07 	lds	r19, 0x0732
    a264:	a9 01       	movw	r20, r18
    a266:	40 9f       	mul	r20, r16
    a268:	90 01       	movw	r18, r0
    a26a:	41 9f       	mul	r20, r17
    a26c:	30 0d       	add	r19, r0
    a26e:	50 9f       	mul	r21, r16
    a270:	30 0d       	add	r19, r0
    a272:	11 24       	eor	r1, r1
    a274:	82 0f       	add	r24, r18
    a276:	93 1f       	adc	r25, r19
    a278:	88 50       	subi	r24, 0x08	; 8
    a27a:	9f 4d       	sbci	r25, 0xDF	; 223
    a27c:	95 83       	std	Z+5, r25	; 0x05
    a27e:	84 83       	std	Z+4, r24	; 0x04
    a280:	0e 94 9a 82 	call	0x10534	; 0x10534 <fprintf_P>
			chSemSignal(&spiUSE);
    a284:	8d b7       	in	r24, 0x3d	; 61
    a286:	9e b7       	in	r25, 0x3e	; 62
    a288:	06 96       	adiw	r24, 0x06	; 6
    a28a:	0f b6       	in	r0, 0x3f	; 63
    a28c:	f8 94       	cli
    a28e:	9e bf       	out	0x3e, r25	; 62
    a290:	0f be       	out	0x3f, r0	; 63
    a292:	8d bf       	out	0x3d, r24	; 61
    a294:	89 e7       	ldi	r24, 0x79	; 121
    a296:	94 e1       	ldi	r25, 0x14	; 20
    a298:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
        }
        menuprintloop++;
    a29c:	80 91 3d 07 	lds	r24, 0x073D
    a2a0:	90 91 3e 07 	lds	r25, 0x073E
    a2a4:	01 96       	adiw	r24, 0x01	; 1
    a2a6:	90 93 3e 07 	sts	0x073E, r25
    a2aa:	80 93 3d 07 	sts	0x073D, r24
        menuCount++;
    a2ae:	e0 91 39 07 	lds	r30, 0x0739
    a2b2:	f0 91 3a 07 	lds	r31, 0x073A
    a2b6:	31 96       	adiw	r30, 0x01	; 1
    a2b8:	f0 93 3a 07 	sts	0x073A, r31
    a2bc:	e0 93 39 07 	sts	0x0739, r30
	chSemWait(&spiUSE);
    st7735_setCursor(5,10);//lcd_goto_xy(1,1);
    fprintf_P(&st7735_out, PSTR("%s"), menutitle[curMenu]);
	chSemSignal(&spiUSE);
    //print menu content
    while ((menuprintloop < (pageSize)) && (menuitem[curMenu][menuCount][0] != '\0')) {
    a2c0:	07 97       	sbiw	r24, 0x07	; 7
    a2c2:	0c f0       	brlt	.+2      	; 0xa2c6 <showMenu+0x1e6>
    a2c4:	71 c0       	rjmp	.+226    	; 0xa3a8 <showMenu+0x2c8>
    a2c6:	20 91 31 07 	lds	r18, 0x0731
    a2ca:	30 91 32 07 	lds	r19, 0x0732
    a2ce:	ee 0f       	add	r30, r30
    a2d0:	ff 1f       	adc	r31, r31
    a2d2:	ee 0f       	add	r30, r30
    a2d4:	ff 1f       	adc	r31, r31
    a2d6:	cf 01       	movw	r24, r30
    a2d8:	88 0f       	add	r24, r24
    a2da:	99 1f       	adc	r25, r25
    a2dc:	88 0f       	add	r24, r24
    a2de:	99 1f       	adc	r25, r25
    a2e0:	e8 0f       	add	r30, r24
    a2e2:	f9 1f       	adc	r31, r25
    a2e4:	20 9f       	mul	r18, r16
    a2e6:	c0 01       	movw	r24, r0
    a2e8:	21 9f       	mul	r18, r17
    a2ea:	90 0d       	add	r25, r0
    a2ec:	30 9f       	mul	r19, r16
    a2ee:	90 0d       	add	r25, r0
    a2f0:	11 24       	eor	r1, r1
    a2f2:	e8 0f       	add	r30, r24
    a2f4:	f9 1f       	adc	r31, r25
    a2f6:	e8 50       	subi	r30, 0x08	; 8
    a2f8:	ff 4d       	sbci	r31, 0xDF	; 223
    a2fa:	80 81       	ld	r24, Z
    a2fc:	88 23       	and	r24, r24
    a2fe:	09 f4       	brne	.+2      	; 0xa302 <showMenu+0x222>
    a300:	53 c0       	rjmp	.+166    	; 0xa3a8 <showMenu+0x2c8>
        chSemWait(&spiUSE);
    a302:	89 e7       	ldi	r24, 0x79	; 121
    a304:	94 e1       	ldi	r25, 0x14	; 20
    a306:	40 e0       	ldi	r20, 0x00	; 0
    a308:	50 e0       	ldi	r21, 0x00	; 0
    a30a:	60 e0       	ldi	r22, 0x00	; 0
    a30c:	70 e0       	ldi	r23, 0x00	; 0
    a30e:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
		st7735_setCursor(5, 10*(menuprintloop+2)); // +1 to leave first line for menu title
    a312:	80 91 3d 07 	lds	r24, 0x073D
    a316:	90 91 3e 07 	lds	r25, 0x073E
    a31a:	bc 01       	movw	r22, r24
    a31c:	66 0f       	add	r22, r22
    a31e:	77 1f       	adc	r23, r23
    a320:	66 0f       	add	r22, r22
    a322:	77 1f       	adc	r23, r23
    a324:	66 0f       	add	r22, r22
    a326:	77 1f       	adc	r23, r23
    a328:	88 0f       	add	r24, r24
    a32a:	99 1f       	adc	r25, r25
    a32c:	68 0f       	add	r22, r24
    a32e:	79 1f       	adc	r23, r25
    a330:	6c 5e       	subi	r22, 0xEC	; 236
    a332:	7f 4f       	sbci	r23, 0xFF	; 255
    a334:	85 e0       	ldi	r24, 0x05	; 5
    a336:	90 e0       	ldi	r25, 0x00	; 0
    a338:	0e 94 c2 19 	call	0x3384	; 0x3384 <st7735_setCursor>
		chSemSignal(&spiUSE);
    a33c:	89 e7       	ldi	r24, 0x79	; 121
    a33e:	94 e1       	ldi	r25, 0x14	; 20
    a340:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
		
        if ((cursorCount + (pageSize*pageScroll)) == menuCount) {
    a344:	20 91 3b 07 	lds	r18, 0x073B
    a348:	30 91 3c 07 	lds	r19, 0x073C
    a34c:	c9 01       	movw	r24, r18
    a34e:	88 0f       	add	r24, r24
    a350:	99 1f       	adc	r25, r25
    a352:	88 0f       	add	r24, r24
    a354:	99 1f       	adc	r25, r25
    a356:	88 0f       	add	r24, r24
    a358:	99 1f       	adc	r25, r25
    a35a:	82 1b       	sub	r24, r18
    a35c:	93 0b       	sbc	r25, r19
    a35e:	20 91 37 07 	lds	r18, 0x0737
    a362:	30 91 38 07 	lds	r19, 0x0738
    a366:	82 0f       	add	r24, r18
    a368:	93 1f       	adc	r25, r19
    a36a:	20 91 39 07 	lds	r18, 0x0739
    a36e:	30 91 3a 07 	lds	r19, 0x073A
    a372:	82 17       	cp	r24, r18
    a374:	93 07       	cpc	r25, r19
    a376:	09 f0       	breq	.+2      	; 0xa37a <showMenu+0x29a>
    a378:	4c cf       	rjmp	.-360    	; 0xa212 <showMenu+0x132>
            // item currently indicated by cursor
            chSemWait(&spiUSE);
    a37a:	89 e7       	ldi	r24, 0x79	; 121
    a37c:	94 e1       	ldi	r25, 0x14	; 20
    a37e:	40 e0       	ldi	r20, 0x00	; 0
    a380:	50 e0       	ldi	r21, 0x00	; 0
    a382:	60 e0       	ldi	r22, 0x00	; 0
    a384:	70 e0       	ldi	r23, 0x00	; 0
    a386:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
			fprintf_P(&st7735_out, PSTR(">%s"), menuitem[curMenu][menuCount]);
    a38a:	00 d0       	rcall	.+0      	; 0xa38c <showMenu+0x2ac>
    a38c:	00 d0       	rcall	.+0      	; 0xa38e <showMenu+0x2ae>
    a38e:	00 d0       	rcall	.+0      	; 0xa390 <showMenu+0x2b0>
    a390:	ed b7       	in	r30, 0x3d	; 61
    a392:	fe b7       	in	r31, 0x3e	; 62
    a394:	31 96       	adiw	r30, 0x01	; 1
    a396:	ad b7       	in	r26, 0x3d	; 61
    a398:	be b7       	in	r27, 0x3e	; 62
    a39a:	12 96       	adiw	r26, 0x02	; 2
    a39c:	dc 93       	st	X, r29
    a39e:	ce 93       	st	-X, r28
    a3a0:	11 97       	sbiw	r26, 0x01	; 1
    a3a2:	d3 82       	std	Z+3, r13	; 0x03
    a3a4:	c2 82       	std	Z+2, r12	; 0x02
    a3a6:	4b cf       	rjmp	.-362    	; 0xa23e <showMenu+0x15e>
			chSemSignal(&spiUSE);
        }
        menuprintloop++;
        menuCount++;
    }
    menuprintloop = 0;
    a3a8:	10 92 3e 07 	sts	0x073E, r1
    a3ac:	10 92 3d 07 	sts	0x073D, r1
}
    a3b0:	df 91       	pop	r29
    a3b2:	cf 91       	pop	r28
    a3b4:	1f 91       	pop	r17
    a3b6:	0f 91       	pop	r16
    a3b8:	ff 90       	pop	r15
    a3ba:	ef 90       	pop	r14
    a3bc:	df 90       	pop	r13
    a3be:	cf 90       	pop	r12
    a3c0:	08 95       	ret

0000a3c2 <chPrintUnusedStack>:

/*********************************************************************************
 * Print unused byte count for all stacks.
 * @param[in] pr Print stream for output.
********************************************************************************/ 
void chPrintUnusedStack(void) {
    a3c2:	ef 92       	push	r14
    a3c4:	ff 92       	push	r15
    a3c6:	0f 93       	push	r16
    a3c8:	1f 93       	push	r17
    a3ca:	cf 93       	push	r28
    a3cc:	df 93       	push	r29
  const thread_config_t *tcp = nil_thd_configs;
  fprintf_P(&usart_out,PSTR("Unused Stack: "));	
    a3ce:	00 d0       	rcall	.+0      	; 0xa3d0 <chPrintUnusedStack+0xe>
    a3d0:	00 d0       	rcall	.+0      	; 0xa3d2 <chPrintUnusedStack+0x10>
    a3d2:	0a ec       	ldi	r16, 0xCA	; 202
    a3d4:	16 e0       	ldi	r17, 0x06	; 6
    a3d6:	ad b7       	in	r26, 0x3d	; 61
    a3d8:	be b7       	in	r27, 0x3e	; 62
    a3da:	12 96       	adiw	r26, 0x02	; 2
    a3dc:	1c 93       	st	X, r17
    a3de:	0e 93       	st	-X, r16
    a3e0:	11 97       	sbiw	r26, 0x01	; 1
    a3e2:	85 e1       	ldi	r24, 0x15	; 21
    a3e4:	9b e0       	ldi	r25, 0x0B	; 11
    a3e6:	14 96       	adiw	r26, 0x04	; 4
    a3e8:	9c 93       	st	X, r25
    a3ea:	8e 93       	st	-X, r24
    a3ec:	13 97       	sbiw	r26, 0x03	; 3
    a3ee:	0e 94 9a 82 	call	0x10534	; 0x10534 <fprintf_P>
  
  while (tcp->wend) {
    a3f2:	60 91 14 06 	lds	r22, 0x0614
    a3f6:	70 91 15 06 	lds	r23, 0x0615
    a3fa:	0f 90       	pop	r0
    a3fc:	0f 90       	pop	r0
    a3fe:	0f 90       	pop	r0
    a400:	0f 90       	pop	r0
    a402:	61 15       	cp	r22, r1
    a404:	71 05       	cpc	r23, r1
    a406:	51 f1       	breq	.+84     	; 0xa45c <chPrintUnusedStack+0x9a>
    a408:	c2 e1       	ldi	r28, 0x12	; 18
    a40a:	d6 e0       	ldi	r29, 0x06	; 6
    a40c:	30 e1       	ldi	r19, 0x10	; 16
    a40e:	e3 2e       	mov	r14, r19
    a410:	3b e0       	ldi	r19, 0x0B	; 11
    a412:	f3 2e       	mov	r15, r19
    fprintf_P(&usart_out,PSTR("%3d "), fillSize((uint8_t*)tcp->wbase, (uint8_t*)tcp->wend));
    a414:	88 81       	ld	r24, Y
    a416:	99 81       	ldd	r25, Y+1	; 0x01
    a418:	0e 94 34 4e 	call	0x9c68	; 0x9c68 <fillSize>
    a41c:	00 d0       	rcall	.+0      	; 0xa41e <chPrintUnusedStack+0x5c>
    a41e:	00 d0       	rcall	.+0      	; 0xa420 <chPrintUnusedStack+0x5e>
    a420:	00 d0       	rcall	.+0      	; 0xa422 <chPrintUnusedStack+0x60>
    a422:	ed b7       	in	r30, 0x3d	; 61
    a424:	fe b7       	in	r31, 0x3e	; 62
    a426:	31 96       	adiw	r30, 0x01	; 1
    a428:	ad b7       	in	r26, 0x3d	; 61
    a42a:	be b7       	in	r27, 0x3e	; 62
    a42c:	12 96       	adiw	r26, 0x02	; 2
    a42e:	1c 93       	st	X, r17
    a430:	0e 93       	st	-X, r16
    a432:	11 97       	sbiw	r26, 0x01	; 1
    a434:	f3 82       	std	Z+3, r15	; 0x03
    a436:	e2 82       	std	Z+2, r14	; 0x02
    a438:	95 83       	std	Z+5, r25	; 0x05
    a43a:	84 83       	std	Z+4, r24	; 0x04
    a43c:	0e 94 9a 82 	call	0x10534	; 0x10534 <fprintf_P>
    tcp++;
    a440:	2a 96       	adiw	r28, 0x0a	; 10
********************************************************************************/ 
void chPrintUnusedStack(void) {
  const thread_config_t *tcp = nil_thd_configs;
  fprintf_P(&usart_out,PSTR("Unused Stack: "));	
  
  while (tcp->wend) {
    a442:	6a 81       	ldd	r22, Y+2	; 0x02
    a444:	7b 81       	ldd	r23, Y+3	; 0x03
    a446:	ed b7       	in	r30, 0x3d	; 61
    a448:	fe b7       	in	r31, 0x3e	; 62
    a44a:	36 96       	adiw	r30, 0x06	; 6
    a44c:	0f b6       	in	r0, 0x3f	; 63
    a44e:	f8 94       	cli
    a450:	fe bf       	out	0x3e, r31	; 62
    a452:	0f be       	out	0x3f, r0	; 63
    a454:	ed bf       	out	0x3d, r30	; 61
    a456:	61 15       	cp	r22, r1
    a458:	71 05       	cpc	r23, r1
    a45a:	e1 f6       	brne	.-72     	; 0xa414 <chPrintUnusedStack+0x52>
    a45c:	80 91 b1 32 	lds	r24, 0x32B1
    a460:	90 91 b2 32 	lds	r25, 0x32B2
    a464:	00 97       	sbiw	r24, 0x00	; 0
    a466:	39 f1       	breq	.+78     	; 0xa4b6 <chPrintUnusedStack+0xf4>
    fprintf_P(&usart_out,PSTR("%3d "), fillSize((uint8_t*)tcp->wbase, (uint8_t*)tcp->wend));
    tcp++;
  }
  fprintf_P(&usart_out,PSTR("%d\r\n"), fillSize((uint8_t*)heapEnd(), (uint8_t*)RAMEND));
    a468:	6f ef       	ldi	r22, 0xFF	; 255
    a46a:	70 e4       	ldi	r23, 0x40	; 64
    a46c:	0e 94 34 4e 	call	0x9c68	; 0x9c68 <fillSize>
    a470:	00 d0       	rcall	.+0      	; 0xa472 <chPrintUnusedStack+0xb0>
    a472:	00 d0       	rcall	.+0      	; 0xa474 <chPrintUnusedStack+0xb2>
    a474:	00 d0       	rcall	.+0      	; 0xa476 <chPrintUnusedStack+0xb4>
    a476:	ed b7       	in	r30, 0x3d	; 61
    a478:	fe b7       	in	r31, 0x3e	; 62
    a47a:	31 96       	adiw	r30, 0x01	; 1
    a47c:	ad b7       	in	r26, 0x3d	; 61
    a47e:	be b7       	in	r27, 0x3e	; 62
    a480:	12 96       	adiw	r26, 0x02	; 2
    a482:	1c 93       	st	X, r17
    a484:	0e 93       	st	-X, r16
    a486:	11 97       	sbiw	r26, 0x01	; 1
    a488:	2b e0       	ldi	r18, 0x0B	; 11
    a48a:	3b e0       	ldi	r19, 0x0B	; 11
    a48c:	33 83       	std	Z+3, r19	; 0x03
    a48e:	22 83       	std	Z+2, r18	; 0x02
    a490:	95 83       	std	Z+5, r25	; 0x05
    a492:	84 83       	std	Z+4, r24	; 0x04
    a494:	0e 94 9a 82 	call	0x10534	; 0x10534 <fprintf_P>
    a498:	ed b7       	in	r30, 0x3d	; 61
    a49a:	fe b7       	in	r31, 0x3e	; 62
    a49c:	36 96       	adiw	r30, 0x06	; 6
    a49e:	0f b6       	in	r0, 0x3f	; 63
    a4a0:	f8 94       	cli
    a4a2:	fe bf       	out	0x3e, r31	; 62
    a4a4:	0f be       	out	0x3f, r0	; 63
    a4a6:	ed bf       	out	0x3d, r30	; 61
  
}
    a4a8:	df 91       	pop	r29
    a4aa:	cf 91       	pop	r28
    a4ac:	1f 91       	pop	r17
    a4ae:	0f 91       	pop	r16
    a4b0:	ff 90       	pop	r15
    a4b2:	ef 90       	pop	r14
    a4b4:	08 95       	ret
    a4b6:	80 91 f6 06 	lds	r24, 0x06F6
    a4ba:	90 91 f7 06 	lds	r25, 0x06F7
    a4be:	d4 cf       	rjmp	.-88     	; 0xa468 <chPrintUnusedStack+0xa6>

0000a4c0 <chPrintStackSizes>:

/*********************************************************************************
 * Print size of all all stacks.
 * @param[in] pr Print stream for output.
********************************************************************************/ 
void chPrintStackSizes(void) {
    a4c0:	ef 92       	push	r14
    a4c2:	ff 92       	push	r15
    a4c4:	0f 93       	push	r16
    a4c6:	1f 93       	push	r17
    a4c8:	cf 93       	push	r28
    a4ca:	df 93       	push	r29
  const thread_config_t *tcp = nil_thd_configs;
  fprintf_P(&usart_out,PSTR(" Stack Sizes: "));	
    a4cc:	00 d0       	rcall	.+0      	; 0xa4ce <chPrintStackSizes+0xe>
    a4ce:	00 d0       	rcall	.+0      	; 0xa4d0 <chPrintStackSizes+0x10>
    a4d0:	0a ec       	ldi	r16, 0xCA	; 202
    a4d2:	16 e0       	ldi	r17, 0x06	; 6
    a4d4:	ad b7       	in	r26, 0x3d	; 61
    a4d6:	be b7       	in	r27, 0x3e	; 62
    a4d8:	12 96       	adiw	r26, 0x02	; 2
    a4da:	1c 93       	st	X, r17
    a4dc:	0e 93       	st	-X, r16
    a4de:	11 97       	sbiw	r26, 0x01	; 1
    a4e0:	8e e2       	ldi	r24, 0x2E	; 46
    a4e2:	9b e0       	ldi	r25, 0x0B	; 11
    a4e4:	14 96       	adiw	r26, 0x04	; 4
    a4e6:	9c 93       	st	X, r25
    a4e8:	8e 93       	st	-X, r24
    a4ea:	13 97       	sbiw	r26, 0x03	; 3
    a4ec:	0e 94 9a 82 	call	0x10534	; 0x10534 <fprintf_P>
  
  while (tcp->wend) {
    a4f0:	20 91 14 06 	lds	r18, 0x0614
    a4f4:	30 91 15 06 	lds	r19, 0x0615
    a4f8:	0f 90       	pop	r0
    a4fa:	0f 90       	pop	r0
    a4fc:	0f 90       	pop	r0
    a4fe:	0f 90       	pop	r0
    a500:	21 15       	cp	r18, r1
    a502:	31 05       	cpc	r19, r1
    a504:	51 f1       	breq	.+84     	; 0xa55a <chPrintStackSizes+0x9a>
    a506:	c2 e1       	ldi	r28, 0x12	; 18
    a508:	d6 e0       	ldi	r29, 0x06	; 6
    a50a:	49 e2       	ldi	r20, 0x29	; 41
    a50c:	e4 2e       	mov	r14, r20
    a50e:	4b e0       	ldi	r20, 0x0B	; 11
    a510:	f4 2e       	mov	r15, r20
    fprintf_P(&usart_out,PSTR("%3d "), tcp->wend - tcp->wbase);
    a512:	00 d0       	rcall	.+0      	; 0xa514 <chPrintStackSizes+0x54>
    a514:	00 d0       	rcall	.+0      	; 0xa516 <chPrintStackSizes+0x56>
    a516:	00 d0       	rcall	.+0      	; 0xa518 <chPrintStackSizes+0x58>
    a518:	ed b7       	in	r30, 0x3d	; 61
    a51a:	fe b7       	in	r31, 0x3e	; 62
    a51c:	31 96       	adiw	r30, 0x01	; 1
    a51e:	ad b7       	in	r26, 0x3d	; 61
    a520:	be b7       	in	r27, 0x3e	; 62
    a522:	12 96       	adiw	r26, 0x02	; 2
    a524:	1c 93       	st	X, r17
    a526:	0e 93       	st	-X, r16
    a528:	11 97       	sbiw	r26, 0x01	; 1
    a52a:	f3 82       	std	Z+3, r15	; 0x03
    a52c:	e2 82       	std	Z+2, r14	; 0x02
    a52e:	88 81       	ld	r24, Y
    a530:	99 81       	ldd	r25, Y+1	; 0x01
    a532:	28 1b       	sub	r18, r24
    a534:	39 0b       	sbc	r19, r25
    a536:	35 83       	std	Z+5, r19	; 0x05
    a538:	24 83       	std	Z+4, r18	; 0x04
    a53a:	0e 94 9a 82 	call	0x10534	; 0x10534 <fprintf_P>
    tcp++;
    a53e:	2a 96       	adiw	r28, 0x0a	; 10
********************************************************************************/ 
void chPrintStackSizes(void) {
  const thread_config_t *tcp = nil_thd_configs;
  fprintf_P(&usart_out,PSTR(" Stack Sizes: "));	
  
  while (tcp->wend) {
    a540:	2a 81       	ldd	r18, Y+2	; 0x02
    a542:	3b 81       	ldd	r19, Y+3	; 0x03
    a544:	ed b7       	in	r30, 0x3d	; 61
    a546:	fe b7       	in	r31, 0x3e	; 62
    a548:	36 96       	adiw	r30, 0x06	; 6
    a54a:	0f b6       	in	r0, 0x3f	; 63
    a54c:	f8 94       	cli
    a54e:	fe bf       	out	0x3e, r31	; 62
    a550:	0f be       	out	0x3f, r0	; 63
    a552:	ed bf       	out	0x3d, r30	; 61
    a554:	21 15       	cp	r18, r1
    a556:	31 05       	cpc	r19, r1
    a558:	e1 f6       	brne	.-72     	; 0xa512 <chPrintStackSizes+0x52>
    fprintf_P(&usart_out,PSTR("%3d "), tcp->wend - tcp->wbase);
    tcp++;
  }
  fprintf_P(&usart_out,PSTR("%d\r\n"), nilHeapIdleSize());
    a55a:	00 d0       	rcall	.+0      	; 0xa55c <chPrintStackSizes+0x9c>
    a55c:	00 d0       	rcall	.+0      	; 0xa55e <chPrintStackSizes+0x9e>
    a55e:	00 d0       	rcall	.+0      	; 0xa560 <chPrintStackSizes+0xa0>
    a560:	ed b7       	in	r30, 0x3d	; 61
    a562:	fe b7       	in	r31, 0x3e	; 62
    a564:	31 96       	adiw	r30, 0x01	; 1
    a566:	ad b7       	in	r26, 0x3d	; 61
    a568:	be b7       	in	r27, 0x3e	; 62
    a56a:	12 96       	adiw	r26, 0x02	; 2
    a56c:	1c 93       	st	X, r17
    a56e:	0e 93       	st	-X, r16
    a570:	11 97       	sbiw	r26, 0x01	; 1
    a572:	84 e2       	ldi	r24, 0x24	; 36
    a574:	9b e0       	ldi	r25, 0x0B	; 11
    a576:	93 83       	std	Z+3, r25	; 0x03
    a578:	82 83       	std	Z+2, r24	; 0x02
    a57a:	80 e0       	ldi	r24, 0x00	; 0
    a57c:	91 e4       	ldi	r25, 0x41	; 65
    a57e:	20 91 f6 06 	lds	r18, 0x06F6
    a582:	30 91 f7 06 	lds	r19, 0x06F7
    a586:	82 1b       	sub	r24, r18
    a588:	93 0b       	sbc	r25, r19
    a58a:	95 83       	std	Z+5, r25	; 0x05
    a58c:	84 83       	std	Z+4, r24	; 0x04
    a58e:	0e 94 9a 82 	call	0x10534	; 0x10534 <fprintf_P>
    a592:	ed b7       	in	r30, 0x3d	; 61
    a594:	fe b7       	in	r31, 0x3e	; 62
    a596:	36 96       	adiw	r30, 0x06	; 6
    a598:	0f b6       	in	r0, 0x3f	; 63
    a59a:	f8 94       	cli
    a59c:	fe bf       	out	0x3e, r31	; 62
    a59e:	0f be       	out	0x3f, r0	; 63
    a5a0:	ed bf       	out	0x3d, r30	; 61
  
}
    a5a2:	df 91       	pop	r29
    a5a4:	cf 91       	pop	r28
    a5a6:	1f 91       	pop	r17
    a5a8:	0f 91       	pop	r16
    a5aa:	ff 90       	pop	r15
    a5ac:	ef 90       	pop	r14
    a5ae:	08 95       	ret

0000a5b0 <Thread14>:
 *********************************************************************************/
THD_FUNCTION(Thread14, arg) {
	(void)arg;
	// initialize the SD card

	tp[13] = chThdGetSelfX();
    a5b0:	80 91 ce 07 	lds	r24, 0x07CE
    a5b4:	90 91 cf 07 	lds	r25, 0x07CF
    a5b8:	90 93 b1 07 	sts	0x07B1, r25
    a5bc:	80 93 b0 07 	sts	0x07B0, r24
    a5c0:	cc eb       	ldi	r28, 0xBC	; 188
    a5c2:	d6 e0       	ldi	r29, 0x06	; 6
    a5c4:	fa e5       	ldi	r31, 0x5A	; 90
    a5c6:	6f 2e       	mov	r6, r31
    a5c8:	f6 e0       	ldi	r31, 0x06	; 6
    a5ca:	7f 2e       	mov	r7, r31
    a5cc:	e9 e4       	ldi	r30, 0x49	; 73
    a5ce:	ae 2e       	mov	r10, r30
    a5d0:	e6 e0       	ldi	r30, 0x06	; 6
    a5d2:	be 2e       	mov	r11, r30
    a5d4:	78 e3       	ldi	r23, 0x38	; 56
    a5d6:	c7 2e       	mov	r12, r23
    a5d8:	76 e0       	ldi	r23, 0x06	; 6
    a5da:	d7 2e       	mov	r13, r23
    a5dc:	67 e2       	ldi	r22, 0x27	; 39
    a5de:	e6 2e       	mov	r14, r22
    a5e0:	66 e0       	ldi	r22, 0x06	; 6
    a5e2:	f6 2e       	mov	r15, r22
		/* Waiting for signal to edit time - transfer via a message*/
		chEvtWaitAnyTimeout((eventmask_t)1, TIME_INFINITE);
		
		chSemWait(&lcdUSE);//grab lcd
		/*switch lcd_context to thread 14*/
		lcd_context = 14;
    a5e4:	5e e0       	ldi	r21, 0x0E	; 14
    a5e6:	95 2e       	mov	r9, r21
	msg_t msg;
	uint8_t time_position;
	
	while (true) {
		/* Waiting for signal to edit time - transfer via a message*/
		chEvtWaitAnyTimeout((eventmask_t)1, TIME_INFINITE);
    a5e8:	81 e0       	ldi	r24, 0x01	; 1
    a5ea:	40 e0       	ldi	r20, 0x00	; 0
    a5ec:	50 e0       	ldi	r21, 0x00	; 0
    a5ee:	60 e0       	ldi	r22, 0x00	; 0
    a5f0:	70 e0       	ldi	r23, 0x00	; 0
    a5f2:	0e 94 b4 08 	call	0x1168	; 0x1168 <chEvtWaitAnyTimeout>
		
		chSemWait(&lcdUSE);//grab lcd
    a5f6:	8d ef       	ldi	r24, 0xFD	; 253
    a5f8:	93 e1       	ldi	r25, 0x13	; 19
    a5fa:	40 e0       	ldi	r20, 0x00	; 0
    a5fc:	50 e0       	ldi	r21, 0x00	; 0
    a5fe:	60 e0       	ldi	r22, 0x00	; 0
    a600:	70 e0       	ldi	r23, 0x00	; 0
    a602:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
		/*switch lcd_context to thread 14*/
		lcd_context = 14;
    a606:	90 92 32 05 	sts	0x0532, r9
		
		//get current time dummy reference & print it and use it as starting point
		chSemWait(&i2cUSE);
    a60a:	80 e0       	ldi	r24, 0x00	; 0
    a60c:	94 e1       	ldi	r25, 0x14	; 20
    a60e:	40 e0       	ldi	r20, 0x00	; 0
    a610:	50 e0       	ldi	r21, 0x00	; 0
    a612:	60 e0       	ldi	r22, 0x00	; 0
    a614:	70 e0       	ldi	r23, 0x00	; 0
    a616:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
		DS3231_getTime(&hr, &min, &s, &am_pm, hr_format); 
    a61a:	00 91 56 05 	lds	r16, 0x0556
    a61e:	10 91 57 05 	lds	r17, 0x0557
    a622:	81 e5       	ldi	r24, 0x51	; 81
    a624:	95 e0       	ldi	r25, 0x05	; 5
    a626:	60 e5       	ldi	r22, 0x50	; 80
    a628:	75 e0       	ldi	r23, 0x05	; 5
    a62a:	47 e4       	ldi	r20, 0x47	; 71
    a62c:	57 e0       	ldi	r21, 0x07	; 7
    a62e:	28 e4       	ldi	r18, 0x48	; 72
    a630:	37 e0       	ldi	r19, 0x07	; 7
    a632:	0e 94 e2 43 	call	0x87c4	; 0x87c4 <DS3231_getTime>
		chSemSignal(&i2cUSE);
    a636:	80 e0       	ldi	r24, 0x00	; 0
    a638:	94 e1       	ldi	r25, 0x14	; 20
    a63a:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
                              
		chSemWait(&spiUSE);
    a63e:	89 e7       	ldi	r24, 0x79	; 121
    a640:	94 e1       	ldi	r25, 0x14	; 20
    a642:	40 e0       	ldi	r20, 0x00	; 0
    a644:	50 e0       	ldi	r21, 0x00	; 0
    a646:	60 e0       	ldi	r22, 0x00	; 0
    a648:	70 e0       	ldi	r23, 0x00	; 0
    a64a:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
		st7735_fill_rect(0, 0, 160, 128, ST7735_COLOR_BLACK);//lcd_clear();
    a64e:	80 e0       	ldi	r24, 0x00	; 0
    a650:	60 e0       	ldi	r22, 0x00	; 0
    a652:	40 ea       	ldi	r20, 0xA0	; 160
    a654:	20 e8       	ldi	r18, 0x80	; 128
    a656:	00 e0       	ldi	r16, 0x00	; 0
    a658:	10 e0       	ldi	r17, 0x00	; 0
    a65a:	0e 94 59 16 	call	0x2cb2	; 0x2cb2 <st7735_fill_rect>
		chSemSignal(&spiUSE);
    a65e:	89 e7       	ldi	r24, 0x79	; 121
    a660:	94 e1       	ldi	r25, 0x14	; 20
    a662:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
		
		chSemWait(&spiUSE); 
    a666:	89 e7       	ldi	r24, 0x79	; 121
    a668:	94 e1       	ldi	r25, 0x14	; 20
    a66a:	40 e0       	ldi	r20, 0x00	; 0
    a66c:	50 e0       	ldi	r21, 0x00	; 0
    a66e:	60 e0       	ldi	r22, 0x00	; 0
    a670:	70 e0       	ldi	r23, 0x00	; 0
    a672:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
		st7735_setCursor(0,50);//lcd_goto_xy(1,1);
    a676:	80 e0       	ldi	r24, 0x00	; 0
    a678:	90 e0       	ldi	r25, 0x00	; 0
    a67a:	62 e3       	ldi	r22, 0x32	; 50
    a67c:	70 e0       	ldi	r23, 0x00	; 0
    a67e:	0e 94 c2 19 	call	0x3384	; 0x3384 <st7735_setCursor>
		if (am_pm==1) {
    a682:	80 91 48 07 	lds	r24, 0x0748
    a686:	90 91 49 07 	lds	r25, 0x0749
    a68a:	01 97       	sbiw	r24, 0x01	; 1
    a68c:	09 f4       	brne	.+2      	; 0xa690 <Thread14+0xe0>
    a68e:	03 c1       	rjmp	.+518    	; 0xa896 <Thread14+0x2e6>
			fprintf_P(&st7735_out, PSTR("%2u:%02u:%02u PM"), hr, min, s);       
		}
		else {
			fprintf_P(&st7735_out, PSTR("%2u:%02u:%02u AM"), hr, min, s);   
    a690:	ad b7       	in	r26, 0x3d	; 61
    a692:	be b7       	in	r27, 0x3e	; 62
    a694:	1a 97       	sbiw	r26, 0x0a	; 10
    a696:	0f b6       	in	r0, 0x3f	; 63
    a698:	f8 94       	cli
    a69a:	be bf       	out	0x3e, r27	; 62
    a69c:	0f be       	out	0x3f, r0	; 63
    a69e:	ad bf       	out	0x3d, r26	; 61
    a6a0:	ed b7       	in	r30, 0x3d	; 61
    a6a2:	fe b7       	in	r31, 0x3e	; 62
    a6a4:	31 96       	adiw	r30, 0x01	; 1
    a6a6:	12 96       	adiw	r26, 0x02	; 2
    a6a8:	dc 93       	st	X, r29
    a6aa:	ce 93       	st	-X, r28
    a6ac:	11 97       	sbiw	r26, 0x01	; 1
    a6ae:	b3 82       	std	Z+3, r11	; 0x03
    a6b0:	a2 82       	std	Z+2, r10	; 0x02
    a6b2:	80 91 51 05 	lds	r24, 0x0551
    a6b6:	84 83       	std	Z+4, r24	; 0x04
    a6b8:	15 82       	std	Z+5, r1	; 0x05
    a6ba:	80 91 50 05 	lds	r24, 0x0550
    a6be:	86 83       	std	Z+6, r24	; 0x06
    a6c0:	17 82       	std	Z+7, r1	; 0x07
    a6c2:	80 91 47 07 	lds	r24, 0x0747
    a6c6:	80 87       	std	Z+8, r24	; 0x08
    a6c8:	11 86       	std	Z+9, r1	; 0x09
    a6ca:	0e 94 9a 82 	call	0x10534	; 0x10534 <fprintf_P>
    a6ce:	8d b7       	in	r24, 0x3d	; 61
    a6d0:	9e b7       	in	r25, 0x3e	; 62
    a6d2:	0a 96       	adiw	r24, 0x0a	; 10
    a6d4:	0f b6       	in	r0, 0x3f	; 63
    a6d6:	f8 94       	cli
    a6d8:	9e bf       	out	0x3e, r25	; 62
    a6da:	0f be       	out	0x3f, r0	; 63
    a6dc:	8d bf       	out	0x3d, r24	; 61
		}	
		chSemSignal(&spiUSE);
    a6de:	89 e7       	ldi	r24, 0x79	; 121
    a6e0:	94 e1       	ldi	r25, 0x14	; 20
    a6e2:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
    a6e6:	11 e0       	ldi	r17, 0x01	; 1
    a6e8:	50 c0       	rjmp	.+160    	; 0xa78a <Thread14+0x1da>
			
			if(chEvtWaitAnyTimeout((eventmask_t)2, TIME_IMMEDIATE) == 2){
				time_position = lcd_context_count[13];
			}
			
			if(chEvtWaitAnyTimeout((eventmask_t)4, TIME_IMMEDIATE) == 4){
    a6ea:	84 e0       	ldi	r24, 0x04	; 4
    a6ec:	4f ef       	ldi	r20, 0xFF	; 255
    a6ee:	5f ef       	ldi	r21, 0xFF	; 255
    a6f0:	6f ef       	ldi	r22, 0xFF	; 255
    a6f2:	7f ef       	ldi	r23, 0xFF	; 255
    a6f4:	0e 94 b4 08 	call	0x1168	; 0x1168 <chEvtWaitAnyTimeout>
    a6f8:	84 30       	cpi	r24, 0x04	; 4
    a6fa:	09 f4       	brne	.+2      	; 0xa6fe <Thread14+0x14e>
    a6fc:	6f c0       	rjmp	.+222    	; 0xa7dc <Thread14+0x22c>
						am_pm = 0;
					}	
				}
			}
			//print out time
			chSemWait(&spiUSE);
    a6fe:	89 e7       	ldi	r24, 0x79	; 121
    a700:	94 e1       	ldi	r25, 0x14	; 20
    a702:	40 e0       	ldi	r20, 0x00	; 0
    a704:	50 e0       	ldi	r21, 0x00	; 0
    a706:	60 e0       	ldi	r22, 0x00	; 0
    a708:	70 e0       	ldi	r23, 0x00	; 0
    a70a:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
			st7735_setCursor(0,50);//lcd_goto_xy(1,1);
    a70e:	80 e0       	ldi	r24, 0x00	; 0
    a710:	90 e0       	ldi	r25, 0x00	; 0
    a712:	62 e3       	ldi	r22, 0x32	; 50
    a714:	70 e0       	ldi	r23, 0x00	; 0
    a716:	0e 94 c2 19 	call	0x3384	; 0x3384 <st7735_setCursor>
			if (am_pm==1) {
    a71a:	80 91 48 07 	lds	r24, 0x0748
    a71e:	90 91 49 07 	lds	r25, 0x0749
    a722:	01 97       	sbiw	r24, 0x01	; 1
    a724:	09 f4       	brne	.+2      	; 0xa728 <Thread14+0x178>
    a726:	48 c0       	rjmp	.+144    	; 0xa7b8 <Thread14+0x208>
				fprintf_P(&st7735_out, PSTR("%2u:%02u:%02u PM"), hr, min, s);    
			}
			else {
				fprintf_P(&st7735_out, PSTR("%2u:%02u:%02u AM"), hr, min, s);   
    a728:	ad b7       	in	r26, 0x3d	; 61
    a72a:	be b7       	in	r27, 0x3e	; 62
    a72c:	1a 97       	sbiw	r26, 0x0a	; 10
    a72e:	0f b6       	in	r0, 0x3f	; 63
    a730:	f8 94       	cli
    a732:	be bf       	out	0x3e, r27	; 62
    a734:	0f be       	out	0x3f, r0	; 63
    a736:	ad bf       	out	0x3d, r26	; 61
    a738:	ed b7       	in	r30, 0x3d	; 61
    a73a:	fe b7       	in	r31, 0x3e	; 62
    a73c:	31 96       	adiw	r30, 0x01	; 1
    a73e:	12 96       	adiw	r26, 0x02	; 2
    a740:	dc 93       	st	X, r29
    a742:	ce 93       	st	-X, r28
    a744:	11 97       	sbiw	r26, 0x01	; 1
    a746:	f3 82       	std	Z+3, r15	; 0x03
    a748:	e2 82       	std	Z+2, r14	; 0x02
    a74a:	80 91 51 05 	lds	r24, 0x0551
    a74e:	84 83       	std	Z+4, r24	; 0x04
    a750:	15 82       	std	Z+5, r1	; 0x05
    a752:	80 91 50 05 	lds	r24, 0x0550
    a756:	86 83       	std	Z+6, r24	; 0x06
    a758:	17 82       	std	Z+7, r1	; 0x07
    a75a:	80 91 47 07 	lds	r24, 0x0747
    a75e:	80 87       	std	Z+8, r24	; 0x08
    a760:	11 86       	std	Z+9, r1	; 0x09
    a762:	0e 94 9a 82 	call	0x10534	; 0x10534 <fprintf_P>
    a766:	8d b7       	in	r24, 0x3d	; 61
    a768:	9e b7       	in	r25, 0x3e	; 62
    a76a:	0a 96       	adiw	r24, 0x0a	; 10
    a76c:	0f b6       	in	r0, 0x3f	; 63
    a76e:	f8 94       	cli
    a770:	9e bf       	out	0x3e, r25	; 62
    a772:	0f be       	out	0x3f, r0	; 63
    a774:	8d bf       	out	0x3d, r24	; 61
			}	
			chSemSignal(&spiUSE);
    a776:	89 e7       	ldi	r24, 0x79	; 121
    a778:	94 e1       	ldi	r25, 0x14	; 20
    a77a:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
			
			//give up slot
			chThdSleepMilliseconds(100);
    a77e:	60 ed       	ldi	r22, 0xD0	; 208
    a780:	77 e0       	ldi	r23, 0x07	; 7
    a782:	80 e0       	ldi	r24, 0x00	; 0
    a784:	90 e0       	ldi	r25, 0x00	; 0
    a786:	0e 94 f4 08 	call	0x11e8	; 0x11e8 <chThdSleep>
		chSemSignal(&spiUSE);
		
		time_position = 1;
		while(true) {
            
			if(chEvtWaitAnyTimeout((eventmask_t)8, TIME_IMMEDIATE) == 8){
    a78a:	88 e0       	ldi	r24, 0x08	; 8
    a78c:	4f ef       	ldi	r20, 0xFF	; 255
    a78e:	5f ef       	ldi	r21, 0xFF	; 255
    a790:	6f ef       	ldi	r22, 0xFF	; 255
    a792:	7f ef       	ldi	r23, 0xFF	; 255
    a794:	0e 94 b4 08 	call	0x1168	; 0x1168 <chEvtWaitAnyTimeout>
    a798:	88 30       	cpi	r24, 0x08	; 8
    a79a:	09 f4       	brne	.+2      	; 0xa79e <Thread14+0x1ee>
    a79c:	47 c0       	rjmp	.+142    	; 0xa82c <Thread14+0x27c>
				chSemSignal(&i2cUSE);
				chSemSignal(&lcdUSE); /*thread 14 gives back the LCD*/
				break;
			}
			
			if(chEvtWaitAnyTimeout((eventmask_t)2, TIME_IMMEDIATE) == 2){
    a79e:	82 e0       	ldi	r24, 0x02	; 2
    a7a0:	4f ef       	ldi	r20, 0xFF	; 255
    a7a2:	5f ef       	ldi	r21, 0xFF	; 255
    a7a4:	6f ef       	ldi	r22, 0xFF	; 255
    a7a6:	7f ef       	ldi	r23, 0xFF	; 255
    a7a8:	0e 94 b4 08 	call	0x1168	; 0x1168 <chEvtWaitAnyTimeout>
    a7ac:	82 30       	cpi	r24, 0x02	; 2
    a7ae:	09 f0       	breq	.+2      	; 0xa7b2 <Thread14+0x202>
    a7b0:	9c cf       	rjmp	.-200    	; 0xa6ea <Thread14+0x13a>
				time_position = lcd_context_count[13];
    a7b2:	10 91 40 05 	lds	r17, 0x0540
    a7b6:	99 cf       	rjmp	.-206    	; 0xa6ea <Thread14+0x13a>
			}
			//print out time
			chSemWait(&spiUSE);
			st7735_setCursor(0,50);//lcd_goto_xy(1,1);
			if (am_pm==1) {
				fprintf_P(&st7735_out, PSTR("%2u:%02u:%02u PM"), hr, min, s);    
    a7b8:	ad b7       	in	r26, 0x3d	; 61
    a7ba:	be b7       	in	r27, 0x3e	; 62
    a7bc:	1a 97       	sbiw	r26, 0x0a	; 10
    a7be:	0f b6       	in	r0, 0x3f	; 63
    a7c0:	f8 94       	cli
    a7c2:	be bf       	out	0x3e, r27	; 62
    a7c4:	0f be       	out	0x3f, r0	; 63
    a7c6:	ad bf       	out	0x3d, r26	; 61
    a7c8:	ed b7       	in	r30, 0x3d	; 61
    a7ca:	fe b7       	in	r31, 0x3e	; 62
    a7cc:	31 96       	adiw	r30, 0x01	; 1
    a7ce:	12 96       	adiw	r26, 0x02	; 2
    a7d0:	dc 93       	st	X, r29
    a7d2:	ce 93       	st	-X, r28
    a7d4:	11 97       	sbiw	r26, 0x01	; 1
    a7d6:	d3 82       	std	Z+3, r13	; 0x03
    a7d8:	c2 82       	std	Z+2, r12	; 0x02
    a7da:	b7 cf       	rjmp	.-146    	; 0xa74a <Thread14+0x19a>
			if(chEvtWaitAnyTimeout((eventmask_t)2, TIME_IMMEDIATE) == 2){
				time_position = lcd_context_count[13];
			}
			
			if(chEvtWaitAnyTimeout((eventmask_t)4, TIME_IMMEDIATE) == 4){
				if (time_position == 1) {
    a7dc:	11 30       	cpi	r17, 0x01	; 1
    a7de:	81 f0       	breq	.+32     	; 0xa800 <Thread14+0x250>
					hr++;
					if (hr>12) {
						hr = 1;
					}	
				}
				if (time_position == 2) {
    a7e0:	12 30       	cpi	r17, 0x02	; 2
    a7e2:	c9 f0       	breq	.+50     	; 0xa816 <Thread14+0x266>
					min++;
					if (min>59) {
						min = 0;
					}	
				}
				if (time_position == 3) {
    a7e4:	13 30       	cpi	r17, 0x03	; 3
    a7e6:	09 f0       	breq	.+2      	; 0xa7ea <Thread14+0x23a>
    a7e8:	42 c0       	rjmp	.+132    	; 0xa86e <Thread14+0x2be>
					s++;
    a7ea:	80 91 47 07 	lds	r24, 0x0747
    a7ee:	8f 5f       	subi	r24, 0xFF	; 255
    a7f0:	80 93 47 07 	sts	0x0747, r24
					if (s>59) {
    a7f4:	8c 33       	cpi	r24, 0x3C	; 60
    a7f6:	08 f4       	brcc	.+2      	; 0xa7fa <Thread14+0x24a>
    a7f8:	82 cf       	rjmp	.-252    	; 0xa6fe <Thread14+0x14e>
						s = 0;
    a7fa:	10 92 47 07 	sts	0x0747, r1
    a7fe:	7f cf       	rjmp	.-258    	; 0xa6fe <Thread14+0x14e>
				time_position = lcd_context_count[13];
			}
			
			if(chEvtWaitAnyTimeout((eventmask_t)4, TIME_IMMEDIATE) == 4){
				if (time_position == 1) {
					hr++;
    a800:	80 91 51 05 	lds	r24, 0x0551
    a804:	8f 5f       	subi	r24, 0xFF	; 255
    a806:	80 93 51 05 	sts	0x0551, r24
					if (hr>12) {
    a80a:	8d 30       	cpi	r24, 0x0D	; 13
    a80c:	08 f4       	brcc	.+2      	; 0xa810 <Thread14+0x260>
    a80e:	77 cf       	rjmp	.-274    	; 0xa6fe <Thread14+0x14e>
						hr = 1;
    a810:	10 93 51 05 	sts	0x0551, r17
    a814:	74 cf       	rjmp	.-280    	; 0xa6fe <Thread14+0x14e>
					}	
				}
				if (time_position == 2) {
					min++;
    a816:	80 91 50 05 	lds	r24, 0x0550
    a81a:	8f 5f       	subi	r24, 0xFF	; 255
    a81c:	80 93 50 05 	sts	0x0550, r24
					if (min>59) {
    a820:	8c 33       	cpi	r24, 0x3C	; 60
    a822:	08 f4       	brcc	.+2      	; 0xa826 <Thread14+0x276>
    a824:	6c cf       	rjmp	.-296    	; 0xa6fe <Thread14+0x14e>
						min = 0;
    a826:	10 92 50 05 	sts	0x0550, r1
    a82a:	69 cf       	rjmp	.-302    	; 0xa6fe <Thread14+0x14e>
		time_position = 1;
		while(true) {
            
			if(chEvtWaitAnyTimeout((eventmask_t)8, TIME_IMMEDIATE) == 8){
				//write out time back to DS3231
				chSemWait(&i2cUSE);
    a82c:	80 e0       	ldi	r24, 0x00	; 0
    a82e:	94 e1       	ldi	r25, 0x14	; 20
    a830:	40 e0       	ldi	r20, 0x00	; 0
    a832:	50 e0       	ldi	r21, 0x00	; 0
    a834:	60 e0       	ldi	r22, 0x00	; 0
    a836:	70 e0       	ldi	r23, 0x00	; 0
    a838:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
				DS3231_setTime(hr, min, s, am_pm, hr_format);  
    a83c:	20 91 48 07 	lds	r18, 0x0748
    a840:	30 91 49 07 	lds	r19, 0x0749
    a844:	00 91 56 05 	lds	r16, 0x0556
    a848:	10 91 57 05 	lds	r17, 0x0557
    a84c:	80 91 51 05 	lds	r24, 0x0551
    a850:	60 91 50 05 	lds	r22, 0x0550
    a854:	40 91 47 07 	lds	r20, 0x0747
    a858:	0e 94 f4 42 	call	0x85e8	; 0x85e8 <DS3231_setTime>
				chSemSignal(&i2cUSE);
    a85c:	80 e0       	ldi	r24, 0x00	; 0
    a85e:	94 e1       	ldi	r25, 0x14	; 20
    a860:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
				chSemSignal(&lcdUSE); /*thread 14 gives back the LCD*/
    a864:	8d ef       	ldi	r24, 0xFD	; 253
    a866:	93 e1       	ldi	r25, 0x13	; 19
    a868:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
    a86c:	bd ce       	rjmp	.-646    	; 0xa5e8 <Thread14+0x38>
					s++;
					if (s>59) {
						s = 0;
					}
				}	
				if (time_position == 4) {
    a86e:	14 30       	cpi	r17, 0x04	; 4
    a870:	09 f0       	breq	.+2      	; 0xa874 <Thread14+0x2c4>
    a872:	45 cf       	rjmp	.-374    	; 0xa6fe <Thread14+0x14e>
					am_pm++;
    a874:	80 91 48 07 	lds	r24, 0x0748
    a878:	90 91 49 07 	lds	r25, 0x0749
    a87c:	01 96       	adiw	r24, 0x01	; 1
    a87e:	90 93 49 07 	sts	0x0749, r25
    a882:	80 93 48 07 	sts	0x0748, r24
					if (am_pm>1) {
    a886:	02 97       	sbiw	r24, 0x02	; 2
    a888:	0c f4       	brge	.+2      	; 0xa88c <Thread14+0x2dc>
    a88a:	39 cf       	rjmp	.-398    	; 0xa6fe <Thread14+0x14e>
						am_pm = 0;
    a88c:	10 92 49 07 	sts	0x0749, r1
    a890:	10 92 48 07 	sts	0x0748, r1
    a894:	34 cf       	rjmp	.-408    	; 0xa6fe <Thread14+0x14e>
		chSemSignal(&spiUSE);
		
		chSemWait(&spiUSE); 
		st7735_setCursor(0,50);//lcd_goto_xy(1,1);
		if (am_pm==1) {
			fprintf_P(&st7735_out, PSTR("%2u:%02u:%02u PM"), hr, min, s);       
    a896:	8d b7       	in	r24, 0x3d	; 61
    a898:	9e b7       	in	r25, 0x3e	; 62
    a89a:	0a 97       	sbiw	r24, 0x0a	; 10
    a89c:	0f b6       	in	r0, 0x3f	; 63
    a89e:	f8 94       	cli
    a8a0:	9e bf       	out	0x3e, r25	; 62
    a8a2:	0f be       	out	0x3f, r0	; 63
    a8a4:	8d bf       	out	0x3d, r24	; 61
    a8a6:	ed b7       	in	r30, 0x3d	; 61
    a8a8:	fe b7       	in	r31, 0x3e	; 62
    a8aa:	31 96       	adiw	r30, 0x01	; 1
    a8ac:	ad b7       	in	r26, 0x3d	; 61
    a8ae:	be b7       	in	r27, 0x3e	; 62
    a8b0:	12 96       	adiw	r26, 0x02	; 2
    a8b2:	dc 93       	st	X, r29
    a8b4:	ce 93       	st	-X, r28
    a8b6:	11 97       	sbiw	r26, 0x01	; 1
    a8b8:	73 82       	std	Z+3, r7	; 0x03
    a8ba:	62 82       	std	Z+2, r6	; 0x02
    a8bc:	fa ce       	rjmp	.-524    	; 0xa6b2 <Thread14+0x102>

0000a8be <Thread13>:
	uint16_t average = 0;
	//setup ADC
	
	
	// AREF = AVcc
    ADMUX = (1<<REFS0);
    a8be:	80 e4       	ldi	r24, 0x40	; 64
    a8c0:	80 93 7c 00 	sts	0x007C, r24
    // ADC Enable and prescaler of 128, 16000000/128 = 125000
    ADCSRA = (1<<ADEN)|(1<<ADPS2)|(1<<ADPS1)|(1<<ADPS0);
    a8c4:	87 e8       	ldi	r24, 0x87	; 135
    a8c6:	80 93 7a 00 	sts	0x007A, r24
	chThdSleepMilliseconds(200);
    a8ca:	60 ea       	ldi	r22, 0xA0	; 160
    a8cc:	7f e0       	ldi	r23, 0x0F	; 15
    a8ce:	80 e0       	ldi	r24, 0x00	; 0
    a8d0:	90 e0       	ldi	r25, 0x00	; 0
    a8d2:	0e 94 f4 08 	call	0x11e8	; 0x11e8 <chThdSleep>
	// select the corresponding channel 0~7
	ADMUX = (ADMUX & 0xF8)|ch;     // clears the bottom 3 bits before ORing	
    a8d6:	80 91 7c 00 	lds	r24, 0x007C
    a8da:	88 7f       	andi	r24, 0xF8	; 248
    a8dc:	85 60       	ori	r24, 0x05	; 5
    a8de:	80 93 7c 00 	sts	0x007C, r24
    a8e2:	10 e0       	ldi	r17, 0x00	; 0
    a8e4:	c0 e0       	ldi	r28, 0x00	; 0
    a8e6:	d0 e0       	ldi	r29, 0x00	; 0
	
	
	while (1) {	
	count ++;
    a8e8:	1f 5f       	subi	r17, 0xFF	; 255
    
	// start single conversion
    // write '1' to ADSC
    ADCSRA |= (1<<ADSC);
    a8ea:	80 91 7a 00 	lds	r24, 0x007A
    a8ee:	80 64       	ori	r24, 0x40	; 64
    a8f0:	80 93 7a 00 	sts	0x007A, r24

    // wait for conversion to complete
    // ADSC becomes '0' again
    // till then, run loop continuously
    while(ADCSRA & (1<<ADSC)) chThdSleepMilliseconds(2);
    a8f4:	80 91 7a 00 	lds	r24, 0x007A
    a8f8:	86 ff       	sbrs	r24, 6
    a8fa:	0a c0       	rjmp	.+20     	; 0xa910 <Thread13+0x52>
    a8fc:	68 e2       	ldi	r22, 0x28	; 40
    a8fe:	70 e0       	ldi	r23, 0x00	; 0
    a900:	80 e0       	ldi	r24, 0x00	; 0
    a902:	90 e0       	ldi	r25, 0x00	; 0
    a904:	0e 94 f4 08 	call	0x11e8	; 0x11e8 <chThdSleep>
    a908:	80 91 7a 00 	lds	r24, 0x007A
    a90c:	86 fd       	sbrc	r24, 6
    a90e:	f6 cf       	rjmp	.-20     	; 0xa8fc <Thread13+0x3e>
	average += ADC;
    a910:	80 91 78 00 	lds	r24, 0x0078
    a914:	90 91 79 00 	lds	r25, 0x0079
    a918:	c8 0f       	add	r28, r24
    a91a:	d9 1f       	adc	r29, r25
	
	if (count > 30) {
    a91c:	1f 31       	cpi	r17, 0x1F	; 31
    a91e:	f8 f0       	brcs	.+62     	; 0xa95e <Thread13+0xa0>
		average = average/(uint16_t)count;
		battery_average = 660*(uint32_t)average/1024;
    a920:	ce 01       	movw	r24, r28
    a922:	61 2f       	mov	r22, r17
    a924:	70 e0       	ldi	r23, 0x00	; 0
    a926:	0e 94 e6 7f 	call	0xffcc	; 0xffcc <__udivmodhi4>
    a92a:	80 e0       	ldi	r24, 0x00	; 0
    a92c:	90 e0       	ldi	r25, 0x00	; 0
    a92e:	24 e9       	ldi	r18, 0x94	; 148
    a930:	32 e0       	ldi	r19, 0x02	; 2
    a932:	40 e0       	ldi	r20, 0x00	; 0
    a934:	50 e0       	ldi	r21, 0x00	; 0
    a936:	0e 94 bb 7f 	call	0xff76	; 0xff76 <__mulsi3>
    a93a:	aa e0       	ldi	r26, 0x0A	; 10
    a93c:	96 95       	lsr	r25
    a93e:	87 95       	ror	r24
    a940:	77 95       	ror	r23
    a942:	67 95       	ror	r22
    a944:	aa 95       	dec	r26
    a946:	d1 f7       	brne	.-12     	; 0xa93c <Thread13+0x7e>
    a948:	60 93 43 07 	sts	0x0743, r22
    a94c:	70 93 44 07 	sts	0x0744, r23
    a950:	80 93 45 07 	sts	0x0745, r24
    a954:	90 93 46 07 	sts	0x0746, r25
    a958:	10 e0       	ldi	r17, 0x00	; 0
    a95a:	c0 e0       	ldi	r28, 0x00	; 0
    a95c:	d0 e0       	ldi	r29, 0x00	; 0
		average = 0;
		count = 0;
	}	
	
	chThdSleepMilliseconds(200);
    a95e:	60 ea       	ldi	r22, 0xA0	; 160
    a960:	7f e0       	ldi	r23, 0x0F	; 15
    a962:	80 e0       	ldi	r24, 0x00	; 0
    a964:	90 e0       	ldi	r25, 0x00	; 0
    a966:	0e 94 f4 08 	call	0x11e8	; 0x11e8 <chThdSleep>
    a96a:	be cf       	rjmp	.-132    	; 0xa8e8 <Thread13+0x2a>

0000a96c <Thread9>:
}//THREAD8

/*********************************************************************************
 * Thread 9 - Show Semaphore Data
 *********************************************************************************/
THD_FUNCTION(Thread9, arg) {
    a96c:	df 93       	push	r29
    a96e:	cf 93       	push	r28
    a970:	0f 92       	push	r0
    a972:	cd b7       	in	r28, 0x3d	; 61
    a974:	de b7       	in	r29, 0x3e	; 62
	(void)arg;
	uint32_t count = 0;
	uint8_t on_off = 0;
	tp[8] = chThdGetSelfX();
    a976:	80 91 ce 07 	lds	r24, 0x07CE
    a97a:	90 91 cf 07 	lds	r25, 0x07CF
    a97e:	90 93 a7 07 	sts	0x07A7, r25
    a982:	80 93 a6 07 	sts	0x07A6, r24
	
	// initialize the direction of PORTC LEDs #6 to be an output
    set_output(DDRC, PC2);
    a986:	3a 9a       	sbi	0x07, 2	; 7
    set_output(DDRC, PC3);
    a988:	3b 9a       	sbi	0x07, 3	; 7
	output_high(PORTC, PC2);
    a98a:	42 9a       	sbi	0x08, 2	; 8
	output_high(PORTC, PC3);
    a98c:	43 9a       	sbi	0x08, 3	; 8
    a98e:	cc 24       	eor	r12, r12
    a990:	dd 24       	eor	r13, r13
    a992:	76 01       	movw	r14, r12
    a994:	19 82       	std	Y+1, r1	; 0x01
    a996:	8c eb       	ldi	r24, 0xBC	; 188
    a998:	48 2e       	mov	r4, r24
    a99a:	86 e0       	ldi	r24, 0x06	; 6
    a99c:	58 2e       	mov	r5, r24
    a99e:	09 ea       	ldi	r16, 0xA9	; 169
    a9a0:	a0 2e       	mov	r10, r16
    a9a2:	08 e0       	ldi	r16, 0x08	; 8
    a9a4:	b0 2e       	mov	r11, r16
    a9a6:	1d e9       	ldi	r17, 0x9D	; 157
    a9a8:	81 2e       	mov	r8, r17
    a9aa:	18 e0       	ldi	r17, 0x08	; 8
    a9ac:	91 2e       	mov	r9, r17
	
	while (true) {
		chEvtWaitAnyTimeout((eventmask_t)1, TIME_INFINITE);
		chSemWait(&lcdUSE);
		thread_internal_started[8]=1;
		lcd_context = 9;
    a9ae:	b9 e0       	ldi	r27, 0x09	; 9
    a9b0:	7b 2e       	mov	r7, r27
    set_output(DDRC, PC3);
	output_high(PORTC, PC2);
	output_high(PORTC, PC3);
	
	while (true) {
		chEvtWaitAnyTimeout((eventmask_t)1, TIME_INFINITE);
    a9b2:	81 e0       	ldi	r24, 0x01	; 1
    a9b4:	40 e0       	ldi	r20, 0x00	; 0
    a9b6:	50 e0       	ldi	r21, 0x00	; 0
    a9b8:	60 e0       	ldi	r22, 0x00	; 0
    a9ba:	70 e0       	ldi	r23, 0x00	; 0
    a9bc:	0e 94 b4 08 	call	0x1168	; 0x1168 <chEvtWaitAnyTimeout>
		chSemWait(&lcdUSE);
    a9c0:	8d ef       	ldi	r24, 0xFD	; 253
    a9c2:	93 e1       	ldi	r25, 0x13	; 19
    a9c4:	40 e0       	ldi	r20, 0x00	; 0
    a9c6:	50 e0       	ldi	r21, 0x00	; 0
    a9c8:	60 e0       	ldi	r22, 0x00	; 0
    a9ca:	70 e0       	ldi	r23, 0x00	; 0
    a9cc:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
		thread_internal_started[8]=1;
    a9d0:	81 e0       	ldi	r24, 0x01	; 1
    a9d2:	80 93 2f 07 	sts	0x072F, r24
		lcd_context = 9;
    a9d6:	70 92 32 05 	sts	0x0532, r7
		chSemWait(&spiUSE);
    a9da:	89 e7       	ldi	r24, 0x79	; 121
    a9dc:	94 e1       	ldi	r25, 0x14	; 20
    a9de:	40 e0       	ldi	r20, 0x00	; 0
    a9e0:	50 e0       	ldi	r21, 0x00	; 0
    a9e2:	60 e0       	ldi	r22, 0x00	; 0
    a9e4:	70 e0       	ldi	r23, 0x00	; 0
    a9e6:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
		st7735_fill_rect(0, 0, 160, 128, ST7735_COLOR_BLACK);//lcd_clear();
    a9ea:	80 e0       	ldi	r24, 0x00	; 0
    a9ec:	60 e0       	ldi	r22, 0x00	; 0
    a9ee:	40 ea       	ldi	r20, 0xA0	; 160
    a9f0:	20 e8       	ldi	r18, 0x80	; 128
    a9f2:	00 e0       	ldi	r16, 0x00	; 0
    a9f4:	10 e0       	ldi	r17, 0x00	; 0
    a9f6:	0e 94 59 16 	call	0x2cb2	; 0x2cb2 <st7735_fill_rect>
		chSemSignal(&spiUSE);
    a9fa:	89 e7       	ldi	r24, 0x79	; 121
    a9fc:	94 e1       	ldi	r25, 0x14	; 20
    a9fe:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
    aa02:	0e c0       	rjmp	.+28     	; 0xaa20 <Thread9+0xb4>
			if (on_off ==1) {
				output_high(PORTC, PC3); 
				on_off = 0;
			} 
			else {
				output_low(PORTC, PC3); on_off = 1; 
    aa04:	43 98       	cbi	0x08, 3	; 8
				count++;
    aa06:	08 94       	sec
    aa08:	c1 1c       	adc	r12, r1
    aa0a:	d1 1c       	adc	r13, r1
    aa0c:	e1 1c       	adc	r14, r1
    aa0e:	f1 1c       	adc	r15, r1
    aa10:	81 e0       	ldi	r24, 0x01	; 1
    aa12:	89 83       	std	Y+1, r24	; 0x01
			}
			chThdSleepMilliseconds(500);
    aa14:	60 e1       	ldi	r22, 0x10	; 16
    aa16:	77 e2       	ldi	r23, 0x27	; 39
    aa18:	80 e0       	ldi	r24, 0x00	; 0
    aa1a:	90 e0       	ldi	r25, 0x00	; 0
    aa1c:	0e 94 f4 08 	call	0x11e8	; 0x11e8 <chThdSleep>
		chSemWait(&spiUSE);
		st7735_fill_rect(0, 0, 160, 128, ST7735_COLOR_BLACK);//lcd_clear();
		chSemSignal(&spiUSE);
		
		while(true) {
            if(chEvtWaitAnyTimeout((eventmask_t)2, TIME_IMMEDIATE) == 2){
    aa20:	82 e0       	ldi	r24, 0x02	; 2
    aa22:	4f ef       	ldi	r20, 0xFF	; 255
    aa24:	5f ef       	ldi	r21, 0xFF	; 255
    aa26:	6f ef       	ldi	r22, 0xFF	; 255
    aa28:	7f ef       	ldi	r23, 0xFF	; 255
    aa2a:	0e 94 b4 08 	call	0x1168	; 0x1168 <chEvtWaitAnyTimeout>
    aa2e:	82 30       	cpi	r24, 0x02	; 2
    aa30:	09 f4       	brne	.+2      	; 0xaa34 <Thread9+0xc8>
    aa32:	63 c0       	rjmp	.+198    	; 0xaafa <Thread9+0x18e>
				output_high(PORTC, PC3); /*stop the LEDS*/
				chSemSignal(&lcdUSE);/*thread 9 releases LCD*/
				break;
				}
			if (lcd_context == 9){
    aa34:	80 91 32 05 	lds	r24, 0x0532
    aa38:	89 30       	cpi	r24, 0x09	; 9
    aa3a:	31 f0       	breq	.+12     	; 0xaa48 <Thread9+0xdc>
				fprintf_P(&st7735_out, PSTR("count:%u"), count); 
				st7735_setCursor(5,20);//lcd_goto_xy(1,2);
				fprintf_P(&st7735_out,PSTR("LCD SEM:%2d"), lcdUSE.cnt);
				chSemSignal(&spiUSE);
			}
			if (on_off ==1) {
    aa3c:	f9 81       	ldd	r31, Y+1	; 0x01
    aa3e:	f1 30       	cpi	r31, 0x01	; 1
    aa40:	09 f7       	brne	.-62     	; 0xaa04 <Thread9+0x98>
				output_high(PORTC, PC3); 
    aa42:	43 9a       	sbi	0x08, 3	; 8
    aa44:	19 82       	std	Y+1, r1	; 0x01
    aa46:	e6 cf       	rjmp	.-52     	; 0xaa14 <Thread9+0xa8>
				output_high(PORTC, PC3); /*stop the LEDS*/
				chSemSignal(&lcdUSE);/*thread 9 releases LCD*/
				break;
				}
			if (lcd_context == 9){
				chSemWait(&spiUSE);
    aa48:	89 e7       	ldi	r24, 0x79	; 121
    aa4a:	94 e1       	ldi	r25, 0x14	; 20
    aa4c:	40 e0       	ldi	r20, 0x00	; 0
    aa4e:	50 e0       	ldi	r21, 0x00	; 0
    aa50:	60 e0       	ldi	r22, 0x00	; 0
    aa52:	70 e0       	ldi	r23, 0x00	; 0
    aa54:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
				st7735_setCursor(5,10);//lcd_goto_xy(1,1);
    aa58:	85 e0       	ldi	r24, 0x05	; 5
    aa5a:	90 e0       	ldi	r25, 0x00	; 0
    aa5c:	6a e0       	ldi	r22, 0x0A	; 10
    aa5e:	70 e0       	ldi	r23, 0x00	; 0
    aa60:	0e 94 c2 19 	call	0x3384	; 0x3384 <st7735_setCursor>
				fprintf_P(&st7735_out, PSTR("count:%u"), count); 
    aa64:	8d b7       	in	r24, 0x3d	; 61
    aa66:	9e b7       	in	r25, 0x3e	; 62
    aa68:	08 97       	sbiw	r24, 0x08	; 8
    aa6a:	0f b6       	in	r0, 0x3f	; 63
    aa6c:	f8 94       	cli
    aa6e:	9e bf       	out	0x3e, r25	; 62
    aa70:	0f be       	out	0x3f, r0	; 63
    aa72:	8d bf       	out	0x3d, r24	; 61
    aa74:	ed b7       	in	r30, 0x3d	; 61
    aa76:	fe b7       	in	r31, 0x3e	; 62
    aa78:	31 96       	adiw	r30, 0x01	; 1
    aa7a:	ad b7       	in	r26, 0x3d	; 61
    aa7c:	be b7       	in	r27, 0x3e	; 62
    aa7e:	12 96       	adiw	r26, 0x02	; 2
    aa80:	5c 92       	st	X, r5
    aa82:	4e 92       	st	-X, r4
    aa84:	11 97       	sbiw	r26, 0x01	; 1
    aa86:	b3 82       	std	Z+3, r11	; 0x03
    aa88:	a2 82       	std	Z+2, r10	; 0x02
    aa8a:	c4 82       	std	Z+4, r12	; 0x04
    aa8c:	d5 82       	std	Z+5, r13	; 0x05
    aa8e:	e6 82       	std	Z+6, r14	; 0x06
    aa90:	f7 82       	std	Z+7, r15	; 0x07
    aa92:	0e 94 9a 82 	call	0x10534	; 0x10534 <fprintf_P>
				st7735_setCursor(5,20);//lcd_goto_xy(1,2);
    aa96:	ed b7       	in	r30, 0x3d	; 61
    aa98:	fe b7       	in	r31, 0x3e	; 62
    aa9a:	38 96       	adiw	r30, 0x08	; 8
    aa9c:	0f b6       	in	r0, 0x3f	; 63
    aa9e:	f8 94       	cli
    aaa0:	fe bf       	out	0x3e, r31	; 62
    aaa2:	0f be       	out	0x3f, r0	; 63
    aaa4:	ed bf       	out	0x3d, r30	; 61
    aaa6:	85 e0       	ldi	r24, 0x05	; 5
    aaa8:	90 e0       	ldi	r25, 0x00	; 0
    aaaa:	64 e1       	ldi	r22, 0x14	; 20
    aaac:	70 e0       	ldi	r23, 0x00	; 0
    aaae:	0e 94 c2 19 	call	0x3384	; 0x3384 <st7735_setCursor>
				fprintf_P(&st7735_out,PSTR("LCD SEM:%2d"), lcdUSE.cnt);
    aab2:	80 91 fd 13 	lds	r24, 0x13FD
    aab6:	00 d0       	rcall	.+0      	; 0xaab8 <Thread9+0x14c>
    aab8:	00 d0       	rcall	.+0      	; 0xaaba <Thread9+0x14e>
    aaba:	00 d0       	rcall	.+0      	; 0xaabc <Thread9+0x150>
    aabc:	ed b7       	in	r30, 0x3d	; 61
    aabe:	fe b7       	in	r31, 0x3e	; 62
    aac0:	31 96       	adiw	r30, 0x01	; 1
    aac2:	ad b7       	in	r26, 0x3d	; 61
    aac4:	be b7       	in	r27, 0x3e	; 62
    aac6:	12 96       	adiw	r26, 0x02	; 2
    aac8:	5c 92       	st	X, r5
    aaca:	4e 92       	st	-X, r4
    aacc:	11 97       	sbiw	r26, 0x01	; 1
    aace:	93 82       	std	Z+3, r9	; 0x03
    aad0:	82 82       	std	Z+2, r8	; 0x02
    aad2:	99 27       	eor	r25, r25
    aad4:	87 fd       	sbrc	r24, 7
    aad6:	90 95       	com	r25
    aad8:	95 83       	std	Z+5, r25	; 0x05
    aada:	84 83       	std	Z+4, r24	; 0x04
    aadc:	0e 94 9a 82 	call	0x10534	; 0x10534 <fprintf_P>
				chSemSignal(&spiUSE);
    aae0:	ed b7       	in	r30, 0x3d	; 61
    aae2:	fe b7       	in	r31, 0x3e	; 62
    aae4:	36 96       	adiw	r30, 0x06	; 6
    aae6:	0f b6       	in	r0, 0x3f	; 63
    aae8:	f8 94       	cli
    aaea:	fe bf       	out	0x3e, r31	; 62
    aaec:	0f be       	out	0x3f, r0	; 63
    aaee:	ed bf       	out	0x3d, r30	; 61
    aaf0:	89 e7       	ldi	r24, 0x79	; 121
    aaf2:	94 e1       	ldi	r25, 0x14	; 20
    aaf4:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
    aaf8:	a1 cf       	rjmp	.-190    	; 0xaa3c <Thread9+0xd0>
		st7735_fill_rect(0, 0, 160, 128, ST7735_COLOR_BLACK);//lcd_clear();
		chSemSignal(&spiUSE);
		
		while(true) {
            if(chEvtWaitAnyTimeout((eventmask_t)2, TIME_IMMEDIATE) == 2){
				output_high(PORTC, PC3); /*stop the LEDS*/
    aafa:	43 9a       	sbi	0x08, 3	; 8
				chSemSignal(&lcdUSE);/*thread 9 releases LCD*/
    aafc:	8d ef       	ldi	r24, 0xFD	; 253
    aafe:	93 e1       	ldi	r25, 0x13	; 19
    ab00:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
    ab04:	56 cf       	rjmp	.-340    	; 0xa9b2 <Thread9+0x46>

0000ab06 <Thread4>:
/*********************************************************************************
 * Thread 4 - Self-contained system time printout thread, triggered from menu
 *********************************************************************************/
THD_FUNCTION(Thread4, arg) {
	(void)arg;
	tp[3] = chThdGetSelfX();
    ab06:	80 91 ce 07 	lds	r24, 0x07CE
    ab0a:	90 91 cf 07 	lds	r25, 0x07CF
    ab0e:	90 93 9d 07 	sts	0x079D, r25
    ab12:	80 93 9c 07 	sts	0x079C, r24
    ab16:	cc eb       	ldi	r28, 0xBC	; 188
    ab18:	d6 e0       	ldi	r29, 0x06	; 6
    ab1a:	33 ee       	ldi	r19, 0xE3	; 227
    ab1c:	c3 2e       	mov	r12, r19
    ab1e:	3a e0       	ldi	r19, 0x0A	; 10
    ab20:	d3 2e       	mov	r13, r19
    ab22:	26 ed       	ldi	r18, 0xD6	; 214
    ab24:	e2 2e       	mov	r14, r18
    ab26:	2a e0       	ldi	r18, 0x0A	; 10
    ab28:	f2 2e       	mov	r15, r18
        /* wait for signal coming from main menu thread 2*/	
		chEvtWaitAnyTimeout((eventmask_t)1, TIME_INFINITE);
		/*take control of LCD semaphore*/
		chSemWait(&lcdUSE);
		/*switch lcd_context to thread 4*/
		lcd_context = 4; 
    ab2a:	94 e0       	ldi	r25, 0x04	; 4
    ab2c:	b9 2e       	mov	r11, r25
THD_FUNCTION(Thread4, arg) {
	(void)arg;
	tp[3] = chThdGetSelfX();
	while (true) {
        /* wait for signal coming from main menu thread 2*/	
		chEvtWaitAnyTimeout((eventmask_t)1, TIME_INFINITE);
    ab2e:	81 e0       	ldi	r24, 0x01	; 1
    ab30:	40 e0       	ldi	r20, 0x00	; 0
    ab32:	50 e0       	ldi	r21, 0x00	; 0
    ab34:	60 e0       	ldi	r22, 0x00	; 0
    ab36:	70 e0       	ldi	r23, 0x00	; 0
    ab38:	0e 94 b4 08 	call	0x1168	; 0x1168 <chEvtWaitAnyTimeout>
		/*take control of LCD semaphore*/
		chSemWait(&lcdUSE);
    ab3c:	8d ef       	ldi	r24, 0xFD	; 253
    ab3e:	93 e1       	ldi	r25, 0x13	; 19
    ab40:	40 e0       	ldi	r20, 0x00	; 0
    ab42:	50 e0       	ldi	r21, 0x00	; 0
    ab44:	60 e0       	ldi	r22, 0x00	; 0
    ab46:	70 e0       	ldi	r23, 0x00	; 0
    ab48:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
		/*switch lcd_context to thread 4*/
		lcd_context = 4; 
    ab4c:	b0 92 32 05 	sts	0x0532, r11
		
		chSemWait(&spiUSE);
    ab50:	89 e7       	ldi	r24, 0x79	; 121
    ab52:	94 e1       	ldi	r25, 0x14	; 20
    ab54:	40 e0       	ldi	r20, 0x00	; 0
    ab56:	50 e0       	ldi	r21, 0x00	; 0
    ab58:	60 e0       	ldi	r22, 0x00	; 0
    ab5a:	70 e0       	ldi	r23, 0x00	; 0
    ab5c:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
		st7735_fill_rect(0, 0, 160, 128, ST7735_COLOR_BLACK);//lcd_clear();
    ab60:	80 e0       	ldi	r24, 0x00	; 0
    ab62:	60 e0       	ldi	r22, 0x00	; 0
    ab64:	40 ea       	ldi	r20, 0xA0	; 160
    ab66:	20 e8       	ldi	r18, 0x80	; 128
    ab68:	00 e0       	ldi	r16, 0x00	; 0
    ab6a:	10 e0       	ldi	r17, 0x00	; 0
    ab6c:	0e 94 59 16 	call	0x2cb2	; 0x2cb2 <st7735_fill_rect>
		st7735_setCursor(5,10);//lcd_goto_xy(1,1);
    ab70:	85 e0       	ldi	r24, 0x05	; 5
    ab72:	90 e0       	ldi	r25, 0x00	; 0
    ab74:	6a e0       	ldi	r22, 0x0A	; 10
    ab76:	70 e0       	ldi	r23, 0x00	; 0
    ab78:	0e 94 c2 19 	call	0x3384	; 0x3384 <st7735_setCursor>
		fprintf_P(&st7735_out, PSTR("System time:"));
    ab7c:	00 d0       	rcall	.+0      	; 0xab7e <Thread4+0x78>
    ab7e:	00 d0       	rcall	.+0      	; 0xab80 <Thread4+0x7a>
    ab80:	ad b7       	in	r26, 0x3d	; 61
    ab82:	be b7       	in	r27, 0x3e	; 62
    ab84:	12 96       	adiw	r26, 0x02	; 2
    ab86:	dc 93       	st	X, r29
    ab88:	ce 93       	st	-X, r28
    ab8a:	11 97       	sbiw	r26, 0x01	; 1
    ab8c:	14 96       	adiw	r26, 0x04	; 4
    ab8e:	dc 92       	st	X, r13
    ab90:	ce 92       	st	-X, r12
    ab92:	13 97       	sbiw	r26, 0x03	; 3
    ab94:	0e 94 9a 82 	call	0x10534	; 0x10534 <fprintf_P>
		chSemSignal(&spiUSE);
    ab98:	0f 90       	pop	r0
    ab9a:	0f 90       	pop	r0
    ab9c:	0f 90       	pop	r0
    ab9e:	0f 90       	pop	r0
    aba0:	89 e7       	ldi	r24, 0x79	; 121
    aba2:	94 e1       	ldi	r25, 0x14	; 20
    aba4:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
    aba8:	4b c0       	rjmp	.+150    	; 0xac40 <Thread4+0x13a>
		    if(chEvtWaitAnyTimeout((eventmask_t)2, TIME_IMMEDIATE) == 2){
			chSemSignal(&lcdUSE);/*thread4 gives back the lcd */ 
			  break;
            }
			else {
			parse_time((double) minute_counter, &elapsed_hours, &elapsed_mins, &elapsed_secs);
    abaa:	60 91 01 0e 	lds	r22, 0x0E01
    abae:	70 91 02 0e 	lds	r23, 0x0E02
    abb2:	80 91 03 0e 	lds	r24, 0x0E03
    abb6:	90 91 04 0e 	lds	r25, 0x0E04
    abba:	40 e4       	ldi	r20, 0x40	; 64
    abbc:	57 e0       	ldi	r21, 0x07	; 7
    abbe:	21 e4       	ldi	r18, 0x41	; 65
    abc0:	37 e0       	ldi	r19, 0x07	; 7
    abc2:	02 e4       	ldi	r16, 0x42	; 66
    abc4:	17 e0       	ldi	r17, 0x07	; 7
    abc6:	0e 94 51 4e 	call	0x9ca2	; 0x9ca2 <parse_time>
			chSemWait(&spiUSE);
    abca:	89 e7       	ldi	r24, 0x79	; 121
    abcc:	94 e1       	ldi	r25, 0x14	; 20
    abce:	40 e0       	ldi	r20, 0x00	; 0
    abd0:	50 e0       	ldi	r21, 0x00	; 0
    abd2:	60 e0       	ldi	r22, 0x00	; 0
    abd4:	70 e0       	ldi	r23, 0x00	; 0
    abd6:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
			st7735_setCursor(5,20);//lcd_goto_xy(1,2);
    abda:	85 e0       	ldi	r24, 0x05	; 5
    abdc:	90 e0       	ldi	r25, 0x00	; 0
    abde:	64 e1       	ldi	r22, 0x14	; 20
    abe0:	70 e0       	ldi	r23, 0x00	; 0
    abe2:	0e 94 c2 19 	call	0x3384	; 0x3384 <st7735_setCursor>
			fprintf_P(&st7735_out,PSTR("%02d:%02d \r\n"),elapsed_mins, elapsed_secs);
    abe6:	ed b7       	in	r30, 0x3d	; 61
    abe8:	fe b7       	in	r31, 0x3e	; 62
    abea:	38 97       	sbiw	r30, 0x08	; 8
    abec:	0f b6       	in	r0, 0x3f	; 63
    abee:	f8 94       	cli
    abf0:	fe bf       	out	0x3e, r31	; 62
    abf2:	0f be       	out	0x3f, r0	; 63
    abf4:	ed bf       	out	0x3d, r30	; 61
    abf6:	31 96       	adiw	r30, 0x01	; 1
    abf8:	ad b7       	in	r26, 0x3d	; 61
    abfa:	be b7       	in	r27, 0x3e	; 62
    abfc:	12 96       	adiw	r26, 0x02	; 2
    abfe:	dc 93       	st	X, r29
    ac00:	ce 93       	st	-X, r28
    ac02:	11 97       	sbiw	r26, 0x01	; 1
    ac04:	f3 82       	std	Z+3, r15	; 0x03
    ac06:	e2 82       	std	Z+2, r14	; 0x02
    ac08:	80 91 41 07 	lds	r24, 0x0741
    ac0c:	84 83       	std	Z+4, r24	; 0x04
    ac0e:	15 82       	std	Z+5, r1	; 0x05
    ac10:	80 91 42 07 	lds	r24, 0x0742
    ac14:	86 83       	std	Z+6, r24	; 0x06
    ac16:	17 82       	std	Z+7, r1	; 0x07
    ac18:	0e 94 9a 82 	call	0x10534	; 0x10534 <fprintf_P>
			chSemSignal(&spiUSE);
    ac1c:	ed b7       	in	r30, 0x3d	; 61
    ac1e:	fe b7       	in	r31, 0x3e	; 62
    ac20:	38 96       	adiw	r30, 0x08	; 8
    ac22:	0f b6       	in	r0, 0x3f	; 63
    ac24:	f8 94       	cli
    ac26:	fe bf       	out	0x3e, r31	; 62
    ac28:	0f be       	out	0x3f, r0	; 63
    ac2a:	ed bf       	out	0x3d, r30	; 61
    ac2c:	89 e7       	ldi	r24, 0x79	; 121
    ac2e:	94 e1       	ldi	r25, 0x14	; 20
    ac30:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
			chThdSleepMilliseconds(25);
    ac34:	64 ef       	ldi	r22, 0xF4	; 244
    ac36:	71 e0       	ldi	r23, 0x01	; 1
    ac38:	80 e0       	ldi	r24, 0x00	; 0
    ac3a:	90 e0       	ldi	r25, 0x00	; 0
    ac3c:	0e 94 f4 08 	call	0x11e8	; 0x11e8 <chThdSleep>
		fprintf_P(&st7735_out, PSTR("System time:"));
		chSemSignal(&spiUSE);
		
		while(true) {
			/*now inside loop, wait for signal from thread1 button handler to get out*/
		    if(chEvtWaitAnyTimeout((eventmask_t)2, TIME_IMMEDIATE) == 2){
    ac40:	82 e0       	ldi	r24, 0x02	; 2
    ac42:	4f ef       	ldi	r20, 0xFF	; 255
    ac44:	5f ef       	ldi	r21, 0xFF	; 255
    ac46:	6f ef       	ldi	r22, 0xFF	; 255
    ac48:	7f ef       	ldi	r23, 0xFF	; 255
    ac4a:	0e 94 b4 08 	call	0x1168	; 0x1168 <chEvtWaitAnyTimeout>
    ac4e:	82 30       	cpi	r24, 0x02	; 2
    ac50:	09 f0       	breq	.+2      	; 0xac54 <Thread4+0x14e>
    ac52:	ab cf       	rjmp	.-170    	; 0xabaa <Thread4+0xa4>
			chSemSignal(&lcdUSE);/*thread4 gives back the lcd */ 
    ac54:	8d ef       	ldi	r24, 0xFD	; 253
    ac56:	93 e1       	ldi	r25, 0x13	; 19
    ac58:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
    ac5c:	68 cf       	rjmp	.-304    	; 0xab2e <Thread4+0x28>

0000ac5e <Thread11>:
}//THREAD10

/*********************************************************************************
 * Thread 11 - visualization of sensors
 *********************************************************************************/
THD_FUNCTION(Thread11, arg) {
    ac5e:	df 93       	push	r29
    ac60:	cf 93       	push	r28
    ac62:	cd b7       	in	r28, 0x3d	; 61
    ac64:	de b7       	in	r29, 0x3e	; 62
    ac66:	64 97       	sbiw	r28, 0x14	; 20
    ac68:	0f b6       	in	r0, 0x3f	; 63
    ac6a:	f8 94       	cli
    ac6c:	de bf       	out	0x3e, r29	; 62
    ac6e:	0f be       	out	0x3f, r0	; 63
    ac70:	cd bf       	out	0x3d, r28	; 61
	(void)arg;
	tp[10] = chThdGetSelfX();
    ac72:	80 91 ce 07 	lds	r24, 0x07CE
    ac76:	90 91 cf 07 	lds	r25, 0x07CF
    ac7a:	90 93 ab 07 	sts	0x07AB, r25
    ac7e:	80 93 aa 07 	sts	0x07AA, r24
	msg_t msg;
	vector_t run_min = {0,0,0}, run_max = {0,0,0};

	chSemWait(&i2cUSE);
    ac82:	80 e0       	ldi	r24, 0x00	; 0
    ac84:	94 e1       	ldi	r25, 0x14	; 20
    ac86:	40 e0       	ldi	r20, 0x00	; 0
    ac88:	50 e0       	ldi	r21, 0x00	; 0
    ac8a:	60 e0       	ldi	r22, 0x00	; 0
    ac8c:	70 e0       	ldi	r23, 0x00	; 0
    ac8e:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
	i2c_init();
    ac92:	0e 94 8f 14 	call	0x291e	; 0x291e <i2c_init>
	MPL3115A2_init();               // Initialize barometer
    ac96:	0e 94 98 40 	call	0x8130	; 0x8130 <MPL3115A2_init>
	L3GD20_enableDefault();		
    ac9a:	0e 94 4b 41 	call	0x8296	; 0x8296 <L3GD20_enableDefault>
	LSM303_enableDefault();
    ac9e:	0e 94 a2 46 	call	0x8d44	; 0x8d44 <LSM303_enableDefault>
	chSemSignal(&i2cUSE);
    aca2:	80 e0       	ldi	r24, 0x00	; 0
    aca4:	94 e1       	ldi	r25, 0x14	; 20
    aca6:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
    acaa:	f8 94       	cli
	/* Waiting for signal to show data - transfer via a message*/
	chSysLock();
	msg = chThdSuspendTimeoutS(&trp[10], TIME_INFINITE);
    acac:	86 ec       	ldi	r24, 0xC6	; 198
    acae:	97 e0       	ldi	r25, 0x07	; 7
    acb0:	40 e0       	ldi	r20, 0x00	; 0
    acb2:	50 e0       	ldi	r21, 0x00	; 0
    acb4:	60 e0       	ldi	r22, 0x00	; 0
    acb6:	70 e0       	ldi	r23, 0x00	; 0
    acb8:	0e 94 fc 08 	call	0x11f8	; 0x11f8 <chThdSuspendTimeoutS>
    acbc:	78 94       	sei
    acbe:	80 e0       	ldi	r24, 0x00	; 0
    acc0:	90 e0       	ldi	r25, 0x00	; 0
    acc2:	a0 e0       	ldi	r26, 0x00	; 0
    acc4:	b0 e0       	ldi	r27, 0x00	; 0
    acc6:	89 8b       	std	Y+17, r24	; 0x11
    acc8:	9a 8b       	std	Y+18, r25	; 0x12
    acca:	ab 8b       	std	Y+19, r26	; 0x13
    accc:	bc 8b       	std	Y+20, r27	; 0x14
    acce:	8d 87       	std	Y+13, r24	; 0x0d
    acd0:	9e 87       	std	Y+14, r25	; 0x0e
    acd2:	af 87       	std	Y+15, r26	; 0x0f
    acd4:	b8 8b       	std	Y+16, r27	; 0x10
    acd6:	89 87       	std	Y+9, r24	; 0x09
    acd8:	9a 87       	std	Y+10, r25	; 0x0a
    acda:	ab 87       	std	Y+11, r26	; 0x0b
    acdc:	bc 87       	std	Y+12, r27	; 0x0c
    acde:	8d 83       	std	Y+5, r24	; 0x05
    ace0:	9e 83       	std	Y+6, r25	; 0x06
    ace2:	af 83       	std	Y+7, r26	; 0x07
    ace4:	b8 87       	std	Y+8, r27	; 0x08
    ace6:	89 83       	std	Y+1, r24	; 0x01
    ace8:	9a 83       	std	Y+2, r25	; 0x02
    acea:	ab 83       	std	Y+3, r26	; 0x03
    acec:	bc 83       	std	Y+4, r27	; 0x04
    acee:	1c 01       	movw	r2, r24
    acf0:	2d 01       	movw	r4, r26
	chSysUnlock();		
	
	while (true) {
		
		chSemWait(&usartUSE);
    acf2:	87 ec       	ldi	r24, 0xC7	; 199
    acf4:	90 e3       	ldi	r25, 0x30	; 48
    acf6:	40 e0       	ldi	r20, 0x00	; 0
    acf8:	50 e0       	ldi	r21, 0x00	; 0
    acfa:	60 e0       	ldi	r22, 0x00	; 0
    acfc:	70 e0       	ldi	r23, 0x00	; 0
    acfe:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
		fprintf_P(&usart_out,PSTR("\r\n"));
    ad02:	00 d0       	rcall	.+0      	; 0xad04 <Thread11+0xa6>
    ad04:	00 d0       	rcall	.+0      	; 0xad06 <Thread11+0xa8>
    ad06:	ea ec       	ldi	r30, 0xCA	; 202
    ad08:	f6 e0       	ldi	r31, 0x06	; 6
    ad0a:	ad b7       	in	r26, 0x3d	; 61
    ad0c:	be b7       	in	r27, 0x3e	; 62
    ad0e:	12 96       	adiw	r26, 0x02	; 2
    ad10:	fc 93       	st	X, r31
    ad12:	ee 93       	st	-X, r30
    ad14:	11 97       	sbiw	r26, 0x01	; 1
    ad16:	28 e6       	ldi	r18, 0x68	; 104
    ad18:	38 e0       	ldi	r19, 0x08	; 8
    ad1a:	14 96       	adiw	r26, 0x04	; 4
    ad1c:	3c 93       	st	X, r19
    ad1e:	2e 93       	st	-X, r18
    ad20:	13 97       	sbiw	r26, 0x03	; 3
    ad22:	0e 94 9a 82 	call	0x10534	; 0x10534 <fprintf_P>
		chSemWait(&i2cUSE);
    ad26:	0f 90       	pop	r0
    ad28:	0f 90       	pop	r0
    ad2a:	0f 90       	pop	r0
    ad2c:	0f 90       	pop	r0
    ad2e:	80 e0       	ldi	r24, 0x00	; 0
    ad30:	94 e1       	ldi	r25, 0x14	; 20
    ad32:	40 e0       	ldi	r20, 0x00	; 0
    ad34:	50 e0       	ldi	r21, 0x00	; 0
    ad36:	60 e0       	ldi	r22, 0x00	; 0
    ad38:	70 e0       	ldi	r23, 0x00	; 0
    ad3a:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
		fprintf_P(&usart_out,PSTR("A: %-7.3fm P: %-7.3f Pa T: %-7.3f C \r\n"), MPL3115A2_getAltitude(), MPL3115A2_getPressure(), MPL3115A2_getTemperature());// Display altitude value
    ad3e:	0e 94 c9 3f 	call	0x7f92	; 0x7f92 <MPL3115A2_getAltitude>
    ad42:	5b 01       	movw	r10, r22
    ad44:	6c 01       	movw	r12, r24
    ad46:	0e 94 33 40 	call	0x8066	; 0x8066 <MPL3115A2_getPressure>
    ad4a:	7b 01       	movw	r14, r22
    ad4c:	8c 01       	movw	r16, r24
    ad4e:	0e 94 95 3f 	call	0x7f2a	; 0x7f2a <MPL3115A2_getTemperature>
    ad52:	ad b7       	in	r26, 0x3d	; 61
    ad54:	be b7       	in	r27, 0x3e	; 62
    ad56:	50 97       	sbiw	r26, 0x10	; 16
    ad58:	0f b6       	in	r0, 0x3f	; 63
    ad5a:	f8 94       	cli
    ad5c:	be bf       	out	0x3e, r27	; 62
    ad5e:	0f be       	out	0x3f, r0	; 63
    ad60:	ad bf       	out	0x3d, r26	; 61
    ad62:	ed b7       	in	r30, 0x3d	; 61
    ad64:	fe b7       	in	r31, 0x3e	; 62
    ad66:	31 96       	adiw	r30, 0x01	; 1
    ad68:	2a ec       	ldi	r18, 0xCA	; 202
    ad6a:	36 e0       	ldi	r19, 0x06	; 6
    ad6c:	12 96       	adiw	r26, 0x02	; 2
    ad6e:	3c 93       	st	X, r19
    ad70:	2e 93       	st	-X, r18
    ad72:	11 97       	sbiw	r26, 0x01	; 1
    ad74:	a1 e4       	ldi	r26, 0x41	; 65
    ad76:	b8 e0       	ldi	r27, 0x08	; 8
    ad78:	b3 83       	std	Z+3, r27	; 0x03
    ad7a:	a2 83       	std	Z+2, r26	; 0x02
    ad7c:	a4 82       	std	Z+4, r10	; 0x04
    ad7e:	b5 82       	std	Z+5, r11	; 0x05
    ad80:	c6 82       	std	Z+6, r12	; 0x06
    ad82:	d7 82       	std	Z+7, r13	; 0x07
    ad84:	e0 86       	std	Z+8, r14	; 0x08
    ad86:	f1 86       	std	Z+9, r15	; 0x09
    ad88:	02 87       	std	Z+10, r16	; 0x0a
    ad8a:	13 87       	std	Z+11, r17	; 0x0b
    ad8c:	64 87       	std	Z+12, r22	; 0x0c
    ad8e:	75 87       	std	Z+13, r23	; 0x0d
    ad90:	86 87       	std	Z+14, r24	; 0x0e
    ad92:	97 87       	std	Z+15, r25	; 0x0f
    ad94:	0e 94 9a 82 	call	0x10534	; 0x10534 <fprintf_P>
		chSemSignal(&i2cUSE);
    ad98:	ed b7       	in	r30, 0x3d	; 61
    ad9a:	fe b7       	in	r31, 0x3e	; 62
    ad9c:	70 96       	adiw	r30, 0x10	; 16
    ad9e:	0f b6       	in	r0, 0x3f	; 63
    ada0:	f8 94       	cli
    ada2:	fe bf       	out	0x3e, r31	; 62
    ada4:	0f be       	out	0x3f, r0	; 63
    ada6:	ed bf       	out	0x3d, r30	; 61
    ada8:	80 e0       	ldi	r24, 0x00	; 0
    adaa:	94 e1       	ldi	r25, 0x14	; 20
    adac:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
		chSemSignal(&usartUSE);
    adb0:	87 ec       	ldi	r24, 0xC7	; 199
    adb2:	90 e3       	ldi	r25, 0x30	; 48
    adb4:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
        
		chSemWait(&i2cUSE);	
    adb8:	80 e0       	ldi	r24, 0x00	; 0
    adba:	94 e1       	ldi	r25, 0x14	; 20
    adbc:	40 e0       	ldi	r20, 0x00	; 0
    adbe:	50 e0       	ldi	r21, 0x00	; 0
    adc0:	60 e0       	ldi	r22, 0x00	; 0
    adc2:	70 e0       	ldi	r23, 0x00	; 0
    adc4:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
		L3GD20_read();
    adc8:	0e 94 d5 40 	call	0x81aa	; 0x81aa <L3GD20_read>
		chSemSignal(&i2cUSE);
    adcc:	80 e0       	ldi	r24, 0x00	; 0
    adce:	94 e1       	ldi	r25, 0x14	; 20
    add0:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
		chSemWait(&usartUSE);
    add4:	87 ec       	ldi	r24, 0xC7	; 199
    add6:	90 e3       	ldi	r25, 0x30	; 48
    add8:	40 e0       	ldi	r20, 0x00	; 0
    adda:	50 e0       	ldi	r21, 0x00	; 0
    addc:	60 e0       	ldi	r22, 0x00	; 0
    adde:	70 e0       	ldi	r23, 0x00	; 0
    ade0:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
		fprintf_P(&usart_out,PSTR("x: %-7.3fm y: %-7.3f Pa z: %-7.3f\r\n"), g.x, g.y, g.z);// Display altitude value	
    ade4:	2d b7       	in	r18, 0x3d	; 61
    ade6:	3e b7       	in	r19, 0x3e	; 62
    ade8:	20 51       	subi	r18, 0x10	; 16
    adea:	30 40       	sbci	r19, 0x00	; 0
    adec:	0f b6       	in	r0, 0x3f	; 63
    adee:	f8 94       	cli
    adf0:	3e bf       	out	0x3e, r19	; 62
    adf2:	0f be       	out	0x3f, r0	; 63
    adf4:	2d bf       	out	0x3d, r18	; 61
    adf6:	ed b7       	in	r30, 0x3d	; 61
    adf8:	fe b7       	in	r31, 0x3e	; 62
    adfa:	31 96       	adiw	r30, 0x01	; 1
    adfc:	2a ec       	ldi	r18, 0xCA	; 202
    adfe:	36 e0       	ldi	r19, 0x06	; 6
    ae00:	ad b7       	in	r26, 0x3d	; 61
    ae02:	be b7       	in	r27, 0x3e	; 62
    ae04:	12 96       	adiw	r26, 0x02	; 2
    ae06:	3c 93       	st	X, r19
    ae08:	2e 93       	st	-X, r18
    ae0a:	11 97       	sbiw	r26, 0x01	; 1
    ae0c:	8d e1       	ldi	r24, 0x1D	; 29
    ae0e:	98 e0       	ldi	r25, 0x08	; 8
    ae10:	93 83       	std	Z+3, r25	; 0x03
    ae12:	82 83       	std	Z+2, r24	; 0x02
    ae14:	80 91 56 0a 	lds	r24, 0x0A56
    ae18:	90 91 57 0a 	lds	r25, 0x0A57
    ae1c:	a0 91 58 0a 	lds	r26, 0x0A58
    ae20:	b0 91 59 0a 	lds	r27, 0x0A59
    ae24:	84 83       	std	Z+4, r24	; 0x04
    ae26:	95 83       	std	Z+5, r25	; 0x05
    ae28:	a6 83       	std	Z+6, r26	; 0x06
    ae2a:	b7 83       	std	Z+7, r27	; 0x07
    ae2c:	80 91 5a 0a 	lds	r24, 0x0A5A
    ae30:	90 91 5b 0a 	lds	r25, 0x0A5B
    ae34:	a0 91 5c 0a 	lds	r26, 0x0A5C
    ae38:	b0 91 5d 0a 	lds	r27, 0x0A5D
    ae3c:	80 87       	std	Z+8, r24	; 0x08
    ae3e:	91 87       	std	Z+9, r25	; 0x09
    ae40:	a2 87       	std	Z+10, r26	; 0x0a
    ae42:	b3 87       	std	Z+11, r27	; 0x0b
    ae44:	80 91 5e 0a 	lds	r24, 0x0A5E
    ae48:	90 91 5f 0a 	lds	r25, 0x0A5F
    ae4c:	a0 91 60 0a 	lds	r26, 0x0A60
    ae50:	b0 91 61 0a 	lds	r27, 0x0A61
    ae54:	84 87       	std	Z+12, r24	; 0x0c
    ae56:	95 87       	std	Z+13, r25	; 0x0d
    ae58:	a6 87       	std	Z+14, r26	; 0x0e
    ae5a:	b7 87       	std	Z+15, r27	; 0x0f
    ae5c:	0e 94 9a 82 	call	0x10534	; 0x10534 <fprintf_P>
		chSemSignal(&usartUSE);
    ae60:	ad b7       	in	r26, 0x3d	; 61
    ae62:	be b7       	in	r27, 0x3e	; 62
    ae64:	50 96       	adiw	r26, 0x10	; 16
    ae66:	0f b6       	in	r0, 0x3f	; 63
    ae68:	f8 94       	cli
    ae6a:	be bf       	out	0x3e, r27	; 62
    ae6c:	0f be       	out	0x3f, r0	; 63
    ae6e:	ad bf       	out	0x3d, r26	; 61
    ae70:	87 ec       	ldi	r24, 0xC7	; 199
    ae72:	90 e3       	ldi	r25, 0x30	; 48
    ae74:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
		
		
		chSemWait(&i2cUSE);	
    ae78:	80 e0       	ldi	r24, 0x00	; 0
    ae7a:	94 e1       	ldi	r25, 0x14	; 20
    ae7c:	40 e0       	ldi	r20, 0x00	; 0
    ae7e:	50 e0       	ldi	r21, 0x00	; 0
    ae80:	60 e0       	ldi	r22, 0x00	; 0
    ae82:	70 e0       	ldi	r23, 0x00	; 0
    ae84:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
		LSM303_read();
    ae88:	0e 94 8b 46 	call	0x8d16	; 0x8d16 <LSM303_read>
		chSemSignal(&i2cUSE);	
    ae8c:	80 e0       	ldi	r24, 0x00	; 0
    ae8e:	94 e1       	ldi	r25, 0x14	; 20
    ae90:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
		chSemWait(&usartUSE);
    ae94:	87 ec       	ldi	r24, 0xC7	; 199
    ae96:	90 e3       	ldi	r25, 0x30	; 48
    ae98:	40 e0       	ldi	r20, 0x00	; 0
    ae9a:	50 e0       	ldi	r21, 0x00	; 0
    ae9c:	60 e0       	ldi	r22, 0x00	; 0
    ae9e:	70 e0       	ldi	r23, 0x00	; 0
    aea0:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
		fprintf_P(&usart_out, PSTR("Acceleration g's x:%7.1f y:%7.1f z:%7.1f \r\n"),a.x,a.y,a.z);
    aea4:	ed b7       	in	r30, 0x3d	; 61
    aea6:	fe b7       	in	r31, 0x3e	; 62
    aea8:	70 97       	sbiw	r30, 0x10	; 16
    aeaa:	0f b6       	in	r0, 0x3f	; 63
    aeac:	f8 94       	cli
    aeae:	fe bf       	out	0x3e, r31	; 62
    aeb0:	0f be       	out	0x3f, r0	; 63
    aeb2:	ed bf       	out	0x3d, r30	; 61
    aeb4:	31 96       	adiw	r30, 0x01	; 1
    aeb6:	2a ec       	ldi	r18, 0xCA	; 202
    aeb8:	36 e0       	ldi	r19, 0x06	; 6
    aeba:	ad b7       	in	r26, 0x3d	; 61
    aebc:	be b7       	in	r27, 0x3e	; 62
    aebe:	12 96       	adiw	r26, 0x02	; 2
    aec0:	3c 93       	st	X, r19
    aec2:	2e 93       	st	-X, r18
    aec4:	11 97       	sbiw	r26, 0x01	; 1
    aec6:	81 ef       	ldi	r24, 0xF1	; 241
    aec8:	97 e0       	ldi	r25, 0x07	; 7
    aeca:	93 83       	std	Z+3, r25	; 0x03
    aecc:	82 83       	std	Z+2, r24	; 0x02
    aece:	80 91 6e 0a 	lds	r24, 0x0A6E
    aed2:	90 91 6f 0a 	lds	r25, 0x0A6F
    aed6:	a0 91 70 0a 	lds	r26, 0x0A70
    aeda:	b0 91 71 0a 	lds	r27, 0x0A71
    aede:	84 83       	std	Z+4, r24	; 0x04
    aee0:	95 83       	std	Z+5, r25	; 0x05
    aee2:	a6 83       	std	Z+6, r26	; 0x06
    aee4:	b7 83       	std	Z+7, r27	; 0x07
    aee6:	80 91 72 0a 	lds	r24, 0x0A72
    aeea:	90 91 73 0a 	lds	r25, 0x0A73
    aeee:	a0 91 74 0a 	lds	r26, 0x0A74
    aef2:	b0 91 75 0a 	lds	r27, 0x0A75
    aef6:	80 87       	std	Z+8, r24	; 0x08
    aef8:	91 87       	std	Z+9, r25	; 0x09
    aefa:	a2 87       	std	Z+10, r26	; 0x0a
    aefc:	b3 87       	std	Z+11, r27	; 0x0b
    aefe:	80 91 76 0a 	lds	r24, 0x0A76
    af02:	90 91 77 0a 	lds	r25, 0x0A77
    af06:	a0 91 78 0a 	lds	r26, 0x0A78
    af0a:	b0 91 79 0a 	lds	r27, 0x0A79
    af0e:	84 87       	std	Z+12, r24	; 0x0c
    af10:	95 87       	std	Z+13, r25	; 0x0d
    af12:	a6 87       	std	Z+14, r26	; 0x0e
    af14:	b7 87       	std	Z+15, r27	; 0x0f
    af16:	0e 94 9a 82 	call	0x10534	; 0x10534 <fprintf_P>
		fprintf_P(&usart_out, PSTR("Magnetometer mgauss x:%7.1f y:%7.1f z:%7.1f \r\n"),m.x,m.y,m.z);
    af1a:	ed b7       	in	r30, 0x3d	; 61
    af1c:	fe b7       	in	r31, 0x3e	; 62
    af1e:	31 96       	adiw	r30, 0x01	; 1
    af20:	2a ec       	ldi	r18, 0xCA	; 202
    af22:	36 e0       	ldi	r19, 0x06	; 6
    af24:	ad b7       	in	r26, 0x3d	; 61
    af26:	be b7       	in	r27, 0x3e	; 62
    af28:	12 96       	adiw	r26, 0x02	; 2
    af2a:	3c 93       	st	X, r19
    af2c:	2e 93       	st	-X, r18
    af2e:	11 97       	sbiw	r26, 0x01	; 1
    af30:	82 ec       	ldi	r24, 0xC2	; 194
    af32:	97 e0       	ldi	r25, 0x07	; 7
    af34:	93 83       	std	Z+3, r25	; 0x03
    af36:	82 83       	std	Z+2, r24	; 0x02
    af38:	80 91 86 0a 	lds	r24, 0x0A86
    af3c:	90 91 87 0a 	lds	r25, 0x0A87
    af40:	a0 91 88 0a 	lds	r26, 0x0A88
    af44:	b0 91 89 0a 	lds	r27, 0x0A89
    af48:	84 83       	std	Z+4, r24	; 0x04
    af4a:	95 83       	std	Z+5, r25	; 0x05
    af4c:	a6 83       	std	Z+6, r26	; 0x06
    af4e:	b7 83       	std	Z+7, r27	; 0x07
    af50:	80 91 8a 0a 	lds	r24, 0x0A8A
    af54:	90 91 8b 0a 	lds	r25, 0x0A8B
    af58:	a0 91 8c 0a 	lds	r26, 0x0A8C
    af5c:	b0 91 8d 0a 	lds	r27, 0x0A8D
    af60:	80 87       	std	Z+8, r24	; 0x08
    af62:	91 87       	std	Z+9, r25	; 0x09
    af64:	a2 87       	std	Z+10, r26	; 0x0a
    af66:	b3 87       	std	Z+11, r27	; 0x0b
    af68:	80 91 8e 0a 	lds	r24, 0x0A8E
    af6c:	90 91 8f 0a 	lds	r25, 0x0A8F
    af70:	a0 91 90 0a 	lds	r26, 0x0A90
    af74:	b0 91 91 0a 	lds	r27, 0x0A91
    af78:	84 87       	std	Z+12, r24	; 0x0c
    af7a:	95 87       	std	Z+13, r25	; 0x0d
    af7c:	a6 87       	std	Z+14, r26	; 0x0e
    af7e:	b7 87       	std	Z+15, r27	; 0x0f
    af80:	0e 94 9a 82 	call	0x10534	; 0x10534 <fprintf_P>
		chSemSignal(&usartUSE);
    af84:	ad b7       	in	r26, 0x3d	; 61
    af86:	be b7       	in	r27, 0x3e	; 62
    af88:	50 96       	adiw	r26, 0x10	; 16
    af8a:	0f b6       	in	r0, 0x3f	; 63
    af8c:	f8 94       	cli
    af8e:	be bf       	out	0x3e, r27	; 62
    af90:	0f be       	out	0x3f, r0	; 63
    af92:	ad bf       	out	0x3d, r26	; 61
    af94:	87 ec       	ldi	r24, 0xC7	; 199
    af96:	90 e3       	ldi	r25, 0x30	; 48
    af98:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
		run_min.x = fmin(run_min.x, m.x);
    af9c:	60 90 86 0a 	lds	r6, 0x0A86
    afa0:	70 90 87 0a 	lds	r7, 0x0A87
    afa4:	80 90 88 0a 	lds	r8, 0x0A88
    afa8:	90 90 89 0a 	lds	r9, 0x0A89
    afac:	69 85       	ldd	r22, Y+9	; 0x09
    afae:	7a 85       	ldd	r23, Y+10	; 0x0a
    afb0:	8b 85       	ldd	r24, Y+11	; 0x0b
    afb2:	9c 85       	ldd	r25, Y+12	; 0x0c
    afb4:	a4 01       	movw	r20, r8
    afb6:	93 01       	movw	r18, r6
    afb8:	0e 94 3e 7e 	call	0xfc7c	; 0xfc7c <fmin>
    afbc:	69 87       	std	Y+9, r22	; 0x09
    afbe:	7a 87       	std	Y+10, r23	; 0x0a
    afc0:	8b 87       	std	Y+11, r24	; 0x0b
    afc2:	9c 87       	std	Y+12, r25	; 0x0c
		run_min.y = fmin(run_min.y, m.y);
    afc4:	a0 90 8a 0a 	lds	r10, 0x0A8A
    afc8:	b0 90 8b 0a 	lds	r11, 0x0A8B
    afcc:	c0 90 8c 0a 	lds	r12, 0x0A8C
    afd0:	d0 90 8d 0a 	lds	r13, 0x0A8D
    afd4:	6d 85       	ldd	r22, Y+13	; 0x0d
    afd6:	7e 85       	ldd	r23, Y+14	; 0x0e
    afd8:	8f 85       	ldd	r24, Y+15	; 0x0f
    afda:	98 89       	ldd	r25, Y+16	; 0x10
    afdc:	a6 01       	movw	r20, r12
    afde:	95 01       	movw	r18, r10
    afe0:	0e 94 3e 7e 	call	0xfc7c	; 0xfc7c <fmin>
    afe4:	6d 87       	std	Y+13, r22	; 0x0d
    afe6:	7e 87       	std	Y+14, r23	; 0x0e
    afe8:	8f 87       	std	Y+15, r24	; 0x0f
    afea:	98 8b       	std	Y+16, r25	; 0x10
		run_min.z = fmin(run_min.z, m.z);
    afec:	e0 90 8e 0a 	lds	r14, 0x0A8E
    aff0:	f0 90 8f 0a 	lds	r15, 0x0A8F
    aff4:	00 91 90 0a 	lds	r16, 0x0A90
    aff8:	10 91 91 0a 	lds	r17, 0x0A91
    affc:	69 89       	ldd	r22, Y+17	; 0x11
    affe:	7a 89       	ldd	r23, Y+18	; 0x12
    b000:	8b 89       	ldd	r24, Y+19	; 0x13
    b002:	9c 89       	ldd	r25, Y+20	; 0x14
    b004:	a8 01       	movw	r20, r16
    b006:	97 01       	movw	r18, r14
    b008:	0e 94 3e 7e 	call	0xfc7c	; 0xfc7c <fmin>
    b00c:	69 8b       	std	Y+17, r22	; 0x11
    b00e:	7a 8b       	std	Y+18, r23	; 0x12
    b010:	8b 8b       	std	Y+19, r24	; 0x13
    b012:	9c 8b       	std	Y+20, r25	; 0x14

		run_max.x = fmax(run_max.x, m.x);
    b014:	c2 01       	movw	r24, r4
    b016:	b1 01       	movw	r22, r2
    b018:	a4 01       	movw	r20, r8
    b01a:	93 01       	movw	r18, r6
    b01c:	0e 94 1f 7e 	call	0xfc3e	; 0xfc3e <fmax>
    b020:	1b 01       	movw	r2, r22
    b022:	2c 01       	movw	r4, r24
		run_max.y = fmax(run_max.y, m.y);
    b024:	69 81       	ldd	r22, Y+1	; 0x01
    b026:	7a 81       	ldd	r23, Y+2	; 0x02
    b028:	8b 81       	ldd	r24, Y+3	; 0x03
    b02a:	9c 81       	ldd	r25, Y+4	; 0x04
    b02c:	a6 01       	movw	r20, r12
    b02e:	95 01       	movw	r18, r10
    b030:	0e 94 1f 7e 	call	0xfc3e	; 0xfc3e <fmax>
    b034:	69 83       	std	Y+1, r22	; 0x01
    b036:	7a 83       	std	Y+2, r23	; 0x02
    b038:	8b 83       	std	Y+3, r24	; 0x03
    b03a:	9c 83       	std	Y+4, r25	; 0x04
		run_max.z = fmax(run_max.z, m.z);
    b03c:	6d 81       	ldd	r22, Y+5	; 0x05
    b03e:	7e 81       	ldd	r23, Y+6	; 0x06
    b040:	8f 81       	ldd	r24, Y+7	; 0x07
    b042:	98 85       	ldd	r25, Y+8	; 0x08
    b044:	a8 01       	movw	r20, r16
    b046:	97 01       	movw	r18, r14
    b048:	0e 94 1f 7e 	call	0xfc3e	; 0xfc3e <fmax>
    b04c:	6d 83       	std	Y+5, r22	; 0x05
    b04e:	7e 83       	std	Y+6, r23	; 0x06
    b050:	8f 83       	std	Y+7, r24	; 0x07
    b052:	98 87       	std	Y+8, r25	; 0x08
		chSemWait(&usartUSE);
    b054:	87 ec       	ldi	r24, 0xC7	; 199
    b056:	90 e3       	ldi	r25, 0x30	; 48
    b058:	40 e0       	ldi	r20, 0x00	; 0
    b05a:	50 e0       	ldi	r21, 0x00	; 0
    b05c:	60 e0       	ldi	r22, 0x00	; 0
    b05e:	70 e0       	ldi	r23, 0x00	; 0
    b060:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
		fprintf_P(&usart_out, PSTR("min: %7.1f %7.1f %7.1f max: %7.1f %7.1f %7.1f \r\n"),run_min.x, run_min.y, run_min.z,run_max.x, run_max.y, run_max.z);
    b064:	ed b7       	in	r30, 0x3d	; 61
    b066:	fe b7       	in	r31, 0x3e	; 62
    b068:	7c 97       	sbiw	r30, 0x1c	; 28
    b06a:	0f b6       	in	r0, 0x3f	; 63
    b06c:	f8 94       	cli
    b06e:	fe bf       	out	0x3e, r31	; 62
    b070:	0f be       	out	0x3f, r0	; 63
    b072:	ed bf       	out	0x3d, r30	; 61
    b074:	31 96       	adiw	r30, 0x01	; 1
    b076:	2a ec       	ldi	r18, 0xCA	; 202
    b078:	36 e0       	ldi	r19, 0x06	; 6
    b07a:	ad b7       	in	r26, 0x3d	; 61
    b07c:	be b7       	in	r27, 0x3e	; 62
    b07e:	12 96       	adiw	r26, 0x02	; 2
    b080:	3c 93       	st	X, r19
    b082:	2e 93       	st	-X, r18
    b084:	11 97       	sbiw	r26, 0x01	; 1
    b086:	81 e9       	ldi	r24, 0x91	; 145
    b088:	97 e0       	ldi	r25, 0x07	; 7
    b08a:	93 83       	std	Z+3, r25	; 0x03
    b08c:	82 83       	std	Z+2, r24	; 0x02
    b08e:	89 85       	ldd	r24, Y+9	; 0x09
    b090:	9a 85       	ldd	r25, Y+10	; 0x0a
    b092:	ab 85       	ldd	r26, Y+11	; 0x0b
    b094:	bc 85       	ldd	r27, Y+12	; 0x0c
    b096:	84 83       	std	Z+4, r24	; 0x04
    b098:	95 83       	std	Z+5, r25	; 0x05
    b09a:	a6 83       	std	Z+6, r26	; 0x06
    b09c:	b7 83       	std	Z+7, r27	; 0x07
    b09e:	8d 85       	ldd	r24, Y+13	; 0x0d
    b0a0:	9e 85       	ldd	r25, Y+14	; 0x0e
    b0a2:	af 85       	ldd	r26, Y+15	; 0x0f
    b0a4:	b8 89       	ldd	r27, Y+16	; 0x10
    b0a6:	80 87       	std	Z+8, r24	; 0x08
    b0a8:	91 87       	std	Z+9, r25	; 0x09
    b0aa:	a2 87       	std	Z+10, r26	; 0x0a
    b0ac:	b3 87       	std	Z+11, r27	; 0x0b
    b0ae:	89 89       	ldd	r24, Y+17	; 0x11
    b0b0:	9a 89       	ldd	r25, Y+18	; 0x12
    b0b2:	ab 89       	ldd	r26, Y+19	; 0x13
    b0b4:	bc 89       	ldd	r27, Y+20	; 0x14
    b0b6:	84 87       	std	Z+12, r24	; 0x0c
    b0b8:	95 87       	std	Z+13, r25	; 0x0d
    b0ba:	a6 87       	std	Z+14, r26	; 0x0e
    b0bc:	b7 87       	std	Z+15, r27	; 0x0f
    b0be:	20 8a       	std	Z+16, r2	; 0x10
    b0c0:	31 8a       	std	Z+17, r3	; 0x11
    b0c2:	42 8a       	std	Z+18, r4	; 0x12
    b0c4:	53 8a       	std	Z+19, r5	; 0x13
    b0c6:	89 81       	ldd	r24, Y+1	; 0x01
    b0c8:	9a 81       	ldd	r25, Y+2	; 0x02
    b0ca:	ab 81       	ldd	r26, Y+3	; 0x03
    b0cc:	bc 81       	ldd	r27, Y+4	; 0x04
    b0ce:	84 8b       	std	Z+20, r24	; 0x14
    b0d0:	95 8b       	std	Z+21, r25	; 0x15
    b0d2:	a6 8b       	std	Z+22, r26	; 0x16
    b0d4:	b7 8b       	std	Z+23, r27	; 0x17
    b0d6:	8d 81       	ldd	r24, Y+5	; 0x05
    b0d8:	9e 81       	ldd	r25, Y+6	; 0x06
    b0da:	af 81       	ldd	r26, Y+7	; 0x07
    b0dc:	b8 85       	ldd	r27, Y+8	; 0x08
    b0de:	80 8f       	std	Z+24, r24	; 0x18
    b0e0:	91 8f       	std	Z+25, r25	; 0x19
    b0e2:	a2 8f       	std	Z+26, r26	; 0x1a
    b0e4:	b3 8f       	std	Z+27, r27	; 0x1b
    b0e6:	0e 94 9a 82 	call	0x10534	; 0x10534 <fprintf_P>
		-Y axis on the Pololu LSM303DLHC, LSM303DLM, and LSM303DLH carriers.
  
		To use a different vector as a reference, use the version of heading() that takes a vector argument; 
		for example, use compass.heading((LSM303::vector<int>){0, 0, 1}) to use the +Z axis as a reference.*/
	    
		chSemWait(&i2cUSE);	
    b0ea:	ad b7       	in	r26, 0x3d	; 61
    b0ec:	be b7       	in	r27, 0x3e	; 62
    b0ee:	5c 96       	adiw	r26, 0x1c	; 28
    b0f0:	0f b6       	in	r0, 0x3f	; 63
    b0f2:	f8 94       	cli
    b0f4:	be bf       	out	0x3e, r27	; 62
    b0f6:	0f be       	out	0x3f, r0	; 63
    b0f8:	ad bf       	out	0x3d, r26	; 61
    b0fa:	80 e0       	ldi	r24, 0x00	; 0
    b0fc:	94 e1       	ldi	r25, 0x14	; 20
    b0fe:	40 e0       	ldi	r20, 0x00	; 0
    b100:	50 e0       	ldi	r21, 0x00	; 0
    b102:	60 e0       	ldi	r22, 0x00	; 0
    b104:	70 e0       	ldi	r23, 0x00	; 0
    b106:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
		fprintf_P(&usart_out, PSTR("Heading: %7.1f \r\n"),LSM303_heading());
    b10a:	0e 94 5a 45 	call	0x8ab4	; 0x8ab4 <LSM303_heading>
    b10e:	ed b7       	in	r30, 0x3d	; 61
    b110:	fe b7       	in	r31, 0x3e	; 62
    b112:	38 97       	sbiw	r30, 0x08	; 8
    b114:	0f b6       	in	r0, 0x3f	; 63
    b116:	f8 94       	cli
    b118:	fe bf       	out	0x3e, r31	; 62
    b11a:	0f be       	out	0x3f, r0	; 63
    b11c:	ed bf       	out	0x3d, r30	; 61
    b11e:	31 96       	adiw	r30, 0x01	; 1
    b120:	2a ec       	ldi	r18, 0xCA	; 202
    b122:	36 e0       	ldi	r19, 0x06	; 6
    b124:	ad b7       	in	r26, 0x3d	; 61
    b126:	be b7       	in	r27, 0x3e	; 62
    b128:	12 96       	adiw	r26, 0x02	; 2
    b12a:	3c 93       	st	X, r19
    b12c:	2e 93       	st	-X, r18
    b12e:	11 97       	sbiw	r26, 0x01	; 1
    b130:	af e7       	ldi	r26, 0x7F	; 127
    b132:	b7 e0       	ldi	r27, 0x07	; 7
    b134:	b3 83       	std	Z+3, r27	; 0x03
    b136:	a2 83       	std	Z+2, r26	; 0x02
    b138:	64 83       	std	Z+4, r22	; 0x04
    b13a:	75 83       	std	Z+5, r23	; 0x05
    b13c:	86 83       	std	Z+6, r24	; 0x06
    b13e:	97 83       	std	Z+7, r25	; 0x07
    b140:	0e 94 9a 82 	call	0x10534	; 0x10534 <fprintf_P>
		chSemSignal(&i2cUSE);	
    b144:	ed b7       	in	r30, 0x3d	; 61
    b146:	fe b7       	in	r31, 0x3e	; 62
    b148:	38 96       	adiw	r30, 0x08	; 8
    b14a:	0f b6       	in	r0, 0x3f	; 63
    b14c:	f8 94       	cli
    b14e:	fe bf       	out	0x3e, r31	; 62
    b150:	0f be       	out	0x3f, r0	; 63
    b152:	ed bf       	out	0x3d, r30	; 61
    b154:	80 e0       	ldi	r24, 0x00	; 0
    b156:	94 e1       	ldi	r25, 0x14	; 20
    b158:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
		chSemSignal(&usartUSE);
    b15c:	87 ec       	ldi	r24, 0xC7	; 199
    b15e:	90 e3       	ldi	r25, 0x30	; 48
    b160:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
		
		chThdSleepMilliseconds(50);
    b164:	68 ee       	ldi	r22, 0xE8	; 232
    b166:	73 e0       	ldi	r23, 0x03	; 3
    b168:	80 e0       	ldi	r24, 0x00	; 0
    b16a:	90 e0       	ldi	r25, 0x00	; 0
    b16c:	0e 94 f4 08 	call	0x11e8	; 0x11e8 <chThdSleep>
    b170:	c0 cd       	rjmp	.-1152   	; 0xacf2 <Thread11+0x94>

0000b172 <Thread7>:
 * Thread 7 - Print Stack Information - tp[6]
 *********************************************************************************/
THD_FUNCTION(Thread7, arg) {

  (void)arg;
  tp[6] = chThdGetSelfX();
    b172:	80 91 ce 07 	lds	r24, 0x07CE
    b176:	90 91 cf 07 	lds	r25, 0x07CF
    b17a:	90 93 a3 07 	sts	0x07A3, r25
    b17e:	80 93 a2 07 	sts	0x07A2, r24
  systime_t wakeTime;
  
  while (true) {
	chEvtWaitAnyTimeout((eventmask_t)1, TIME_INFINITE);
    b182:	81 e0       	ldi	r24, 0x01	; 1
    b184:	40 e0       	ldi	r20, 0x00	; 0
    b186:	50 e0       	ldi	r21, 0x00	; 0
    b188:	60 e0       	ldi	r22, 0x00	; 0
    b18a:	70 e0       	ldi	r23, 0x00	; 0
    b18c:	0e 94 b4 08 	call	0x1168	; 0x1168 <chEvtWaitAnyTimeout>
	wakeTime = chVTGetSystemTimeX();
    b190:	60 91 d2 07 	lds	r22, 0x07D2
    b194:	70 91 d3 07 	lds	r23, 0x07D3
    b198:	80 91 d4 07 	lds	r24, 0x07D4
    b19c:	90 91 d5 07 	lds	r25, 0x07D5
	wakeTime += MS2ST(120);
    // Sleep until next second.
    chThdSleepUntil(wakeTime);
    b1a0:	60 5a       	subi	r22, 0xA0	; 160
    b1a2:	76 4f       	sbci	r23, 0xF6	; 246
    b1a4:	8f 4f       	sbci	r24, 0xFF	; 255
    b1a6:	9f 4f       	sbci	r25, 0xFF	; 255
    b1a8:	0e 94 e0 08 	call	0x11c0	; 0x11c0 <chThdSleepUntil>
	chSemWait(&usartUSE); 
    b1ac:	87 ec       	ldi	r24, 0xC7	; 199
    b1ae:	90 e3       	ldi	r25, 0x30	; 48
    b1b0:	40 e0       	ldi	r20, 0x00	; 0
    b1b2:	50 e0       	ldi	r21, 0x00	; 0
    b1b4:	60 e0       	ldi	r22, 0x00	; 0
    b1b6:	70 e0       	ldi	r23, 0x00	; 0
    b1b8:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
	// Print unused stack for thread 1, thread 2, and idle thread.
    chPrintStackSizes();
    b1bc:	0e 94 60 52 	call	0xa4c0	; 0xa4c0 <chPrintStackSizes>
    // Print unused stack for thread 1, thread 2, and idle thread.
    chPrintUnusedStack();
    b1c0:	0e 94 e1 51 	call	0xa3c2	; 0xa3c2 <chPrintUnusedStack>
	chSemSignal(&usartUSE);
    b1c4:	87 ec       	ldi	r24, 0xC7	; 199
    b1c6:	90 e3       	ldi	r25, 0x30	; 48
    b1c8:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
    b1cc:	da cf       	rjmp	.-76     	; 0xb182 <Thread7+0x10>

0000b1ce <Thread6>:
 * >>>> & see if it helps
 *
 *********************************************************************************/
THD_FUNCTION(Thread6, arg) {
  (void)arg;
  tp[5] = chThdGetSelfX();
    b1ce:	80 91 ce 07 	lds	r24, 0x07CE
    b1d2:	90 91 cf 07 	lds	r25, 0x07CF
    b1d6:	90 93 a1 07 	sts	0x07A1, r25
    b1da:	80 93 a0 07 	sts	0x07A0, r24
  msg_t msg;
  /*
   * Activates the serial driver 1 using the driver default configuration.
   * PA9 and PA10 are routed to USART1.
   */
  sdStart(&SD1, NULL);
    b1de:	8a e3       	ldi	r24, 0x3A	; 58
    b1e0:	99 e0       	ldi	r25, 0x09	; 9
    b1e2:	60 e0       	ldi	r22, 0x00	; 0
    b1e4:	70 e0       	ldi	r23, 0x00	; 0
    b1e6:	0e 94 86 12 	call	0x250c	; 0x250c <sdStart>
  usart_init(MYUBRR);
    b1ea:	89 e1       	ldi	r24, 0x19	; 25
    b1ec:	90 e0       	ldi	r25, 0x00	; 0
    b1ee:	0e 94 e1 20 	call	0x41c2	; 0x41c2 <usart_init>
  /* Welcome message.*/
  chSemWait(&usartUSE);
    b1f2:	87 ec       	ldi	r24, 0xC7	; 199
    b1f4:	90 e3       	ldi	r25, 0x30	; 48
    b1f6:	40 e0       	ldi	r20, 0x00	; 0
    b1f8:	50 e0       	ldi	r21, 0x00	; 0
    b1fa:	60 e0       	ldi	r22, 0x00	; 0
    b1fc:	70 e0       	ldi	r23, 0x00	; 0
    b1fe:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
  fprintf_P(&usart_out,PSTR("\r\n NILRTOS 1.1 \r\n"));
    b202:	00 d0       	rcall	.+0      	; 0xb204 <Thread6+0x36>
    b204:	00 d0       	rcall	.+0      	; 0xb206 <Thread6+0x38>
    b206:	8a ec       	ldi	r24, 0xCA	; 202
    b208:	96 e0       	ldi	r25, 0x06	; 6
    b20a:	ed b7       	in	r30, 0x3d	; 61
    b20c:	fe b7       	in	r31, 0x3e	; 62
    b20e:	92 83       	std	Z+2, r25	; 0x02
    b210:	81 83       	std	Z+1, r24	; 0x01
    b212:	87 ed       	ldi	r24, 0xD7	; 215
    b214:	98 e0       	ldi	r25, 0x08	; 8
    b216:	94 83       	std	Z+4, r25	; 0x04
    b218:	83 83       	std	Z+3, r24	; 0x03
    b21a:	0e 94 9a 82 	call	0x10534	; 0x10534 <fprintf_P>
  chSemSignal(&usartUSE);
    b21e:	0f 90       	pop	r0
    b220:	0f 90       	pop	r0
    b222:	0f 90       	pop	r0
    b224:	0f 90       	pop	r0
    b226:	87 ec       	ldi	r24, 0xC7	; 199
    b228:	90 e3       	ldi	r25, 0x30	; 48
    b22a:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
    b22e:	f8 94       	cli
 
  while (true) {
		/* Waiting for button push and activation of the test suite.*/
		chSysLock();
		msg = chThdSuspendTimeoutS(&trp[5], TIME_INFINITE);
    b230:	8c eb       	ldi	r24, 0xBC	; 188
    b232:	97 e0       	ldi	r25, 0x07	; 7
    b234:	40 e0       	ldi	r20, 0x00	; 0
    b236:	50 e0       	ldi	r21, 0x00	; 0
    b238:	60 e0       	ldi	r22, 0x00	; 0
    b23a:	70 e0       	ldi	r23, 0x00	; 0
    b23c:	0e 94 fc 08 	call	0x11f8	; 0x11f8 <chThdSuspendTimeoutS>
    b240:	78 94       	sei
		chSysUnlock();
		
		//chEvtWaitAnyTimeout((eventmask_t)1, TIME_INFINITE);
		chSemWait(&usartUSE);	
    b242:	87 ec       	ldi	r24, 0xC7	; 199
    b244:	90 e3       	ldi	r25, 0x30	; 48
    b246:	40 e0       	ldi	r20, 0x00	; 0
    b248:	50 e0       	ldi	r21, 0x00	; 0
    b24a:	60 e0       	ldi	r22, 0x00	; 0
    b24c:	70 e0       	ldi	r23, 0x00	; 0
    b24e:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
		test_execute((BaseSequentialStream *)&SD1);
    b252:	8a e3       	ldi	r24, 0x3A	; 58
    b254:	99 e0       	ldi	r25, 0x09	; 9
    b256:	0e 94 d0 0a 	call	0x15a0	; 0x15a0 <test_execute>
	    chSemSignal(&usartUSE);
    b25a:	87 ec       	ldi	r24, 0xC7	; 199
    b25c:	90 e3       	ldi	r25, 0x30	; 48
    b25e:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
    b262:	e5 cf       	rjmp	.-54     	; 0xb22e <Thread6+0x60>

0000b264 <Thread5>:
	(void)arg;
	//setup SD card
	double corrected_heading;
	
	uint8_t entry_flag;
	tp[4] = chThdGetSelfX();//returns a pointer to current thread
    b264:	80 91 ce 07 	lds	r24, 0x07CE
    b268:	90 91 cf 07 	lds	r25, 0x07CF
    b26c:	90 93 9f 07 	sts	0x079F, r25
    b270:	80 93 9e 07 	sts	0x079E, r24
    b274:	cc eb       	ldi	r28, 0xBC	; 188
    b276:	d6 e0       	ldi	r29, 0x06	; 6
    b278:	ba e6       	ldi	r27, 0x6A	; 106
    b27a:	6b 2e       	mov	r6, r27
    b27c:	b9 e0       	ldi	r27, 0x09	; 9
    b27e:	7b 2e       	mov	r7, r27
    b280:	a7 e6       	ldi	r26, 0x67	; 103
    b282:	4a 2e       	mov	r4, r26
    b284:	a9 e0       	ldi	r26, 0x09	; 9
    b286:	5a 2e       	mov	r5, r26
    b288:	f8 e4       	ldi	r31, 0x48	; 72
    b28a:	2f 2e       	mov	r2, r31
    b28c:	f9 e0       	ldi	r31, 0x09	; 9
    b28e:	3f 2e       	mov	r3, r31
    b290:	e5 e3       	ldi	r30, 0x35	; 53
    b292:	8e 2e       	mov	r8, r30
    b294:	e9 e0       	ldi	r30, 0x09	; 9
    b296:	9e 2e       	mov	r9, r30
    b298:	79 ee       	ldi	r23, 0xE9	; 233
    b29a:	a7 2e       	mov	r10, r23
    b29c:	78 e0       	ldi	r23, 0x08	; 8
    b29e:	b7 2e       	mov	r11, r23
					DS3231_getDate(&dy, &dt, &mt, &yr);
					chSemSignal(&i2cUSE);
					
					chSemWait(&spiUSE);
					st7735_setTextSize(2);
					fprintf_P(&st7735_out, PSTR("%s"), DAY_NAME[dy-1]);
    b2a0:	ce 01       	movw	r24, r28
    b2a2:	dc 2e       	mov	r13, r28
    b2a4:	c9 2e       	mov	r12, r25
	
	uint8_t entry_flag;
	tp[4] = chThdGetSelfX();//returns a pointer to current thread
	while (true) {
		/* wait for signal coming from main menu thread 2*/	
		chEvtWaitAnyTimeout((eventmask_t)1, TIME_INFINITE);
    b2a6:	81 e0       	ldi	r24, 0x01	; 1
    b2a8:	40 e0       	ldi	r20, 0x00	; 0
    b2aa:	50 e0       	ldi	r21, 0x00	; 0
    b2ac:	60 e0       	ldi	r22, 0x00	; 0
    b2ae:	70 e0       	ldi	r23, 0x00	; 0
    b2b0:	0e 94 b4 08 	call	0x1168	; 0x1168 <chEvtWaitAnyTimeout>
		/*take control of LCD semaphore*/
		chSemWait(&lcdUSE);
    b2b4:	8d ef       	ldi	r24, 0xFD	; 253
    b2b6:	93 e1       	ldi	r25, 0x13	; 19
    b2b8:	40 e0       	ldi	r20, 0x00	; 0
    b2ba:	50 e0       	ldi	r21, 0x00	; 0
    b2bc:	60 e0       	ldi	r22, 0x00	; 0
    b2be:	70 e0       	ldi	r23, 0x00	; 0
    b2c0:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
		/*switch lcd_context to thread 5*/
		lcd_context = 5;
    b2c4:	25 e0       	ldi	r18, 0x05	; 5
    b2c6:	20 93 32 05 	sts	0x0532, r18
    b2ca:	11 e0       	ldi	r17, 0x01	; 1
    b2cc:	7f c1       	rjmp	.+766    	; 0xb5cc <Thread5+0x368>
			}
			/*now inside loop, respond to signal from thread1 button handler to switch sub-menu*/
			if (chEvtWaitAnyTimeout((eventmask_t)4, TIME_IMMEDIATE) == 4) {
				entry_flag =1;//we have switched menu pages, clear the lcd
			}
			if(entry_flag ==1) {
    b2ce:	11 30       	cpi	r17, 0x01	; 1
    b2d0:	09 f4       	brne	.+2      	; 0xb2d4 <Thread5+0x70>
    b2d2:	90 c1       	rjmp	.+800    	; 0xb5f4 <Thread5+0x390>
			st7735_fill_rect(0, 0, 160, 128, ST7735_COLOR_BLACK);//lcd_clear();
			st7735_setCursor(0,10);//lcd_goto_xy(1,1);
			chSemSignal(&spiUSE);
			entry_flag = 0; 
			}
			switch (lcd_context_count[4]) {
    b2d4:	80 91 37 05 	lds	r24, 0x0537
    b2d8:	82 30       	cpi	r24, 0x02	; 2
    b2da:	09 f4       	brne	.+2      	; 0xb2de <Thread5+0x7a>
    b2dc:	aa c1       	rjmp	.+852    	; 0xb632 <Thread5+0x3ce>
    b2de:	83 30       	cpi	r24, 0x03	; 3
    b2e0:	09 f4       	brne	.+2      	; 0xb2e4 <Thread5+0x80>
    b2e2:	6e c3       	rjmp	.+1756   	; 0xb9c0 <Thread5+0x75c>
    b2e4:	81 30       	cpi	r24, 0x01	; 1
    b2e6:	09 f0       	breq	.+2      	; 0xb2ea <Thread5+0x86>
    b2e8:	58 c1       	rjmp	.+688    	; 0xb59a <Thread5+0x336>
				case 1:	// action 5.2a					
					chSemWait(&i2cUSE);
    b2ea:	80 e0       	ldi	r24, 0x00	; 0
    b2ec:	94 e1       	ldi	r25, 0x14	; 20
    b2ee:	40 e0       	ldi	r20, 0x00	; 0
    b2f0:	50 e0       	ldi	r21, 0x00	; 0
    b2f2:	60 e0       	ldi	r22, 0x00	; 0
    b2f4:	70 e0       	ldi	r23, 0x00	; 0
    b2f6:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
					chSemWait(&spiUSE);
    b2fa:	89 e7       	ldi	r24, 0x79	; 121
    b2fc:	94 e1       	ldi	r25, 0x14	; 20
    b2fe:	40 e0       	ldi	r20, 0x00	; 0
    b300:	50 e0       	ldi	r21, 0x00	; 0
    b302:	60 e0       	ldi	r22, 0x00	; 0
    b304:	70 e0       	ldi	r23, 0x00	; 0
    b306:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
					fprintf_P(&st7735_out, PSTR("   Altitude: %-4.0fm\r\n"), MPL3115A2_getAltitude());// Display altitude value
    b30a:	0e 94 c9 3f 	call	0x7f92	; 0x7f92 <MPL3115A2_getAltitude>
    b30e:	4d b7       	in	r20, 0x3d	; 61
    b310:	5e b7       	in	r21, 0x3e	; 62
    b312:	48 50       	subi	r20, 0x08	; 8
    b314:	50 40       	sbci	r21, 0x00	; 0
    b316:	0f b6       	in	r0, 0x3f	; 63
    b318:	f8 94       	cli
    b31a:	5e bf       	out	0x3e, r21	; 62
    b31c:	0f be       	out	0x3f, r0	; 63
    b31e:	4d bf       	out	0x3d, r20	; 61
    b320:	ed b7       	in	r30, 0x3d	; 61
    b322:	fe b7       	in	r31, 0x3e	; 62
    b324:	31 96       	adiw	r30, 0x01	; 1
    b326:	ad b7       	in	r26, 0x3d	; 61
    b328:	be b7       	in	r27, 0x3e	; 62
    b32a:	12 96       	adiw	r26, 0x02	; 2
    b32c:	dc 93       	st	X, r29
    b32e:	ce 93       	st	-X, r28
    b330:	11 97       	sbiw	r26, 0x01	; 1
    b332:	2f eb       	ldi	r18, 0xBF	; 191
    b334:	3a e0       	ldi	r19, 0x0A	; 10
    b336:	33 83       	std	Z+3, r19	; 0x03
    b338:	22 83       	std	Z+2, r18	; 0x02
    b33a:	64 83       	std	Z+4, r22	; 0x04
    b33c:	75 83       	std	Z+5, r23	; 0x05
    b33e:	86 83       	std	Z+6, r24	; 0x06
    b340:	97 83       	std	Z+7, r25	; 0x07
    b342:	0e 94 9a 82 	call	0x10534	; 0x10534 <fprintf_P>
					chSemSignal(&spiUSE);
    b346:	4d b7       	in	r20, 0x3d	; 61
    b348:	5e b7       	in	r21, 0x3e	; 62
    b34a:	48 5f       	subi	r20, 0xF8	; 248
    b34c:	5f 4f       	sbci	r21, 0xFF	; 255
    b34e:	0f b6       	in	r0, 0x3f	; 63
    b350:	f8 94       	cli
    b352:	5e bf       	out	0x3e, r21	; 62
    b354:	0f be       	out	0x3f, r0	; 63
    b356:	4d bf       	out	0x3d, r20	; 61
    b358:	89 e7       	ldi	r24, 0x79	; 121
    b35a:	94 e1       	ldi	r25, 0x14	; 20
    b35c:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
					chSemSignal(&i2cUSE);
    b360:	80 e0       	ldi	r24, 0x00	; 0
    b362:	94 e1       	ldi	r25, 0x14	; 20
    b364:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
					
					chSemWait(&i2cUSE);
    b368:	80 e0       	ldi	r24, 0x00	; 0
    b36a:	94 e1       	ldi	r25, 0x14	; 20
    b36c:	40 e0       	ldi	r20, 0x00	; 0
    b36e:	50 e0       	ldi	r21, 0x00	; 0
    b370:	60 e0       	ldi	r22, 0x00	; 0
    b372:	70 e0       	ldi	r23, 0x00	; 0
    b374:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
					chSemWait(&spiUSE);
    b378:	89 e7       	ldi	r24, 0x79	; 121
    b37a:	94 e1       	ldi	r25, 0x14	; 20
    b37c:	40 e0       	ldi	r20, 0x00	; 0
    b37e:	50 e0       	ldi	r21, 0x00	; 0
    b380:	60 e0       	ldi	r22, 0x00	; 0
    b382:	70 e0       	ldi	r23, 0x00	; 0
    b384:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
					fprintf_P(&st7735_out, PSTR("   Pressure: %-7.0fPa\r\n"), MPL3115A2_getPressure());// Display altitude value
    b388:	0e 94 33 40 	call	0x8066	; 0x8066 <MPL3115A2_getPressure>
    b38c:	ad b7       	in	r26, 0x3d	; 61
    b38e:	be b7       	in	r27, 0x3e	; 62
    b390:	18 97       	sbiw	r26, 0x08	; 8
    b392:	0f b6       	in	r0, 0x3f	; 63
    b394:	f8 94       	cli
    b396:	be bf       	out	0x3e, r27	; 62
    b398:	0f be       	out	0x3f, r0	; 63
    b39a:	ad bf       	out	0x3d, r26	; 61
    b39c:	ed b7       	in	r30, 0x3d	; 61
    b39e:	fe b7       	in	r31, 0x3e	; 62
    b3a0:	31 96       	adiw	r30, 0x01	; 1
    b3a2:	12 96       	adiw	r26, 0x02	; 2
    b3a4:	dc 93       	st	X, r29
    b3a6:	ce 93       	st	-X, r28
    b3a8:	11 97       	sbiw	r26, 0x01	; 1
    b3aa:	27 ea       	ldi	r18, 0xA7	; 167
    b3ac:	3a e0       	ldi	r19, 0x0A	; 10
    b3ae:	33 83       	std	Z+3, r19	; 0x03
    b3b0:	22 83       	std	Z+2, r18	; 0x02
    b3b2:	64 83       	std	Z+4, r22	; 0x04
    b3b4:	75 83       	std	Z+5, r23	; 0x05
    b3b6:	86 83       	std	Z+6, r24	; 0x06
    b3b8:	97 83       	std	Z+7, r25	; 0x07
    b3ba:	0e 94 9a 82 	call	0x10534	; 0x10534 <fprintf_P>
					chSemSignal(&spiUSE);
    b3be:	4d b7       	in	r20, 0x3d	; 61
    b3c0:	5e b7       	in	r21, 0x3e	; 62
    b3c2:	48 5f       	subi	r20, 0xF8	; 248
    b3c4:	5f 4f       	sbci	r21, 0xFF	; 255
    b3c6:	0f b6       	in	r0, 0x3f	; 63
    b3c8:	f8 94       	cli
    b3ca:	5e bf       	out	0x3e, r21	; 62
    b3cc:	0f be       	out	0x3f, r0	; 63
    b3ce:	4d bf       	out	0x3d, r20	; 61
    b3d0:	89 e7       	ldi	r24, 0x79	; 121
    b3d2:	94 e1       	ldi	r25, 0x14	; 20
    b3d4:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
					chSemSignal(&i2cUSE);
    b3d8:	80 e0       	ldi	r24, 0x00	; 0
    b3da:	94 e1       	ldi	r25, 0x14	; 20
    b3dc:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
					
					chSemWait(&i2cUSE);
    b3e0:	80 e0       	ldi	r24, 0x00	; 0
    b3e2:	94 e1       	ldi	r25, 0x14	; 20
    b3e4:	40 e0       	ldi	r20, 0x00	; 0
    b3e6:	50 e0       	ldi	r21, 0x00	; 0
    b3e8:	60 e0       	ldi	r22, 0x00	; 0
    b3ea:	70 e0       	ldi	r23, 0x00	; 0
    b3ec:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
					chSemWait(&spiUSE);
    b3f0:	89 e7       	ldi	r24, 0x79	; 121
    b3f2:	94 e1       	ldi	r25, 0x14	; 20
    b3f4:	40 e0       	ldi	r20, 0x00	; 0
    b3f6:	50 e0       	ldi	r21, 0x00	; 0
    b3f8:	60 e0       	ldi	r22, 0x00	; 0
    b3fa:	70 e0       	ldi	r23, 0x00	; 0
    b3fc:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
					fprintf_P(&st7735_out, PSTR("Temperature: %-4.1f C\r\n"), MPL3115A2_getTemperature());// Display altitude value
    b400:	0e 94 95 3f 	call	0x7f2a	; 0x7f2a <MPL3115A2_getTemperature>
    b404:	ad b7       	in	r26, 0x3d	; 61
    b406:	be b7       	in	r27, 0x3e	; 62
    b408:	18 97       	sbiw	r26, 0x08	; 8
    b40a:	0f b6       	in	r0, 0x3f	; 63
    b40c:	f8 94       	cli
    b40e:	be bf       	out	0x3e, r27	; 62
    b410:	0f be       	out	0x3f, r0	; 63
    b412:	ad bf       	out	0x3d, r26	; 61
    b414:	ed b7       	in	r30, 0x3d	; 61
    b416:	fe b7       	in	r31, 0x3e	; 62
    b418:	31 96       	adiw	r30, 0x01	; 1
    b41a:	12 96       	adiw	r26, 0x02	; 2
    b41c:	dc 93       	st	X, r29
    b41e:	ce 93       	st	-X, r28
    b420:	11 97       	sbiw	r26, 0x01	; 1
    b422:	2f e8       	ldi	r18, 0x8F	; 143
    b424:	3a e0       	ldi	r19, 0x0A	; 10
    b426:	33 83       	std	Z+3, r19	; 0x03
    b428:	22 83       	std	Z+2, r18	; 0x02
    b42a:	64 83       	std	Z+4, r22	; 0x04
    b42c:	75 83       	std	Z+5, r23	; 0x05
    b42e:	86 83       	std	Z+6, r24	; 0x06
    b430:	97 83       	std	Z+7, r25	; 0x07
    b432:	0e 94 9a 82 	call	0x10534	; 0x10534 <fprintf_P>
					chSemSignal(&spiUSE);
    b436:	4d b7       	in	r20, 0x3d	; 61
    b438:	5e b7       	in	r21, 0x3e	; 62
    b43a:	48 5f       	subi	r20, 0xF8	; 248
    b43c:	5f 4f       	sbci	r21, 0xFF	; 255
    b43e:	0f b6       	in	r0, 0x3f	; 63
    b440:	f8 94       	cli
    b442:	5e bf       	out	0x3e, r21	; 62
    b444:	0f be       	out	0x3f, r0	; 63
    b446:	4d bf       	out	0x3d, r20	; 61
    b448:	89 e7       	ldi	r24, 0x79	; 121
    b44a:	94 e1       	ldi	r25, 0x14	; 20
    b44c:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
					chSemSignal(&i2cUSE);
    b450:	80 e0       	ldi	r24, 0x00	; 0
    b452:	94 e1       	ldi	r25, 0x14	; 20
    b454:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
					
					WWW = (uint16_t) battery_average;
    b458:	e0 91 43 07 	lds	r30, 0x0743
    b45c:	f0 91 44 07 	lds	r31, 0x0744
    b460:	f0 93 83 2e 	sts	0x2E83, r31
    b464:	e0 93 82 2e 	sts	0x2E82, r30
					XXX = WWW/100;
    b468:	cf 01       	movw	r24, r30
    b46a:	64 e6       	ldi	r22, 0x64	; 100
    b46c:	70 e0       	ldi	r23, 0x00	; 0
    b46e:	0e 94 e6 7f 	call	0xffcc	; 0xffcc <__udivmodhi4>
    b472:	70 93 7b 18 	sts	0x187B, r23
    b476:	60 93 7a 18 	sts	0x187A, r22
					YYY = WWW - 100*XXX;
    b47a:	24 e6       	ldi	r18, 0x64	; 100
    b47c:	30 e0       	ldi	r19, 0x00	; 0
    b47e:	62 9f       	mul	r22, r18
    b480:	c0 01       	movw	r24, r0
    b482:	63 9f       	mul	r22, r19
    b484:	90 0d       	add	r25, r0
    b486:	72 9f       	mul	r23, r18
    b488:	90 0d       	add	r25, r0
    b48a:	11 24       	eor	r1, r1
    b48c:	e8 1b       	sub	r30, r24
    b48e:	f9 0b       	sbc	r31, r25
    b490:	f0 93 f7 1c 	sts	0x1CF7, r31
    b494:	e0 93 f6 1c 	sts	0x1CF6, r30
					ZZZ = YYY/10;
    b498:	cf 01       	movw	r24, r30
    b49a:	6a e0       	ldi	r22, 0x0A	; 10
    b49c:	70 e0       	ldi	r23, 0x00	; 0
    b49e:	0e 94 e6 7f 	call	0xffcc	; 0xffcc <__udivmodhi4>
    b4a2:	60 93 66 1c 	sts	0x1C66, r22
    b4a6:	70 93 67 1c 	sts	0x1C67, r23
					AAA = YYY - 10*ZZZ;
    b4aa:	cb 01       	movw	r24, r22
    b4ac:	9b 01       	movw	r18, r22
    b4ae:	22 0f       	add	r18, r18
    b4b0:	33 1f       	adc	r19, r19
    b4b2:	22 0f       	add	r18, r18
    b4b4:	33 1f       	adc	r19, r19
    b4b6:	22 0f       	add	r18, r18
    b4b8:	33 1f       	adc	r19, r19
    b4ba:	88 0f       	add	r24, r24
    b4bc:	99 1f       	adc	r25, r25
    b4be:	28 0f       	add	r18, r24
    b4c0:	39 1f       	adc	r19, r25
    b4c2:	e2 1b       	sub	r30, r18
    b4c4:	f3 0b       	sbc	r31, r19
    b4c6:	f0 93 ff 13 	sts	0x13FF, r31
    b4ca:	e0 93 fe 13 	sts	0x13FE, r30
					
					chSemWait(&spiUSE);st7735_setCursor(0,90);//lcd_goto_xy(1,1)
    b4ce:	89 e7       	ldi	r24, 0x79	; 121
    b4d0:	94 e1       	ldi	r25, 0x14	; 20
    b4d2:	40 e0       	ldi	r20, 0x00	; 0
    b4d4:	50 e0       	ldi	r21, 0x00	; 0
    b4d6:	60 e0       	ldi	r22, 0x00	; 0
    b4d8:	70 e0       	ldi	r23, 0x00	; 0
    b4da:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
    b4de:	80 e0       	ldi	r24, 0x00	; 0
    b4e0:	90 e0       	ldi	r25, 0x00	; 0
    b4e2:	6a e5       	ldi	r22, 0x5A	; 90
    b4e4:	70 e0       	ldi	r23, 0x00	; 0
    b4e6:	0e 94 c2 19 	call	0x3384	; 0x3384 <st7735_setCursor>
					fprintf_P(&st7735_out, PSTR("   DS3231 status: 0x%02X\r\n"),DS3231_getStatus());
    b4ea:	0e 94 7f 43 	call	0x86fe	; 0x86fe <DS3231_getStatus>
    b4ee:	00 d0       	rcall	.+0      	; 0xb4f0 <Thread5+0x28c>
    b4f0:	00 d0       	rcall	.+0      	; 0xb4f2 <Thread5+0x28e>
    b4f2:	00 d0       	rcall	.+0      	; 0xb4f4 <Thread5+0x290>
    b4f4:	ed b7       	in	r30, 0x3d	; 61
    b4f6:	fe b7       	in	r31, 0x3e	; 62
    b4f8:	31 96       	adiw	r30, 0x01	; 1
    b4fa:	ad b7       	in	r26, 0x3d	; 61
    b4fc:	be b7       	in	r27, 0x3e	; 62
    b4fe:	12 96       	adiw	r26, 0x02	; 2
    b500:	dc 93       	st	X, r29
    b502:	ce 93       	st	-X, r28
    b504:	11 97       	sbiw	r26, 0x01	; 1
    b506:	24 e7       	ldi	r18, 0x74	; 116
    b508:	3a e0       	ldi	r19, 0x0A	; 10
    b50a:	33 83       	std	Z+3, r19	; 0x03
    b50c:	22 83       	std	Z+2, r18	; 0x02
    b50e:	84 83       	std	Z+4, r24	; 0x04
    b510:	15 82       	std	Z+5, r1	; 0x05
    b512:	0e 94 9a 82 	call	0x10534	; 0x10534 <fprintf_P>
					fprintf_P(&st7735_out, PSTR(" Battery Voltage: %u.%u%u\r\n"),XXX,ZZZ,AAA);
    b516:	00 d0       	rcall	.+0      	; 0xb518 <Thread5+0x2b4>
    b518:	00 d0       	rcall	.+0      	; 0xb51a <Thread5+0x2b6>
    b51a:	ed b7       	in	r30, 0x3d	; 61
    b51c:	fe b7       	in	r31, 0x3e	; 62
    b51e:	31 96       	adiw	r30, 0x01	; 1
    b520:	ad b7       	in	r26, 0x3d	; 61
    b522:	be b7       	in	r27, 0x3e	; 62
    b524:	12 96       	adiw	r26, 0x02	; 2
    b526:	dc 93       	st	X, r29
    b528:	ce 93       	st	-X, r28
    b52a:	11 97       	sbiw	r26, 0x01	; 1
    b52c:	28 e5       	ldi	r18, 0x58	; 88
    b52e:	3a e0       	ldi	r19, 0x0A	; 10
    b530:	33 83       	std	Z+3, r19	; 0x03
    b532:	22 83       	std	Z+2, r18	; 0x02
    b534:	80 91 7a 18 	lds	r24, 0x187A
    b538:	90 91 7b 18 	lds	r25, 0x187B
    b53c:	95 83       	std	Z+5, r25	; 0x05
    b53e:	84 83       	std	Z+4, r24	; 0x04
    b540:	80 91 66 1c 	lds	r24, 0x1C66
    b544:	90 91 67 1c 	lds	r25, 0x1C67
    b548:	97 83       	std	Z+7, r25	; 0x07
    b54a:	86 83       	std	Z+6, r24	; 0x06
    b54c:	80 91 fe 13 	lds	r24, 0x13FE
    b550:	90 91 ff 13 	lds	r25, 0x13FF
    b554:	91 87       	std	Z+9, r25	; 0x09
    b556:	80 87       	std	Z+8, r24	; 0x08
    b558:	0e 94 9a 82 	call	0x10534	; 0x10534 <fprintf_P>
					fprintf_P(&st7735_out, PSTR("Firmware Version: 0.12\r\n")); 
    b55c:	4d b7       	in	r20, 0x3d	; 61
    b55e:	5e b7       	in	r21, 0x3e	; 62
    b560:	4a 5f       	subi	r20, 0xFA	; 250
    b562:	5f 4f       	sbci	r21, 0xFF	; 255
    b564:	0f b6       	in	r0, 0x3f	; 63
    b566:	f8 94       	cli
    b568:	5e bf       	out	0x3e, r21	; 62
    b56a:	0f be       	out	0x3f, r0	; 63
    b56c:	4d bf       	out	0x3d, r20	; 61
    b56e:	ad b7       	in	r26, 0x3d	; 61
    b570:	be b7       	in	r27, 0x3e	; 62
    b572:	12 96       	adiw	r26, 0x02	; 2
    b574:	dc 93       	st	X, r29
    b576:	ce 93       	st	-X, r28
    b578:	11 97       	sbiw	r26, 0x01	; 1
    b57a:	ef e3       	ldi	r30, 0x3F	; 63
    b57c:	fa e0       	ldi	r31, 0x0A	; 10
    b57e:	14 96       	adiw	r26, 0x04	; 4
    b580:	fc 93       	st	X, r31
    b582:	ee 93       	st	-X, r30
    b584:	13 97       	sbiw	r26, 0x03	; 3
    b586:	0e 94 9a 82 	call	0x10534	; 0x10534 <fprintf_P>
					// screen2
					chSemSignal(&spiUSE);
    b58a:	0f 90       	pop	r0
    b58c:	0f 90       	pop	r0
    b58e:	0f 90       	pop	r0
    b590:	0f 90       	pop	r0
    b592:	89 e7       	ldi	r24, 0x79	; 121
    b594:	94 e1       	ldi	r25, 0x14	; 20
    b596:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
					fprintf_P(&st7735_out, PSTR("Temp: %-3.1f C\r\n"), DS3231_getTemp()); 
					chSemSignal(&i2cUSE);
					chSemSignal(&spiUSE);
					break;
			}
			chSemWait(&spiUSE);
    b59a:	89 e7       	ldi	r24, 0x79	; 121
    b59c:	94 e1       	ldi	r25, 0x14	; 20
    b59e:	40 e0       	ldi	r20, 0x00	; 0
    b5a0:	50 e0       	ldi	r21, 0x00	; 0
    b5a2:	60 e0       	ldi	r22, 0x00	; 0
    b5a4:	70 e0       	ldi	r23, 0x00	; 0
    b5a6:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
			st7735_setCursor(0,10);//lcd_goto_xy(1,1);
    b5aa:	80 e0       	ldi	r24, 0x00	; 0
    b5ac:	90 e0       	ldi	r25, 0x00	; 0
    b5ae:	6a e0       	ldi	r22, 0x0A	; 10
    b5b0:	70 e0       	ldi	r23, 0x00	; 0
    b5b2:	0e 94 c2 19 	call	0x3384	; 0x3384 <st7735_setCursor>
			chSemSignal(&spiUSE);
    b5b6:	89 e7       	ldi	r24, 0x79	; 121
    b5b8:	94 e1       	ldi	r25, 0x14	; 20
    b5ba:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
			chThdSleepMilliseconds(150);	
    b5be:	68 eb       	ldi	r22, 0xB8	; 184
    b5c0:	7b e0       	ldi	r23, 0x0B	; 11
    b5c2:	80 e0       	ldi	r24, 0x00	; 0
    b5c4:	90 e0       	ldi	r25, 0x00	; 0
    b5c6:	0e 94 f4 08 	call	0x11e8	; 0x11e8 <chThdSleep>
    b5ca:	10 e0       	ldi	r17, 0x00	; 0
		lcd_context = 5;
		//st7735_fill_rect(0, 0, 160, 128, ST7735_COLOR_BLACK);//lcd_clear();
		entry_flag = 1;
		while(true) {
		    /*now inside loop, wait for signal from thread1 button handler to get out*/
			if(chEvtWaitAnyTimeout((eventmask_t)2, TIME_IMMEDIATE) == 2){
    b5cc:	82 e0       	ldi	r24, 0x02	; 2
    b5ce:	4f ef       	ldi	r20, 0xFF	; 255
    b5d0:	5f ef       	ldi	r21, 0xFF	; 255
    b5d2:	6f ef       	ldi	r22, 0xFF	; 255
    b5d4:	7f ef       	ldi	r23, 0xFF	; 255
    b5d6:	0e 94 b4 08 	call	0x1168	; 0x1168 <chEvtWaitAnyTimeout>
    b5da:	82 30       	cpi	r24, 0x02	; 2
    b5dc:	09 f4       	brne	.+2      	; 0xb5e0 <Thread5+0x37c>
    b5de:	8c c3       	rjmp	.+1816   	; 0xbcf8 <Thread5+0xa94>
				chSemSignal(&lcdUSE); /*thread5 gives back the lcd */
				break;
			}
			/*now inside loop, respond to signal from thread1 button handler to switch sub-menu*/
			if (chEvtWaitAnyTimeout((eventmask_t)4, TIME_IMMEDIATE) == 4) {
    b5e0:	84 e0       	ldi	r24, 0x04	; 4
    b5e2:	4f ef       	ldi	r20, 0xFF	; 255
    b5e4:	5f ef       	ldi	r21, 0xFF	; 255
    b5e6:	6f ef       	ldi	r22, 0xFF	; 255
    b5e8:	7f ef       	ldi	r23, 0xFF	; 255
    b5ea:	0e 94 b4 08 	call	0x1168	; 0x1168 <chEvtWaitAnyTimeout>
    b5ee:	84 30       	cpi	r24, 0x04	; 4
    b5f0:	09 f0       	breq	.+2      	; 0xb5f4 <Thread5+0x390>
    b5f2:	6d ce       	rjmp	.-806    	; 0xb2ce <Thread5+0x6a>
				entry_flag =1;//we have switched menu pages, clear the lcd
			}
			if(entry_flag ==1) {
			chSemWait(&spiUSE);
    b5f4:	89 e7       	ldi	r24, 0x79	; 121
    b5f6:	94 e1       	ldi	r25, 0x14	; 20
    b5f8:	40 e0       	ldi	r20, 0x00	; 0
    b5fa:	50 e0       	ldi	r21, 0x00	; 0
    b5fc:	60 e0       	ldi	r22, 0x00	; 0
    b5fe:	70 e0       	ldi	r23, 0x00	; 0
    b600:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
			st7735_fill_rect(0, 0, 160, 128, ST7735_COLOR_BLACK);//lcd_clear();
    b604:	80 e0       	ldi	r24, 0x00	; 0
    b606:	60 e0       	ldi	r22, 0x00	; 0
    b608:	40 ea       	ldi	r20, 0xA0	; 160
    b60a:	20 e8       	ldi	r18, 0x80	; 128
    b60c:	00 e0       	ldi	r16, 0x00	; 0
    b60e:	10 e0       	ldi	r17, 0x00	; 0
    b610:	0e 94 59 16 	call	0x2cb2	; 0x2cb2 <st7735_fill_rect>
			st7735_setCursor(0,10);//lcd_goto_xy(1,1);
    b614:	80 e0       	ldi	r24, 0x00	; 0
    b616:	90 e0       	ldi	r25, 0x00	; 0
    b618:	6a e0       	ldi	r22, 0x0A	; 10
    b61a:	70 e0       	ldi	r23, 0x00	; 0
    b61c:	0e 94 c2 19 	call	0x3384	; 0x3384 <st7735_setCursor>
			chSemSignal(&spiUSE);
    b620:	89 e7       	ldi	r24, 0x79	; 121
    b622:	94 e1       	ldi	r25, 0x14	; 20
    b624:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
			entry_flag = 0; 
			}
			switch (lcd_context_count[4]) {
    b628:	80 91 37 05 	lds	r24, 0x0537
    b62c:	82 30       	cpi	r24, 0x02	; 2
    b62e:	09 f0       	breq	.+2      	; 0xb632 <Thread5+0x3ce>
    b630:	56 ce       	rjmp	.-852    	; 0xb2de <Thread5+0x7a>
					fprintf_P(&st7735_out, PSTR("Firmware Version: 0.12\r\n")); 
					// screen2
					chSemSignal(&spiUSE);
					break;
				case 2:	// action 5.2b
					chSemWait(&i2cUSE);	
    b632:	80 e0       	ldi	r24, 0x00	; 0
    b634:	94 e1       	ldi	r25, 0x14	; 20
    b636:	40 e0       	ldi	r20, 0x00	; 0
    b638:	50 e0       	ldi	r21, 0x00	; 0
    b63a:	60 e0       	ldi	r22, 0x00	; 0
    b63c:	70 e0       	ldi	r23, 0x00	; 0
    b63e:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
					L3GD20_read();
    b642:	0e 94 d5 40 	call	0x81aa	; 0x81aa <L3GD20_read>
					chSemSignal(&i2cUSE);
    b646:	80 e0       	ldi	r24, 0x00	; 0
    b648:	94 e1       	ldi	r25, 0x14	; 20
    b64a:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
					
					chSemWait(&spiUSE);
    b64e:	89 e7       	ldi	r24, 0x79	; 121
    b650:	94 e1       	ldi	r25, 0x14	; 20
    b652:	40 e0       	ldi	r20, 0x00	; 0
    b654:	50 e0       	ldi	r21, 0x00	; 0
    b656:	60 e0       	ldi	r22, 0x00	; 0
    b658:	70 e0       	ldi	r23, 0x00	; 0
    b65a:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
					fprintf_P(&st7735_out, PSTR("Rotation   x: %-7.0f\r\n"), g.x);// Display altitude value	
    b65e:	2d b7       	in	r18, 0x3d	; 61
    b660:	3e b7       	in	r19, 0x3e	; 62
    b662:	28 50       	subi	r18, 0x08	; 8
    b664:	30 40       	sbci	r19, 0x00	; 0
    b666:	0f b6       	in	r0, 0x3f	; 63
    b668:	f8 94       	cli
    b66a:	3e bf       	out	0x3e, r19	; 62
    b66c:	0f be       	out	0x3f, r0	; 63
    b66e:	2d bf       	out	0x3d, r18	; 61
    b670:	ed b7       	in	r30, 0x3d	; 61
    b672:	fe b7       	in	r31, 0x3e	; 62
    b674:	31 96       	adiw	r30, 0x01	; 1
    b676:	ad b7       	in	r26, 0x3d	; 61
    b678:	be b7       	in	r27, 0x3e	; 62
    b67a:	12 96       	adiw	r26, 0x02	; 2
    b67c:	dc 93       	st	X, r29
    b67e:	ce 93       	st	-X, r28
    b680:	11 97       	sbiw	r26, 0x01	; 1
    b682:	28 e2       	ldi	r18, 0x28	; 40
    b684:	3a e0       	ldi	r19, 0x0A	; 10
    b686:	33 83       	std	Z+3, r19	; 0x03
    b688:	22 83       	std	Z+2, r18	; 0x02
    b68a:	80 91 56 0a 	lds	r24, 0x0A56
    b68e:	90 91 57 0a 	lds	r25, 0x0A57
    b692:	a0 91 58 0a 	lds	r26, 0x0A58
    b696:	b0 91 59 0a 	lds	r27, 0x0A59
    b69a:	84 83       	std	Z+4, r24	; 0x04
    b69c:	95 83       	std	Z+5, r25	; 0x05
    b69e:	a6 83       	std	Z+6, r26	; 0x06
    b6a0:	b7 83       	std	Z+7, r27	; 0x07
    b6a2:	0e 94 9a 82 	call	0x10534	; 0x10534 <fprintf_P>
					fprintf_P(&st7735_out, PSTR("[mdeg/s]   y: %-7.0f\r\n"), g.y);// Display altitude value	
    b6a6:	ed b7       	in	r30, 0x3d	; 61
    b6a8:	fe b7       	in	r31, 0x3e	; 62
    b6aa:	31 96       	adiw	r30, 0x01	; 1
    b6ac:	ad b7       	in	r26, 0x3d	; 61
    b6ae:	be b7       	in	r27, 0x3e	; 62
    b6b0:	12 96       	adiw	r26, 0x02	; 2
    b6b2:	dc 93       	st	X, r29
    b6b4:	ce 93       	st	-X, r28
    b6b6:	11 97       	sbiw	r26, 0x01	; 1
    b6b8:	21 e1       	ldi	r18, 0x11	; 17
    b6ba:	3a e0       	ldi	r19, 0x0A	; 10
    b6bc:	33 83       	std	Z+3, r19	; 0x03
    b6be:	22 83       	std	Z+2, r18	; 0x02
    b6c0:	80 91 5a 0a 	lds	r24, 0x0A5A
    b6c4:	90 91 5b 0a 	lds	r25, 0x0A5B
    b6c8:	a0 91 5c 0a 	lds	r26, 0x0A5C
    b6cc:	b0 91 5d 0a 	lds	r27, 0x0A5D
    b6d0:	84 83       	std	Z+4, r24	; 0x04
    b6d2:	95 83       	std	Z+5, r25	; 0x05
    b6d4:	a6 83       	std	Z+6, r26	; 0x06
    b6d6:	b7 83       	std	Z+7, r27	; 0x07
    b6d8:	0e 94 9a 82 	call	0x10534	; 0x10534 <fprintf_P>
					fprintf_P(&st7735_out, PSTR("           z: %-7.0f\r\n"), g.z);// Display altitude value	
    b6dc:	ed b7       	in	r30, 0x3d	; 61
    b6de:	fe b7       	in	r31, 0x3e	; 62
    b6e0:	31 96       	adiw	r30, 0x01	; 1
    b6e2:	ad b7       	in	r26, 0x3d	; 61
    b6e4:	be b7       	in	r27, 0x3e	; 62
    b6e6:	12 96       	adiw	r26, 0x02	; 2
    b6e8:	dc 93       	st	X, r29
    b6ea:	ce 93       	st	-X, r28
    b6ec:	11 97       	sbiw	r26, 0x01	; 1
    b6ee:	2a ef       	ldi	r18, 0xFA	; 250
    b6f0:	39 e0       	ldi	r19, 0x09	; 9
    b6f2:	33 83       	std	Z+3, r19	; 0x03
    b6f4:	22 83       	std	Z+2, r18	; 0x02
    b6f6:	80 91 5e 0a 	lds	r24, 0x0A5E
    b6fa:	90 91 5f 0a 	lds	r25, 0x0A5F
    b6fe:	a0 91 60 0a 	lds	r26, 0x0A60
    b702:	b0 91 61 0a 	lds	r27, 0x0A61
    b706:	84 83       	std	Z+4, r24	; 0x04
    b708:	95 83       	std	Z+5, r25	; 0x05
    b70a:	a6 83       	std	Z+6, r26	; 0x06
    b70c:	b7 83       	std	Z+7, r27	; 0x07
    b70e:	0e 94 9a 82 	call	0x10534	; 0x10534 <fprintf_P>
					fprintf_P(&st7735_out, PSTR("\r\n")); // screen2
    b712:	0f 90       	pop	r0
    b714:	0f 90       	pop	r0
    b716:	0f 90       	pop	r0
    b718:	0f 90       	pop	r0
    b71a:	ad b7       	in	r26, 0x3d	; 61
    b71c:	be b7       	in	r27, 0x3e	; 62
    b71e:	12 96       	adiw	r26, 0x02	; 2
    b720:	dc 93       	st	X, r29
    b722:	ce 93       	st	-X, r28
    b724:	11 97       	sbiw	r26, 0x01	; 1
    b726:	e7 ef       	ldi	r30, 0xF7	; 247
    b728:	f9 e0       	ldi	r31, 0x09	; 9
    b72a:	14 96       	adiw	r26, 0x04	; 4
    b72c:	fc 93       	st	X, r31
    b72e:	ee 93       	st	-X, r30
    b730:	13 97       	sbiw	r26, 0x03	; 3
    b732:	0e 94 9a 82 	call	0x10534	; 0x10534 <fprintf_P>
					chSemSignal(&spiUSE);
    b736:	0f 90       	pop	r0
    b738:	0f 90       	pop	r0
    b73a:	0f 90       	pop	r0
    b73c:	0f 90       	pop	r0
    b73e:	89 e7       	ldi	r24, 0x79	; 121
    b740:	94 e1       	ldi	r25, 0x14	; 20
    b742:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
					
					chSemWait(&i2cUSE);	
    b746:	80 e0       	ldi	r24, 0x00	; 0
    b748:	94 e1       	ldi	r25, 0x14	; 20
    b74a:	40 e0       	ldi	r20, 0x00	; 0
    b74c:	50 e0       	ldi	r21, 0x00	; 0
    b74e:	60 e0       	ldi	r22, 0x00	; 0
    b750:	70 e0       	ldi	r23, 0x00	; 0
    b752:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
					LSM303_read();
    b756:	0e 94 8b 46 	call	0x8d16	; 0x8d16 <LSM303_read>
					chSemSignal(&i2cUSE);
    b75a:	80 e0       	ldi	r24, 0x00	; 0
    b75c:	94 e1       	ldi	r25, 0x14	; 20
    b75e:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
					
					chSemWait(&spiUSE);
    b762:	89 e7       	ldi	r24, 0x79	; 121
    b764:	94 e1       	ldi	r25, 0x14	; 20
    b766:	40 e0       	ldi	r20, 0x00	; 0
    b768:	50 e0       	ldi	r21, 0x00	; 0
    b76a:	60 e0       	ldi	r22, 0x00	; 0
    b76c:	70 e0       	ldi	r23, 0x00	; 0
    b76e:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
					fprintf_P(&st7735_out, PSTR("Accel'n    x: %-4.1f\r\n"),a.x);
    b772:	2d b7       	in	r18, 0x3d	; 61
    b774:	3e b7       	in	r19, 0x3e	; 62
    b776:	28 50       	subi	r18, 0x08	; 8
    b778:	30 40       	sbci	r19, 0x00	; 0
    b77a:	0f b6       	in	r0, 0x3f	; 63
    b77c:	f8 94       	cli
    b77e:	3e bf       	out	0x3e, r19	; 62
    b780:	0f be       	out	0x3f, r0	; 63
    b782:	2d bf       	out	0x3d, r18	; 61
    b784:	ed b7       	in	r30, 0x3d	; 61
    b786:	fe b7       	in	r31, 0x3e	; 62
    b788:	31 96       	adiw	r30, 0x01	; 1
    b78a:	ad b7       	in	r26, 0x3d	; 61
    b78c:	be b7       	in	r27, 0x3e	; 62
    b78e:	12 96       	adiw	r26, 0x02	; 2
    b790:	dc 93       	st	X, r29
    b792:	ce 93       	st	-X, r28
    b794:	11 97       	sbiw	r26, 0x01	; 1
    b796:	20 ee       	ldi	r18, 0xE0	; 224
    b798:	39 e0       	ldi	r19, 0x09	; 9
    b79a:	33 83       	std	Z+3, r19	; 0x03
    b79c:	22 83       	std	Z+2, r18	; 0x02
    b79e:	80 91 6e 0a 	lds	r24, 0x0A6E
    b7a2:	90 91 6f 0a 	lds	r25, 0x0A6F
    b7a6:	a0 91 70 0a 	lds	r26, 0x0A70
    b7aa:	b0 91 71 0a 	lds	r27, 0x0A71
    b7ae:	84 83       	std	Z+4, r24	; 0x04
    b7b0:	95 83       	std	Z+5, r25	; 0x05
    b7b2:	a6 83       	std	Z+6, r26	; 0x06
    b7b4:	b7 83       	std	Z+7, r27	; 0x07
    b7b6:	0e 94 9a 82 	call	0x10534	; 0x10534 <fprintf_P>
					fprintf_P(&st7735_out, PSTR("[g's]      y: %-4.1f\r\n"),a.y);
    b7ba:	ed b7       	in	r30, 0x3d	; 61
    b7bc:	fe b7       	in	r31, 0x3e	; 62
    b7be:	31 96       	adiw	r30, 0x01	; 1
    b7c0:	ad b7       	in	r26, 0x3d	; 61
    b7c2:	be b7       	in	r27, 0x3e	; 62
    b7c4:	12 96       	adiw	r26, 0x02	; 2
    b7c6:	dc 93       	st	X, r29
    b7c8:	ce 93       	st	-X, r28
    b7ca:	11 97       	sbiw	r26, 0x01	; 1
    b7cc:	29 ec       	ldi	r18, 0xC9	; 201
    b7ce:	39 e0       	ldi	r19, 0x09	; 9
    b7d0:	33 83       	std	Z+3, r19	; 0x03
    b7d2:	22 83       	std	Z+2, r18	; 0x02
    b7d4:	80 91 72 0a 	lds	r24, 0x0A72
    b7d8:	90 91 73 0a 	lds	r25, 0x0A73
    b7dc:	a0 91 74 0a 	lds	r26, 0x0A74
    b7e0:	b0 91 75 0a 	lds	r27, 0x0A75
    b7e4:	84 83       	std	Z+4, r24	; 0x04
    b7e6:	95 83       	std	Z+5, r25	; 0x05
    b7e8:	a6 83       	std	Z+6, r26	; 0x06
    b7ea:	b7 83       	std	Z+7, r27	; 0x07
    b7ec:	0e 94 9a 82 	call	0x10534	; 0x10534 <fprintf_P>
					fprintf_P(&st7735_out, PSTR("           z: %-4.1f\r\n"),a.z);
    b7f0:	ed b7       	in	r30, 0x3d	; 61
    b7f2:	fe b7       	in	r31, 0x3e	; 62
    b7f4:	31 96       	adiw	r30, 0x01	; 1
    b7f6:	ad b7       	in	r26, 0x3d	; 61
    b7f8:	be b7       	in	r27, 0x3e	; 62
    b7fa:	12 96       	adiw	r26, 0x02	; 2
    b7fc:	dc 93       	st	X, r29
    b7fe:	ce 93       	st	-X, r28
    b800:	11 97       	sbiw	r26, 0x01	; 1
    b802:	22 eb       	ldi	r18, 0xB2	; 178
    b804:	39 e0       	ldi	r19, 0x09	; 9
    b806:	33 83       	std	Z+3, r19	; 0x03
    b808:	22 83       	std	Z+2, r18	; 0x02
    b80a:	80 91 76 0a 	lds	r24, 0x0A76
    b80e:	90 91 77 0a 	lds	r25, 0x0A77
    b812:	a0 91 78 0a 	lds	r26, 0x0A78
    b816:	b0 91 79 0a 	lds	r27, 0x0A79
    b81a:	84 83       	std	Z+4, r24	; 0x04
    b81c:	95 83       	std	Z+5, r25	; 0x05
    b81e:	a6 83       	std	Z+6, r26	; 0x06
    b820:	b7 83       	std	Z+7, r27	; 0x07
    b822:	0e 94 9a 82 	call	0x10534	; 0x10534 <fprintf_P>
					fprintf_P(&st7735_out, PSTR("\r\n")); // screen2
    b826:	0f 90       	pop	r0
    b828:	0f 90       	pop	r0
    b82a:	0f 90       	pop	r0
    b82c:	0f 90       	pop	r0
    b82e:	ad b7       	in	r26, 0x3d	; 61
    b830:	be b7       	in	r27, 0x3e	; 62
    b832:	12 96       	adiw	r26, 0x02	; 2
    b834:	dc 93       	st	X, r29
    b836:	ce 93       	st	-X, r28
    b838:	11 97       	sbiw	r26, 0x01	; 1
    b83a:	ef ea       	ldi	r30, 0xAF	; 175
    b83c:	f9 e0       	ldi	r31, 0x09	; 9
    b83e:	14 96       	adiw	r26, 0x04	; 4
    b840:	fc 93       	st	X, r31
    b842:	ee 93       	st	-X, r30
    b844:	13 97       	sbiw	r26, 0x03	; 3
    b846:	0e 94 9a 82 	call	0x10534	; 0x10534 <fprintf_P>
					fprintf_P(&st7735_out, PSTR("Mag Field  x: %-6.1f\r\n"),m.x);
    b84a:	00 d0       	rcall	.+0      	; 0xb84c <Thread5+0x5e8>
    b84c:	00 d0       	rcall	.+0      	; 0xb84e <Thread5+0x5ea>
    b84e:	ed b7       	in	r30, 0x3d	; 61
    b850:	fe b7       	in	r31, 0x3e	; 62
    b852:	31 96       	adiw	r30, 0x01	; 1
    b854:	ad b7       	in	r26, 0x3d	; 61
    b856:	be b7       	in	r27, 0x3e	; 62
    b858:	12 96       	adiw	r26, 0x02	; 2
    b85a:	dc 93       	st	X, r29
    b85c:	ce 93       	st	-X, r28
    b85e:	11 97       	sbiw	r26, 0x01	; 1
    b860:	28 e9       	ldi	r18, 0x98	; 152
    b862:	39 e0       	ldi	r19, 0x09	; 9
    b864:	33 83       	std	Z+3, r19	; 0x03
    b866:	22 83       	std	Z+2, r18	; 0x02
    b868:	80 91 86 0a 	lds	r24, 0x0A86
    b86c:	90 91 87 0a 	lds	r25, 0x0A87
    b870:	a0 91 88 0a 	lds	r26, 0x0A88
    b874:	b0 91 89 0a 	lds	r27, 0x0A89
    b878:	84 83       	std	Z+4, r24	; 0x04
    b87a:	95 83       	std	Z+5, r25	; 0x05
    b87c:	a6 83       	std	Z+6, r26	; 0x06
    b87e:	b7 83       	std	Z+7, r27	; 0x07
    b880:	0e 94 9a 82 	call	0x10534	; 0x10534 <fprintf_P>
					fprintf_P(&st7735_out, PSTR("[mgauss]   y: %-6.1f\r\n"),m.y);
    b884:	ed b7       	in	r30, 0x3d	; 61
    b886:	fe b7       	in	r31, 0x3e	; 62
    b888:	31 96       	adiw	r30, 0x01	; 1
    b88a:	ad b7       	in	r26, 0x3d	; 61
    b88c:	be b7       	in	r27, 0x3e	; 62
    b88e:	12 96       	adiw	r26, 0x02	; 2
    b890:	dc 93       	st	X, r29
    b892:	ce 93       	st	-X, r28
    b894:	11 97       	sbiw	r26, 0x01	; 1
    b896:	21 e8       	ldi	r18, 0x81	; 129
    b898:	39 e0       	ldi	r19, 0x09	; 9
    b89a:	33 83       	std	Z+3, r19	; 0x03
    b89c:	22 83       	std	Z+2, r18	; 0x02
    b89e:	80 91 8a 0a 	lds	r24, 0x0A8A
    b8a2:	90 91 8b 0a 	lds	r25, 0x0A8B
    b8a6:	a0 91 8c 0a 	lds	r26, 0x0A8C
    b8aa:	b0 91 8d 0a 	lds	r27, 0x0A8D
    b8ae:	84 83       	std	Z+4, r24	; 0x04
    b8b0:	95 83       	std	Z+5, r25	; 0x05
    b8b2:	a6 83       	std	Z+6, r26	; 0x06
    b8b4:	b7 83       	std	Z+7, r27	; 0x07
    b8b6:	0e 94 9a 82 	call	0x10534	; 0x10534 <fprintf_P>
					fprintf_P(&st7735_out, PSTR("           z: %-6.1f\r\n"),m.z);
    b8ba:	ed b7       	in	r30, 0x3d	; 61
    b8bc:	fe b7       	in	r31, 0x3e	; 62
    b8be:	31 96       	adiw	r30, 0x01	; 1
    b8c0:	ad b7       	in	r26, 0x3d	; 61
    b8c2:	be b7       	in	r27, 0x3e	; 62
    b8c4:	12 96       	adiw	r26, 0x02	; 2
    b8c6:	dc 93       	st	X, r29
    b8c8:	ce 93       	st	-X, r28
    b8ca:	11 97       	sbiw	r26, 0x01	; 1
    b8cc:	73 82       	std	Z+3, r7	; 0x03
    b8ce:	62 82       	std	Z+2, r6	; 0x02
    b8d0:	80 91 8e 0a 	lds	r24, 0x0A8E
    b8d4:	90 91 8f 0a 	lds	r25, 0x0A8F
    b8d8:	a0 91 90 0a 	lds	r26, 0x0A90
    b8dc:	b0 91 91 0a 	lds	r27, 0x0A91
    b8e0:	84 83       	std	Z+4, r24	; 0x04
    b8e2:	95 83       	std	Z+5, r25	; 0x05
    b8e4:	a6 83       	std	Z+6, r26	; 0x06
    b8e6:	b7 83       	std	Z+7, r27	; 0x07
    b8e8:	0e 94 9a 82 	call	0x10534	; 0x10534 <fprintf_P>
					fprintf_P(&st7735_out, PSTR("\r\n"));
    b8ec:	0f 90       	pop	r0
    b8ee:	0f 90       	pop	r0
    b8f0:	0f 90       	pop	r0
    b8f2:	0f 90       	pop	r0
    b8f4:	ed b7       	in	r30, 0x3d	; 61
    b8f6:	fe b7       	in	r31, 0x3e	; 62
    b8f8:	d2 83       	std	Z+2, r29	; 0x02
    b8fa:	c1 83       	std	Z+1, r28	; 0x01
    b8fc:	54 82       	std	Z+4, r5	; 0x04
    b8fe:	43 82       	std	Z+3, r4	; 0x03
    b900:	0e 94 9a 82 	call	0x10534	; 0x10534 <fprintf_P>
					chSemSignal(&spiUSE);
    b904:	0f 90       	pop	r0
    b906:	0f 90       	pop	r0
    b908:	0f 90       	pop	r0
    b90a:	0f 90       	pop	r0
    b90c:	89 e7       	ldi	r24, 0x79	; 121
    b90e:	94 e1       	ldi	r25, 0x14	; 20
    b910:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>

					chSemWait(&i2cUSE);	
    b914:	80 e0       	ldi	r24, 0x00	; 0
    b916:	94 e1       	ldi	r25, 0x14	; 20
    b918:	40 e0       	ldi	r20, 0x00	; 0
    b91a:	50 e0       	ldi	r21, 0x00	; 0
    b91c:	60 e0       	ldi	r22, 0x00	; 0
    b91e:	70 e0       	ldi	r23, 0x00	; 0
    b920:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
					corrected_heading = LSM303_heading();
    b924:	0e 94 5a 45 	call	0x8ab4	; 0x8ab4 <LSM303_heading>
    b928:	7b 01       	movw	r14, r22
    b92a:	8c 01       	movw	r16, r24
					chSemSignal(&i2cUSE);	
    b92c:	80 e0       	ldi	r24, 0x00	; 0
    b92e:	94 e1       	ldi	r25, 0x14	; 20
    b930:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
					
					if (corrected_heading < 180.0) {
    b934:	c8 01       	movw	r24, r16
    b936:	b7 01       	movw	r22, r14
    b938:	20 e0       	ldi	r18, 0x00	; 0
    b93a:	30 e0       	ldi	r19, 0x00	; 0
    b93c:	44 e3       	ldi	r20, 0x34	; 52
    b93e:	53 e4       	ldi	r21, 0x43	; 67
    b940:	0e 94 4a 7d 	call	0xfa94	; 0xfa94 <__cmpsf2>
    b944:	88 23       	and	r24, r24
    b946:	0c f0       	brlt	.+2      	; 0xb94a <Thread5+0x6e6>
    b948:	cc c1       	rjmp	.+920    	; 0xbce2 <Thread5+0xa7e>
						corrected_heading += 180.0;
    b94a:	c8 01       	movw	r24, r16
    b94c:	b7 01       	movw	r22, r14
    b94e:	20 e0       	ldi	r18, 0x00	; 0
    b950:	30 e0       	ldi	r19, 0x00	; 0
    b952:	44 e3       	ldi	r20, 0x34	; 52
    b954:	53 e4       	ldi	r21, 0x43	; 67
    b956:	0e 94 84 7c 	call	0xf908	; 0xf908 <__addsf3>
    b95a:	7b 01       	movw	r14, r22
    b95c:	8c 01       	movw	r16, r24
					}
					else {
						corrected_heading -= 180.0;
					}
					
					chSemWait(&spiUSE);
    b95e:	89 e7       	ldi	r24, 0x79	; 121
    b960:	94 e1       	ldi	r25, 0x14	; 20
    b962:	40 e0       	ldi	r20, 0x00	; 0
    b964:	50 e0       	ldi	r21, 0x00	; 0
    b966:	60 e0       	ldi	r22, 0x00	; 0
    b968:	70 e0       	ldi	r23, 0x00	; 0
    b96a:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
					fprintf_P(&st7735_out, PSTR("^ North %3.0f degrees East ^\r\n"),corrected_heading);
    b96e:	2d b7       	in	r18, 0x3d	; 61
    b970:	3e b7       	in	r19, 0x3e	; 62
    b972:	28 50       	subi	r18, 0x08	; 8
    b974:	30 40       	sbci	r19, 0x00	; 0
    b976:	0f b6       	in	r0, 0x3f	; 63
    b978:	f8 94       	cli
    b97a:	3e bf       	out	0x3e, r19	; 62
    b97c:	0f be       	out	0x3f, r0	; 63
    b97e:	2d bf       	out	0x3d, r18	; 61
    b980:	ed b7       	in	r30, 0x3d	; 61
    b982:	fe b7       	in	r31, 0x3e	; 62
    b984:	31 96       	adiw	r30, 0x01	; 1
    b986:	ad b7       	in	r26, 0x3d	; 61
    b988:	be b7       	in	r27, 0x3e	; 62
    b98a:	12 96       	adiw	r26, 0x02	; 2
    b98c:	dc 93       	st	X, r29
    b98e:	ce 93       	st	-X, r28
    b990:	11 97       	sbiw	r26, 0x01	; 1
    b992:	33 82       	std	Z+3, r3	; 0x03
    b994:	22 82       	std	Z+2, r2	; 0x02
    b996:	c7 01       	movw	r24, r14
    b998:	d8 01       	movw	r26, r16
    b99a:	84 83       	std	Z+4, r24	; 0x04
    b99c:	95 83       	std	Z+5, r25	; 0x05
    b99e:	a6 83       	std	Z+6, r26	; 0x06
    b9a0:	b7 83       	std	Z+7, r27	; 0x07
    b9a2:	0e 94 9a 82 	call	0x10534	; 0x10534 <fprintf_P>
					chSemSignal(&spiUSE);
    b9a6:	ed b7       	in	r30, 0x3d	; 61
    b9a8:	fe b7       	in	r31, 0x3e	; 62
    b9aa:	38 96       	adiw	r30, 0x08	; 8
    b9ac:	0f b6       	in	r0, 0x3f	; 63
    b9ae:	f8 94       	cli
    b9b0:	fe bf       	out	0x3e, r31	; 62
    b9b2:	0f be       	out	0x3f, r0	; 63
    b9b4:	ed bf       	out	0x3d, r30	; 61
    b9b6:	89 e7       	ldi	r24, 0x79	; 121
    b9b8:	94 e1       	ldi	r25, 0x14	; 20
    b9ba:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
    b9be:	ed cd       	rjmp	.-1062   	; 0xb59a <Thread5+0x336>
					
					break;
				case 3:// action 5.2c
					chSemWait(&i2cUSE);
    b9c0:	80 e0       	ldi	r24, 0x00	; 0
    b9c2:	94 e1       	ldi	r25, 0x14	; 20
    b9c4:	40 e0       	ldi	r20, 0x00	; 0
    b9c6:	50 e0       	ldi	r21, 0x00	; 0
    b9c8:	60 e0       	ldi	r22, 0x00	; 0
    b9ca:	70 e0       	ldi	r23, 0x00	; 0
    b9cc:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
					DS3231_getTime(&hr, &min, &s, &am_pm, hr_format); 
    b9d0:	00 91 56 05 	lds	r16, 0x0556
    b9d4:	10 91 57 05 	lds	r17, 0x0557
    b9d8:	81 e5       	ldi	r24, 0x51	; 81
    b9da:	95 e0       	ldi	r25, 0x05	; 5
    b9dc:	60 e5       	ldi	r22, 0x50	; 80
    b9de:	75 e0       	ldi	r23, 0x05	; 5
    b9e0:	47 e4       	ldi	r20, 0x47	; 71
    b9e2:	57 e0       	ldi	r21, 0x07	; 7
    b9e4:	28 e4       	ldi	r18, 0x48	; 72
    b9e6:	37 e0       	ldi	r19, 0x07	; 7
    b9e8:	0e 94 e2 43 	call	0x87c4	; 0x87c4 <DS3231_getTime>
					chSemSignal(&i2cUSE);
    b9ec:	80 e0       	ldi	r24, 0x00	; 0
    b9ee:	94 e1       	ldi	r25, 0x14	; 20
    b9f0:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>

					chSemWait(&i2cUSE);
    b9f4:	80 e0       	ldi	r24, 0x00	; 0
    b9f6:	94 e1       	ldi	r25, 0x14	; 20
    b9f8:	40 e0       	ldi	r20, 0x00	; 0
    b9fa:	50 e0       	ldi	r21, 0x00	; 0
    b9fc:	60 e0       	ldi	r22, 0x00	; 0
    b9fe:	70 e0       	ldi	r23, 0x00	; 0
    ba00:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
					DS3231_getDate(&dy, &dt, &mt, &yr);
    ba04:	82 e5       	ldi	r24, 0x52	; 82
    ba06:	95 e0       	ldi	r25, 0x05	; 5
    ba08:	63 e5       	ldi	r22, 0x53	; 83
    ba0a:	75 e0       	ldi	r23, 0x05	; 5
    ba0c:	44 e5       	ldi	r20, 0x54	; 84
    ba0e:	55 e0       	ldi	r21, 0x05	; 5
    ba10:	25 e5       	ldi	r18, 0x55	; 85
    ba12:	35 e0       	ldi	r19, 0x05	; 5
    ba14:	0e 94 83 43 	call	0x8706	; 0x8706 <DS3231_getDate>
					chSemSignal(&i2cUSE);
    ba18:	80 e0       	ldi	r24, 0x00	; 0
    ba1a:	94 e1       	ldi	r25, 0x14	; 20
    ba1c:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
					
					chSemWait(&spiUSE);
    ba20:	89 e7       	ldi	r24, 0x79	; 121
    ba22:	94 e1       	ldi	r25, 0x14	; 20
    ba24:	40 e0       	ldi	r20, 0x00	; 0
    ba26:	50 e0       	ldi	r21, 0x00	; 0
    ba28:	60 e0       	ldi	r22, 0x00	; 0
    ba2a:	70 e0       	ldi	r23, 0x00	; 0
    ba2c:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
					st7735_setTextSize(2);
    ba30:	82 e0       	ldi	r24, 0x02	; 2
    ba32:	0e 94 cb 19 	call	0x3396	; 0x3396 <st7735_setTextSize>
					fprintf_P(&st7735_out, PSTR("%s"), DAY_NAME[dy-1]);
    ba36:	00 d0       	rcall	.+0      	; 0xba38 <Thread5+0x7d4>
    ba38:	00 d0       	rcall	.+0      	; 0xba3a <Thread5+0x7d6>
    ba3a:	00 d0       	rcall	.+0      	; 0xba3c <Thread5+0x7d8>
    ba3c:	ad b7       	in	r26, 0x3d	; 61
    ba3e:	be b7       	in	r27, 0x3e	; 62
    ba40:	11 96       	adiw	r26, 0x01	; 1
    ba42:	ed b7       	in	r30, 0x3d	; 61
    ba44:	fe b7       	in	r31, 0x3e	; 62
    ba46:	d2 83       	std	Z+2, r29	; 0x02
    ba48:	c1 83       	std	Z+1, r28	; 0x01
    ba4a:	25 e4       	ldi	r18, 0x45	; 69
    ba4c:	39 e0       	ldi	r19, 0x09	; 9
    ba4e:	13 96       	adiw	r26, 0x03	; 3
    ba50:	3c 93       	st	X, r19
    ba52:	2e 93       	st	-X, r18
    ba54:	12 97       	sbiw	r26, 0x02	; 2
    ba56:	e0 91 52 05 	lds	r30, 0x0552
    ba5a:	f0 e0       	ldi	r31, 0x00	; 0
    ba5c:	ee 0f       	add	r30, r30
    ba5e:	ff 1f       	adc	r31, r31
    ba60:	ee 58       	subi	r30, 0x8E	; 142
    ba62:	fa 4f       	sbci	r31, 0xFA	; 250
    ba64:	80 81       	ld	r24, Z
    ba66:	91 81       	ldd	r25, Z+1	; 0x01
    ba68:	15 96       	adiw	r26, 0x05	; 5
    ba6a:	9c 93       	st	X, r25
    ba6c:	8e 93       	st	-X, r24
    ba6e:	14 97       	sbiw	r26, 0x04	; 4
    ba70:	0e 94 9a 82 	call	0x10534	; 0x10534 <fprintf_P>
					st7735_setCursor(64,10);//lcd_goto_xy(1,1);
    ba74:	4d b7       	in	r20, 0x3d	; 61
    ba76:	5e b7       	in	r21, 0x3e	; 62
    ba78:	4a 5f       	subi	r20, 0xFA	; 250
    ba7a:	5f 4f       	sbci	r21, 0xFF	; 255
    ba7c:	0f b6       	in	r0, 0x3f	; 63
    ba7e:	f8 94       	cli
    ba80:	5e bf       	out	0x3e, r21	; 62
    ba82:	0f be       	out	0x3f, r0	; 63
    ba84:	4d bf       	out	0x3d, r20	; 61
    ba86:	80 e4       	ldi	r24, 0x40	; 64
    ba88:	90 e0       	ldi	r25, 0x00	; 0
    ba8a:	6a e0       	ldi	r22, 0x0A	; 10
    ba8c:	70 e0       	ldi	r23, 0x00	; 0
    ba8e:	0e 94 c2 19 	call	0x3384	; 0x3384 <st7735_setCursor>
					fprintf_P(&st7735_out, PSTR("%2u/%02u/%02u\r\n"), mt, dt, yr);
    ba92:	8d b7       	in	r24, 0x3d	; 61
    ba94:	9e b7       	in	r25, 0x3e	; 62
    ba96:	0a 97       	sbiw	r24, 0x0a	; 10
    ba98:	0f b6       	in	r0, 0x3f	; 63
    ba9a:	f8 94       	cli
    ba9c:	9e bf       	out	0x3e, r25	; 62
    ba9e:	0f be       	out	0x3f, r0	; 63
    baa0:	8d bf       	out	0x3d, r24	; 61
    baa2:	ed b7       	in	r30, 0x3d	; 61
    baa4:	fe b7       	in	r31, 0x3e	; 62
    baa6:	31 96       	adiw	r30, 0x01	; 1
    baa8:	ad b7       	in	r26, 0x3d	; 61
    baaa:	be b7       	in	r27, 0x3e	; 62
    baac:	12 96       	adiw	r26, 0x02	; 2
    baae:	dc 93       	st	X, r29
    bab0:	ce 93       	st	-X, r28
    bab2:	11 97       	sbiw	r26, 0x01	; 1
    bab4:	93 82       	std	Z+3, r9	; 0x03
    bab6:	82 82       	std	Z+2, r8	; 0x02
    bab8:	80 91 54 05 	lds	r24, 0x0554
    babc:	84 83       	std	Z+4, r24	; 0x04
    babe:	15 82       	std	Z+5, r1	; 0x05
    bac0:	80 91 53 05 	lds	r24, 0x0553
    bac4:	86 83       	std	Z+6, r24	; 0x06
    bac6:	17 82       	std	Z+7, r1	; 0x07
    bac8:	80 91 55 05 	lds	r24, 0x0555
    bacc:	80 87       	std	Z+8, r24	; 0x08
    bace:	11 86       	std	Z+9, r1	; 0x09
    bad0:	0e 94 9a 82 	call	0x10534	; 0x10534 <fprintf_P>
					chSemSignal(&spiUSE);
    bad4:	ed b7       	in	r30, 0x3d	; 61
    bad6:	fe b7       	in	r31, 0x3e	; 62
    bad8:	3a 96       	adiw	r30, 0x0a	; 10
    bada:	0f b6       	in	r0, 0x3f	; 63
    badc:	f8 94       	cli
    bade:	fe bf       	out	0x3e, r31	; 62
    bae0:	0f be       	out	0x3f, r0	; 63
    bae2:	ed bf       	out	0x3d, r30	; 61
    bae4:	89 e7       	ldi	r24, 0x79	; 121
    bae6:	94 e1       	ldi	r25, 0x14	; 20
    bae8:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
					
					if (hr_format==1) {                                  
    baec:	80 91 56 05 	lds	r24, 0x0556
    baf0:	90 91 57 05 	lds	r25, 0x0557
    baf4:	01 97       	sbiw	r24, 0x01	; 1
    baf6:	09 f0       	breq	.+2      	; 0xbafa <Thread5+0x896>
    baf8:	ad c0       	rjmp	.+346    	; 0xbc54 <Thread5+0x9f0>
						if (am_pm==1) {
    bafa:	80 91 48 07 	lds	r24, 0x0748
    bafe:	90 91 49 07 	lds	r25, 0x0749
    bb02:	01 97       	sbiw	r24, 0x01	; 1
    bb04:	09 f4       	brne	.+2      	; 0xbb08 <Thread5+0x8a4>
    bb06:	fd c0       	rjmp	.+506    	; 0xbd02 <Thread5+0xa9e>
							fprintf_P(&st7735_out, PSTR("PM\r\n"));    
							st7735_setTextSize(3);
							chSemSignal(&spiUSE);
						}
						else {
							chSemWait(&spiUSE);
    bb08:	89 e7       	ldi	r24, 0x79	; 121
    bb0a:	94 e1       	ldi	r25, 0x14	; 20
    bb0c:	40 e0       	ldi	r20, 0x00	; 0
    bb0e:	50 e0       	ldi	r21, 0x00	; 0
    bb10:	60 e0       	ldi	r22, 0x00	; 0
    bb12:	70 e0       	ldi	r23, 0x00	; 0
    bb14:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
							st7735_setCursor(0,50);//lcd_goto_xy(1,1);
    bb18:	80 e0       	ldi	r24, 0x00	; 0
    bb1a:	90 e0       	ldi	r25, 0x00	; 0
    bb1c:	62 e3       	ldi	r22, 0x32	; 50
    bb1e:	70 e0       	ldi	r23, 0x00	; 0
    bb20:	0e 94 c2 19 	call	0x3384	; 0x3384 <st7735_setCursor>
							st7735_setTextSize(3);
    bb24:	83 e0       	ldi	r24, 0x03	; 3
    bb26:	0e 94 cb 19 	call	0x3396	; 0x3396 <st7735_setTextSize>
							fprintf_P(&st7735_out, PSTR("%2u:%02u:%02u\r\n"), hr, min, s);
    bb2a:	2d b7       	in	r18, 0x3d	; 61
    bb2c:	3e b7       	in	r19, 0x3e	; 62
    bb2e:	2a 50       	subi	r18, 0x0A	; 10
    bb30:	30 40       	sbci	r19, 0x00	; 0
    bb32:	0f b6       	in	r0, 0x3f	; 63
    bb34:	f8 94       	cli
    bb36:	3e bf       	out	0x3e, r19	; 62
    bb38:	0f be       	out	0x3f, r0	; 63
    bb3a:	2d bf       	out	0x3d, r18	; 61
    bb3c:	ed b7       	in	r30, 0x3d	; 61
    bb3e:	fe b7       	in	r31, 0x3e	; 62
    bb40:	31 96       	adiw	r30, 0x01	; 1
    bb42:	ad b7       	in	r26, 0x3d	; 61
    bb44:	be b7       	in	r27, 0x3e	; 62
    bb46:	11 96       	adiw	r26, 0x01	; 1
    bb48:	dc 92       	st	X, r13
    bb4a:	11 97       	sbiw	r26, 0x01	; 1
    bb4c:	12 96       	adiw	r26, 0x02	; 2
    bb4e:	cc 92       	st	X, r12
    bb50:	20 e1       	ldi	r18, 0x10	; 16
    bb52:	39 e0       	ldi	r19, 0x09	; 9
    bb54:	33 83       	std	Z+3, r19	; 0x03
    bb56:	22 83       	std	Z+2, r18	; 0x02
    bb58:	80 91 51 05 	lds	r24, 0x0551
    bb5c:	84 83       	std	Z+4, r24	; 0x04
    bb5e:	15 82       	std	Z+5, r1	; 0x05
    bb60:	80 91 50 05 	lds	r24, 0x0550
    bb64:	86 83       	std	Z+6, r24	; 0x06
    bb66:	17 82       	std	Z+7, r1	; 0x07
    bb68:	80 91 47 07 	lds	r24, 0x0747
    bb6c:	80 87       	std	Z+8, r24	; 0x08
    bb6e:	11 86       	std	Z+9, r1	; 0x09
    bb70:	0e 94 9a 82 	call	0x10534	; 0x10534 <fprintf_P>
							st7735_setTextSize(1);
    bb74:	4d b7       	in	r20, 0x3d	; 61
    bb76:	5e b7       	in	r21, 0x3e	; 62
    bb78:	46 5f       	subi	r20, 0xF6	; 246
    bb7a:	5f 4f       	sbci	r21, 0xFF	; 255
    bb7c:	0f b6       	in	r0, 0x3f	; 63
    bb7e:	f8 94       	cli
    bb80:	5e bf       	out	0x3e, r21	; 62
    bb82:	0f be       	out	0x3f, r0	; 63
    bb84:	4d bf       	out	0x3d, r20	; 61
    bb86:	81 e0       	ldi	r24, 0x01	; 1
    bb88:	0e 94 cb 19 	call	0x3396	; 0x3396 <st7735_setTextSize>
							st7735_setCursor(148,50);//lcd_goto_xy(1,1);
    bb8c:	84 e9       	ldi	r24, 0x94	; 148
    bb8e:	90 e0       	ldi	r25, 0x00	; 0
    bb90:	62 e3       	ldi	r22, 0x32	; 50
    bb92:	70 e0       	ldi	r23, 0x00	; 0
    bb94:	0e 94 c2 19 	call	0x3384	; 0x3384 <st7735_setCursor>
							fprintf_P(&st7735_out, PSTR("AM\r\n"));    
    bb98:	00 d0       	rcall	.+0      	; 0xbb9a <Thread5+0x936>
    bb9a:	00 d0       	rcall	.+0      	; 0xbb9c <Thread5+0x938>
    bb9c:	ad b7       	in	r26, 0x3d	; 61
    bb9e:	be b7       	in	r27, 0x3e	; 62
    bba0:	12 96       	adiw	r26, 0x02	; 2
    bba2:	dc 93       	st	X, r29
    bba4:	ce 93       	st	-X, r28
    bba6:	11 97       	sbiw	r26, 0x01	; 1
    bba8:	eb e0       	ldi	r30, 0x0B	; 11
    bbaa:	f9 e0       	ldi	r31, 0x09	; 9
    bbac:	14 96       	adiw	r26, 0x04	; 4
    bbae:	fc 93       	st	X, r31
    bbb0:	ee 93       	st	-X, r30
    bbb2:	13 97       	sbiw	r26, 0x03	; 3
    bbb4:	0e 94 9a 82 	call	0x10534	; 0x10534 <fprintf_P>
							st7735_setTextSize(3);
    bbb8:	0f 90       	pop	r0
    bbba:	0f 90       	pop	r0
    bbbc:	0f 90       	pop	r0
    bbbe:	0f 90       	pop	r0
    bbc0:	83 e0       	ldi	r24, 0x03	; 3
    bbc2:	0e 94 cb 19 	call	0x3396	; 0x3396 <st7735_setTextSize>
							chSemSignal(&spiUSE);
    bbc6:	89 e7       	ldi	r24, 0x79	; 121
    bbc8:	94 e1       	ldi	r25, 0x14	; 20
    bbca:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
						fprintf_P(&st7735_out, PSTR("%02u:%02u:%02u\r\n"), hr, min, s);
						st7735_setTextSize(1);
						chSemSignal(&spiUSE);
					}//hr_format				
					//DS3231_showParameters(0);
					chSemWait(&spiUSE);
    bbce:	89 e7       	ldi	r24, 0x79	; 121
    bbd0:	94 e1       	ldi	r25, 0x14	; 20
    bbd2:	40 e0       	ldi	r20, 0x00	; 0
    bbd4:	50 e0       	ldi	r21, 0x00	; 0
    bbd6:	60 e0       	ldi	r22, 0x00	; 0
    bbd8:	70 e0       	ldi	r23, 0x00	; 0
    bbda:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
					st7735_setCursor(0,120);//lcd_goto_xy(1,1);
    bbde:	80 e0       	ldi	r24, 0x00	; 0
    bbe0:	90 e0       	ldi	r25, 0x00	; 0
    bbe2:	68 e7       	ldi	r22, 0x78	; 120
    bbe4:	70 e0       	ldi	r23, 0x00	; 0
    bbe6:	0e 94 c2 19 	call	0x3384	; 0x3384 <st7735_setCursor>
					st7735_setTextSize(1);
    bbea:	81 e0       	ldi	r24, 0x01	; 1
    bbec:	0e 94 cb 19 	call	0x3396	; 0x3396 <st7735_setTextSize>
					chSemWait(&i2cUSE);
    bbf0:	80 e0       	ldi	r24, 0x00	; 0
    bbf2:	94 e1       	ldi	r25, 0x14	; 20
    bbf4:	40 e0       	ldi	r20, 0x00	; 0
    bbf6:	50 e0       	ldi	r21, 0x00	; 0
    bbf8:	60 e0       	ldi	r22, 0x00	; 0
    bbfa:	70 e0       	ldi	r23, 0x00	; 0
    bbfc:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
					fprintf_P(&st7735_out, PSTR("Temp: %-3.1f C\r\n"), DS3231_getTemp()); 
    bc00:	0e 94 45 43 	call	0x868a	; 0x868a <DS3231_getTemp>
    bc04:	ad b7       	in	r26, 0x3d	; 61
    bc06:	be b7       	in	r27, 0x3e	; 62
    bc08:	18 97       	sbiw	r26, 0x08	; 8
    bc0a:	0f b6       	in	r0, 0x3f	; 63
    bc0c:	f8 94       	cli
    bc0e:	be bf       	out	0x3e, r27	; 62
    bc10:	0f be       	out	0x3f, r0	; 63
    bc12:	ad bf       	out	0x3d, r26	; 61
    bc14:	ed b7       	in	r30, 0x3d	; 61
    bc16:	fe b7       	in	r31, 0x3e	; 62
    bc18:	31 96       	adiw	r30, 0x01	; 1
    bc1a:	12 96       	adiw	r26, 0x02	; 2
    bc1c:	dc 93       	st	X, r29
    bc1e:	ce 93       	st	-X, r28
    bc20:	11 97       	sbiw	r26, 0x01	; 1
    bc22:	b3 82       	std	Z+3, r11	; 0x03
    bc24:	a2 82       	std	Z+2, r10	; 0x02
    bc26:	64 83       	std	Z+4, r22	; 0x04
    bc28:	75 83       	std	Z+5, r23	; 0x05
    bc2a:	86 83       	std	Z+6, r24	; 0x06
    bc2c:	97 83       	std	Z+7, r25	; 0x07
    bc2e:	0e 94 9a 82 	call	0x10534	; 0x10534 <fprintf_P>
					chSemSignal(&i2cUSE);
    bc32:	ed b7       	in	r30, 0x3d	; 61
    bc34:	fe b7       	in	r31, 0x3e	; 62
    bc36:	38 96       	adiw	r30, 0x08	; 8
    bc38:	0f b6       	in	r0, 0x3f	; 63
    bc3a:	f8 94       	cli
    bc3c:	fe bf       	out	0x3e, r31	; 62
    bc3e:	0f be       	out	0x3f, r0	; 63
    bc40:	ed bf       	out	0x3d, r30	; 61
    bc42:	80 e0       	ldi	r24, 0x00	; 0
    bc44:	94 e1       	ldi	r25, 0x14	; 20
    bc46:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
					chSemSignal(&spiUSE);
    bc4a:	89 e7       	ldi	r24, 0x79	; 121
    bc4c:	94 e1       	ldi	r25, 0x14	; 20
    bc4e:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
    bc52:	a3 cc       	rjmp	.-1722   	; 0xb59a <Thread5+0x336>
							st7735_setTextSize(3);
							chSemSignal(&spiUSE);
						}
					}	
					else {
						chSemWait(&spiUSE);
    bc54:	89 e7       	ldi	r24, 0x79	; 121
    bc56:	94 e1       	ldi	r25, 0x14	; 20
    bc58:	40 e0       	ldi	r20, 0x00	; 0
    bc5a:	50 e0       	ldi	r21, 0x00	; 0
    bc5c:	60 e0       	ldi	r22, 0x00	; 0
    bc5e:	70 e0       	ldi	r23, 0x00	; 0
    bc60:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
						st7735_setCursor(0,50);//lcd_goto_xy(1,1);
    bc64:	80 e0       	ldi	r24, 0x00	; 0
    bc66:	90 e0       	ldi	r25, 0x00	; 0
    bc68:	62 e3       	ldi	r22, 0x32	; 50
    bc6a:	70 e0       	ldi	r23, 0x00	; 0
    bc6c:	0e 94 c2 19 	call	0x3384	; 0x3384 <st7735_setCursor>
						st7735_setTextSize(3);
    bc70:	83 e0       	ldi	r24, 0x03	; 3
    bc72:	0e 94 cb 19 	call	0x3396	; 0x3396 <st7735_setTextSize>
						fprintf_P(&st7735_out, PSTR("%02u:%02u:%02u\r\n"), hr, min, s);
    bc76:	2d b7       	in	r18, 0x3d	; 61
    bc78:	3e b7       	in	r19, 0x3e	; 62
    bc7a:	2a 50       	subi	r18, 0x0A	; 10
    bc7c:	30 40       	sbci	r19, 0x00	; 0
    bc7e:	0f b6       	in	r0, 0x3f	; 63
    bc80:	f8 94       	cli
    bc82:	3e bf       	out	0x3e, r19	; 62
    bc84:	0f be       	out	0x3f, r0	; 63
    bc86:	2d bf       	out	0x3d, r18	; 61
    bc88:	ed b7       	in	r30, 0x3d	; 61
    bc8a:	fe b7       	in	r31, 0x3e	; 62
    bc8c:	31 96       	adiw	r30, 0x01	; 1
    bc8e:	ad b7       	in	r26, 0x3d	; 61
    bc90:	be b7       	in	r27, 0x3e	; 62
    bc92:	11 96       	adiw	r26, 0x01	; 1
    bc94:	dc 92       	st	X, r13
    bc96:	11 97       	sbiw	r26, 0x01	; 1
    bc98:	12 96       	adiw	r26, 0x02	; 2
    bc9a:	cc 92       	st	X, r12
    bc9c:	2a ef       	ldi	r18, 0xFA	; 250
    bc9e:	38 e0       	ldi	r19, 0x08	; 8
    bca0:	33 83       	std	Z+3, r19	; 0x03
    bca2:	22 83       	std	Z+2, r18	; 0x02
    bca4:	80 91 51 05 	lds	r24, 0x0551
    bca8:	84 83       	std	Z+4, r24	; 0x04
    bcaa:	15 82       	std	Z+5, r1	; 0x05
    bcac:	80 91 50 05 	lds	r24, 0x0550
    bcb0:	86 83       	std	Z+6, r24	; 0x06
    bcb2:	17 82       	std	Z+7, r1	; 0x07
    bcb4:	80 91 47 07 	lds	r24, 0x0747
    bcb8:	80 87       	std	Z+8, r24	; 0x08
    bcba:	11 86       	std	Z+9, r1	; 0x09
    bcbc:	0e 94 9a 82 	call	0x10534	; 0x10534 <fprintf_P>
						st7735_setTextSize(1);
    bcc0:	4d b7       	in	r20, 0x3d	; 61
    bcc2:	5e b7       	in	r21, 0x3e	; 62
    bcc4:	46 5f       	subi	r20, 0xF6	; 246
    bcc6:	5f 4f       	sbci	r21, 0xFF	; 255
    bcc8:	0f b6       	in	r0, 0x3f	; 63
    bcca:	f8 94       	cli
    bccc:	5e bf       	out	0x3e, r21	; 62
    bcce:	0f be       	out	0x3f, r0	; 63
    bcd0:	4d bf       	out	0x3d, r20	; 61
    bcd2:	81 e0       	ldi	r24, 0x01	; 1
    bcd4:	0e 94 cb 19 	call	0x3396	; 0x3396 <st7735_setTextSize>
						chSemSignal(&spiUSE);
    bcd8:	89 e7       	ldi	r24, 0x79	; 121
    bcda:	94 e1       	ldi	r25, 0x14	; 20
    bcdc:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
    bce0:	76 cf       	rjmp	.-276    	; 0xbbce <Thread5+0x96a>
					
					if (corrected_heading < 180.0) {
						corrected_heading += 180.0;
					}
					else {
						corrected_heading -= 180.0;
    bce2:	c8 01       	movw	r24, r16
    bce4:	b7 01       	movw	r22, r14
    bce6:	20 e0       	ldi	r18, 0x00	; 0
    bce8:	30 e0       	ldi	r19, 0x00	; 0
    bcea:	44 e3       	ldi	r20, 0x34	; 52
    bcec:	53 e4       	ldi	r21, 0x43	; 67
    bcee:	0e 94 83 7c 	call	0xf906	; 0xf906 <__subsf3>
    bcf2:	7b 01       	movw	r14, r22
    bcf4:	8c 01       	movw	r16, r24
    bcf6:	33 ce       	rjmp	.-922    	; 0xb95e <Thread5+0x6fa>
		//st7735_fill_rect(0, 0, 160, 128, ST7735_COLOR_BLACK);//lcd_clear();
		entry_flag = 1;
		while(true) {
		    /*now inside loop, wait for signal from thread1 button handler to get out*/
			if(chEvtWaitAnyTimeout((eventmask_t)2, TIME_IMMEDIATE) == 2){
				chSemSignal(&lcdUSE); /*thread5 gives back the lcd */
    bcf8:	8d ef       	ldi	r24, 0xFD	; 253
    bcfa:	93 e1       	ldi	r25, 0x13	; 19
    bcfc:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
    bd00:	d2 ca       	rjmp	.-2652   	; 0xb2a6 <Thread5+0x42>
					fprintf_P(&st7735_out, PSTR("%2u/%02u/%02u\r\n"), mt, dt, yr);
					chSemSignal(&spiUSE);
					
					if (hr_format==1) {                                  
						if (am_pm==1) {
							chSemWait(&spiUSE);
    bd02:	89 e7       	ldi	r24, 0x79	; 121
    bd04:	94 e1       	ldi	r25, 0x14	; 20
    bd06:	40 e0       	ldi	r20, 0x00	; 0
    bd08:	50 e0       	ldi	r21, 0x00	; 0
    bd0a:	60 e0       	ldi	r22, 0x00	; 0
    bd0c:	70 e0       	ldi	r23, 0x00	; 0
    bd0e:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
							st7735_setCursor(0,50);//lcd_goto_xy(1,1);
    bd12:	80 e0       	ldi	r24, 0x00	; 0
    bd14:	90 e0       	ldi	r25, 0x00	; 0
    bd16:	62 e3       	ldi	r22, 0x32	; 50
    bd18:	70 e0       	ldi	r23, 0x00	; 0
    bd1a:	0e 94 c2 19 	call	0x3384	; 0x3384 <st7735_setCursor>
							st7735_setTextSize(3);
    bd1e:	83 e0       	ldi	r24, 0x03	; 3
    bd20:	0e 94 cb 19 	call	0x3396	; 0x3396 <st7735_setTextSize>
							fprintf_P(&st7735_out, PSTR("%2u:%02u:%02u\r\n"), hr, min, s);    
    bd24:	2d b7       	in	r18, 0x3d	; 61
    bd26:	3e b7       	in	r19, 0x3e	; 62
    bd28:	2a 50       	subi	r18, 0x0A	; 10
    bd2a:	30 40       	sbci	r19, 0x00	; 0
    bd2c:	0f b6       	in	r0, 0x3f	; 63
    bd2e:	f8 94       	cli
    bd30:	3e bf       	out	0x3e, r19	; 62
    bd32:	0f be       	out	0x3f, r0	; 63
    bd34:	2d bf       	out	0x3d, r18	; 61
    bd36:	ed b7       	in	r30, 0x3d	; 61
    bd38:	fe b7       	in	r31, 0x3e	; 62
    bd3a:	31 96       	adiw	r30, 0x01	; 1
    bd3c:	ad b7       	in	r26, 0x3d	; 61
    bd3e:	be b7       	in	r27, 0x3e	; 62
    bd40:	11 96       	adiw	r26, 0x01	; 1
    bd42:	dc 92       	st	X, r13
    bd44:	11 97       	sbiw	r26, 0x01	; 1
    bd46:	12 96       	adiw	r26, 0x02	; 2
    bd48:	cc 92       	st	X, r12
    bd4a:	25 e2       	ldi	r18, 0x25	; 37
    bd4c:	39 e0       	ldi	r19, 0x09	; 9
    bd4e:	33 83       	std	Z+3, r19	; 0x03
    bd50:	22 83       	std	Z+2, r18	; 0x02
    bd52:	80 91 51 05 	lds	r24, 0x0551
    bd56:	84 83       	std	Z+4, r24	; 0x04
    bd58:	15 82       	std	Z+5, r1	; 0x05
    bd5a:	80 91 50 05 	lds	r24, 0x0550
    bd5e:	86 83       	std	Z+6, r24	; 0x06
    bd60:	17 82       	std	Z+7, r1	; 0x07
    bd62:	80 91 47 07 	lds	r24, 0x0747
    bd66:	80 87       	std	Z+8, r24	; 0x08
    bd68:	11 86       	std	Z+9, r1	; 0x09
    bd6a:	0e 94 9a 82 	call	0x10534	; 0x10534 <fprintf_P>
							st7735_setTextSize(1);
    bd6e:	4d b7       	in	r20, 0x3d	; 61
    bd70:	5e b7       	in	r21, 0x3e	; 62
    bd72:	46 5f       	subi	r20, 0xF6	; 246
    bd74:	5f 4f       	sbci	r21, 0xFF	; 255
    bd76:	0f b6       	in	r0, 0x3f	; 63
    bd78:	f8 94       	cli
    bd7a:	5e bf       	out	0x3e, r21	; 62
    bd7c:	0f be       	out	0x3f, r0	; 63
    bd7e:	4d bf       	out	0x3d, r20	; 61
    bd80:	81 e0       	ldi	r24, 0x01	; 1
    bd82:	0e 94 cb 19 	call	0x3396	; 0x3396 <st7735_setTextSize>
							st7735_setCursor(148,50);//lcd_goto_xy(1,1);
    bd86:	84 e9       	ldi	r24, 0x94	; 148
    bd88:	90 e0       	ldi	r25, 0x00	; 0
    bd8a:	62 e3       	ldi	r22, 0x32	; 50
    bd8c:	70 e0       	ldi	r23, 0x00	; 0
    bd8e:	0e 94 c2 19 	call	0x3384	; 0x3384 <st7735_setCursor>
							fprintf_P(&st7735_out, PSTR("PM\r\n"));    
    bd92:	00 d0       	rcall	.+0      	; 0xbd94 <Thread5+0xb30>
    bd94:	00 d0       	rcall	.+0      	; 0xbd96 <Thread5+0xb32>
    bd96:	ad b7       	in	r26, 0x3d	; 61
    bd98:	be b7       	in	r27, 0x3e	; 62
    bd9a:	12 96       	adiw	r26, 0x02	; 2
    bd9c:	dc 93       	st	X, r29
    bd9e:	ce 93       	st	-X, r28
    bda0:	11 97       	sbiw	r26, 0x01	; 1
    bda2:	e0 e2       	ldi	r30, 0x20	; 32
    bda4:	f9 e0       	ldi	r31, 0x09	; 9
    bda6:	02 cf       	rjmp	.-508    	; 0xbbac <Thread5+0x948>

0000bda8 <DS3231_showParameters>:
Show RTC parameters
display = 0: LCD
display = 1: UART
********************************************************************************/
void DS3231_showParameters(uint8_t display)                                  
{ 
    bda8:	cf 93       	push	r28
    bdaa:	df 93       	push	r29
//char todays_date[3];
 
   if (display ==1) {
    bdac:	81 30       	cpi	r24, 0x01	; 1
    bdae:	19 f0       	breq	.+6      	; 0xbdb6 <DS3231_showParameters+0xe>
			fprintf_P(&st7735_out, PSTR("%02u:%02u:%02u \r\n"), hr, min, s); 
		}	
		}//hr_format
	}//if display					
*/
 }//showParameters
    bdb0:	df 91       	pop	r29
    bdb2:	cf 91       	pop	r28
    bdb4:	08 95       	ret
void DS3231_showParameters(uint8_t display)                                  
{ 
//char todays_date[3];
 
   if (display ==1) {
		fprintf_P(&usart_out, PSTR("Date: %02u/%02u/%02u \r\n"), mt, dt, yr); 
    bdb6:	2d b7       	in	r18, 0x3d	; 61
    bdb8:	3e b7       	in	r19, 0x3e	; 62
    bdba:	2a 50       	subi	r18, 0x0A	; 10
    bdbc:	30 40       	sbci	r19, 0x00	; 0
    bdbe:	0f b6       	in	r0, 0x3f	; 63
    bdc0:	f8 94       	cli
    bdc2:	3e bf       	out	0x3e, r19	; 62
    bdc4:	0f be       	out	0x3f, r0	; 63
    bdc6:	2d bf       	out	0x3d, r18	; 61
    bdc8:	ed b7       	in	r30, 0x3d	; 61
    bdca:	fe b7       	in	r31, 0x3e	; 62
    bdcc:	31 96       	adiw	r30, 0x01	; 1
    bdce:	ca ec       	ldi	r28, 0xCA	; 202
    bdd0:	d6 e0       	ldi	r29, 0x06	; 6
    bdd2:	ad b7       	in	r26, 0x3d	; 61
    bdd4:	be b7       	in	r27, 0x3e	; 62
    bdd6:	12 96       	adiw	r26, 0x02	; 2
    bdd8:	dc 93       	st	X, r29
    bdda:	ce 93       	st	-X, r28
    bddc:	11 97       	sbiw	r26, 0x01	; 1
    bdde:	81 e8       	ldi	r24, 0x81	; 129
    bde0:	9c e0       	ldi	r25, 0x0C	; 12
    bde2:	93 83       	std	Z+3, r25	; 0x03
    bde4:	82 83       	std	Z+2, r24	; 0x02
    bde6:	80 91 54 05 	lds	r24, 0x0554
    bdea:	84 83       	std	Z+4, r24	; 0x04
    bdec:	15 82       	std	Z+5, r1	; 0x05
    bdee:	80 91 53 05 	lds	r24, 0x0553
    bdf2:	86 83       	std	Z+6, r24	; 0x06
    bdf4:	17 82       	std	Z+7, r1	; 0x07
    bdf6:	80 91 55 05 	lds	r24, 0x0555
    bdfa:	80 87       	std	Z+8, r24	; 0x08
    bdfc:	11 86       	std	Z+9, r1	; 0x09
    bdfe:	0e 94 9a 82 	call	0x10534	; 0x10534 <fprintf_P>
		//showDay(dy, 16, 3); 
		fprintf_P(&usart_out, PSTR("DS3231_Temp: %2.2g'C \r\n"), DS3231_getTemp());          
    be02:	2d b7       	in	r18, 0x3d	; 61
    be04:	3e b7       	in	r19, 0x3e	; 62
    be06:	26 5f       	subi	r18, 0xF6	; 246
    be08:	3f 4f       	sbci	r19, 0xFF	; 255
    be0a:	0f b6       	in	r0, 0x3f	; 63
    be0c:	f8 94       	cli
    be0e:	3e bf       	out	0x3e, r19	; 62
    be10:	0f be       	out	0x3f, r0	; 63
    be12:	2d bf       	out	0x3d, r18	; 61
    be14:	0e 94 45 43 	call	0x868a	; 0x868a <DS3231_getTemp>
    be18:	ad b7       	in	r26, 0x3d	; 61
    be1a:	be b7       	in	r27, 0x3e	; 62
    be1c:	18 97       	sbiw	r26, 0x08	; 8
    be1e:	0f b6       	in	r0, 0x3f	; 63
    be20:	f8 94       	cli
    be22:	be bf       	out	0x3e, r27	; 62
    be24:	0f be       	out	0x3f, r0	; 63
    be26:	ad bf       	out	0x3d, r26	; 61
    be28:	ed b7       	in	r30, 0x3d	; 61
    be2a:	fe b7       	in	r31, 0x3e	; 62
    be2c:	31 96       	adiw	r30, 0x01	; 1
    be2e:	12 96       	adiw	r26, 0x02	; 2
    be30:	dc 93       	st	X, r29
    be32:	ce 93       	st	-X, r28
    be34:	11 97       	sbiw	r26, 0x01	; 1
    be36:	29 e6       	ldi	r18, 0x69	; 105
    be38:	3c e0       	ldi	r19, 0x0C	; 12
    be3a:	33 83       	std	Z+3, r19	; 0x03
    be3c:	22 83       	std	Z+2, r18	; 0x02
    be3e:	64 83       	std	Z+4, r22	; 0x04
    be40:	75 83       	std	Z+5, r23	; 0x05
    be42:	86 83       	std	Z+6, r24	; 0x06
    be44:	97 83       	std	Z+7, r25	; 0x07
    be46:	0e 94 9a 82 	call	0x10534	; 0x10534 <fprintf_P>
		switch(hr_format) {                                  
    be4a:	2d b7       	in	r18, 0x3d	; 61
    be4c:	3e b7       	in	r19, 0x3e	; 62
    be4e:	28 5f       	subi	r18, 0xF8	; 248
    be50:	3f 4f       	sbci	r19, 0xFF	; 255
    be52:	0f b6       	in	r0, 0x3f	; 63
    be54:	f8 94       	cli
    be56:	3e bf       	out	0x3e, r19	; 62
    be58:	0f be       	out	0x3f, r0	; 63
    be5a:	2d bf       	out	0x3d, r18	; 61
    be5c:	80 91 56 05 	lds	r24, 0x0556
    be60:	90 91 57 05 	lds	r25, 0x0557
    be64:	01 97       	sbiw	r24, 0x01	; 1
    be66:	79 f1       	breq	.+94     	; 0xbec6 <DS3231_showParameters+0x11e>
						fprintf_P(&usart_out, PSTR("Time: %02u:%02u:%02u AM \r\n"), hr, min, s);    
						break;    
				}  
				break;               
			default:           
				fprintf_P(&usart_out, PSTR("Time: %02u:%02u:%02u \r\n"), hr, min, s);    
    be68:	8d b7       	in	r24, 0x3d	; 61
    be6a:	9e b7       	in	r25, 0x3e	; 62
    be6c:	0a 97       	sbiw	r24, 0x0a	; 10
    be6e:	0f b6       	in	r0, 0x3f	; 63
    be70:	f8 94       	cli
    be72:	9e bf       	out	0x3e, r25	; 62
    be74:	0f be       	out	0x3f, r0	; 63
    be76:	8d bf       	out	0x3d, r24	; 61
    be78:	ed b7       	in	r30, 0x3d	; 61
    be7a:	fe b7       	in	r31, 0x3e	; 62
    be7c:	31 96       	adiw	r30, 0x01	; 1
    be7e:	ad b7       	in	r26, 0x3d	; 61
    be80:	be b7       	in	r27, 0x3e	; 62
    be82:	12 96       	adiw	r26, 0x02	; 2
    be84:	dc 93       	st	X, r29
    be86:	ce 93       	st	-X, r28
    be88:	11 97       	sbiw	r26, 0x01	; 1
    be8a:	8b e1       	ldi	r24, 0x1B	; 27
    be8c:	9c e0       	ldi	r25, 0x0C	; 12
    be8e:	93 83       	std	Z+3, r25	; 0x03
    be90:	82 83       	std	Z+2, r24	; 0x02
    be92:	80 91 51 05 	lds	r24, 0x0551
    be96:	84 83       	std	Z+4, r24	; 0x04
    be98:	15 82       	std	Z+5, r1	; 0x05
    be9a:	80 91 50 05 	lds	r24, 0x0550
    be9e:	86 83       	std	Z+6, r24	; 0x06
    bea0:	17 82       	std	Z+7, r1	; 0x07
    bea2:	80 91 47 07 	lds	r24, 0x0747
    bea6:	80 87       	std	Z+8, r24	; 0x08
    bea8:	11 86       	std	Z+9, r1	; 0x09
    beaa:	0e 94 9a 82 	call	0x10534	; 0x10534 <fprintf_P>
    beae:	2d b7       	in	r18, 0x3d	; 61
    beb0:	3e b7       	in	r19, 0x3e	; 62
    beb2:	26 5f       	subi	r18, 0xF6	; 246
    beb4:	3f 4f       	sbci	r19, 0xFF	; 255
    beb6:	0f b6       	in	r0, 0x3f	; 63
    beb8:	f8 94       	cli
    beba:	3e bf       	out	0x3e, r19	; 62
    bebc:	0f be       	out	0x3f, r0	; 63
    bebe:	2d bf       	out	0x3d, r18	; 61
			fprintf_P(&st7735_out, PSTR("%02u:%02u:%02u \r\n"), hr, min, s); 
		}	
		}//hr_format
	}//if display					
*/
 }//showParameters
    bec0:	df 91       	pop	r29
    bec2:	cf 91       	pop	r28
    bec4:	08 95       	ret
		fprintf_P(&usart_out, PSTR("Date: %02u/%02u/%02u \r\n"), mt, dt, yr); 
		//showDay(dy, 16, 3); 
		fprintf_P(&usart_out, PSTR("DS3231_Temp: %2.2g'C \r\n"), DS3231_getTemp());          
		switch(hr_format) {                                  
			case 1:   
				switch(am_pm) { 
    bec6:	80 91 48 07 	lds	r24, 0x0748
    beca:	90 91 49 07 	lds	r25, 0x0749
    bece:	01 97       	sbiw	r24, 0x01	; 1
    bed0:	a1 f0       	breq	.+40     	; 0xbefa <DS3231_showParameters+0x152>
					case 1: 
						fprintf_P(&usart_out, PSTR("Time: %02u:%02u:%02u PM \r\n"), hr, min, s);    
						break;                                                                            
					default:               
						fprintf_P(&usart_out, PSTR("Time: %02u:%02u:%02u AM \r\n"), hr, min, s);    
    bed2:	8d b7       	in	r24, 0x3d	; 61
    bed4:	9e b7       	in	r25, 0x3e	; 62
    bed6:	0a 97       	sbiw	r24, 0x0a	; 10
    bed8:	0f b6       	in	r0, 0x3f	; 63
    beda:	f8 94       	cli
    bedc:	9e bf       	out	0x3e, r25	; 62
    bede:	0f be       	out	0x3f, r0	; 63
    bee0:	8d bf       	out	0x3d, r24	; 61
    bee2:	ed b7       	in	r30, 0x3d	; 61
    bee4:	fe b7       	in	r31, 0x3e	; 62
    bee6:	31 96       	adiw	r30, 0x01	; 1
    bee8:	ad b7       	in	r26, 0x3d	; 61
    beea:	be b7       	in	r27, 0x3e	; 62
    beec:	12 96       	adiw	r26, 0x02	; 2
    beee:	dc 93       	st	X, r29
    bef0:	ce 93       	st	-X, r28
    bef2:	11 97       	sbiw	r26, 0x01	; 1
    bef4:	83 e3       	ldi	r24, 0x33	; 51
    bef6:	9c e0       	ldi	r25, 0x0C	; 12
    bef8:	ca cf       	rjmp	.-108    	; 0xbe8e <DS3231_showParameters+0xe6>
		fprintf_P(&usart_out, PSTR("DS3231_Temp: %2.2g'C \r\n"), DS3231_getTemp());          
		switch(hr_format) {                                  
			case 1:   
				switch(am_pm) { 
					case 1: 
						fprintf_P(&usart_out, PSTR("Time: %02u:%02u:%02u PM \r\n"), hr, min, s);    
    befa:	8d b7       	in	r24, 0x3d	; 61
    befc:	9e b7       	in	r25, 0x3e	; 62
    befe:	0a 97       	sbiw	r24, 0x0a	; 10
    bf00:	0f b6       	in	r0, 0x3f	; 63
    bf02:	f8 94       	cli
    bf04:	9e bf       	out	0x3e, r25	; 62
    bf06:	0f be       	out	0x3f, r0	; 63
    bf08:	8d bf       	out	0x3d, r24	; 61
    bf0a:	ed b7       	in	r30, 0x3d	; 61
    bf0c:	fe b7       	in	r31, 0x3e	; 62
    bf0e:	31 96       	adiw	r30, 0x01	; 1
    bf10:	ad b7       	in	r26, 0x3d	; 61
    bf12:	be b7       	in	r27, 0x3e	; 62
    bf14:	12 96       	adiw	r26, 0x02	; 2
    bf16:	dc 93       	st	X, r29
    bf18:	ce 93       	st	-X, r28
    bf1a:	11 97       	sbiw	r26, 0x01	; 1
    bf1c:	8e e4       	ldi	r24, 0x4E	; 78
    bf1e:	9c e0       	ldi	r25, 0x0C	; 12
    bf20:	b6 cf       	rjmp	.-148    	; 0xbe8e <DS3231_showParameters+0xe6>

0000bf22 <Thread10>:
/*********************************************************************************
 * Thread 10 - visualization of RTC
 *********************************************************************************/
THD_FUNCTION(Thread10, arg) {
	(void)arg;
	tp[9] = chThdGetSelfX();
    bf22:	80 91 ce 07 	lds	r24, 0x07CE
    bf26:	90 91 cf 07 	lds	r25, 0x07CF
    bf2a:	90 93 a9 07 	sts	0x07A9, r25
    bf2e:	80 93 a8 07 	sts	0x07A8, r24
	msg_t msg;
	
	chSemWait(&i2cUSE);
    bf32:	80 e0       	ldi	r24, 0x00	; 0
    bf34:	94 e1       	ldi	r25, 0x14	; 20
    bf36:	40 e0       	ldi	r20, 0x00	; 0
    bf38:	50 e0       	ldi	r21, 0x00	; 0
    bf3a:	60 e0       	ldi	r22, 0x00	; 0
    bf3c:	70 e0       	ldi	r23, 0x00	; 0
    bf3e:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
	i2c_init();
    bf42:	0e 94 8f 14 	call	0x291e	; 0x291e <i2c_init>
	chSemSignal(&i2cUSE);
    bf46:	80 e0       	ldi	r24, 0x00	; 0
    bf48:	94 e1       	ldi	r25, 0x14	; 20
    bf4a:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
	
	chSemWait(&usartUSE);
    bf4e:	87 ec       	ldi	r24, 0xC7	; 199
    bf50:	90 e3       	ldi	r25, 0x30	; 48
    bf52:	40 e0       	ldi	r20, 0x00	; 0
    bf54:	50 e0       	ldi	r21, 0x00	; 0
    bf56:	60 e0       	ldi	r22, 0x00	; 0
    bf58:	70 e0       	ldi	r23, 0x00	; 0
    bf5a:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
	fprintf_P(&usart_out,PSTR("i2c init successful\r\n"));
    bf5e:	00 d0       	rcall	.+0      	; 0xbf60 <Thread10+0x3e>
    bf60:	00 d0       	rcall	.+0      	; 0xbf62 <Thread10+0x40>
    bf62:	ca ec       	ldi	r28, 0xCA	; 202
    bf64:	d6 e0       	ldi	r29, 0x06	; 6
    bf66:	ed b7       	in	r30, 0x3d	; 61
    bf68:	fe b7       	in	r31, 0x3e	; 62
    bf6a:	d2 83       	std	Z+2, r29	; 0x02
    bf6c:	c1 83       	std	Z+1, r28	; 0x01
    bf6e:	87 e8       	ldi	r24, 0x87	; 135
    bf70:	98 e0       	ldi	r25, 0x08	; 8
    bf72:	94 83       	std	Z+4, r25	; 0x04
    bf74:	83 83       	std	Z+3, r24	; 0x03
    bf76:	0e 94 9a 82 	call	0x10534	; 0x10534 <fprintf_P>
	chSemSignal(&usartUSE);
    bf7a:	0f 90       	pop	r0
    bf7c:	0f 90       	pop	r0
    bf7e:	0f 90       	pop	r0
    bf80:	0f 90       	pop	r0
    bf82:	87 ec       	ldi	r24, 0xC7	; 199
    bf84:	90 e3       	ldi	r25, 0x30	; 48
    bf86:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
	
	chSemWait(&i2cUSE);
    bf8a:	80 e0       	ldi	r24, 0x00	; 0
    bf8c:	94 e1       	ldi	r25, 0x14	; 20
    bf8e:	40 e0       	ldi	r20, 0x00	; 0
    bf90:	50 e0       	ldi	r21, 0x00	; 0
    bf92:	60 e0       	ldi	r22, 0x00	; 0
    bf94:	70 e0       	ldi	r23, 0x00	; 0
    bf96:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
	DS3231_init();
    bf9a:	0e 94 50 44 	call	0x88a0	; 0x88a0 <DS3231_init>
	chSemSignal(&i2cUSE);
    bf9e:	80 e0       	ldi	r24, 0x00	; 0
    bfa0:	94 e1       	ldi	r25, 0x14	; 20
    bfa2:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
	
	chSemWait(&usartUSE);
    bfa6:	87 ec       	ldi	r24, 0xC7	; 199
    bfa8:	90 e3       	ldi	r25, 0x30	; 48
    bfaa:	40 e0       	ldi	r20, 0x00	; 0
    bfac:	50 e0       	ldi	r21, 0x00	; 0
    bfae:	60 e0       	ldi	r22, 0x00	; 0
    bfb0:	70 e0       	ldi	r23, 0x00	; 0
    bfb2:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
	fprintf_P(&usart_out,PSTR("DS3231 init successful\r\n"));
    bfb6:	00 d0       	rcall	.+0      	; 0xbfb8 <Thread10+0x96>
    bfb8:	00 d0       	rcall	.+0      	; 0xbfba <Thread10+0x98>
    bfba:	ed b7       	in	r30, 0x3d	; 61
    bfbc:	fe b7       	in	r31, 0x3e	; 62
    bfbe:	d2 83       	std	Z+2, r29	; 0x02
    bfc0:	c1 83       	std	Z+1, r28	; 0x01
    bfc2:	8e e6       	ldi	r24, 0x6E	; 110
    bfc4:	98 e0       	ldi	r25, 0x08	; 8
    bfc6:	94 83       	std	Z+4, r25	; 0x04
    bfc8:	83 83       	std	Z+3, r24	; 0x03
    bfca:	0e 94 9a 82 	call	0x10534	; 0x10534 <fprintf_P>
	chSemSignal(&usartUSE);
    bfce:	0f 90       	pop	r0
    bfd0:	0f 90       	pop	r0
    bfd2:	0f 90       	pop	r0
    bfd4:	0f 90       	pop	r0
    bfd6:	87 ec       	ldi	r24, 0xC7	; 199
    bfd8:	90 e3       	ldi	r25, 0x30	; 48
    bfda:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
    bfde:	f8 94       	cli
	chSemSignal(&i2cUSE);
	*/
	
	/* Waiting for signal to show data - transfer via a message*/
	chSysLock();
	msg = chThdSuspendTimeoutS(&trp[9], TIME_INFINITE);
    bfe0:	84 ec       	ldi	r24, 0xC4	; 196
    bfe2:	97 e0       	ldi	r25, 0x07	; 7
    bfe4:	40 e0       	ldi	r20, 0x00	; 0
    bfe6:	50 e0       	ldi	r21, 0x00	; 0
    bfe8:	60 e0       	ldi	r22, 0x00	; 0
    bfea:	70 e0       	ldi	r23, 0x00	; 0
    bfec:	0e 94 fc 08 	call	0x11f8	; 0x11f8 <chThdSuspendTimeoutS>
    bff0:	78 94       	sei
    bff2:	1b e6       	ldi	r17, 0x6B	; 107
    bff4:	e1 2e       	mov	r14, r17
    bff6:	18 e0       	ldi	r17, 0x08	; 8
    bff8:	f1 2e       	mov	r15, r17
	chSysUnlock();	
	while (true) {				
		
		chSemWait(&i2cUSE);
    bffa:	80 e0       	ldi	r24, 0x00	; 0
    bffc:	94 e1       	ldi	r25, 0x14	; 20
    bffe:	40 e0       	ldi	r20, 0x00	; 0
    c000:	50 e0       	ldi	r21, 0x00	; 0
    c002:	60 e0       	ldi	r22, 0x00	; 0
    c004:	70 e0       	ldi	r23, 0x00	; 0
    c006:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
		DS3231_getTime(&hr, &min, &s, &am_pm, hr_format); 
    c00a:	00 91 56 05 	lds	r16, 0x0556
    c00e:	10 91 57 05 	lds	r17, 0x0557
    c012:	81 e5       	ldi	r24, 0x51	; 81
    c014:	95 e0       	ldi	r25, 0x05	; 5
    c016:	60 e5       	ldi	r22, 0x50	; 80
    c018:	75 e0       	ldi	r23, 0x05	; 5
    c01a:	47 e4       	ldi	r20, 0x47	; 71
    c01c:	57 e0       	ldi	r21, 0x07	; 7
    c01e:	28 e4       	ldi	r18, 0x48	; 72
    c020:	37 e0       	ldi	r19, 0x07	; 7
    c022:	0e 94 e2 43 	call	0x87c4	; 0x87c4 <DS3231_getTime>
		DS3231_getDate(&dy, &dt, &mt, &yr);
    c026:	82 e5       	ldi	r24, 0x52	; 82
    c028:	95 e0       	ldi	r25, 0x05	; 5
    c02a:	63 e5       	ldi	r22, 0x53	; 83
    c02c:	75 e0       	ldi	r23, 0x05	; 5
    c02e:	44 e5       	ldi	r20, 0x54	; 84
    c030:	55 e0       	ldi	r21, 0x05	; 5
    c032:	25 e5       	ldi	r18, 0x55	; 85
    c034:	35 e0       	ldi	r19, 0x05	; 5
    c036:	0e 94 83 43 	call	0x8706	; 0x8706 <DS3231_getDate>
		chSemSignal(&i2cUSE);
    c03a:	80 e0       	ldi	r24, 0x00	; 0
    c03c:	94 e1       	ldi	r25, 0x14	; 20
    c03e:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
		chSemWait(&usartUSE);
    c042:	87 ec       	ldi	r24, 0xC7	; 199
    c044:	90 e3       	ldi	r25, 0x30	; 48
    c046:	40 e0       	ldi	r20, 0x00	; 0
    c048:	50 e0       	ldi	r21, 0x00	; 0
    c04a:	60 e0       	ldi	r22, 0x00	; 0
    c04c:	70 e0       	ldi	r23, 0x00	; 0
    c04e:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
		fprintf_P(&usart_out,PSTR("\r\n")); 
    c052:	00 d0       	rcall	.+0      	; 0xc054 <Thread10+0x132>
    c054:	00 d0       	rcall	.+0      	; 0xc056 <Thread10+0x134>
    c056:	ed b7       	in	r30, 0x3d	; 61
    c058:	fe b7       	in	r31, 0x3e	; 62
    c05a:	d2 83       	std	Z+2, r29	; 0x02
    c05c:	c1 83       	std	Z+1, r28	; 0x01
    c05e:	f4 82       	std	Z+4, r15	; 0x04
    c060:	e3 82       	std	Z+3, r14	; 0x03
    c062:	0e 94 9a 82 	call	0x10534	; 0x10534 <fprintf_P>
		DS3231_showParameters(1);
    c066:	0f 90       	pop	r0
    c068:	0f 90       	pop	r0
    c06a:	0f 90       	pop	r0
    c06c:	0f 90       	pop	r0
    c06e:	81 e0       	ldi	r24, 0x01	; 1
    c070:	0e 94 d4 5e 	call	0xbda8	; 0xbda8 <DS3231_showParameters>
		chSemSignal(&usartUSE);	
    c074:	87 ec       	ldi	r24, 0xC7	; 199
    c076:	90 e3       	ldi	r25, 0x30	; 48
    c078:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
	
		chThdSleepMilliseconds(50);
    c07c:	68 ee       	ldi	r22, 0xE8	; 232
    c07e:	73 e0       	ldi	r23, 0x03	; 3
    c080:	80 e0       	ldi	r24, 0x00	; 0
    c082:	90 e0       	ldi	r25, 0x00	; 0
    c084:	0e 94 f4 08 	call	0x11e8	; 0x11e8 <chThdSleep>
    c088:	b8 cf       	rjmp	.-144    	; 0xbffa <Thread10+0xd8>

0000c08a <Thread1>:
/*********************************************************************************
 * Thread 1 - button interrupt handler
 *********************************************************************************/
THD_FUNCTION(Thread1, arg) {
  (void)arg;
  tp[0] = chThdGetSelfX();
    c08a:	80 91 ce 07 	lds	r24, 0x07CE
    c08e:	90 91 cf 07 	lds	r25, 0x07CF
    c092:	90 93 97 07 	sts	0x0797, r25
    c096:	80 93 96 07 	sts	0x0796, r24
  msg_t msg;

  PCMSK0 |= (1<<PCINT3)|(1<<PCINT2) |(1<<PCINT4) ;
    c09a:	80 91 6b 00 	lds	r24, 0x006B
    c09e:	8c 61       	ori	r24, 0x1C	; 28
    c0a0:	80 93 6b 00 	sts	0x006B, r24
  PCICR |= (1<<PCIE0);
    c0a4:	80 91 68 00 	lds	r24, 0x0068
    c0a8:	81 60       	ori	r24, 0x01	; 1
    c0aa:	80 93 68 00 	sts	0x0068, r24
  PORTA |= _BV(PA2);
    c0ae:	12 9a       	sbi	0x02, 2	; 2
  PORTA |= _BV(PA3);
    c0b0:	13 9a       	sbi	0x02, 3	; 2
  PORTA |= _BV(PA4);
    c0b2:	14 9a       	sbi	0x02, 4	; 2
				/*switchtype ==2, we are staying in thread 12*/
				/*don't change lcd_context, we are staying in thread12*/
				/*button pressed to cycle through subscreens ... update the subscreen count*/
				/*staying in thread 12, signal thread12 to re-enter submenu with the new lcd context*/
				lcd_context_count[11] = lcd_context_count[11]+1;
				if (lcd_context_count[11] > lcd_context_count_MAX[11]) {lcd_context_count[11] = 1;}
    c0b4:	11 e0       	ldi	r17, 0x01	; 1
    c0b6:	04 c0       	rjmp	.+8      	; 0xc0c0 <Thread1+0x36>
		switchtype = 0;
		triggered = 0;
		chSysUnlock();
	}	
		
   if (triggered ==1){		
    c0b8:	80 91 26 07 	lds	r24, 0x0726
    c0bc:	81 30       	cpi	r24, 0x01	; 1
    c0be:	69 f1       	breq	.+90     	; 0xc11a <Thread1+0x90>
    c0c0:	f8 94       	cli
  while (true) {
    chSysLock();
	/* Waiting for button push & IRQ to happen */
	/* Current thread put to sleep & sets up the reference variable trp for the trigger to reference */
	/* Will resume with a chThdResumeI*/
    msg = chThdSuspendTimeoutS(&trp[0], TIME_INFINITE);
    c0c2:	82 eb       	ldi	r24, 0xB2	; 178
    c0c4:	97 e0       	ldi	r25, 0x07	; 7
    c0c6:	40 e0       	ldi	r20, 0x00	; 0
    c0c8:	50 e0       	ldi	r21, 0x00	; 0
    c0ca:	60 e0       	ldi	r22, 0x00	; 0
    c0cc:	70 e0       	ldi	r23, 0x00	; 0
    c0ce:	0e 94 fc 08 	call	0x11f8	; 0x11f8 <chThdSuspendTimeoutS>
    c0d2:	78 94       	sei
    chSysUnlock(); 
	chThdSleepMilliseconds(DEBOUNCE_TIME); //wait and block the button from triggering again
    c0d4:	68 e5       	ldi	r22, 0x58	; 88
    c0d6:	7b e1       	ldi	r23, 0x1B	; 27
    c0d8:	80 e0       	ldi	r24, 0x00	; 0
    c0da:	90 e0       	ldi	r25, 0x00	; 0
    c0dc:	0e 94 f4 08 	call	0x11e8	; 0x11e8 <chThdSleep>
    if (switchtype == 4) {//button4
    c0e0:	80 91 3f 07 	lds	r24, 0x073F
    c0e4:	84 30       	cpi	r24, 0x04	; 4
    c0e6:	41 f7       	brne	.-48     	; 0xc0b8 <Thread1+0x2e>
		//next 3 should be atomic	
		if (LCD_PWM_SET ==50) {
    c0e8:	80 91 31 05 	lds	r24, 0x0531
    c0ec:	82 33       	cpi	r24, 0x32	; 50
    c0ee:	09 f4       	brne	.+2      	; 0xc0f2 <Thread1+0x68>
    c0f0:	48 c0       	rjmp	.+144    	; 0xc182 <Thread1+0xf8>
			LCD_PWM_SET = 0;
		}
		else {
			LCD_PWM_SET += 10;
    c0f2:	80 91 31 05 	lds	r24, 0x0531
    c0f6:	86 5f       	subi	r24, 0xF6	; 246
    c0f8:	80 93 31 05 	sts	0x0531, r24
    c0fc:	f8 94       	cli
		}	
		chSysLock();	
		OCR2A = LCD_PWM_SET;
    c0fe:	80 91 31 05 	lds	r24, 0x0531
    c102:	80 93 b3 00 	sts	0x00B3, r24
		PCIFR |= (1<<PCIF0);
    c106:	d8 9a       	sbi	0x1b, 0	; 27
		switchtype = 0;
    c108:	10 92 3f 07 	sts	0x073F, r1
		triggered = 0;
    c10c:	10 92 26 07 	sts	0x0726, r1
    c110:	78 94       	sei
		chSysUnlock();
	}	
		
   if (triggered ==1){		
    c112:	80 91 26 07 	lds	r24, 0x0726
    c116:	81 30       	cpi	r24, 0x01	; 1
    c118:	99 f6       	brne	.-90     	; 0xc0c0 <Thread1+0x36>
		if (lcd_context ==1){//coming from thread 1 
    c11a:	80 91 32 05 	lds	r24, 0x0532
    c11e:	81 30       	cpi	r24, 0x01	; 1
    c120:	09 f4       	brne	.+2      	; 0xc124 <Thread1+0x9a>
    c122:	c5 c0       	rjmp	.+394    	; 0xc2ae <Thread1+0x224>
			triggered = 0;
			/*signal thread 2 ... the menu scrolling thread*/
			chSemSignal(&ButtonPressed);
			chSysUnlock();
		}
		if (lcd_context ==3){ //we were in thread3
    c124:	80 91 32 05 	lds	r24, 0x0532
    c128:	83 30       	cpi	r24, 0x03	; 3
    c12a:	09 f4       	brne	.+2      	; 0xc12e <Thread1+0xa4>
    c12c:	a5 c0       	rjmp	.+330    	; 0xc278 <Thread1+0x1ee>
			/*send semaphore to thread2 that the button is pressed */
			chSemSignal(&ButtonPressed); //need to signal thread1
			chSysUnlock();				
		}
		
		if (lcd_context ==4){ //we were in thread4
    c12e:	80 91 32 05 	lds	r24, 0x0532
    c132:	84 30       	cpi	r24, 0x04	; 4
    c134:	09 f4       	brne	.+2      	; 0xc138 <Thread1+0xae>
    c136:	85 c0       	rjmp	.+266    	; 0xc242 <Thread1+0x1b8>
			
			/*send semaphore to thread2 that the button is pressed */
			chSemSignal(&ButtonPressed); //need to signal thread2
			chSysUnlock();				
		}
		if (lcd_context ==5){ 
    c138:	80 91 32 05 	lds	r24, 0x0532
    c13c:	85 30       	cpi	r24, 0x05	; 5
    c13e:	09 f4       	brne	.+2      	; 0xc142 <Thread1+0xb8>
    c140:	42 c0       	rjmp	.+132    	; 0xc1c6 <Thread1+0x13c>
				chEvtSignalI(tp[4], (eventmask_t)4);  //stay in thread
				chSysUnlock();
            }/* if (switchtype == 1)*/		
        }/* if (lcd_context == 5)*/		

		if (lcd_context ==9){//returning from thread9 back to thread 1 
    c142:	80 91 32 05 	lds	r24, 0x0532
    c146:	89 30       	cpi	r24, 0x09	; 9
    c148:	09 f4       	brne	.+2      	; 0xc14c <Thread1+0xc2>
    c14a:	60 c0       	rjmp	.+192    	; 0xc20c <Thread1+0x182>

			chSemSignal(&ButtonPressed); //need to signal thread2
			chSysUnlock();				
		}/*if (lcd_context ==9)*/	
		
		if (lcd_context ==12){//returning from thread12 back to thread 1 
    c14c:	80 91 32 05 	lds	r24, 0x0532
    c150:	8c 30       	cpi	r24, 0x0C	; 12
    c152:	d1 f0       	breq	.+52     	; 0xc188 <Thread1+0xfe>
				chSysUnlock();
			}	
		
		}//if (lcd_context ==12)	
		
		if (lcd_context ==14){ 
    c154:	80 91 32 05 	lds	r24, 0x0532
    c158:	8e 30       	cpi	r24, 0x0E	; 14
    c15a:	09 f0       	breq	.+2      	; 0xc15e <Thread1+0xd4>
    c15c:	b1 cf       	rjmp	.-158    	; 0xc0c0 <Thread1+0x36>
    c15e:	f8 94       	cli
			//next 3 should be atomic
			chSysLock();
			PCIFR |= (1<<PCIF0);
    c160:	d8 9a       	sbi	0x1b, 0	; 27
			triggered = 0;
    c162:	10 92 26 07 	sts	0x0726, r1
			
			if (switchtype == 1) { //either cycling or returning from thread14 back to thread 1
    c166:	20 91 3f 07 	lds	r18, 0x073F
    c16a:	21 30       	cpi	r18, 0x01	; 1
    c16c:	09 f4       	brne	.+2      	; 0xc170 <Thread1+0xe6>
    c16e:	d7 c0       	rjmp	.+430    	; 0xc31e <Thread1+0x294>
             else { /*switchtype ==2, we are staying in thread14*/
				/*don't change lcd_context, we are staying in thread14*/
				
				/*staying in thread 14, signal thread5 to re-enter submenu with the new lcd context*/
				/* note, skip eventmask 3 because that is binary 11, which would signal 2 events*/
				chEvtSignalI(tp[13], (eventmask_t)4);  //stay in thread
    c170:	80 91 b0 07 	lds	r24, 0x07B0
    c174:	90 91 b1 07 	lds	r25, 0x07B1
    c178:	64 e0       	ldi	r22, 0x04	; 4
    c17a:	0e 94 3a 08 	call	0x1074	; 0x1074 <chEvtSignalI>
    c17e:	78 94       	sei
    c180:	9f cf       	rjmp	.-194    	; 0xc0c0 <Thread1+0x36>
    chSysUnlock(); 
	chThdSleepMilliseconds(DEBOUNCE_TIME); //wait and block the button from triggering again
    if (switchtype == 4) {//button4
		//next 3 should be atomic	
		if (LCD_PWM_SET ==50) {
			LCD_PWM_SET = 0;
    c182:	10 92 31 05 	sts	0x0531, r1
    c186:	ba cf       	rjmp	.-140    	; 0xc0fc <Thread1+0x72>
    c188:	f8 94       	cli
		}/*if (lcd_context ==9)*/	
		
		if (lcd_context ==12){//returning from thread12 back to thread 1 
			//next 3 should be atomic
			chSysLock();
			PCIFR |= (1<<PCIF0);
    c18a:	d8 9a       	sbi	0x1b, 0	; 27
			triggered = 0;
    c18c:	10 92 26 07 	sts	0x0726, r1
			if (switchtype == 1) { //returning from thread12 back to thread 1
    c190:	80 91 3f 07 	lds	r24, 0x073F
    c194:	81 30       	cpi	r24, 0x01	; 1
    c196:	09 f4       	brne	.+2      	; 0xc19a <Thread1+0x110>
    c198:	ab c0       	rjmp	.+342    	; 0xc2f0 <Thread1+0x266>
			else {
				/*switchtype ==2, we are staying in thread 12*/
				/*don't change lcd_context, we are staying in thread12*/
				/*button pressed to cycle through subscreens ... update the subscreen count*/
				/*staying in thread 12, signal thread12 to re-enter submenu with the new lcd context*/
				lcd_context_count[11] = lcd_context_count[11]+1;
    c19a:	80 91 3e 05 	lds	r24, 0x053E
    c19e:	8f 5f       	subi	r24, 0xFF	; 255
    c1a0:	80 93 3e 05 	sts	0x053E, r24
				if (lcd_context_count[11] > lcd_context_count_MAX[11]) {lcd_context_count[11] = 1;}
    c1a4:	90 91 3e 05 	lds	r25, 0x053E
    c1a8:	80 91 4c 05 	lds	r24, 0x054C
    c1ac:	89 17       	cp	r24, r25
    c1ae:	10 f4       	brcc	.+4      	; 0xc1b4 <Thread1+0x12a>
    c1b0:	10 93 3e 05 	sts	0x053E, r17
				chEvtSignalI(tp[11], (eventmask_t)4);  //stay in thread
    c1b4:	80 91 ac 07 	lds	r24, 0x07AC
    c1b8:	90 91 ad 07 	lds	r25, 0x07AD
    c1bc:	64 e0       	ldi	r22, 0x04	; 4
    c1be:	0e 94 3a 08 	call	0x1074	; 0x1074 <chEvtSignalI>
    c1c2:	78 94       	sei
    c1c4:	c7 cf       	rjmp	.-114    	; 0xc154 <Thread1+0xca>
    c1c6:	f8 94       	cli
			chSysUnlock();				
		}
		if (lcd_context ==5){ 
			//next 3 should be atomic
			chSysLock();
			PCIFR |= (1<<PCIF0);
    c1c8:	d8 9a       	sbi	0x1b, 0	; 27
			triggered = 0;
    c1ca:	10 92 26 07 	sts	0x0726, r1
			
			
			if (switchtype == 1) { //returning from thread5 back to thread 1
    c1ce:	80 91 3f 07 	lds	r24, 0x073F
    c1d2:	81 30       	cpi	r24, 0x01	; 1
    c1d4:	09 f4       	brne	.+2      	; 0xc1d8 <Thread1+0x14e>
    c1d6:	75 c0       	rjmp	.+234    	; 0xc2c2 <Thread1+0x238>
             } 
             else { /*switchtype ==2, we are staying in thread5*/
				/*don't change lcd_context, we are staying in thread5*/
											
				/*button pressed to cycle through subscreens ... update the subscreen count*/
				lcd_context_count[4] = lcd_context_count[4]+1;
    c1d8:	80 91 37 05 	lds	r24, 0x0537
    c1dc:	8f 5f       	subi	r24, 0xFF	; 255
    c1de:	80 93 37 05 	sts	0x0537, r24
				if (lcd_context_count[4] > lcd_context_count_MAX[4]) {lcd_context_count[4] = 1;}
    c1e2:	90 91 37 05 	lds	r25, 0x0537
    c1e6:	80 91 45 05 	lds	r24, 0x0545
    c1ea:	89 17       	cp	r24, r25
    c1ec:	10 f4       	brcc	.+4      	; 0xc1f2 <Thread1+0x168>
    c1ee:	10 93 37 05 	sts	0x0537, r17
				
				/*staying in thread 5, signal thread5 to re-enter submenu with the new lcd context*/
				/* note, skip eventmask 3 because that is binary 11, which would signal 2 events*/
				chEvtSignalI(tp[4], (eventmask_t)4);  //stay in thread
    c1f2:	80 91 9e 07 	lds	r24, 0x079E
    c1f6:	90 91 9f 07 	lds	r25, 0x079F
    c1fa:	64 e0       	ldi	r22, 0x04	; 4
    c1fc:	0e 94 3a 08 	call	0x1074	; 0x1074 <chEvtSignalI>
    c200:	78 94       	sei
				chSysUnlock();
            }/* if (switchtype == 1)*/		
        }/* if (lcd_context == 5)*/		

		if (lcd_context ==9){//returning from thread9 back to thread 1 
    c202:	80 91 32 05 	lds	r24, 0x0532
    c206:	89 30       	cpi	r24, 0x09	; 9
    c208:	09 f0       	breq	.+2      	; 0xc20c <Thread1+0x182>
    c20a:	a0 cf       	rjmp	.-192    	; 0xc14c <Thread1+0xc2>
    c20c:	f8 94       	cli
			//next 3 should be atomic
			chSysLock();
			PCIFR |= (1<<PCIF0);
    c20e:	d8 9a       	sbi	0x1b, 0	; 27
			triggered = 0;
    c210:	10 92 26 07 	sts	0x0726, r1
			
			lcd_context =1;//returning to thread1
    c214:	10 93 32 05 	sts	0x0532, r17
			/*returning from thread9 ... button 1 did it ... so we will go back to the main menu */
			    /* reset the switchtype to 0*/
			switchtype = 0; //returning from thread9
    c218:	10 92 3f 07 	sts	0x073F, r1
			
			chEvtSignalI(tp[8], (eventmask_t)2);  //signal thread 9 that we are back out
    c21c:	80 91 a6 07 	lds	r24, 0x07A6
    c220:	90 91 a7 07 	lds	r25, 0x07A7
    c224:	62 e0       	ldi	r22, 0x02	; 2
    c226:	0e 94 3a 08 	call	0x1074	; 0x1074 <chEvtSignalI>
			
			chThdSleepMilliseconds(THREAD_EXIT); //give it some time to exit thread 9
    c22a:	68 e5       	ldi	r22, 0x58	; 88
    c22c:	72 e0       	ldi	r23, 0x02	; 2
    c22e:	80 e0       	ldi	r24, 0x00	; 0
    c230:	90 e0       	ldi	r25, 0x00	; 0
    c232:	0e 94 f4 08 	call	0x11e8	; 0x11e8 <chThdSleep>

			chSemSignal(&ButtonPressed); //need to signal thread2
    c236:	81 e0       	ldi	r24, 0x01	; 1
    c238:	96 e2       	ldi	r25, 0x26	; 38
    c23a:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
    c23e:	78 94       	sei
    c240:	85 cf       	rjmp	.-246    	; 0xc14c <Thread1+0xc2>
    c242:	f8 94       	cli
		}
		
		if (lcd_context ==4){ //we were in thread4
			//next 3 should be atomic
			chSysLock();
			PCIFR |= (1<<PCIF0);//clear Pin change interrupt flag 0
    c244:	d8 9a       	sbi	0x1b, 0	; 27
			triggered = 0;//reset the trigger flag
    c246:	10 92 26 07 	sts	0x0726, r1
			lcd_context =1;//going back to thread1
    c24a:	10 93 32 05 	sts	0x0532, r17
			
			/*returning from thread4 ... any button did it ... so we will go back to the main menu */
			/* reset the switchtype to 0*/
			switchtype = 0;
    c24e:	10 92 3f 07 	sts	0x073F, r1
			/*Since the button was pressed to get out of that thread */
			/* Note - event masks should be thought of as or'd binary places. So you should use */
			/* 1, 2, 4, 8, 16 etc.. as distinct masks when signaling a specific thread*/
			/* the same mask # can be used when signaling other distinct threads, if you are */
			/* directly signaling that thread anyways */
			chEvtSignalI(tp[3], (eventmask_t)2);  //signal thread 4 that we are back out
    c252:	80 91 9c 07 	lds	r24, 0x079C
    c256:	90 91 9d 07 	lds	r25, 0x079D
    c25a:	62 e0       	ldi	r22, 0x02	; 2
    c25c:	0e 94 3a 08 	call	0x1074	; 0x1074 <chEvtSignalI>
			
			chThdSleepMilliseconds(THREAD_EXIT); //give it some time to exit thread 4
    c260:	68 e5       	ldi	r22, 0x58	; 88
    c262:	72 e0       	ldi	r23, 0x02	; 2
    c264:	80 e0       	ldi	r24, 0x00	; 0
    c266:	90 e0       	ldi	r25, 0x00	; 0
    c268:	0e 94 f4 08 	call	0x11e8	; 0x11e8 <chThdSleep>
			
			
			/*send semaphore to thread2 that the button is pressed */
			chSemSignal(&ButtonPressed); //need to signal thread2
    c26c:	81 e0       	ldi	r24, 0x01	; 1
    c26e:	96 e2       	ldi	r25, 0x26	; 38
    c270:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
    c274:	78 94       	sei
    c276:	60 cf       	rjmp	.-320    	; 0xc138 <Thread1+0xae>
    c278:	f8 94       	cli
			chSysUnlock();
		}
		if (lcd_context ==3){ //we were in thread3
			//next 3 should be atomic
			chSysLock();
			PCIFR |= (1<<PCIF0);//clear Pin change interrupt flag 0
    c27a:	d8 9a       	sbi	0x1b, 0	; 27
			triggered = 0;//reset the trigger flag
    c27c:	10 92 26 07 	sts	0x0726, r1
			lcd_context =1;//going back to thread1
    c280:	10 93 32 05 	sts	0x0532, r17
			
			/*returning from thread3 ... any button did it ... so we will go back to the main menu */
			/* reset the switchtype to 0*/
			switchtype = 0;
    c284:	10 92 3f 07 	sts	0x073F, r1
			/*Since the button was pressed to get out of that thread */
			/* Note - event masks should be thought of as or'd binary places. So you should use */
			/* 1, 2, 4, 8, 16 etc.. as distinct masks when signaling a specific thread*/
			/* the same mask # can be used when signaling other distinct threads, if you are */
			/* directly signaling that thread anyways */
			chEvtSignalI(tp[2], (eventmask_t)2);  //signal thread 3 that we are back out & its time to give up LCD
    c288:	80 91 9a 07 	lds	r24, 0x079A
    c28c:	90 91 9b 07 	lds	r25, 0x079B
    c290:	62 e0       	ldi	r22, 0x02	; 2
    c292:	0e 94 3a 08 	call	0x1074	; 0x1074 <chEvtSignalI>
			
			chThdSleepMilliseconds(THREAD_EXIT); //give it some time to exit thread 3
    c296:	68 e5       	ldi	r22, 0x58	; 88
    c298:	72 e0       	ldi	r23, 0x02	; 2
    c29a:	80 e0       	ldi	r24, 0x00	; 0
    c29c:	90 e0       	ldi	r25, 0x00	; 0
    c29e:	0e 94 f4 08 	call	0x11e8	; 0x11e8 <chThdSleep>
			
			/*send semaphore to thread2 that the button is pressed */
			chSemSignal(&ButtonPressed); //need to signal thread1
    c2a2:	81 e0       	ldi	r24, 0x01	; 1
    c2a4:	96 e2       	ldi	r25, 0x26	; 38
    c2a6:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
    c2aa:	78 94       	sei
    c2ac:	40 cf       	rjmp	.-384    	; 0xc12e <Thread1+0xa4>
    c2ae:	f8 94       	cli
		
   if (triggered ==1){		
		if (lcd_context ==1){//coming from thread 1 
			//next 3 should be atomic	
			chSysLock();
			PCIFR |= (1<<PCIF0);
    c2b0:	d8 9a       	sbi	0x1b, 0	; 27
			triggered = 0;
    c2b2:	10 92 26 07 	sts	0x0726, r1
			/*signal thread 2 ... the menu scrolling thread*/
			chSemSignal(&ButtonPressed);
    c2b6:	81 e0       	ldi	r24, 0x01	; 1
    c2b8:	96 e2       	ldi	r25, 0x26	; 38
    c2ba:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
    c2be:	78 94       	sei
    c2c0:	31 cf       	rjmp	.-414    	; 0xc124 <Thread1+0x9a>
			PCIFR |= (1<<PCIF0);
			triggered = 0;
			
			
			if (switchtype == 1) { //returning from thread5 back to thread 1
				lcd_context =1; //returning to thread1
    c2c2:	80 93 32 05 	sts	0x0532, r24
				
				/*returning from thread5 ... button 1 did it ... so we will go back to the main menu */
			    /* reset the switchtype to 0*/
				switchtype = 0;
    c2c6:	10 92 3f 07 	sts	0x073F, r1
				
				/*Send an event signal to thread 5 to go back up to the main entry point*/
				/*Since the button was pressed to get out of that thread */
				chEvtSignalI(tp[4], (eventmask_t)2);
    c2ca:	80 91 9e 07 	lds	r24, 0x079E
    c2ce:	90 91 9f 07 	lds	r25, 0x079F
    c2d2:	62 e0       	ldi	r22, 0x02	; 2
    c2d4:	0e 94 3a 08 	call	0x1074	; 0x1074 <chEvtSignalI>
				
				chThdSleepMilliseconds(THREAD_EXIT); //give it some time to exit thread 5
    c2d8:	68 e5       	ldi	r22, 0x58	; 88
    c2da:	72 e0       	ldi	r23, 0x02	; 2
    c2dc:	80 e0       	ldi	r24, 0x00	; 0
    c2de:	90 e0       	ldi	r25, 0x00	; 0
    c2e0:	0e 94 f4 08 	call	0x11e8	; 0x11e8 <chThdSleep>
				
				/*send semaphore to thread2 that the button is pressed */
				chSemSignal(&ButtonPressed); //need to signal the thread 2
    c2e4:	81 e0       	ldi	r24, 0x01	; 1
    c2e6:	96 e2       	ldi	r25, 0x26	; 38
    c2e8:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
    c2ec:	78 94       	sei
    c2ee:	29 cf       	rjmp	.-430    	; 0xc142 <Thread1+0xb8>
			//next 3 should be atomic
			chSysLock();
			PCIFR |= (1<<PCIF0);
			triggered = 0;
			if (switchtype == 1) { //returning from thread12 back to thread 1
				lcd_context =1;//returning to thread1
    c2f0:	80 93 32 05 	sts	0x0532, r24
			
				//returning from thread 12 ... button 1 did it ... so we will go back to the main menu 
				// reset the switchtype to 0
				switchtype = 0; //returning from thread 12
    c2f4:	10 92 3f 07 	sts	0x073F, r1
			
				chEvtSignalI(tp[11], (eventmask_t)2);  //signal thread 12 that we are back out
    c2f8:	80 91 ac 07 	lds	r24, 0x07AC
    c2fc:	90 91 ad 07 	lds	r25, 0x07AD
    c300:	62 e0       	ldi	r22, 0x02	; 2
    c302:	0e 94 3a 08 	call	0x1074	; 0x1074 <chEvtSignalI>
			
				chThdSleepMilliseconds(THREAD_EXIT); //give it some time to exit thread 12
    c306:	68 e5       	ldi	r22, 0x58	; 88
    c308:	72 e0       	ldi	r23, 0x02	; 2
    c30a:	80 e0       	ldi	r24, 0x00	; 0
    c30c:	90 e0       	ldi	r25, 0x00	; 0
    c30e:	0e 94 f4 08 	call	0x11e8	; 0x11e8 <chThdSleep>

				chSemSignal(&ButtonPressed); //need to signal thread2
    c312:	81 e0       	ldi	r24, 0x01	; 1
    c314:	96 e2       	ldi	r25, 0x26	; 38
    c316:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
    c31a:	78 94       	sei
    c31c:	1b cf       	rjmp	.-458    	; 0xc154 <Thread1+0xca>
			triggered = 0;
			
			if (switchtype == 1) { //either cycling or returning from thread14 back to thread 1
				
				/*button pressed to cycle through subscreens ... update the subscreen count*/
				lcd_context_count[13]++;
    c31e:	80 91 40 05 	lds	r24, 0x0540
    c322:	8f 5f       	subi	r24, 0xFF	; 255
    c324:	80 93 40 05 	sts	0x0540, r24
				if (lcd_context_count[13] > lcd_context_count_MAX[13]) {
    c328:	90 91 40 05 	lds	r25, 0x0540
    c32c:	80 91 4e 05 	lds	r24, 0x054E
    c330:	89 17       	cp	r24, r25
    c332:	c8 f4       	brcc	.+50     	; 0xc366 <Thread1+0x2dc>
					lcd_context_count[13] = 1;//reset it
    c334:	20 93 40 05 	sts	0x0540, r18
					lcd_context =1; //returning to thread1
    c338:	20 93 32 05 	sts	0x0532, r18
				
					/*returning from thread5 ... button 1 did it ... so we will go back to the main menu */
					/* reset the switchtype to 0*/
					switchtype = 0;
    c33c:	10 92 3f 07 	sts	0x073F, r1
				
					/*Send an event signal to thread 14 to go back up to the main entry point*/
					/*Since the button was pressed to get out of that thread */
					chEvtSignalI(tp[13], (eventmask_t)8);
    c340:	80 91 b0 07 	lds	r24, 0x07B0
    c344:	90 91 b1 07 	lds	r25, 0x07B1
    c348:	68 e0       	ldi	r22, 0x08	; 8
    c34a:	0e 94 3a 08 	call	0x1074	; 0x1074 <chEvtSignalI>
				
					chThdSleepMilliseconds(THREAD_EXIT); //give it some time to exit thread 14
    c34e:	68 e5       	ldi	r22, 0x58	; 88
    c350:	72 e0       	ldi	r23, 0x02	; 2
    c352:	80 e0       	ldi	r24, 0x00	; 0
    c354:	90 e0       	ldi	r25, 0x00	; 0
    c356:	0e 94 f4 08 	call	0x11e8	; 0x11e8 <chThdSleep>
				
					/*send semaphore to thread2 that the button is pressed */
					chSemSignal(&ButtonPressed); //need to signal the thread 2
    c35a:	81 e0       	ldi	r24, 0x01	; 1
    c35c:	96 e2       	ldi	r25, 0x26	; 38
    c35e:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
    c362:	78 94       	sei
    c364:	ad ce       	rjmp	.-678    	; 0xc0c0 <Thread1+0x36>
					chSysUnlock();
				}
				else {
					/*Send an event signal to thread 14 to change to the next part of the time editing*/
					/*Since the button was pressed to get out of that thread */
					chEvtSignalI(tp[13], (eventmask_t)2);
    c366:	80 91 b0 07 	lds	r24, 0x07B0
    c36a:	90 91 b1 07 	lds	r25, 0x07B1
    c36e:	62 e0       	ldi	r22, 0x02	; 2
    c370:	0e 94 3a 08 	call	0x1074	; 0x1074 <chEvtSignalI>
    c374:	78 94       	sei
    c376:	a4 ce       	rjmp	.-696    	; 0xc0c0 <Thread1+0x36>

0000c378 <__vector_4>:

/*********************************************************************************
 * Button Handler
 *********************************************************************************/
CH_IRQ_HANDLER(PCINT0_vect)
{           
    c378:	1f 92       	push	r1
    c37a:	0f 92       	push	r0
    c37c:	0f b6       	in	r0, 0x3f	; 63
    c37e:	0f 92       	push	r0
    c380:	0b b6       	in	r0, 0x3b	; 59
    c382:	0f 92       	push	r0
    c384:	11 24       	eor	r1, r1
    c386:	2f 93       	push	r18
    c388:	3f 93       	push	r19
    c38a:	4f 93       	push	r20
    c38c:	5f 93       	push	r21
    c38e:	6f 93       	push	r22
    c390:	7f 93       	push	r23
    c392:	8f 93       	push	r24
    c394:	9f 93       	push	r25
    c396:	af 93       	push	r26
    c398:	bf 93       	push	r27
    c39a:	ef 93       	push	r30
    c39c:	ff 93       	push	r31

CH_IRQ_PROLOGUE();
chSysLockFromISR();
			triggered = 1;
    c39e:	81 e0       	ldi	r24, 0x01	; 1
    c3a0:	80 93 26 07 	sts	0x0726, r24
			if (bit_is_clear(PINA, PA3)) {
    c3a4:	03 9b       	sbis	0x00, 3	; 0
    c3a6:	05 c0       	rjmp	.+10     	; 0xc3b2 <__vector_4+0x3a>
				switchtype = 1; //button 3//
			}	
			else if (bit_is_clear(PINA, PA2)) {
    c3a8:	02 9b       	sbis	0x00, 2	; 0
    c3aa:	21 c0       	rjmp	.+66     	; 0xc3ee <__vector_4+0x76>
					switchtype = 2;/*it is button 2 */	
			}
			else if (bit_is_clear(PINA, PA4)) {
    c3ac:	04 99       	sbic	0x00, 4	; 0
    c3ae:	03 c0       	rjmp	.+6      	; 0xc3b6 <__vector_4+0x3e>
					switchtype = 4;/* button is pressed */
    c3b0:	84 e0       	ldi	r24, 0x04	; 4
    c3b2:	80 93 3f 07 	sts	0x073F, r24
			}	
		/* Wakes up a thread waiting on a thread reference object*/
		/* Resuming the thread with message, synchronous*/
		/* Synchronizes with thread that is suspended with &trp*/
		/* can also pass the message to that thread	*/
		chThdResumeI(&trp[0], (msg_t)switchtype); 	
    c3b6:	60 91 3f 07 	lds	r22, 0x073F
    c3ba:	82 eb       	ldi	r24, 0xB2	; 178
    c3bc:	97 e0       	ldi	r25, 0x07	; 7
    c3be:	70 e0       	ldi	r23, 0x00	; 0
    c3c0:	0e 94 c9 07 	call	0xf92	; 0xf92 <chThdResumeI>
chSysUnlockFromISR();
CH_IRQ_EPILOGUE();
    c3c4:	0e 94 0e 09 	call	0x121c	; 0x121c <chSchRescheduleS>
}
    c3c8:	ff 91       	pop	r31
    c3ca:	ef 91       	pop	r30
    c3cc:	bf 91       	pop	r27
    c3ce:	af 91       	pop	r26
    c3d0:	9f 91       	pop	r25
    c3d2:	8f 91       	pop	r24
    c3d4:	7f 91       	pop	r23
    c3d6:	6f 91       	pop	r22
    c3d8:	5f 91       	pop	r21
    c3da:	4f 91       	pop	r20
    c3dc:	3f 91       	pop	r19
    c3de:	2f 91       	pop	r18
    c3e0:	0f 90       	pop	r0
    c3e2:	0b be       	out	0x3b, r0	; 59
    c3e4:	0f 90       	pop	r0
    c3e6:	0f be       	out	0x3f, r0	; 63
    c3e8:	0f 90       	pop	r0
    c3ea:	1f 90       	pop	r1
    c3ec:	18 95       	reti
			triggered = 1;
			if (bit_is_clear(PINA, PA3)) {
				switchtype = 1; //button 3//
			}	
			else if (bit_is_clear(PINA, PA2)) {
					switchtype = 2;/*it is button 2 */	
    c3ee:	82 e0       	ldi	r24, 0x02	; 2
    c3f0:	80 93 3f 07 	sts	0x073F, r24
    c3f4:	e0 cf       	rjmp	.-64     	; 0xc3b6 <__vector_4+0x3e>

0000c3f6 <__vector_11>:

/*********************************************************************************
 * Timer for LCD PWM
 *********************************************************************************/
CH_IRQ_HANDLER(TIMER2_OVF_vect)
{           
    c3f6:	1f 92       	push	r1
    c3f8:	0f 92       	push	r0
    c3fa:	0f b6       	in	r0, 0x3f	; 63
    c3fc:	0f 92       	push	r0
    c3fe:	0b b6       	in	r0, 0x3b	; 59
    c400:	0f 92       	push	r0
    c402:	11 24       	eor	r1, r1
    c404:	2f 93       	push	r18
    c406:	3f 93       	push	r19
    c408:	4f 93       	push	r20
    c40a:	5f 93       	push	r21
    c40c:	6f 93       	push	r22
    c40e:	7f 93       	push	r23
    c410:	8f 93       	push	r24
    c412:	9f 93       	push	r25
    c414:	af 93       	push	r26
    c416:	bf 93       	push	r27
    c418:	ef 93       	push	r30
    c41a:	ff 93       	push	r31
CH_IRQ_PROLOGUE();
chSysLockFromISR();
     PORTB |= (1<<PB3);			// set output on timer overflow
    c41c:	2b 9a       	sbi	0x05, 3	; 5
chSysUnlockFromISR();
CH_IRQ_EPILOGUE();
    c41e:	0e 94 0e 09 	call	0x121c	; 0x121c <chSchRescheduleS>
}
    c422:	ff 91       	pop	r31
    c424:	ef 91       	pop	r30
    c426:	bf 91       	pop	r27
    c428:	af 91       	pop	r26
    c42a:	9f 91       	pop	r25
    c42c:	8f 91       	pop	r24
    c42e:	7f 91       	pop	r23
    c430:	6f 91       	pop	r22
    c432:	5f 91       	pop	r21
    c434:	4f 91       	pop	r20
    c436:	3f 91       	pop	r19
    c438:	2f 91       	pop	r18
    c43a:	0f 90       	pop	r0
    c43c:	0b be       	out	0x3b, r0	; 59
    c43e:	0f 90       	pop	r0
    c440:	0f be       	out	0x3f, r0	; 63
    c442:	0f 90       	pop	r0
    c444:	1f 90       	pop	r1
    c446:	18 95       	reti

0000c448 <__vector_9>:

/*********************************************************************************
 * Timer for LCD PWM
 *********************************************************************************/
CH_IRQ_HANDLER(TIMER2_COMPA_vect)
{           
    c448:	1f 92       	push	r1
    c44a:	0f 92       	push	r0
    c44c:	0f b6       	in	r0, 0x3f	; 63
    c44e:	0f 92       	push	r0
    c450:	0b b6       	in	r0, 0x3b	; 59
    c452:	0f 92       	push	r0
    c454:	11 24       	eor	r1, r1
    c456:	2f 93       	push	r18
    c458:	3f 93       	push	r19
    c45a:	4f 93       	push	r20
    c45c:	5f 93       	push	r21
    c45e:	6f 93       	push	r22
    c460:	7f 93       	push	r23
    c462:	8f 93       	push	r24
    c464:	9f 93       	push	r25
    c466:	af 93       	push	r26
    c468:	bf 93       	push	r27
    c46a:	ef 93       	push	r30
    c46c:	ff 93       	push	r31
CH_IRQ_PROLOGUE();
chSysLockFromISR();
      PORTB &= ~(1<<PB3);// clear output on timer overflow
    c46e:	2b 98       	cbi	0x05, 3	; 5
chSysUnlockFromISR();
CH_IRQ_EPILOGUE();
    c470:	0e 94 0e 09 	call	0x121c	; 0x121c <chSchRescheduleS>
}
    c474:	ff 91       	pop	r31
    c476:	ef 91       	pop	r30
    c478:	bf 91       	pop	r27
    c47a:	af 91       	pop	r26
    c47c:	9f 91       	pop	r25
    c47e:	8f 91       	pop	r24
    c480:	7f 91       	pop	r23
    c482:	6f 91       	pop	r22
    c484:	5f 91       	pop	r21
    c486:	4f 91       	pop	r20
    c488:	3f 91       	pop	r19
    c48a:	2f 91       	pop	r18
    c48c:	0f 90       	pop	r0
    c48e:	0b be       	out	0x3b, r0	; 59
    c490:	0f 90       	pop	r0
    c492:	0f be       	out	0x3f, r0	; 63
    c494:	0f 90       	pop	r0
    c496:	1f 90       	pop	r1
    c498:	18 95       	reti

0000c49a <initMenu>:

/********************************************************************************
Main Menu info
********************************************************************************/
void initMenu(void) {
    strcpy(menutitle[0], "MAIN MENU");
    c49a:	aa e6       	ldi	r26, 0x6A	; 106
    c49c:	bc e1       	ldi	r27, 0x1C	; 28
    c49e:	e2 e1       	ldi	r30, 0x12	; 18
    c4a0:	f4 e0       	ldi	r31, 0x04	; 4
    c4a2:	8a e0       	ldi	r24, 0x0A	; 10
    c4a4:	01 90       	ld	r0, Z+
    c4a6:	0d 92       	st	X+, r0
    c4a8:	81 50       	subi	r24, 0x01	; 1
    c4aa:	e1 f7       	brne	.-8      	; 0xc4a4 <initMenu+0xa>
    strcpy(menuitem[0][0], "RTOS Tests");
    c4ac:	a8 ef       	ldi	r26, 0xF8	; 248
    c4ae:	b0 e2       	ldi	r27, 0x20	; 32
    c4b0:	ec e1       	ldi	r30, 0x1C	; 28
    c4b2:	f4 e0       	ldi	r31, 0x04	; 4
    c4b4:	8b e0       	ldi	r24, 0x0B	; 11
    c4b6:	01 90       	ld	r0, Z+
    c4b8:	0d 92       	st	X+, r0
    c4ba:	81 50       	subi	r24, 0x01	; 1
    c4bc:	e1 f7       	brne	.-8      	; 0xc4b6 <initMenu+0x1c>
    menulink[0][0] = 1; // link to menutitle[1];
    c4be:	81 e0       	ldi	r24, 0x01	; 1
    c4c0:	90 e0       	ldi	r25, 0x00	; 0
    c4c2:	90 93 e3 16 	sts	0x16E3, r25
    c4c6:	80 93 e2 16 	sts	0x16E2, r24
    menuactn[0][0] = 0; // No action - just a sub menu
    c4ca:	10 92 02 14 	sts	0x1402, r1
    c4ce:	10 92 01 14 	sts	0x1401, r1
    strcpy(menuitem[0][1], "Information");
    c4d2:	ac e0       	ldi	r26, 0x0C	; 12
    c4d4:	b1 e2       	ldi	r27, 0x21	; 33
    c4d6:	e7 e2       	ldi	r30, 0x27	; 39
    c4d8:	f4 e0       	ldi	r31, 0x04	; 4
    c4da:	8c e0       	ldi	r24, 0x0C	; 12
    c4dc:	01 90       	ld	r0, Z+
    c4de:	0d 92       	st	X+, r0
    c4e0:	81 50       	subi	r24, 0x01	; 1
    c4e2:	e1 f7       	brne	.-8      	; 0xc4dc <initMenu+0x42>
    menulink[0][1] = 2;
    c4e4:	82 e0       	ldi	r24, 0x02	; 2
    c4e6:	90 e0       	ldi	r25, 0x00	; 0
    c4e8:	90 93 e5 16 	sts	0x16E5, r25
    c4ec:	80 93 e4 16 	sts	0x16E4, r24
    menuactn[0][1] = 0;
    c4f0:	10 92 04 14 	sts	0x1404, r1
    c4f4:	10 92 03 14 	sts	0x1403, r1
    strcpy(menuitem[0][2], "SD Card Images");
    c4f8:	a0 e2       	ldi	r26, 0x20	; 32
    c4fa:	b1 e2       	ldi	r27, 0x21	; 33
    c4fc:	e3 e3       	ldi	r30, 0x33	; 51
    c4fe:	f4 e0       	ldi	r31, 0x04	; 4
    c500:	8f e0       	ldi	r24, 0x0F	; 15
    c502:	01 90       	ld	r0, Z+
    c504:	0d 92       	st	X+, r0
    c506:	81 50       	subi	r24, 0x01	; 1
    c508:	e1 f7       	brne	.-8      	; 0xc502 <initMenu+0x68>
    menulink[0][2] = 3;
    c50a:	83 e0       	ldi	r24, 0x03	; 3
    c50c:	90 e0       	ldi	r25, 0x00	; 0
    c50e:	90 93 e7 16 	sts	0x16E7, r25
    c512:	80 93 e6 16 	sts	0x16E6, r24
    menuactn[0][2] = 0;
    c516:	10 92 06 14 	sts	0x1406, r1
    c51a:	10 92 05 14 	sts	0x1405, r1
    strcpy(menuitem[0][3], "Sensor Data");
    c51e:	a4 e3       	ldi	r26, 0x34	; 52
    c520:	b1 e2       	ldi	r27, 0x21	; 33
    c522:	e2 e4       	ldi	r30, 0x42	; 66
    c524:	f4 e0       	ldi	r31, 0x04	; 4
    c526:	8c e0       	ldi	r24, 0x0C	; 12
    c528:	01 90       	ld	r0, Z+
    c52a:	0d 92       	st	X+, r0
    c52c:	81 50       	subi	r24, 0x01	; 1
    c52e:	e1 f7       	brne	.-8      	; 0xc528 <initMenu+0x8e>
    menulink[0][3] = 4;
    c530:	84 e0       	ldi	r24, 0x04	; 4
    c532:	90 e0       	ldi	r25, 0x00	; 0
    c534:	90 93 e9 16 	sts	0x16E9, r25
    c538:	80 93 e8 16 	sts	0x16E8, r24
    menuactn[0][3] = 0;
    c53c:	10 92 08 14 	sts	0x1408, r1
    c540:	10 92 07 14 	sts	0x1407, r1
    strcpy(menuitem[0][4], "Menu 2");
    c544:	a8 e4       	ldi	r26, 0x48	; 72
    c546:	b1 e2       	ldi	r27, 0x21	; 33
    c548:	ee e4       	ldi	r30, 0x4E	; 78
    c54a:	f4 e0       	ldi	r31, 0x04	; 4
    c54c:	87 e0       	ldi	r24, 0x07	; 7
    c54e:	01 90       	ld	r0, Z+
    c550:	0d 92       	st	X+, r0
    c552:	81 50       	subi	r24, 0x01	; 1
    c554:	e1 f7       	brne	.-8      	; 0xc54e <initMenu+0xb4>
    menulink[0][4] = 5;
    c556:	85 e0       	ldi	r24, 0x05	; 5
    c558:	90 e0       	ldi	r25, 0x00	; 0
    c55a:	90 93 eb 16 	sts	0x16EB, r25
    c55e:	80 93 ea 16 	sts	0x16EA, r24
    menuactn[0][4] = 0;
    c562:	10 92 0a 14 	sts	0x140A, r1
    c566:	10 92 09 14 	sts	0x1409, r1
 
    strcpy(menuitem[0][5], "\0"); // Need to initialize the end str of array
    c56a:	10 92 5c 21 	sts	0x215C, r1
 
    strcpy(menutitle[1], "RTOS Tests");
    c56e:	ae e7       	ldi	r26, 0x7E	; 126
    c570:	bc e1       	ldi	r27, 0x1C	; 28
    c572:	ec e1       	ldi	r30, 0x1C	; 28
    c574:	f4 e0       	ldi	r31, 0x04	; 4
    c576:	8b e0       	ldi	r24, 0x0B	; 11
    c578:	01 90       	ld	r0, Z+
    c57a:	0d 92       	st	X+, r0
    c57c:	81 50       	subi	r24, 0x01	; 1
    c57e:	e1 f7       	brne	.-8      	; 0xc578 <initMenu+0xde>
    strcpy(menuitem[1][0], "NIL RTOS Test");
    c580:	a4 e8       	ldi	r26, 0x84	; 132
    c582:	b1 e2       	ldi	r27, 0x21	; 33
    c584:	e5 e5       	ldi	r30, 0x55	; 85
    c586:	f4 e0       	ldi	r31, 0x04	; 4
    c588:	8e e0       	ldi	r24, 0x0E	; 14
    c58a:	01 90       	ld	r0, Z+
    c58c:	0d 92       	st	X+, r0
    c58e:	81 50       	subi	r24, 0x01	; 1
    c590:	e1 f7       	brne	.-8      	; 0xc58a <initMenu+0xf0>
    menulink[1][0] = 0; 
    c592:	10 92 f1 16 	sts	0x16F1, r1
    c596:	10 92 f0 16 	sts	0x16F0, r1
    menuactn[1][0] = 1;
    c59a:	81 e0       	ldi	r24, 0x01	; 1
    c59c:	90 e0       	ldi	r25, 0x00	; 0
    c59e:	90 93 10 14 	sts	0x1410, r25
    c5a2:	80 93 0f 14 	sts	0x140F, r24
    strcpy(menuitem[1][1], "Thread Stack Data");
    c5a6:	a8 e9       	ldi	r26, 0x98	; 152
    c5a8:	b1 e2       	ldi	r27, 0x21	; 33
    c5aa:	e3 e6       	ldi	r30, 0x63	; 99
    c5ac:	f4 e0       	ldi	r31, 0x04	; 4
    c5ae:	82 e1       	ldi	r24, 0x12	; 18
    c5b0:	01 90       	ld	r0, Z+
    c5b2:	0d 92       	st	X+, r0
    c5b4:	81 50       	subi	r24, 0x01	; 1
    c5b6:	e1 f7       	brne	.-8      	; 0xc5b0 <initMenu+0x116>
    menulink[1][1] = 0;
    c5b8:	10 92 f3 16 	sts	0x16F3, r1
    c5bc:	10 92 f2 16 	sts	0x16F2, r1
    menuactn[1][1] = 2;
    c5c0:	82 e0       	ldi	r24, 0x02	; 2
    c5c2:	90 e0       	ldi	r25, 0x00	; 0
    c5c4:	90 93 12 14 	sts	0x1412, r25
    c5c8:	80 93 11 14 	sts	0x1411, r24
    strcpy(menuitem[1][2], "Thread Status");
    c5cc:	ac ea       	ldi	r26, 0xAC	; 172
    c5ce:	b1 e2       	ldi	r27, 0x21	; 33
    c5d0:	e5 e7       	ldi	r30, 0x75	; 117
    c5d2:	f4 e0       	ldi	r31, 0x04	; 4
    c5d4:	8e e0       	ldi	r24, 0x0E	; 14
    c5d6:	01 90       	ld	r0, Z+
    c5d8:	0d 92       	st	X+, r0
    c5da:	81 50       	subi	r24, 0x01	; 1
    c5dc:	e1 f7       	brne	.-8      	; 0xc5d6 <initMenu+0x13c>
    menulink[1][2] = 0;
    c5de:	10 92 f5 16 	sts	0x16F5, r1
    c5e2:	10 92 f4 16 	sts	0x16F4, r1
    menuactn[1][2] = 3;
    c5e6:	83 e0       	ldi	r24, 0x03	; 3
    c5e8:	90 e0       	ldi	r25, 0x00	; 0
    c5ea:	90 93 14 14 	sts	0x1414, r25
    c5ee:	80 93 13 14 	sts	0x1413, r24
	strcpy(menuitem[1][3], "//");
    c5f2:	a0 ec       	ldi	r26, 0xC0	; 192
    c5f4:	b1 e2       	ldi	r27, 0x21	; 33
    c5f6:	e3 e8       	ldi	r30, 0x83	; 131
    c5f8:	f4 e0       	ldi	r31, 0x04	; 4
    c5fa:	83 e0       	ldi	r24, 0x03	; 3
    c5fc:	01 90       	ld	r0, Z+
    c5fe:	0d 92       	st	X+, r0
    c600:	81 50       	subi	r24, 0x01	; 1
    c602:	e1 f7       	brne	.-8      	; 0xc5fc <initMenu+0x162>
    menulink[1][3] = 0;
    c604:	10 92 f7 16 	sts	0x16F7, r1
    c608:	10 92 f6 16 	sts	0x16F6, r1
    menuactn[1][3] = 999;
    c60c:	87 ee       	ldi	r24, 0xE7	; 231
    c60e:	93 e0       	ldi	r25, 0x03	; 3
    c610:	90 93 16 14 	sts	0x1416, r25
    c614:	80 93 15 14 	sts	0x1415, r24
    strcpy(menuitem[1][4], "\0"); // Need to initialize the end str of array
    c618:	10 92 d4 21 	sts	0x21D4, r1
 
    strcpy(menutitle[2], "Information");
    c61c:	a2 e9       	ldi	r26, 0x92	; 146
    c61e:	bc e1       	ldi	r27, 0x1C	; 28
    c620:	e7 e2       	ldi	r30, 0x27	; 39
    c622:	f4 e0       	ldi	r31, 0x04	; 4
    c624:	8c e0       	ldi	r24, 0x0C	; 12
    c626:	01 90       	ld	r0, Z+
    c628:	0d 92       	st	X+, r0
    c62a:	81 50       	subi	r24, 0x01	; 1
    c62c:	e1 f7       	brne	.-8      	; 0xc626 <initMenu+0x18c>
    strcpy(menuitem[2][0], "System Time");
    c62e:	a0 e1       	ldi	r26, 0x10	; 16
    c630:	b2 e2       	ldi	r27, 0x22	; 34
    c632:	e6 e8       	ldi	r30, 0x86	; 134
    c634:	f4 e0       	ldi	r31, 0x04	; 4
    c636:	8c e0       	ldi	r24, 0x0C	; 12
    c638:	01 90       	ld	r0, Z+
    c63a:	0d 92       	st	X+, r0
    c63c:	81 50       	subi	r24, 0x01	; 1
    c63e:	e1 f7       	brne	.-8      	; 0xc638 <initMenu+0x19e>
    menulink[2][0] = 0; // no sub menu, just action
    c640:	10 92 ff 16 	sts	0x16FF, r1
    c644:	10 92 fe 16 	sts	0x16FE, r1
    menuactn[2][0] = 4;
    c648:	84 e0       	ldi	r24, 0x04	; 4
    c64a:	90 e0       	ldi	r25, 0x00	; 0
    c64c:	90 93 1e 14 	sts	0x141E, r25
    c650:	80 93 1d 14 	sts	0x141D, r24
    strcpy(menuitem[2][1], "HeartBeat");
    c654:	a4 e2       	ldi	r26, 0x24	; 36
    c656:	b2 e2       	ldi	r27, 0x22	; 34
    c658:	e2 e9       	ldi	r30, 0x92	; 146
    c65a:	f4 e0       	ldi	r31, 0x04	; 4
    c65c:	8a e0       	ldi	r24, 0x0A	; 10
    c65e:	01 90       	ld	r0, Z+
    c660:	0d 92       	st	X+, r0
    c662:	81 50       	subi	r24, 0x01	; 1
    c664:	e1 f7       	brne	.-8      	; 0xc65e <initMenu+0x1c4>
    menulink[2][1] = 0;
    c666:	10 92 01 17 	sts	0x1701, r1
    c66a:	10 92 00 17 	sts	0x1700, r1
    menuactn[2][1] = 11;
    c66e:	8b e0       	ldi	r24, 0x0B	; 11
    c670:	90 e0       	ldi	r25, 0x00	; 0
    c672:	90 93 20 14 	sts	0x1420, r25
    c676:	80 93 1f 14 	sts	0x141F, r24
	strcpy(menuitem[2][2], "Info Scroll");
    c67a:	a8 e3       	ldi	r26, 0x38	; 56
    c67c:	b2 e2       	ldi	r27, 0x22	; 34
    c67e:	ec e9       	ldi	r30, 0x9C	; 156
    c680:	f4 e0       	ldi	r31, 0x04	; 4
    c682:	8c e0       	ldi	r24, 0x0C	; 12
    c684:	01 90       	ld	r0, Z+
    c686:	0d 92       	st	X+, r0
    c688:	81 50       	subi	r24, 0x01	; 1
    c68a:	e1 f7       	brne	.-8      	; 0xc684 <initMenu+0x1ea>
    menulink[2][2] = 0;
    c68c:	10 92 03 17 	sts	0x1703, r1
    c690:	10 92 02 17 	sts	0x1702, r1
    menuactn[2][2] = 5;
    c694:	85 e0       	ldi	r24, 0x05	; 5
    c696:	90 e0       	ldi	r25, 0x00	; 0
    c698:	90 93 22 14 	sts	0x1422, r25
    c69c:	80 93 21 14 	sts	0x1421, r24
	strcpy(menuitem[2][3], "Simple Timer");
    c6a0:	ac e4       	ldi	r26, 0x4C	; 76
    c6a2:	b2 e2       	ldi	r27, 0x22	; 34
    c6a4:	e8 ea       	ldi	r30, 0xA8	; 168
    c6a6:	f4 e0       	ldi	r31, 0x04	; 4
    c6a8:	8d e0       	ldi	r24, 0x0D	; 13
    c6aa:	01 90       	ld	r0, Z+
    c6ac:	0d 92       	st	X+, r0
    c6ae:	81 50       	subi	r24, 0x01	; 1
    c6b0:	e1 f7       	brne	.-8      	; 0xc6aa <initMenu+0x210>
    menulink[2][3] = 0;
    c6b2:	10 92 05 17 	sts	0x1705, r1
    c6b6:	10 92 04 17 	sts	0x1704, r1
    menuactn[2][3] = 6;
    c6ba:	86 e0       	ldi	r24, 0x06	; 6
    c6bc:	90 e0       	ldi	r25, 0x00	; 0
    c6be:	90 93 24 14 	sts	0x1424, r25
    c6c2:	80 93 23 14 	sts	0x1423, r24
	strcpy(menuitem[2][4], "Set the Time");
    c6c6:	a0 e6       	ldi	r26, 0x60	; 96
    c6c8:	b2 e2       	ldi	r27, 0x22	; 34
    c6ca:	e5 eb       	ldi	r30, 0xB5	; 181
    c6cc:	f4 e0       	ldi	r31, 0x04	; 4
    c6ce:	8d e0       	ldi	r24, 0x0D	; 13
    c6d0:	01 90       	ld	r0, Z+
    c6d2:	0d 92       	st	X+, r0
    c6d4:	81 50       	subi	r24, 0x01	; 1
    c6d6:	e1 f7       	brne	.-8      	; 0xc6d0 <initMenu+0x236>
    menulink[2][4] = 0;
    c6d8:	10 92 07 17 	sts	0x1707, r1
    c6dc:	10 92 06 17 	sts	0x1706, r1
    menuactn[2][4] = 12;
    c6e0:	8c e0       	ldi	r24, 0x0C	; 12
    c6e2:	90 e0       	ldi	r25, 0x00	; 0
    c6e4:	90 93 26 14 	sts	0x1426, r25
    c6e8:	80 93 25 14 	sts	0x1425, r24
    strcpy(menuitem[2][5], "//");
    c6ec:	a4 e7       	ldi	r26, 0x74	; 116
    c6ee:	b2 e2       	ldi	r27, 0x22	; 34
    c6f0:	e3 e8       	ldi	r30, 0x83	; 131
    c6f2:	f4 e0       	ldi	r31, 0x04	; 4
    c6f4:	83 e0       	ldi	r24, 0x03	; 3
    c6f6:	01 90       	ld	r0, Z+
    c6f8:	0d 92       	st	X+, r0
    c6fa:	81 50       	subi	r24, 0x01	; 1
    c6fc:	e1 f7       	brne	.-8      	; 0xc6f6 <initMenu+0x25c>
    menulink[2][5] = 0; // code to trigger return to main menu.  Can't use 0 as that is considered no action here
    c6fe:	10 92 09 17 	sts	0x1709, r1
    c702:	10 92 08 17 	sts	0x1708, r1
    menuactn[2][5] = 999;
    c706:	87 ee       	ldi	r24, 0xE7	; 231
    c708:	93 e0       	ldi	r25, 0x03	; 3
    c70a:	90 93 28 14 	sts	0x1428, r25
    c70e:	80 93 27 14 	sts	0x1427, r24
    strcpy(menuitem[2][6], "\0"); // Need to initialize the end str of array
    c712:	10 92 88 22 	sts	0x2288, r1
 
    strcpy(menutitle[3], "SD Card Images");
    c716:	a6 ea       	ldi	r26, 0xA6	; 166
    c718:	bc e1       	ldi	r27, 0x1C	; 28
    c71a:	e3 e3       	ldi	r30, 0x33	; 51
    c71c:	f4 e0       	ldi	r31, 0x04	; 4
    c71e:	8f e0       	ldi	r24, 0x0F	; 15
    c720:	01 90       	ld	r0, Z+
    c722:	0d 92       	st	X+, r0
    c724:	81 50       	subi	r24, 0x01	; 1
    c726:	e1 f7       	brne	.-8      	; 0xc720 <initMenu+0x286>
    strcpy(menuitem[3][0], "Show image 1");
    c728:	ac e9       	ldi	r26, 0x9C	; 156
    c72a:	b2 e2       	ldi	r27, 0x22	; 34
    c72c:	e2 ec       	ldi	r30, 0xC2	; 194
    c72e:	f4 e0       	ldi	r31, 0x04	; 4
    c730:	8d e0       	ldi	r24, 0x0D	; 13
    c732:	01 90       	ld	r0, Z+
    c734:	0d 92       	st	X+, r0
    c736:	81 50       	subi	r24, 0x01	; 1
    c738:	e1 f7       	brne	.-8      	; 0xc732 <initMenu+0x298>
    menulink[3][0] = 0; // no sub menu, just action
    c73a:	10 92 0d 17 	sts	0x170D, r1
    c73e:	10 92 0c 17 	sts	0x170C, r1
    menuactn[3][0] = 7;
    c742:	87 e0       	ldi	r24, 0x07	; 7
    c744:	90 e0       	ldi	r25, 0x00	; 0
    c746:	90 93 2c 14 	sts	0x142C, r25
    c74a:	80 93 2b 14 	sts	0x142B, r24
    strcpy(menuitem[3][1], "Show image 2");
    c74e:	a0 eb       	ldi	r26, 0xB0	; 176
    c750:	b2 e2       	ldi	r27, 0x22	; 34
    c752:	ef ec       	ldi	r30, 0xCF	; 207
    c754:	f4 e0       	ldi	r31, 0x04	; 4
    c756:	8d e0       	ldi	r24, 0x0D	; 13
    c758:	01 90       	ld	r0, Z+
    c75a:	0d 92       	st	X+, r0
    c75c:	81 50       	subi	r24, 0x01	; 1
    c75e:	e1 f7       	brne	.-8      	; 0xc758 <initMenu+0x2be>
    menulink[3][1] = 0;
    c760:	10 92 0f 17 	sts	0x170F, r1
    c764:	10 92 0e 17 	sts	0x170E, r1
    menuactn[3][1] = 8;
    c768:	88 e0       	ldi	r24, 0x08	; 8
    c76a:	90 e0       	ldi	r25, 0x00	; 0
    c76c:	90 93 2e 14 	sts	0x142E, r25
    c770:	80 93 2d 14 	sts	0x142D, r24
    strcpy(menuitem[3][2], "//");
    c774:	a4 ec       	ldi	r26, 0xC4	; 196
    c776:	b2 e2       	ldi	r27, 0x22	; 34
    c778:	e3 e8       	ldi	r30, 0x83	; 131
    c77a:	f4 e0       	ldi	r31, 0x04	; 4
    c77c:	83 e0       	ldi	r24, 0x03	; 3
    c77e:	01 90       	ld	r0, Z+
    c780:	0d 92       	st	X+, r0
    c782:	81 50       	subi	r24, 0x01	; 1
    c784:	e1 f7       	brne	.-8      	; 0xc77e <initMenu+0x2e4>
    menulink[3][2] = 0; // code to trigger return to main menu.  Can't use 0 as that is considered no action here
    c786:	10 92 11 17 	sts	0x1711, r1
    c78a:	10 92 10 17 	sts	0x1710, r1
    menuactn[3][2] = 999;
    c78e:	87 ee       	ldi	r24, 0xE7	; 231
    c790:	93 e0       	ldi	r25, 0x03	; 3
    c792:	90 93 30 14 	sts	0x1430, r25
    c796:	80 93 2f 14 	sts	0x142F, r24
    strcpy(menuitem[3][3], "\0"); // Need to initialize the end str of array
    c79a:	10 92 d8 22 	sts	0x22D8, r1
 
    strcpy(menutitle[4], "Sensor Data");
    c79e:	aa eb       	ldi	r26, 0xBA	; 186
    c7a0:	bc e1       	ldi	r27, 0x1C	; 28
    c7a2:	e2 e4       	ldi	r30, 0x42	; 66
    c7a4:	f4 e0       	ldi	r31, 0x04	; 4
    c7a6:	8c e0       	ldi	r24, 0x0C	; 12
    c7a8:	01 90       	ld	r0, Z+
    c7aa:	0d 92       	st	X+, r0
    c7ac:	81 50       	subi	r24, 0x01	; 1
    c7ae:	e1 f7       	brne	.-8      	; 0xc7a8 <initMenu+0x30e>
    strcpy(menuitem[4][0], "Real Time Clock");
    c7b0:	a8 e2       	ldi	r26, 0x28	; 40
    c7b2:	b3 e2       	ldi	r27, 0x23	; 35
    c7b4:	ec ed       	ldi	r30, 0xDC	; 220
    c7b6:	f4 e0       	ldi	r31, 0x04	; 4
    c7b8:	80 e1       	ldi	r24, 0x10	; 16
    c7ba:	01 90       	ld	r0, Z+
    c7bc:	0d 92       	st	X+, r0
    c7be:	81 50       	subi	r24, 0x01	; 1
    c7c0:	e1 f7       	brne	.-8      	; 0xc7ba <initMenu+0x320>
    menulink[4][0] = 0; // no sub menu, just action
    c7c2:	10 92 1b 17 	sts	0x171B, r1
    c7c6:	10 92 1a 17 	sts	0x171A, r1
    menuactn[4][0] = 9;
    c7ca:	89 e0       	ldi	r24, 0x09	; 9
    c7cc:	90 e0       	ldi	r25, 0x00	; 0
    c7ce:	90 93 3a 14 	sts	0x143A, r25
    c7d2:	80 93 39 14 	sts	0x1439, r24
    strcpy(menuitem[4][1], "Sensormania");
    c7d6:	ac e3       	ldi	r26, 0x3C	; 60
    c7d8:	b3 e2       	ldi	r27, 0x23	; 35
    c7da:	ec ee       	ldi	r30, 0xEC	; 236
    c7dc:	f4 e0       	ldi	r31, 0x04	; 4
    c7de:	8c e0       	ldi	r24, 0x0C	; 12
    c7e0:	01 90       	ld	r0, Z+
    c7e2:	0d 92       	st	X+, r0
    c7e4:	81 50       	subi	r24, 0x01	; 1
    c7e6:	e1 f7       	brne	.-8      	; 0xc7e0 <initMenu+0x346>
    menulink[4][1] = 0;
    c7e8:	10 92 1d 17 	sts	0x171D, r1
    c7ec:	10 92 1c 17 	sts	0x171C, r1
    menuactn[4][1] = 10;
    c7f0:	8a e0       	ldi	r24, 0x0A	; 10
    c7f2:	90 e0       	ldi	r25, 0x00	; 0
    c7f4:	90 93 3c 14 	sts	0x143C, r25
    c7f8:	80 93 3b 14 	sts	0x143B, r24
    strcpy(menuitem[4][2], "//");
    c7fc:	a0 e5       	ldi	r26, 0x50	; 80
    c7fe:	b3 e2       	ldi	r27, 0x23	; 35
    c800:	e3 e8       	ldi	r30, 0x83	; 131
    c802:	f4 e0       	ldi	r31, 0x04	; 4
    c804:	83 e0       	ldi	r24, 0x03	; 3
    c806:	01 90       	ld	r0, Z+
    c808:	0d 92       	st	X+, r0
    c80a:	81 50       	subi	r24, 0x01	; 1
    c80c:	e1 f7       	brne	.-8      	; 0xc806 <initMenu+0x36c>
    menulink[4][2] = 0; // code to trigger return to main menu.  Can't use 0 as that is considered no action here
    c80e:	10 92 1f 17 	sts	0x171F, r1
    c812:	10 92 1e 17 	sts	0x171E, r1
    menuactn[4][2] = 999;
    c816:	87 ee       	ldi	r24, 0xE7	; 231
    c818:	93 e0       	ldi	r25, 0x03	; 3
    c81a:	90 93 3e 14 	sts	0x143E, r25
    c81e:	80 93 3d 14 	sts	0x143D, r24
    strcpy(menuitem[4][3], "\0"); // Need to initialize the end str of array
    c822:	10 92 64 23 	sts	0x2364, r1
 
    strcpy(menutitle[5], "Menu 2");
    c826:	ae ec       	ldi	r26, 0xCE	; 206
    c828:	bc e1       	ldi	r27, 0x1C	; 28
    c82a:	ee e4       	ldi	r30, 0x4E	; 78
    c82c:	f4 e0       	ldi	r31, 0x04	; 4
    c82e:	87 e0       	ldi	r24, 0x07	; 7
    c830:	01 90       	ld	r0, Z+
    c832:	0d 92       	st	X+, r0
    c834:	81 50       	subi	r24, 0x01	; 1
    c836:	e1 f7       	brne	.-8      	; 0xc830 <initMenu+0x396>
    strcpy(menuitem[5][0], "Menu 3");
    c838:	a4 eb       	ldi	r26, 0xB4	; 180
    c83a:	b3 e2       	ldi	r27, 0x23	; 35
    c83c:	e8 ef       	ldi	r30, 0xF8	; 248
    c83e:	f4 e0       	ldi	r31, 0x04	; 4
    c840:	87 e0       	ldi	r24, 0x07	; 7
    c842:	01 90       	ld	r0, Z+
    c844:	0d 92       	st	X+, r0
    c846:	81 50       	subi	r24, 0x01	; 1
    c848:	e1 f7       	brne	.-8      	; 0xc842 <initMenu+0x3a8>
    menulink[5][0] = 6; // go to menu 6
    c84a:	86 e0       	ldi	r24, 0x06	; 6
    c84c:	90 e0       	ldi	r25, 0x00	; 0
    c84e:	90 93 29 17 	sts	0x1729, r25
    c852:	80 93 28 17 	sts	0x1728, r24
    menuactn[5][0] = 0;
    c856:	10 92 48 14 	sts	0x1448, r1
    c85a:	10 92 47 14 	sts	0x1447, r1
    strcpy(menuitem[5][1], "//");
    c85e:	a8 ec       	ldi	r26, 0xC8	; 200
    c860:	b3 e2       	ldi	r27, 0x23	; 35
    c862:	e3 e8       	ldi	r30, 0x83	; 131
    c864:	f4 e0       	ldi	r31, 0x04	; 4
    c866:	83 e0       	ldi	r24, 0x03	; 3
    c868:	01 90       	ld	r0, Z+
    c86a:	0d 92       	st	X+, r0
    c86c:	81 50       	subi	r24, 0x01	; 1
    c86e:	e1 f7       	brne	.-8      	; 0xc868 <initMenu+0x3ce>
    menulink[5][1] = 0; // code to trigger return to main menu.  Can't use 0 as that is considered no action here
    c870:	10 92 2b 17 	sts	0x172B, r1
    c874:	10 92 2a 17 	sts	0x172A, r1
    menuactn[5][1] = 999;
    c878:	87 ee       	ldi	r24, 0xE7	; 231
    c87a:	93 e0       	ldi	r25, 0x03	; 3
    c87c:	90 93 4a 14 	sts	0x144A, r25
    c880:	80 93 49 14 	sts	0x1449, r24
    strcpy(menuitem[5][2], "\0"); // Need to initialize the end str of array
    c884:	10 92 dc 23 	sts	0x23DC, r1
 
    strcpy(menutitle[6], "Menu 3");
    c888:	a2 ee       	ldi	r26, 0xE2	; 226
    c88a:	bc e1       	ldi	r27, 0x1C	; 28
    c88c:	e8 ef       	ldi	r30, 0xF8	; 248
    c88e:	f4 e0       	ldi	r31, 0x04	; 4
    c890:	87 e0       	ldi	r24, 0x07	; 7
    c892:	01 90       	ld	r0, Z+
    c894:	0d 92       	st	X+, r0
    c896:	81 50       	subi	r24, 0x01	; 1
    c898:	e1 f7       	brne	.-8      	; 0xc892 <initMenu+0x3f8>
    strcpy(menuitem[6][0], "//");
    c89a:	a0 e4       	ldi	r26, 0x40	; 64
    c89c:	b4 e2       	ldi	r27, 0x24	; 36
    c89e:	e3 e8       	ldi	r30, 0x83	; 131
    c8a0:	f4 e0       	ldi	r31, 0x04	; 4
    c8a2:	83 e0       	ldi	r24, 0x03	; 3
    c8a4:	01 90       	ld	r0, Z+
    c8a6:	0d 92       	st	X+, r0
    c8a8:	81 50       	subi	r24, 0x01	; 1
    c8aa:	e1 f7       	brne	.-8      	; 0xc8a4 <initMenu+0x40a>
    menulink[6][0] = 5; // code to trigger return to main menu.  Can't use 0 as that is considered no action here
    c8ac:	85 e0       	ldi	r24, 0x05	; 5
    c8ae:	90 e0       	ldi	r25, 0x00	; 0
    c8b0:	90 93 37 17 	sts	0x1737, r25
    c8b4:	80 93 36 17 	sts	0x1736, r24
    menuactn[6][0] = 0;
    c8b8:	10 92 56 14 	sts	0x1456, r1
    c8bc:	10 92 55 14 	sts	0x1455, r1
    strcpy(menuitem[6][1], "\0"); // Need to initialize the end str of array
    c8c0:	10 92 54 24 	sts	0x2454, r1
 
    // END of menu data
}
    c8c4:	08 95       	ret

0000c8c6 <Thread2>:
 * Thread 2 - LCD Display Handler
 *********************************************************************************/
THD_FUNCTION(Thread2, arg) {

  (void)arg;
    tp[1] = chThdGetSelfX();
    c8c6:	80 91 ce 07 	lds	r24, 0x07CE
    c8ca:	90 91 cf 07 	lds	r25, 0x07CF
    c8ce:	90 93 99 07 	sts	0x0799, r25
    c8d2:	80 93 98 07 	sts	0x0798, r24
    initMenu(); // initialize menu by adding menu data to menu globals
    c8d6:	0e 94 4d 62 	call	0xc49a	; 0xc49a <initMenu>
	/*Wait for the lcdUSe semaphore to be free & take it */
	chSemWait(&lcdUSE);
    c8da:	8d ef       	ldi	r24, 0xFD	; 253
    c8dc:	93 e1       	ldi	r25, 0x13	; 19
    c8de:	40 e0       	ldi	r20, 0x00	; 0
    c8e0:	50 e0       	ldi	r21, 0x00	; 0
    c8e2:	60 e0       	ldi	r22, 0x00	; 0
    c8e4:	70 e0       	ldi	r23, 0x00	; 0
    c8e6:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>

static
void LCD_PWM_Init (void)
{
	
	DDRB |= (1<<PB3);
    c8ea:	23 9a       	sbi	0x04, 3	; 4
	OCR2A = LCD_PWM_SET;
    c8ec:	80 91 31 05 	lds	r24, 0x0531
    c8f0:	80 93 b3 00 	sts	0x00B3, r24
	TCCR2B |= (1<<CS22) |(1<<CS21)|(1<<CS20);
    c8f4:	80 91 b1 00 	lds	r24, 0x00B1
    c8f8:	87 60       	ori	r24, 0x07	; 7
    c8fa:	80 93 b1 00 	sts	0x00B1, r24
	TIMSK2 |= (1<<OCIE2A) |(1<<TOIE2) ;
    c8fe:	80 91 70 00 	lds	r24, 0x0070
    c902:	83 60       	ori	r24, 0x03	; 3
    c904:	80 93 70 00 	sts	0x0070, r24
    initMenu(); // initialize menu by adding menu data to menu globals
	/*Wait for the lcdUSe semaphore to be free & take it */
	chSemWait(&lcdUSE);
	LCD_PWM_Init();
	
	chSemWait(&spiUSE);
    c908:	89 e7       	ldi	r24, 0x79	; 121
    c90a:	94 e1       	ldi	r25, 0x14	; 20
    c90c:	40 e0       	ldi	r20, 0x00	; 0
    c90e:	50 e0       	ldi	r21, 0x00	; 0
    c910:	60 e0       	ldi	r22, 0x00	; 0
    c912:	70 e0       	ldi	r23, 0x00	; 0
    c914:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
	spi_init();
    c918:	0e 94 88 14 	call	0x2910	; 0x2910 <spi_init>
	st7735_init();//lcd_init();
    c91c:	0e 94 97 15 	call	0x2b2e	; 0x2b2e <st7735_init>
	chSemSignal(&spiUSE);
    c920:	89 e7       	ldi	r24, 0x79	; 121
    c922:	94 e1       	ldi	r25, 0x14	; 20
    c924:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
	
	//lcd_contrast(0x36);//0x36
	chSemWait(&spiUSE);
    c928:	89 e7       	ldi	r24, 0x79	; 121
    c92a:	94 e1       	ldi	r25, 0x14	; 20
    c92c:	40 e0       	ldi	r20, 0x00	; 0
    c92e:	50 e0       	ldi	r21, 0x00	; 0
    c930:	60 e0       	ldi	r22, 0x00	; 0
    c932:	70 e0       	ldi	r23, 0x00	; 0
    c934:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
	st7735_set_orientation(ST7735_LANDSCAPE_INV);
    c938:	82 e0       	ldi	r24, 0x02	; 2
    c93a:	0e 94 95 17 	call	0x2f2a	; 0x2f2a <st7735_set_orientation>
	st7735_fill_rect(0, 0, 160, 128, ST7735_COLOR_BLACK);
    c93e:	80 e0       	ldi	r24, 0x00	; 0
    c940:	60 e0       	ldi	r22, 0x00	; 0
    c942:	40 ea       	ldi	r20, 0xA0	; 160
    c944:	20 e8       	ldi	r18, 0x80	; 128
    c946:	00 e0       	ldi	r16, 0x00	; 0
    c948:	10 e0       	ldi	r17, 0x00	; 0
    c94a:	0e 94 59 16 	call	0x2cb2	; 0x2cb2 <st7735_fill_rect>
	chSemSignal(&spiUSE);
    c94e:	89 e7       	ldi	r24, 0x79	; 121
    c950:	94 e1       	ldi	r25, 0x14	; 20
    c952:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
	
	chSemWait(&spiUSE);
    c956:	89 e7       	ldi	r24, 0x79	; 121
    c958:	94 e1       	ldi	r25, 0x14	; 20
    c95a:	40 e0       	ldi	r20, 0x00	; 0
    c95c:	50 e0       	ldi	r21, 0x00	; 0
    c95e:	60 e0       	ldi	r22, 0x00	; 0
    c960:	70 e0       	ldi	r23, 0x00	; 0
    c962:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
	st7735_setTextColor(ST7735_COLOR_CYAN,ST7735_COLOR_BLACK);
    c966:	8f ef       	ldi	r24, 0xFF	; 255
    c968:	97 e0       	ldi	r25, 0x07	; 7
    c96a:	60 e0       	ldi	r22, 0x00	; 0
    c96c:	70 e0       	ldi	r23, 0x00	; 0
    c96e:	0e 94 d1 19 	call	0x33a2	; 0x33a2 <st7735_setTextColor>
	st7735_setTextSize(1);
    c972:	81 e0       	ldi	r24, 0x01	; 1
    c974:	0e 94 cb 19 	call	0x3396	; 0x3396 <st7735_setTextSize>
	st7735_setTextWrap(1);
    c978:	81 e0       	ldi	r24, 0x01	; 1
    c97a:	0e 94 da 19 	call	0x33b4	; 0x33b4 <st7735_setTextWrap>
	chSemSignal(&spiUSE);
    c97e:	89 e7       	ldi	r24, 0x79	; 121
    c980:	94 e1       	ldi	r25, 0x14	; 20
    c982:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>

	/*give back lcd semaphore */
	chSemSignal(&lcdUSE);
    c986:	8d ef       	ldi	r24, 0xFD	; 253
    c988:	93 e1       	ldi	r25, 0x13	; 19
    c98a:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
	chThdSleepMilliseconds(100); 
    c98e:	60 ed       	ldi	r22, 0xD0	; 208
    c990:	77 e0       	ldi	r23, 0x07	; 7
    c992:	80 e0       	ldi	r24, 0x00	; 0
    c994:	90 e0       	ldi	r25, 0x00	; 0
    c996:	0e 94 f4 08 	call	0x11e8	; 0x11e8 <chThdSleep>
		
        /*********************************************************************************
			No action
		********************************************************************************/ 
		if (switchtype == 0) { ///we are returning from a sub-menu action
                if (menuitem[curMenu][curItem][0] == '\0') { 
    c99a:	0c e8       	ldi	r16, 0x8C	; 140
    c99c:	10 e0       	ldi	r17, 0x00	; 0
				curItem = 0; // reset menu item to which cursor point
				pageScroll = 0; // reset menu page scroll
				cursorCount = 0; // reset menu location of page
				menuCount = pageScroll*pageSize; // reprint from first line of this page
			}//end if menuaction
			updateFlag = 1; // we have updated the menu.  Flag is used to delay user input
    c99e:	c1 e0       	ldi	r28, 0x01	; 1
    c9a0:	d0 e0       	ldi	r29, 0x00	; 0
    c9a2:	05 c0       	rjmp	.+10     	; 0xc9ae <Thread2+0xe8>
        } //switchtype 1				
		
		/*********************************************************************************
			Selecting and triggering
		********************************************************************************/ 
		if (switchtype == 2) { //we are selecting 
    c9a4:	80 91 3f 07 	lds	r24, 0x073F
    c9a8:	82 30       	cpi	r24, 0x02	; 2
    c9aa:	09 f4       	brne	.+2      	; 0xc9ae <Thread2+0xe8>
    c9ac:	ad c0       	rjmp	.+346    	; 0xcb08 <Thread2+0x242>
    while(true) { 
	/*********************************************************************************
		Update LCD when triggered, then wait
	********************************************************************************/ 
	/*Wait for the lcdUSe semaphore to be free & take it again */
	chSemWait(&lcdUSE);
    c9ae:	8d ef       	ldi	r24, 0xFD	; 253
    c9b0:	93 e1       	ldi	r25, 0x13	; 19
    c9b2:	40 e0       	ldi	r20, 0x00	; 0
    c9b4:	50 e0       	ldi	r21, 0x00	; 0
    c9b6:	60 e0       	ldi	r22, 0x00	; 0
    c9b8:	70 e0       	ldi	r23, 0x00	; 0
    c9ba:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
		
	/*show the menu*/
	
	showMenu();
    c9be:	0e 94 70 50 	call	0xa0e0	; 0xa0e0 <showMenu>
		
	/*give back the lcd semaphore */
	chSemSignal(&lcdUSE);	
    c9c2:	8d ef       	ldi	r24, 0xFD	; 253
    c9c4:	93 e1       	ldi	r25, 0x13	; 19
    c9c6:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>

	/*********************************************************************************
			wait for button press semaphore to be free to do any more processing
	********************************************************************************/
	chSemWait(&ButtonPressed);
    c9ca:	81 e0       	ldi	r24, 0x01	; 1
    c9cc:	96 e2       	ldi	r25, 0x26	; 38
    c9ce:	40 e0       	ldi	r20, 0x00	; 0
    c9d0:	50 e0       	ldi	r21, 0x00	; 0
    c9d2:	60 e0       	ldi	r22, 0x00	; 0
    c9d4:	70 e0       	ldi	r23, 0x00	; 0
    c9d6:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
		
        /*********************************************************************************
			No action
		********************************************************************************/ 
		if (switchtype == 0) { ///we are returning from a sub-menu action
    c9da:	80 91 3f 07 	lds	r24, 0x073F
    c9de:	88 23       	and	r24, r24
    c9e0:	e9 f5       	brne	.+122    	; 0xca5c <Thread2+0x196>
                if (menuitem[curMenu][curItem][0] == '\0') { 
    c9e2:	20 91 31 07 	lds	r18, 0x0731
    c9e6:	30 91 32 07 	lds	r19, 0x0732
    c9ea:	e0 91 33 07 	lds	r30, 0x0733
    c9ee:	f0 91 34 07 	lds	r31, 0x0734
    c9f2:	ee 0f       	add	r30, r30
    c9f4:	ff 1f       	adc	r31, r31
    c9f6:	ee 0f       	add	r30, r30
    c9f8:	ff 1f       	adc	r31, r31
    c9fa:	cf 01       	movw	r24, r30
    c9fc:	88 0f       	add	r24, r24
    c9fe:	99 1f       	adc	r25, r25
    ca00:	88 0f       	add	r24, r24
    ca02:	99 1f       	adc	r25, r25
    ca04:	e8 0f       	add	r30, r24
    ca06:	f9 1f       	adc	r31, r25
    ca08:	20 9f       	mul	r18, r16
    ca0a:	c0 01       	movw	r24, r0
    ca0c:	21 9f       	mul	r18, r17
    ca0e:	90 0d       	add	r25, r0
    ca10:	30 9f       	mul	r19, r16
    ca12:	90 0d       	add	r25, r0
    ca14:	11 24       	eor	r1, r1
    ca16:	e8 0f       	add	r30, r24
    ca18:	f9 1f       	adc	r31, r25
    ca1a:	e8 50       	subi	r30, 0x08	; 8
    ca1c:	ff 4d       	sbci	r31, 0xDF	; 223
    ca1e:	80 81       	ld	r24, Z
    ca20:	88 23       	and	r24, r24
    ca22:	09 f0       	breq	.+2      	; 0xca26 <Thread2+0x160>
    ca24:	b5 c0       	rjmp	.+362    	; 0xcb90 <Thread2+0x2ca>
				   curItem = 0; 
    ca26:	10 92 34 07 	sts	0x0734, r1
    ca2a:	10 92 33 07 	sts	0x0733, r1
				   pageScroll = 0; 
    ca2e:	10 92 3c 07 	sts	0x073C, r1
    ca32:	10 92 3b 07 	sts	0x073B, r1
				   cursorCount = 0;
    ca36:	10 92 38 07 	sts	0x0738, r1
    ca3a:	10 92 37 07 	sts	0x0737, r1
    ca3e:	20 e0       	ldi	r18, 0x00	; 0
    ca40:	30 e0       	ldi	r19, 0x00	; 0
                    // we have scrolled past this page, go to next
                    // remember, we check if we have scrolled off the MENU under clicks.  This is off the PAGE.
                    pageScroll++;  // next "page"
                    cursorCount=0; // reset cursor location
                }
            menuCount = pageScroll*pageSize;
    ca42:	c9 01       	movw	r24, r18
    ca44:	88 0f       	add	r24, r24
    ca46:	99 1f       	adc	r25, r25
    ca48:	88 0f       	add	r24, r24
    ca4a:	99 1f       	adc	r25, r25
    ca4c:	88 0f       	add	r24, r24
    ca4e:	99 1f       	adc	r25, r25
    ca50:	82 1b       	sub	r24, r18
    ca52:	93 0b       	sbc	r25, r19
    ca54:	90 93 3a 07 	sts	0x073A, r25
    ca58:	80 93 39 07 	sts	0x0739, r24
        } //switchtype 0	
		
		/*********************************************************************************
			Scrolling
		********************************************************************************/ 
		if (switchtype == 1) { //we are scrolling
    ca5c:	80 91 3f 07 	lds	r24, 0x073F
    ca60:	81 30       	cpi	r24, 0x01	; 1
    ca62:	09 f0       	breq	.+2      	; 0xca66 <Thread2+0x1a0>
    ca64:	9f cf       	rjmp	.-194    	; 0xc9a4 <Thread2+0xde>
			curItem++; // add one to curr item
    ca66:	e0 91 33 07 	lds	r30, 0x0733
    ca6a:	f0 91 34 07 	lds	r31, 0x0734
    ca6e:	31 96       	adiw	r30, 0x01	; 1
    ca70:	f0 93 34 07 	sts	0x0734, r31
    ca74:	e0 93 33 07 	sts	0x0733, r30
            cursorCount++;
    ca78:	40 91 37 07 	lds	r20, 0x0737
    ca7c:	50 91 38 07 	lds	r21, 0x0738
    ca80:	4f 5f       	subi	r20, 0xFF	; 255
    ca82:	5f 4f       	sbci	r21, 0xFF	; 255
    ca84:	50 93 38 07 	sts	0x0738, r21
    ca88:	40 93 37 07 	sts	0x0737, r20
                if (menuitem[curMenu][curItem][0] == '\0') { 
    ca8c:	20 91 31 07 	lds	r18, 0x0731
    ca90:	30 91 32 07 	lds	r19, 0x0732
    ca94:	ee 0f       	add	r30, r30
    ca96:	ff 1f       	adc	r31, r31
    ca98:	ee 0f       	add	r30, r30
    ca9a:	ff 1f       	adc	r31, r31
    ca9c:	cf 01       	movw	r24, r30
    ca9e:	88 0f       	add	r24, r24
    caa0:	99 1f       	adc	r25, r25
    caa2:	88 0f       	add	r24, r24
    caa4:	99 1f       	adc	r25, r25
    caa6:	e8 0f       	add	r30, r24
    caa8:	f9 1f       	adc	r31, r25
    caaa:	20 9f       	mul	r18, r16
    caac:	c0 01       	movw	r24, r0
    caae:	21 9f       	mul	r18, r17
    cab0:	90 0d       	add	r25, r0
    cab2:	30 9f       	mul	r19, r16
    cab4:	90 0d       	add	r25, r0
    cab6:	11 24       	eor	r1, r1
    cab8:	e8 0f       	add	r30, r24
    caba:	f9 1f       	adc	r31, r25
    cabc:	e8 50       	subi	r30, 0x08	; 8
    cabe:	ff 4d       	sbci	r31, 0xDF	; 223
    cac0:	80 81       	ld	r24, Z
    cac2:	88 23       	and	r24, r24
    cac4:	09 f0       	breq	.+2      	; 0xcac8 <Thread2+0x202>
    cac6:	7a c0       	rjmp	.+244    	; 0xcbbc <Thread2+0x2f6>
				   curItem = 0; 
    cac8:	10 92 34 07 	sts	0x0734, r1
    cacc:	10 92 33 07 	sts	0x0733, r1
				   pageScroll = 0; 
    cad0:	10 92 3c 07 	sts	0x073C, r1
    cad4:	10 92 3b 07 	sts	0x073B, r1
				   cursorCount = 0;
    cad8:	10 92 38 07 	sts	0x0738, r1
    cadc:	10 92 37 07 	sts	0x0737, r1
    cae0:	20 e0       	ldi	r18, 0x00	; 0
    cae2:	30 e0       	ldi	r19, 0x00	; 0
                    // we have scrolled past this page, go to next
                    // remember, we check if we have scrolled off the MENU under clicks.  This is off the PAGE.
                    pageScroll++;  // next "page"
                    cursorCount=0; // reset cursor location
                }
            menuCount = pageScroll*pageSize;
    cae4:	c9 01       	movw	r24, r18
    cae6:	88 0f       	add	r24, r24
    cae8:	99 1f       	adc	r25, r25
    caea:	88 0f       	add	r24, r24
    caec:	99 1f       	adc	r25, r25
    caee:	88 0f       	add	r24, r24
    caf0:	99 1f       	adc	r25, r25
    caf2:	82 1b       	sub	r24, r18
    caf4:	93 0b       	sbc	r25, r19
    caf6:	90 93 3a 07 	sts	0x073A, r25
    cafa:	80 93 39 07 	sts	0x0739, r24
        } //switchtype 1				
		
		/*********************************************************************************
			Selecting and triggering
		********************************************************************************/ 
		if (switchtype == 2) { //we are selecting 
    cafe:	80 91 3f 07 	lds	r24, 0x073F
    cb02:	82 30       	cpi	r24, 0x02	; 2
    cb04:	09 f0       	breq	.+2      	; 0xcb08 <Thread2+0x242>
    cb06:	53 cf       	rjmp	.-346    	; 0xc9ae <Thread2+0xe8>
			// handle user input
			if (menuactn[curMenu][curItem]) {
    cb08:	80 91 31 07 	lds	r24, 0x0731
    cb0c:	90 91 32 07 	lds	r25, 0x0732
    cb10:	20 91 33 07 	lds	r18, 0x0733
    cb14:	30 91 34 07 	lds	r19, 0x0734
    cb18:	dc 01       	movw	r26, r24
    cb1a:	aa 0f       	add	r26, r26
    cb1c:	bb 1f       	adc	r27, r27
    cb1e:	aa 0f       	add	r26, r26
    cb20:	bb 1f       	adc	r27, r27
    cb22:	aa 0f       	add	r26, r26
    cb24:	bb 1f       	adc	r27, r27
    cb26:	a8 1b       	sub	r26, r24
    cb28:	b9 0b       	sbc	r27, r25
    cb2a:	a2 0f       	add	r26, r18
    cb2c:	b3 1f       	adc	r27, r19
    cb2e:	aa 0f       	add	r26, r26
    cb30:	bb 1f       	adc	r27, r27
    cb32:	fd 01       	movw	r30, r26
    cb34:	ef 5f       	subi	r30, 0xFF	; 255
    cb36:	fb 4e       	sbci	r31, 0xEB	; 235
    cb38:	01 90       	ld	r0, Z+
    cb3a:	f0 81       	ld	r31, Z
    cb3c:	e0 2d       	mov	r30, r0
    cb3e:	30 97       	sbiw	r30, 0x00	; 0
    cb40:	09 f4       	brne	.+2      	; 0xcb44 <Thread2+0x27e>
    cb42:	4f c0       	rjmp	.+158    	; 0xcbe2 <Thread2+0x31c>
				// has an action
				switch (menuactn[curMenu][curItem]) {
    cb44:	e7 30       	cpi	r30, 0x07	; 7
    cb46:	f1 05       	cpc	r31, r1
    cb48:	09 f4       	brne	.+2      	; 0xcb4c <Thread2+0x286>
    cb4a:	cc c0       	rjmp	.+408    	; 0xcce4 <Thread2+0x41e>
    cb4c:	e8 30       	cpi	r30, 0x08	; 8
    cb4e:	f1 05       	cpc	r31, r1
    cb50:	0c f0       	brlt	.+2      	; 0xcb54 <Thread2+0x28e>
    cb52:	5c c0       	rjmp	.+184    	; 0xcc0c <Thread2+0x346>
    cb54:	e3 30       	cpi	r30, 0x03	; 3
    cb56:	f1 05       	cpc	r31, r1
    cb58:	09 f4       	brne	.+2      	; 0xcb5c <Thread2+0x296>
    cb5a:	cd c0       	rjmp	.+410    	; 0xccf6 <Thread2+0x430>
    cb5c:	e4 30       	cpi	r30, 0x04	; 4
    cb5e:	f1 05       	cpc	r31, r1
    cb60:	0c f0       	brlt	.+2      	; 0xcb64 <Thread2+0x29e>
    cb62:	88 c0       	rjmp	.+272    	; 0xcc74 <Thread2+0x3ae>
    cb64:	e1 30       	cpi	r30, 0x01	; 1
    cb66:	f1 05       	cpc	r31, r1
    cb68:	09 f4       	brne	.+2      	; 0xcb6c <Thread2+0x2a6>
    cb6a:	93 c0       	rjmp	.+294    	; 0xcc92 <Thread2+0x3cc>
    cb6c:	32 97       	sbiw	r30, 0x02	; 2
    cb6e:	39 f4       	brne	.+14     	; 0xcb7e <Thread2+0x2b8>
						chSysLock();
						chThdResumeI(&trp[5], (msg_t)0x55);
						chSysUnlock();
						break;
					case 2:	// action 1.2
						chEvtSignalI(tp[6], (eventmask_t)1); //signal thread 7, Stack usage
    cb70:	80 91 a2 07 	lds	r24, 0x07A2
    cb74:	90 91 a3 07 	lds	r25, 0x07A3
    cb78:	61 e0       	ldi	r22, 0x01	; 1
    cb7a:	0e 94 3a 08 	call	0x1074	; 0x1074 <chEvtSignalI>
			else {
				curMenu = menulink[curMenu][curItem];  // set to menu selected by cursor
				curItem = 0; // reset menu item to which cursor point
				pageScroll = 0; // reset menu page scroll
				cursorCount = 0; // reset menu location of page
				menuCount = pageScroll*pageSize; // reprint from first line of this page
    cb7e:	10 92 3a 07 	sts	0x073A, r1
    cb82:	10 92 39 07 	sts	0x0739, r1
			}//end if menuaction
			updateFlag = 1; // we have updated the menu.  Flag is used to delay user input
    cb86:	d0 93 36 07 	sts	0x0736, r29
    cb8a:	c0 93 35 07 	sts	0x0735, r28
    cb8e:	0f cf       	rjmp	.-482    	; 0xc9ae <Thread2+0xe8>
                if (menuitem[curMenu][curItem][0] == '\0') { 
				   curItem = 0; 
				   pageScroll = 0; 
				   cursorCount = 0;
				}
                if (cursorCount >= pageSize) {
    cb90:	80 91 37 07 	lds	r24, 0x0737
    cb94:	90 91 38 07 	lds	r25, 0x0738
    cb98:	07 97       	sbiw	r24, 0x07	; 7
    cb9a:	0c f4       	brge	.+2      	; 0xcb9e <Thread2+0x2d8>
    cb9c:	c6 c0       	rjmp	.+396    	; 0xcd2a <Thread2+0x464>
                    // we have scrolled past this page, go to next
                    // remember, we check if we have scrolled off the MENU under clicks.  This is off the PAGE.
                    pageScroll++;  // next "page"
    cb9e:	20 91 3b 07 	lds	r18, 0x073B
    cba2:	30 91 3c 07 	lds	r19, 0x073C
    cba6:	2f 5f       	subi	r18, 0xFF	; 255
    cba8:	3f 4f       	sbci	r19, 0xFF	; 255
    cbaa:	30 93 3c 07 	sts	0x073C, r19
    cbae:	20 93 3b 07 	sts	0x073B, r18
                    cursorCount=0; // reset cursor location
    cbb2:	10 92 38 07 	sts	0x0738, r1
    cbb6:	10 92 37 07 	sts	0x0737, r1
    cbba:	43 cf       	rjmp	.-378    	; 0xca42 <Thread2+0x17c>
                if (menuitem[curMenu][curItem][0] == '\0') { 
				   curItem = 0; 
				   pageScroll = 0; 
				   cursorCount = 0;
				}
                if (cursorCount >= pageSize) {
    cbbc:	47 30       	cpi	r20, 0x07	; 7
    cbbe:	51 05       	cpc	r21, r1
    cbc0:	0c f4       	brge	.+2      	; 0xcbc4 <Thread2+0x2fe>
    cbc2:	b8 c0       	rjmp	.+368    	; 0xcd34 <Thread2+0x46e>
                    // we have scrolled past this page, go to next
                    // remember, we check if we have scrolled off the MENU under clicks.  This is off the PAGE.
                    pageScroll++;  // next "page"
    cbc4:	20 91 3b 07 	lds	r18, 0x073B
    cbc8:	30 91 3c 07 	lds	r19, 0x073C
    cbcc:	2f 5f       	subi	r18, 0xFF	; 255
    cbce:	3f 4f       	sbci	r19, 0xFF	; 255
    cbd0:	30 93 3c 07 	sts	0x073C, r19
    cbd4:	20 93 3b 07 	sts	0x073B, r18
                    cursorCount=0; // reset cursor location
    cbd8:	10 92 38 07 	sts	0x0738, r1
    cbdc:	10 92 37 07 	sts	0x0737, r1
    cbe0:	81 cf       	rjmp	.-254    	; 0xcae4 <Thread2+0x21e>
					    break;
				}//switch	
				menuCount = 0;
			} //menuaction
			else {
				curMenu = menulink[curMenu][curItem];  // set to menu selected by cursor
    cbe2:	ae 51       	subi	r26, 0x1E	; 30
    cbe4:	b9 4e       	sbci	r27, 0xE9	; 233
    cbe6:	8d 91       	ld	r24, X+
    cbe8:	9c 91       	ld	r25, X
    cbea:	90 93 32 07 	sts	0x0732, r25
    cbee:	80 93 31 07 	sts	0x0731, r24
				curItem = 0; // reset menu item to which cursor point
    cbf2:	10 92 34 07 	sts	0x0734, r1
    cbf6:	10 92 33 07 	sts	0x0733, r1
				pageScroll = 0; // reset menu page scroll
    cbfa:	10 92 3c 07 	sts	0x073C, r1
    cbfe:	10 92 3b 07 	sts	0x073B, r1
				cursorCount = 0; // reset menu location of page
    cc02:	10 92 38 07 	sts	0x0738, r1
    cc06:	10 92 37 07 	sts	0x0737, r1
    cc0a:	b9 cf       	rjmp	.-142    	; 0xcb7e <Thread2+0x2b8>
		********************************************************************************/ 
		if (switchtype == 2) { //we are selecting 
			// handle user input
			if (menuactn[curMenu][curItem]) {
				// has an action
				switch (menuactn[curMenu][curItem]) {
    cc0c:	ea 30       	cpi	r30, 0x0A	; 10
    cc0e:	f1 05       	cpc	r31, r1
    cc10:	09 f4       	brne	.+2      	; 0xcc14 <Thread2+0x34e>
    cc12:	82 c0       	rjmp	.+260    	; 0xcd18 <Thread2+0x452>
    cc14:	eb 30       	cpi	r30, 0x0B	; 11
    cc16:	f1 05       	cpc	r31, r1
    cc18:	84 f4       	brge	.+32     	; 0xcc3a <Thread2+0x374>
    cc1a:	e8 30       	cpi	r30, 0x08	; 8
    cc1c:	f1 05       	cpc	r31, r1
    cc1e:	09 f4       	brne	.+2      	; 0xcc22 <Thread2+0x35c>
    cc20:	72 c0       	rjmp	.+228    	; 0xcd06 <Thread2+0x440>
    cc22:	39 97       	sbiw	r30, 0x09	; 9
    cc24:	09 f0       	breq	.+2      	; 0xcc28 <Thread2+0x362>
    cc26:	ab cf       	rjmp	.-170    	; 0xcb7e <Thread2+0x2b8>
    cc28:	f8 94       	cli
						chThdResumeI(&trp[2], (msg_t)0x02);
						chSysUnlock();
						break;
					case 9: //show real time clock
						chSysLock();
						chThdResumeI(&trp[9], (msg_t)0x01);
    cc2a:	84 ec       	ldi	r24, 0xC4	; 196
    cc2c:	97 e0       	ldi	r25, 0x07	; 7
    cc2e:	61 e0       	ldi	r22, 0x01	; 1
    cc30:	70 e0       	ldi	r23, 0x00	; 0
    cc32:	0e 94 c9 07 	call	0xf92	; 0xf92 <chThdResumeI>
    cc36:	78 94       	sei
    cc38:	a2 cf       	rjmp	.-188    	; 0xcb7e <Thread2+0x2b8>
		********************************************************************************/ 
		if (switchtype == 2) { //we are selecting 
			// handle user input
			if (menuactn[curMenu][curItem]) {
				// has an action
				switch (menuactn[curMenu][curItem]) {
    cc3a:	ec 30       	cpi	r30, 0x0C	; 12
    cc3c:	f1 05       	cpc	r31, r1
    cc3e:	09 f4       	brne	.+2      	; 0xcc42 <Thread2+0x37c>
    cc40:	49 c0       	rjmp	.+146    	; 0xccd4 <Thread2+0x40e>
    cc42:	ec 30       	cpi	r30, 0x0C	; 12
    cc44:	f1 05       	cpc	r31, r1
    cc46:	0c f4       	brge	.+2      	; 0xcc4a <Thread2+0x384>
    cc48:	3d c0       	rjmp	.+122    	; 0xccc4 <Thread2+0x3fe>
    cc4a:	e7 5e       	subi	r30, 0xE7	; 231
    cc4c:	f3 40       	sbci	r31, 0x03	; 3
    cc4e:	09 f0       	breq	.+2      	; 0xcc52 <Thread2+0x38c>
    cc50:	96 cf       	rjmp	.-212    	; 0xcb7e <Thread2+0x2b8>
						break;
					case 12: //set the Time
						chEvtSignalI(tp[13], (eventmask_t)1); //signal thread 14, Thread status
						break;	
					case 999:
						curMenu = 0; // return to main menu
    cc52:	10 92 32 07 	sts	0x0732, r1
    cc56:	10 92 31 07 	sts	0x0731, r1
						curItem = 0; // reset menu item to which cursor point
    cc5a:	10 92 34 07 	sts	0x0734, r1
    cc5e:	10 92 33 07 	sts	0x0733, r1
						pageScroll = 0; // reset menu page scroll
    cc62:	10 92 3c 07 	sts	0x073C, r1
    cc66:	10 92 3b 07 	sts	0x073B, r1
						cursorCount = 0; // reset menu location of page
    cc6a:	10 92 38 07 	sts	0x0738, r1
    cc6e:	10 92 37 07 	sts	0x0737, r1
    cc72:	85 cf       	rjmp	.-246    	; 0xcb7e <Thread2+0x2b8>
		********************************************************************************/ 
		if (switchtype == 2) { //we are selecting 
			// handle user input
			if (menuactn[curMenu][curItem]) {
				// has an action
				switch (menuactn[curMenu][curItem]) {
    cc74:	e5 30       	cpi	r30, 0x05	; 5
    cc76:	f1 05       	cpc	r31, r1
    cc78:	e9 f0       	breq	.+58     	; 0xccb4 <Thread2+0x3ee>
    cc7a:	36 97       	sbiw	r30, 0x06	; 6
    cc7c:	9c f0       	brlt	.+38     	; 0xcca4 <Thread2+0x3de>
						break;             
					case 5: // action 2.2 - Example 2
						chEvtSignalI(tp[4], (eventmask_t)1);  // blank screen
						break;
                    case 6: // action 2.3 - Example 2
						if (thread_internal_started[8] ==0)
    cc7e:	80 91 2f 07 	lds	r24, 0x072F
						{						
							chEvtSignalI(tp[8], (eventmask_t)1);
							break;
						}
						else{
						chEvtSignalI(tp[8], (eventmask_t)1);  // Turn on LCD counter
    cc82:	80 91 a6 07 	lds	r24, 0x07A6
    cc86:	90 91 a7 07 	lds	r25, 0x07A7
    cc8a:	61 e0       	ldi	r22, 0x01	; 1
    cc8c:	0e 94 3a 08 	call	0x1074	; 0x1074 <chEvtSignalI>
    cc90:	76 cf       	rjmp	.-276    	; 0xcb7e <Thread2+0x2b8>
    cc92:	f8 94       	cli
				// has an action
				switch (menuactn[curMenu][curItem]) {
					case 1:	// action 1.1
						//chEvtSignalI(tp[5], (eventmask_t)1); //signal thread 6, Test thread
						chSysLock();
						chThdResumeI(&trp[5], (msg_t)0x55);
    cc94:	8c eb       	ldi	r24, 0xBC	; 188
    cc96:	97 e0       	ldi	r25, 0x07	; 7
    cc98:	65 e5       	ldi	r22, 0x55	; 85
    cc9a:	70 e0       	ldi	r23, 0x00	; 0
    cc9c:	0e 94 c9 07 	call	0xf92	; 0xf92 <chThdResumeI>
    cca0:	78 94       	sei
    cca2:	6d cf       	rjmp	.-294    	; 0xcb7e <Thread2+0x2b8>
						chEvtSignalI(tp[7], (eventmask_t)1); //signal thread 8, Thread status
						break;	
					case 4: // action 2.1 - Example 1
						/*signals first thread, which is sitting there waiting */
						/*with chEvtWaitAnyTimeout. Can also send flags */
						chEvtSignalI(tp[3], (eventmask_t)1);  // blank screen
    cca4:	80 91 9c 07 	lds	r24, 0x079C
    cca8:	90 91 9d 07 	lds	r25, 0x079D
    ccac:	61 e0       	ldi	r22, 0x01	; 1
    ccae:	0e 94 3a 08 	call	0x1074	; 0x1074 <chEvtSignalI>
    ccb2:	65 cf       	rjmp	.-310    	; 0xcb7e <Thread2+0x2b8>
						break;             
					case 5: // action 2.2 - Example 2
						chEvtSignalI(tp[4], (eventmask_t)1);  // blank screen
    ccb4:	80 91 9e 07 	lds	r24, 0x079E
    ccb8:	90 91 9f 07 	lds	r25, 0x079F
    ccbc:	61 e0       	ldi	r22, 0x01	; 1
    ccbe:	0e 94 3a 08 	call	0x1074	; 0x1074 <chEvtSignalI>
    ccc2:	5d cf       	rjmp	.-326    	; 0xcb7e <Thread2+0x2b8>
						chSysLock();
						chThdResumeI(&trp[10], (msg_t)0x01);
						chSysUnlock();
						break;
					case 11: //show heartbeat
						chEvtSignalI(tp[11], (eventmask_t)1); //signal thread 12, Thread status
    ccc4:	80 91 ac 07 	lds	r24, 0x07AC
    ccc8:	90 91 ad 07 	lds	r25, 0x07AD
    cccc:	61 e0       	ldi	r22, 0x01	; 1
    ccce:	0e 94 3a 08 	call	0x1074	; 0x1074 <chEvtSignalI>
    ccd2:	55 cf       	rjmp	.-342    	; 0xcb7e <Thread2+0x2b8>
						break;
					case 12: //set the Time
						chEvtSignalI(tp[13], (eventmask_t)1); //signal thread 14, Thread status
    ccd4:	80 91 b0 07 	lds	r24, 0x07B0
    ccd8:	90 91 b1 07 	lds	r25, 0x07B1
    ccdc:	61 e0       	ldi	r22, 0x01	; 1
    ccde:	0e 94 3a 08 	call	0x1074	; 0x1074 <chEvtSignalI>
    cce2:	4d cf       	rjmp	.-358    	; 0xcb7e <Thread2+0x2b8>
    cce4:	f8 94       	cli
						break;
						}
						break;
					case 7: //Show picture 1
						chSysLock();
						chThdResumeI(&trp[2], (msg_t)0x01);
    cce6:	86 eb       	ldi	r24, 0xB6	; 182
    cce8:	97 e0       	ldi	r25, 0x07	; 7
    ccea:	61 e0       	ldi	r22, 0x01	; 1
    ccec:	70 e0       	ldi	r23, 0x00	; 0
    ccee:	0e 94 c9 07 	call	0xf92	; 0xf92 <chThdResumeI>
    ccf2:	78 94       	sei
    ccf4:	44 cf       	rjmp	.-376    	; 0xcb7e <Thread2+0x2b8>
						break;
					case 2:	// action 1.2
						chEvtSignalI(tp[6], (eventmask_t)1); //signal thread 7, Stack usage
						break;
					case 3:	// action 1.2
						chEvtSignalI(tp[7], (eventmask_t)1); //signal thread 8, Thread status
    ccf6:	80 91 a4 07 	lds	r24, 0x07A4
    ccfa:	90 91 a5 07 	lds	r25, 0x07A5
    ccfe:	61 e0       	ldi	r22, 0x01	; 1
    cd00:	0e 94 3a 08 	call	0x1074	; 0x1074 <chEvtSignalI>
    cd04:	3c cf       	rjmp	.-392    	; 0xcb7e <Thread2+0x2b8>
    cd06:	f8 94       	cli
						chThdResumeI(&trp[2], (msg_t)0x01);
						chSysUnlock();
						break;
					case 8: //show picture 2
						chSysLock();
						chThdResumeI(&trp[2], (msg_t)0x02);
    cd08:	86 eb       	ldi	r24, 0xB6	; 182
    cd0a:	97 e0       	ldi	r25, 0x07	; 7
    cd0c:	62 e0       	ldi	r22, 0x02	; 2
    cd0e:	70 e0       	ldi	r23, 0x00	; 0
    cd10:	0e 94 c9 07 	call	0xf92	; 0xf92 <chThdResumeI>
    cd14:	78 94       	sei
    cd16:	33 cf       	rjmp	.-410    	; 0xcb7e <Thread2+0x2b8>
    cd18:	f8 94       	cli
						chThdResumeI(&trp[9], (msg_t)0x01);
						chSysUnlock();
						break;
					case 10: //show sensors
						chSysLock();
						chThdResumeI(&trp[10], (msg_t)0x01);
    cd1a:	86 ec       	ldi	r24, 0xC6	; 198
    cd1c:	97 e0       	ldi	r25, 0x07	; 7
    cd1e:	61 e0       	ldi	r22, 0x01	; 1
    cd20:	70 e0       	ldi	r23, 0x00	; 0
    cd22:	0e 94 c9 07 	call	0xf92	; 0xf92 <chThdResumeI>
    cd26:	78 94       	sei
    cd28:	2a cf       	rjmp	.-428    	; 0xcb7e <Thread2+0x2b8>
    cd2a:	20 91 3b 07 	lds	r18, 0x073B
    cd2e:	30 91 3c 07 	lds	r19, 0x073C
    cd32:	87 ce       	rjmp	.-754    	; 0xca42 <Thread2+0x17c>
    cd34:	20 91 3b 07 	lds	r18, 0x073B
    cd38:	30 91 3c 07 	lds	r19, 0x073C
    cd3c:	d3 ce       	rjmp	.-602    	; 0xcae4 <Thread2+0x21e>

0000cd3e <read32>:
read 32 bits from a bmp file
// These read 16- and 32-bit types from the SD card file.
// BMP data is stored little-endian, Arduino is little-endian too.
// May need to reverse subscript order if porting elsewhere.
********************************************************************************/ 
uint32_t read32(FIL* f) {
    cd3e:	af 92       	push	r10
    cd40:	bf 92       	push	r11
    cd42:	cf 92       	push	r12
    cd44:	df 92       	push	r13
    cd46:	ef 92       	push	r14
    cd48:	ff 92       	push	r15
    cd4a:	0f 93       	push	r16
    cd4c:	1f 93       	push	r17
    cd4e:	df 93       	push	r29
    cd50:	cf 93       	push	r28
    cd52:	cd b7       	in	r28, 0x3d	; 61
    cd54:	de b7       	in	r29, 0x3e	; 62
    cd56:	27 97       	sbiw	r28, 0x07	; 7
    cd58:	0f b6       	in	r0, 0x3f	; 63
    cd5a:	f8 94       	cli
    cd5c:	de bf       	out	0x3e, r29	; 62
    cd5e:	0f be       	out	0x3f, r0	; 63
    cd60:	cd bf       	out	0x3d, r28	; 61
    cd62:	7c 01       	movw	r14, r24
  uint32_t result;
  uint8_t buffer;
  uint16_t br;
 
	f_read(f, &buffer, sizeof(buffer), &br);
    cd64:	92 e0       	ldi	r25, 0x02	; 2
    cd66:	c9 2e       	mov	r12, r25
    cd68:	d1 2c       	mov	r13, r1
    cd6a:	cc 0e       	add	r12, r28
    cd6c:	dd 1e       	adc	r13, r29
    cd6e:	c7 01       	movw	r24, r14
    cd70:	8e 01       	movw	r16, r28
    cd72:	0f 5f       	subi	r16, 0xFF	; 255
    cd74:	1f 4f       	sbci	r17, 0xFF	; 255
    cd76:	b8 01       	movw	r22, r16
    cd78:	41 e0       	ldi	r20, 0x01	; 1
    cd7a:	50 e0       	ldi	r21, 0x00	; 0
    cd7c:	96 01       	movw	r18, r12
    cd7e:	0e 94 ab 35 	call	0x6b56	; 0x6b56 <f_read>
    ((uint8_t *)&result)[0] = buffer; // LSB
    cd82:	84 e0       	ldi	r24, 0x04	; 4
    cd84:	a8 2e       	mov	r10, r24
    cd86:	b1 2c       	mov	r11, r1
    cd88:	ac 0e       	add	r10, r28
    cd8a:	bd 1e       	adc	r11, r29
    cd8c:	89 81       	ldd	r24, Y+1	; 0x01
    cd8e:	8c 83       	std	Y+4, r24	; 0x04

	f_read(f, &buffer, sizeof(buffer), &br);
    cd90:	c7 01       	movw	r24, r14
    cd92:	b8 01       	movw	r22, r16
    cd94:	41 e0       	ldi	r20, 0x01	; 1
    cd96:	50 e0       	ldi	r21, 0x00	; 0
    cd98:	96 01       	movw	r18, r12
    cd9a:	0e 94 ab 35 	call	0x6b56	; 0x6b56 <f_read>
    ((uint8_t *)&result)[1] = buffer;
    cd9e:	89 81       	ldd	r24, Y+1	; 0x01
    cda0:	f5 01       	movw	r30, r10
    cda2:	81 83       	std	Z+1, r24	; 0x01

	f_read(f, &buffer, sizeof(buffer), &br);
    cda4:	c7 01       	movw	r24, r14
    cda6:	b8 01       	movw	r22, r16
    cda8:	41 e0       	ldi	r20, 0x01	; 1
    cdaa:	50 e0       	ldi	r21, 0x00	; 0
    cdac:	96 01       	movw	r18, r12
    cdae:	0e 94 ab 35 	call	0x6b56	; 0x6b56 <f_read>
    ((uint8_t *)&result)[2] = buffer;
    cdb2:	89 81       	ldd	r24, Y+1	; 0x01
    cdb4:	f5 01       	movw	r30, r10
    cdb6:	82 83       	std	Z+2, r24	; 0x02

	f_read(f, &buffer, sizeof(buffer), &br);
    cdb8:	c7 01       	movw	r24, r14
    cdba:	b8 01       	movw	r22, r16
    cdbc:	41 e0       	ldi	r20, 0x01	; 1
    cdbe:	50 e0       	ldi	r21, 0x00	; 0
    cdc0:	96 01       	movw	r18, r12
    cdc2:	0e 94 ab 35 	call	0x6b56	; 0x6b56 <f_read>
    ((uint8_t *)&result)[3] = buffer; // MSB
    cdc6:	6c 81       	ldd	r22, Y+4	; 0x04
    cdc8:	7d 81       	ldd	r23, Y+5	; 0x05
  return result;
}
    cdca:	8e 81       	ldd	r24, Y+6	; 0x06
    cdcc:	99 81       	ldd	r25, Y+1	; 0x01
    cdce:	27 96       	adiw	r28, 0x07	; 7
    cdd0:	0f b6       	in	r0, 0x3f	; 63
    cdd2:	f8 94       	cli
    cdd4:	de bf       	out	0x3e, r29	; 62
    cdd6:	0f be       	out	0x3f, r0	; 63
    cdd8:	cd bf       	out	0x3d, r28	; 61
    cdda:	cf 91       	pop	r28
    cddc:	df 91       	pop	r29
    cdde:	1f 91       	pop	r17
    cde0:	0f 91       	pop	r16
    cde2:	ff 90       	pop	r15
    cde4:	ef 90       	pop	r14
    cde6:	df 90       	pop	r13
    cde8:	cf 90       	pop	r12
    cdea:	bf 90       	pop	r11
    cdec:	af 90       	pop	r10
    cdee:	08 95       	ret

0000cdf0 <read16>:
read 16 bits from a .bmp file - little endian
// These read 16- and 32-bit types from the SD card file.
// BMP data is stored little-endian, Arduino is little-endian too.
// May need to reverse subscript order if porting elsewhere.
********************************************************************************/ 
uint16_t read16(FIL* f) {
    cdf0:	cf 92       	push	r12
    cdf2:	df 92       	push	r13
    cdf4:	ef 92       	push	r14
    cdf6:	ff 92       	push	r15
    cdf8:	0f 93       	push	r16
    cdfa:	1f 93       	push	r17
    cdfc:	df 93       	push	r29
    cdfe:	cf 93       	push	r28
    ce00:	00 d0       	rcall	.+0      	; 0xce02 <read16+0x12>
    ce02:	00 d0       	rcall	.+0      	; 0xce04 <read16+0x14>
    ce04:	0f 92       	push	r0
    ce06:	cd b7       	in	r28, 0x3d	; 61
    ce08:	de b7       	in	r29, 0x3e	; 62
    ce0a:	7c 01       	movw	r14, r24
  uint16_t result;
  uint8_t buffer;
  uint16_t br;
  
  f_read(f, &buffer, sizeof(buffer), &br);
    ce0c:	24 e0       	ldi	r18, 0x04	; 4
    ce0e:	c2 2e       	mov	r12, r18
    ce10:	d1 2c       	mov	r13, r1
    ce12:	cc 0e       	add	r12, r28
    ce14:	dd 1e       	adc	r13, r29
    ce16:	8e 01       	movw	r16, r28
    ce18:	0f 5f       	subi	r16, 0xFF	; 255
    ce1a:	1f 4f       	sbci	r17, 0xFF	; 255
    ce1c:	b8 01       	movw	r22, r16
    ce1e:	41 e0       	ldi	r20, 0x01	; 1
    ce20:	50 e0       	ldi	r21, 0x00	; 0
    ce22:	96 01       	movw	r18, r12
    ce24:	0e 94 ab 35 	call	0x6b56	; 0x6b56 <f_read>
  ((uint8_t *)&result)[0] = buffer; // LSB
    ce28:	89 81       	ldd	r24, Y+1	; 0x01
    ce2a:	8a 83       	std	Y+2, r24	; 0x02
  
  f_read(f, &buffer, sizeof(buffer), &br);
    ce2c:	c7 01       	movw	r24, r14
    ce2e:	b8 01       	movw	r22, r16
    ce30:	41 e0       	ldi	r20, 0x01	; 1
    ce32:	50 e0       	ldi	r21, 0x00	; 0
    ce34:	96 01       	movw	r18, r12
    ce36:	0e 94 ab 35 	call	0x6b56	; 0x6b56 <f_read>
  ((uint8_t *)&result)[1] = buffer; // MSB
  return result;
}
    ce3a:	8a 81       	ldd	r24, Y+2	; 0x02
    ce3c:	99 81       	ldd	r25, Y+1	; 0x01
    ce3e:	0f 90       	pop	r0
    ce40:	0f 90       	pop	r0
    ce42:	0f 90       	pop	r0
    ce44:	0f 90       	pop	r0
    ce46:	0f 90       	pop	r0
    ce48:	cf 91       	pop	r28
    ce4a:	df 91       	pop	r29
    ce4c:	1f 91       	pop	r17
    ce4e:	0f 91       	pop	r16
    ce50:	ff 90       	pop	r15
    ce52:	ef 90       	pop	r14
    ce54:	df 90       	pop	r13
    ce56:	cf 90       	pop	r12
    ce58:	08 95       	ret

0000ce5a <bmpDraw>:
}

/*********************************************************************************
Put a bmp on on the screen
********************************************************************************/ 
void bmpDraw(char *filename, uint8_t x, uint8_t y) {
    ce5a:	2f 92       	push	r2
    ce5c:	3f 92       	push	r3
    ce5e:	4f 92       	push	r4
    ce60:	5f 92       	push	r5
    ce62:	6f 92       	push	r6
    ce64:	7f 92       	push	r7
    ce66:	8f 92       	push	r8
    ce68:	9f 92       	push	r9
    ce6a:	af 92       	push	r10
    ce6c:	bf 92       	push	r11
    ce6e:	cf 92       	push	r12
    ce70:	df 92       	push	r13
    ce72:	ef 92       	push	r14
    ce74:	ff 92       	push	r15
    ce76:	0f 93       	push	r16
    ce78:	1f 93       	push	r17
    ce7a:	df 93       	push	r29
    ce7c:	cf 93       	push	r28
    ce7e:	cd b7       	in	r28, 0x3d	; 61
    ce80:	de b7       	in	r29, 0x3e	; 62
    ce82:	c0 5b       	subi	r28, 0xB0	; 176
    ce84:	d0 40       	sbci	r29, 0x00	; 0
    ce86:	0f b6       	in	r0, 0x3f	; 63
    ce88:	f8 94       	cli
    ce8a:	de bf       	out	0x3e, r29	; 62
    ce8c:	0f be       	out	0x3f, r0	; 63
    ce8e:	cd bf       	out	0x3d, r28	; 61
    ce90:	8c 01       	movw	r16, r24
    ce92:	e6 2e       	mov	r14, r22
    ce94:	c4 2e       	mov	r12, r20
	uint8_t  r, g, b;
	uint32_t pos = 0;
	uint16_t br;
	const uint8_t SIZE_OF_SDBUFFER = sizeof(sdbuffer);

	if((x >= st7735_width) || (y >= st7735_height)) {
    ce96:	80 91 17 07 	lds	r24, 0x0717
    ce9a:	68 17       	cp	r22, r24
    ce9c:	20 f4       	brcc	.+8      	; 0xcea6 <bmpDraw+0x4c>
    ce9e:	80 91 18 07 	lds	r24, 0x0718
    cea2:	48 17       	cp	r20, r24
    cea4:	f0 f0       	brcs	.+60     	; 0xcee2 <bmpDraw+0x88>
		xputs(PSTR("bad position \r\n"));
    cea6:	8b e0       	ldi	r24, 0x0B	; 11
    cea8:	9c e0       	ldi	r25, 0x0C	; 12
    ceaa:	0e 94 7b 1b 	call	0x36f6	; 0x36f6 <xputs>
	
	chSemWait(&spiUSE);
	f_close(&bmpFile);
	chSemSignal(&spiUSE);

} // end bmpDraw
    ceae:	c0 55       	subi	r28, 0x50	; 80
    ceb0:	df 4f       	sbci	r29, 0xFF	; 255
    ceb2:	0f b6       	in	r0, 0x3f	; 63
    ceb4:	f8 94       	cli
    ceb6:	de bf       	out	0x3e, r29	; 62
    ceb8:	0f be       	out	0x3f, r0	; 63
    ceba:	cd bf       	out	0x3d, r28	; 61
    cebc:	cf 91       	pop	r28
    cebe:	df 91       	pop	r29
    cec0:	1f 91       	pop	r17
    cec2:	0f 91       	pop	r16
    cec4:	ff 90       	pop	r15
    cec6:	ef 90       	pop	r14
    cec8:	df 90       	pop	r13
    ceca:	cf 90       	pop	r12
    cecc:	bf 90       	pop	r11
    cece:	af 90       	pop	r10
    ced0:	9f 90       	pop	r9
    ced2:	8f 90       	pop	r8
    ced4:	7f 90       	pop	r7
    ced6:	6f 90       	pop	r6
    ced8:	5f 90       	pop	r5
    ceda:	4f 90       	pop	r4
    cedc:	3f 90       	pop	r3
    cede:	2f 90       	pop	r2
    cee0:	08 95       	ret

	if((x >= st7735_width) || (y >= st7735_height)) {
		xputs(PSTR("bad position \r\n"));
		return;
	}
	xputs(PSTR("Loading image \r\n"));
    cee2:	8a ef       	ldi	r24, 0xFA	; 250
    cee4:	9b e0       	ldi	r25, 0x0B	; 11
    cee6:	0e 94 7b 1b 	call	0x36f6	; 0x36f6 <xputs>
	// Open requested file on SD card
	chSemWait(&spiUSE);
    ceea:	89 e7       	ldi	r24, 0x79	; 121
    ceec:	94 e1       	ldi	r25, 0x14	; 20
    ceee:	40 e0       	ldi	r20, 0x00	; 0
    cef0:	50 e0       	ldi	r21, 0x00	; 0
    cef2:	60 e0       	ldi	r22, 0x00	; 0
    cef4:	70 e0       	ldi	r23, 0x00	; 0
    cef6:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
	if (f_open(&bmpFile, filename, FA_READ) != 0) {
    cefa:	ce 01       	movw	r24, r28
    cefc:	03 96       	adiw	r24, 0x03	; 3
    cefe:	b8 01       	movw	r22, r16
    cf00:	41 e0       	ldi	r20, 0x01	; 1
    cf02:	0e 94 0c 3c 	call	0x7818	; 0x7818 <f_open>
    cf06:	88 23       	and	r24, r24
    cf08:	e1 f4       	brne	.+56     	; 0xcf42 <bmpDraw+0xe8>
		xputs(PSTR("File open error \r\n"));
		chSemSignal(&spiUSE);
		return;
	}
	chSemSignal(&spiUSE);
    cf0a:	89 e7       	ldi	r24, 0x79	; 121
    cf0c:	94 e1       	ldi	r25, 0x14	; 20
    cf0e:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
	// Parse BMP header
	
	chSemWait(&spiUSE);
    cf12:	89 e7       	ldi	r24, 0x79	; 121
    cf14:	94 e1       	ldi	r25, 0x14	; 20
    cf16:	40 e0       	ldi	r20, 0x00	; 0
    cf18:	50 e0       	ldi	r21, 0x00	; 0
    cf1a:	60 e0       	ldi	r22, 0x00	; 0
    cf1c:	70 e0       	ldi	r23, 0x00	; 0
    cf1e:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
	if (read16(&bmpFile) != 0x4D42) {							// BMP signature
    cf22:	ce 01       	movw	r24, r28
    cf24:	03 96       	adiw	r24, 0x03	; 3
    cf26:	0e 94 f8 66 	call	0xcdf0	; 0xcdf0 <read16>
    cf2a:	82 54       	subi	r24, 0x42	; 66
    cf2c:	9d 44       	sbci	r25, 0x4D	; 77
    cf2e:	91 f0       	breq	.+36     	; 0xcf54 <bmpDraw+0xfa>
		xputs(PSTR("invalid bmp \r\n"));
    cf30:	88 ed       	ldi	r24, 0xD8	; 216
    cf32:	9b e0       	ldi	r25, 0x0B	; 11
    cf34:	0e 94 7b 1b 	call	0x36f6	; 0x36f6 <xputs>
		chSemSignal(&spiUSE);
    cf38:	89 e7       	ldi	r24, 0x79	; 121
    cf3a:	94 e1       	ldi	r25, 0x14	; 20
    cf3c:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
    cf40:	b6 cf       	rjmp	.-148    	; 0xceae <bmpDraw+0x54>
	}
	xputs(PSTR("Loading image \r\n"));
	// Open requested file on SD card
	chSemWait(&spiUSE);
	if (f_open(&bmpFile, filename, FA_READ) != 0) {
		xputs(PSTR("File open error \r\n"));
    cf42:	87 ee       	ldi	r24, 0xE7	; 231
    cf44:	9b e0       	ldi	r25, 0x0B	; 11
    cf46:	0e 94 7b 1b 	call	0x36f6	; 0x36f6 <xputs>
		chSemSignal(&spiUSE);
    cf4a:	89 e7       	ldi	r24, 0x79	; 121
    cf4c:	94 e1       	ldi	r25, 0x14	; 20
    cf4e:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
    cf52:	ad cf       	rjmp	.-166    	; 0xceae <bmpDraw+0x54>
	if (read16(&bmpFile) != 0x4D42) {							// BMP signature
		xputs(PSTR("invalid bmp \r\n"));
		chSemSignal(&spiUSE);
		return;
	}
    chSemSignal(&spiUSE);
    cf54:	89 e7       	ldi	r24, 0x79	; 121
    cf56:	94 e1       	ldi	r25, 0x14	; 20
    cf58:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
	
	chSemWait(&spiUSE);
    cf5c:	89 e7       	ldi	r24, 0x79	; 121
    cf5e:	94 e1       	ldi	r25, 0x14	; 20
    cf60:	40 e0       	ldi	r20, 0x00	; 0
    cf62:	50 e0       	ldi	r21, 0x00	; 0
    cf64:	60 e0       	ldi	r22, 0x00	; 0
    cf66:	70 e0       	ldi	r23, 0x00	; 0
    cf68:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
	xprintf(PSTR("File size: %ld \r\n"), read32(&bmpFile));	// File size
    cf6c:	ce 01       	movw	r24, r28
    cf6e:	03 96       	adiw	r24, 0x03	; 3
    cf70:	0e 94 9f 66 	call	0xcd3e	; 0xcd3e <read32>
    cf74:	00 d0       	rcall	.+0      	; 0xcf76 <bmpDraw+0x11c>
    cf76:	00 d0       	rcall	.+0      	; 0xcf78 <bmpDraw+0x11e>
    cf78:	00 d0       	rcall	.+0      	; 0xcf7a <bmpDraw+0x120>
    cf7a:	26 ec       	ldi	r18, 0xC6	; 198
    cf7c:	3b e0       	ldi	r19, 0x0B	; 11
    cf7e:	ad b7       	in	r26, 0x3d	; 61
    cf80:	be b7       	in	r27, 0x3e	; 62
    cf82:	12 96       	adiw	r26, 0x02	; 2
    cf84:	3c 93       	st	X, r19
    cf86:	2e 93       	st	-X, r18
    cf88:	11 97       	sbiw	r26, 0x01	; 1
    cf8a:	ed b7       	in	r30, 0x3d	; 61
    cf8c:	fe b7       	in	r31, 0x3e	; 62
    cf8e:	63 83       	std	Z+3, r22	; 0x03
    cf90:	74 83       	std	Z+4, r23	; 0x04
    cf92:	85 83       	std	Z+5, r24	; 0x05
    cf94:	96 83       	std	Z+6, r25	; 0x06
    cf96:	0e 94 1e 20 	call	0x403c	; 0x403c <xprintf>
	chSemSignal(&spiUSE);
    cf9a:	2d b7       	in	r18, 0x3d	; 61
    cf9c:	3e b7       	in	r19, 0x3e	; 62
    cf9e:	2a 5f       	subi	r18, 0xFA	; 250
    cfa0:	3f 4f       	sbci	r19, 0xFF	; 255
    cfa2:	0f b6       	in	r0, 0x3f	; 63
    cfa4:	f8 94       	cli
    cfa6:	3e bf       	out	0x3e, r19	; 62
    cfa8:	0f be       	out	0x3f, r0	; 63
    cfaa:	2d bf       	out	0x3d, r18	; 61
    cfac:	89 e7       	ldi	r24, 0x79	; 121
    cfae:	94 e1       	ldi	r25, 0x14	; 20
    cfb0:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
	
	chSemWait(&spiUSE);
    cfb4:	89 e7       	ldi	r24, 0x79	; 121
    cfb6:	94 e1       	ldi	r25, 0x14	; 20
    cfb8:	40 e0       	ldi	r20, 0x00	; 0
    cfba:	50 e0       	ldi	r21, 0x00	; 0
    cfbc:	60 e0       	ldi	r22, 0x00	; 0
    cfbe:	70 e0       	ldi	r23, 0x00	; 0
    cfc0:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
	(void)read32(&bmpFile); 									// Read & ignore creator bytes
    cfc4:	ce 01       	movw	r24, r28
    cfc6:	03 96       	adiw	r24, 0x03	; 3
    cfc8:	0e 94 9f 66 	call	0xcd3e	; 0xcd3e <read32>
	chSemSignal(&spiUSE);
    cfcc:	89 e7       	ldi	r24, 0x79	; 121
    cfce:	94 e1       	ldi	r25, 0x14	; 20
    cfd0:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
	
	chSemWait(&spiUSE);
    cfd4:	89 e7       	ldi	r24, 0x79	; 121
    cfd6:	94 e1       	ldi	r25, 0x14	; 20
    cfd8:	40 e0       	ldi	r20, 0x00	; 0
    cfda:	50 e0       	ldi	r21, 0x00	; 0
    cfdc:	60 e0       	ldi	r22, 0x00	; 0
    cfde:	70 e0       	ldi	r23, 0x00	; 0
    cfe0:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
	bmpImageoffset = read32(&bmpFile); 						// Start of image data
    cfe4:	ce 01       	movw	r24, r28
    cfe6:	03 96       	adiw	r24, 0x03	; 3
    cfe8:	0e 94 9f 66 	call	0xcd3e	; 0xcd3e <read32>
    cfec:	c7 55       	subi	r28, 0x57	; 87
    cfee:	df 4f       	sbci	r29, 0xFF	; 255
    cff0:	68 83       	st	Y, r22
    cff2:	79 83       	std	Y+1, r23	; 0x01
    cff4:	8a 83       	std	Y+2, r24	; 0x02
    cff6:	9b 83       	std	Y+3, r25	; 0x03
    cff8:	c9 5a       	subi	r28, 0xA9	; 169
    cffa:	d0 40       	sbci	r29, 0x00	; 0
	chSemSignal(&spiUSE);
    cffc:	89 e7       	ldi	r24, 0x79	; 121
    cffe:	94 e1       	ldi	r25, 0x14	; 20
    d000:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
	
	xprintf(PSTR("Image Offset: %ld \r\n"), bmpImageoffset);
    d004:	00 d0       	rcall	.+0      	; 0xd006 <bmpDraw+0x1ac>
    d006:	00 d0       	rcall	.+0      	; 0xd008 <bmpDraw+0x1ae>
    d008:	00 d0       	rcall	.+0      	; 0xd00a <bmpDraw+0x1b0>
    d00a:	81 eb       	ldi	r24, 0xB1	; 177
    d00c:	9b e0       	ldi	r25, 0x0B	; 11
    d00e:	ad b7       	in	r26, 0x3d	; 61
    d010:	be b7       	in	r27, 0x3e	; 62
    d012:	12 96       	adiw	r26, 0x02	; 2
    d014:	9c 93       	st	X, r25
    d016:	8e 93       	st	-X, r24
    d018:	11 97       	sbiw	r26, 0x01	; 1
    d01a:	c7 55       	subi	r28, 0x57	; 87
    d01c:	df 4f       	sbci	r29, 0xFF	; 255
    d01e:	28 81       	ld	r18, Y
    d020:	39 81       	ldd	r19, Y+1	; 0x01
    d022:	4a 81       	ldd	r20, Y+2	; 0x02
    d024:	5b 81       	ldd	r21, Y+3	; 0x03
    d026:	c9 5a       	subi	r28, 0xA9	; 169
    d028:	d0 40       	sbci	r29, 0x00	; 0
    d02a:	13 96       	adiw	r26, 0x03	; 3
    d02c:	2d 93       	st	X+, r18
    d02e:	3d 93       	st	X+, r19
    d030:	4d 93       	st	X+, r20
    d032:	5c 93       	st	X, r21
    d034:	16 97       	sbiw	r26, 0x06	; 6
    d036:	0e 94 1e 20 	call	0x403c	; 0x403c <xprintf>

	chSemWait(&spiUSE);
    d03a:	ed b7       	in	r30, 0x3d	; 61
    d03c:	fe b7       	in	r31, 0x3e	; 62
    d03e:	36 96       	adiw	r30, 0x06	; 6
    d040:	0f b6       	in	r0, 0x3f	; 63
    d042:	f8 94       	cli
    d044:	fe bf       	out	0x3e, r31	; 62
    d046:	0f be       	out	0x3f, r0	; 63
    d048:	ed bf       	out	0x3d, r30	; 61
    d04a:	89 e7       	ldi	r24, 0x79	; 121
    d04c:	94 e1       	ldi	r25, 0x14	; 20
    d04e:	40 e0       	ldi	r20, 0x00	; 0
    d050:	50 e0       	ldi	r21, 0x00	; 0
    d052:	60 e0       	ldi	r22, 0x00	; 0
    d054:	70 e0       	ldi	r23, 0x00	; 0
    d056:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
	xprintf(PSTR("Header size: %ld \r\n"),read32(&bmpFile));	// Read DIB header
    d05a:	ce 01       	movw	r24, r28
    d05c:	03 96       	adiw	r24, 0x03	; 3
    d05e:	0e 94 9f 66 	call	0xcd3e	; 0xcd3e <read32>
    d062:	00 d0       	rcall	.+0      	; 0xd064 <bmpDraw+0x20a>
    d064:	00 d0       	rcall	.+0      	; 0xd066 <bmpDraw+0x20c>
    d066:	00 d0       	rcall	.+0      	; 0xd068 <bmpDraw+0x20e>
    d068:	2d e9       	ldi	r18, 0x9D	; 157
    d06a:	3b e0       	ldi	r19, 0x0B	; 11
    d06c:	ad b7       	in	r26, 0x3d	; 61
    d06e:	be b7       	in	r27, 0x3e	; 62
    d070:	12 96       	adiw	r26, 0x02	; 2
    d072:	3c 93       	st	X, r19
    d074:	2e 93       	st	-X, r18
    d076:	11 97       	sbiw	r26, 0x01	; 1
    d078:	ed b7       	in	r30, 0x3d	; 61
    d07a:	fe b7       	in	r31, 0x3e	; 62
    d07c:	63 83       	std	Z+3, r22	; 0x03
    d07e:	74 83       	std	Z+4, r23	; 0x04
    d080:	85 83       	std	Z+5, r24	; 0x05
    d082:	96 83       	std	Z+6, r25	; 0x06
    d084:	0e 94 1e 20 	call	0x403c	; 0x403c <xprintf>
	chSemSignal(&spiUSE);
    d088:	2d b7       	in	r18, 0x3d	; 61
    d08a:	3e b7       	in	r19, 0x3e	; 62
    d08c:	2a 5f       	subi	r18, 0xFA	; 250
    d08e:	3f 4f       	sbci	r19, 0xFF	; 255
    d090:	0f b6       	in	r0, 0x3f	; 63
    d092:	f8 94       	cli
    d094:	3e bf       	out	0x3e, r19	; 62
    d096:	0f be       	out	0x3f, r0	; 63
    d098:	2d bf       	out	0x3d, r18	; 61
    d09a:	89 e7       	ldi	r24, 0x79	; 121
    d09c:	94 e1       	ldi	r25, 0x14	; 20
    d09e:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
	
	chSemWait(&spiUSE);
    d0a2:	89 e7       	ldi	r24, 0x79	; 121
    d0a4:	94 e1       	ldi	r25, 0x14	; 20
    d0a6:	40 e0       	ldi	r20, 0x00	; 0
    d0a8:	50 e0       	ldi	r21, 0x00	; 0
    d0aa:	60 e0       	ldi	r22, 0x00	; 0
    d0ac:	70 e0       	ldi	r23, 0x00	; 0
    d0ae:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
	bmpWidth  = read32(&bmpFile);							// Width
    d0b2:	ce 01       	movw	r24, r28
    d0b4:	03 96       	adiw	r24, 0x03	; 3
    d0b6:	0e 94 9f 66 	call	0xcd3e	; 0xcd3e <read32>
    d0ba:	c3 55       	subi	r28, 0x53	; 83
    d0bc:	df 4f       	sbci	r29, 0xFF	; 255
    d0be:	68 83       	st	Y, r22
    d0c0:	79 83       	std	Y+1, r23	; 0x01
    d0c2:	8a 83       	std	Y+2, r24	; 0x02
    d0c4:	9b 83       	std	Y+3, r25	; 0x03
    d0c6:	cd 5a       	subi	r28, 0xAD	; 173
    d0c8:	d0 40       	sbci	r29, 0x00	; 0
	chSemSignal(&spiUSE);
    d0ca:	89 e7       	ldi	r24, 0x79	; 121
    d0cc:	94 e1       	ldi	r25, 0x14	; 20
    d0ce:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
	
	chSemWait(&spiUSE);
    d0d2:	89 e7       	ldi	r24, 0x79	; 121
    d0d4:	94 e1       	ldi	r25, 0x14	; 20
    d0d6:	40 e0       	ldi	r20, 0x00	; 0
    d0d8:	50 e0       	ldi	r21, 0x00	; 0
    d0da:	60 e0       	ldi	r22, 0x00	; 0
    d0dc:	70 e0       	ldi	r23, 0x00	; 0
    d0de:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
	bmpHeight = read32(&bmpFile);							// Height
    d0e2:	ce 01       	movw	r24, r28
    d0e4:	03 96       	adiw	r24, 0x03	; 3
    d0e6:	0e 94 9f 66 	call	0xcd3e	; 0xcd3e <read32>
    d0ea:	2b 01       	movw	r4, r22
    d0ec:	3c 01       	movw	r6, r24
	chSemSignal(&spiUSE);
    d0ee:	89 e7       	ldi	r24, 0x79	; 121
    d0f0:	94 e1       	ldi	r25, 0x14	; 20
    d0f2:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
	
	chSemWait(&spiUSE);
    d0f6:	89 e7       	ldi	r24, 0x79	; 121
    d0f8:	94 e1       	ldi	r25, 0x14	; 20
    d0fa:	40 e0       	ldi	r20, 0x00	; 0
    d0fc:	50 e0       	ldi	r21, 0x00	; 0
    d0fe:	60 e0       	ldi	r22, 0x00	; 0
    d100:	70 e0       	ldi	r23, 0x00	; 0
    d102:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
	if(read16(&bmpFile) != 1) {							// # planes -- must be '1'
    d106:	ce 01       	movw	r24, r28
    d108:	03 96       	adiw	r24, 0x03	; 3
    d10a:	0e 94 f8 66 	call	0xcdf0	; 0xcdf0 <read16>
    d10e:	01 97       	sbiw	r24, 0x01	; 1
    d110:	49 f0       	breq	.+18     	; 0xd124 <bmpDraw+0x2ca>
		xputs(PSTR("planes not 1 \r\n"));
    d112:	8d e8       	ldi	r24, 0x8D	; 141
    d114:	9b e0       	ldi	r25, 0x0B	; 11
    d116:	0e 94 7b 1b 	call	0x36f6	; 0x36f6 <xputs>
		chSemSignal(&spiUSE);
    d11a:	89 e7       	ldi	r24, 0x79	; 121
    d11c:	94 e1       	ldi	r25, 0x14	; 20
    d11e:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
    d122:	c5 ce       	rjmp	.-630    	; 0xceae <bmpDraw+0x54>
		return;
	}  
	chSemSignal(&spiUSE);
    d124:	89 e7       	ldi	r24, 0x79	; 121
    d126:	94 e1       	ldi	r25, 0x14	; 20
    d128:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
	
	chSemWait(&spiUSE);
    d12c:	89 e7       	ldi	r24, 0x79	; 121
    d12e:	94 e1       	ldi	r25, 0x14	; 20
    d130:	40 e0       	ldi	r20, 0x00	; 0
    d132:	50 e0       	ldi	r21, 0x00	; 0
    d134:	60 e0       	ldi	r22, 0x00	; 0
    d136:	70 e0       	ldi	r23, 0x00	; 0
    d138:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
	bmpDepth = read16(&bmpFile); 							// bits per pixel -- should be 24
    d13c:	ce 01       	movw	r24, r28
    d13e:	03 96       	adiw	r24, 0x03	; 3
    d140:	0e 94 f8 66 	call	0xcdf0	; 0xcdf0 <read16>
    d144:	18 2f       	mov	r17, r24
	chSemSignal(&spiUSE);
    d146:	89 e7       	ldi	r24, 0x79	; 121
    d148:	94 e1       	ldi	r25, 0x14	; 20
    d14a:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
	
	xprintf(PSTR("Bit Depth: %d \r\n"), bmpDepth);
    d14e:	00 d0       	rcall	.+0      	; 0xd150 <bmpDraw+0x2f6>
    d150:	00 d0       	rcall	.+0      	; 0xd152 <bmpDraw+0x2f8>
    d152:	ed b7       	in	r30, 0x3d	; 61
    d154:	fe b7       	in	r31, 0x3e	; 62
    d156:	31 96       	adiw	r30, 0x01	; 1
    d158:	8c e7       	ldi	r24, 0x7C	; 124
    d15a:	9b e0       	ldi	r25, 0x0B	; 11
    d15c:	ad b7       	in	r26, 0x3d	; 61
    d15e:	be b7       	in	r27, 0x3e	; 62
    d160:	12 96       	adiw	r26, 0x02	; 2
    d162:	9c 93       	st	X, r25
    d164:	8e 93       	st	-X, r24
    d166:	11 97       	sbiw	r26, 0x01	; 1
    d168:	12 83       	std	Z+2, r17	; 0x02
    d16a:	13 82       	std	Z+3, r1	; 0x03
    d16c:	0e 94 1e 20 	call	0x403c	; 0x403c <xprintf>
	
	chSemWait(&spiUSE);
    d170:	0f 90       	pop	r0
    d172:	0f 90       	pop	r0
    d174:	0f 90       	pop	r0
    d176:	0f 90       	pop	r0
    d178:	89 e7       	ldi	r24, 0x79	; 121
    d17a:	94 e1       	ldi	r25, 0x14	; 20
    d17c:	40 e0       	ldi	r20, 0x00	; 0
    d17e:	50 e0       	ldi	r21, 0x00	; 0
    d180:	60 e0       	ldi	r22, 0x00	; 0
    d182:	70 e0       	ldi	r23, 0x00	; 0
    d184:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
	if((bmpDepth != 24) && (read32(&bmpFile) != 0)) { 	// 0 = uncompressed
    d188:	18 31       	cpi	r17, 0x18	; 24
    d18a:	51 f0       	breq	.+20     	; 0xd1a0 <bmpDraw+0x346>
    d18c:	ce 01       	movw	r24, r28
    d18e:	03 96       	adiw	r24, 0x03	; 3
    d190:	0e 94 9f 66 	call	0xcd3e	; 0xcd3e <read32>
    d194:	61 15       	cp	r22, r1
    d196:	71 05       	cpc	r23, r1
    d198:	81 05       	cpc	r24, r1
    d19a:	91 05       	cpc	r25, r1
    d19c:	09 f0       	breq	.+2      	; 0xd1a0 <bmpDraw+0x346>
    d19e:	f1 c1       	rjmp	.+994    	; 0xd582 <bmpDraw+0x728>
	chSemWait(&spiUSE);
	xprintf(PSTR("Header size: %ld \r\n"),read32(&bmpFile));	// Read DIB header
	chSemSignal(&spiUSE);
	
	chSemWait(&spiUSE);
	bmpWidth  = read32(&bmpFile);							// Width
    d1a0:	c3 55       	subi	r28, 0x53	; 83
    d1a2:	df 4f       	sbci	r29, 0xFF	; 255
    d1a4:	a8 80       	ld	r10, Y
    d1a6:	b9 80       	ldd	r11, Y+1	; 0x01
    d1a8:	cd 5a       	subi	r28, 0xAD	; 173
    d1aa:	d0 40       	sbci	r29, 0x00	; 0
	chSemSignal(&spiUSE);
	
	chSemWait(&spiUSE);
	bmpHeight = read32(&bmpFile);							// Height
    d1ac:	82 01       	movw	r16, r4
	if((bmpDepth != 24) && (read32(&bmpFile) != 0)) { 	// 0 = uncompressed
		xputs(PSTR("invalid depth or compression \r\n"));
		chSemSignal(&spiUSE);
		return;
	}
	chSemSignal(&spiUSE);
    d1ae:	89 e7       	ldi	r24, 0x79	; 121
    d1b0:	94 e1       	ldi	r25, 0x14	; 20
    d1b2:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
	
	goodBmp = 1; 										// Supported BMP format -- proceed!
	xprintf(PSTR("Image size: %d by %d pixels \r\n"), bmpWidth, bmpHeight);
    d1b6:	00 d0       	rcall	.+0      	; 0xd1b8 <bmpDraw+0x35e>
    d1b8:	00 d0       	rcall	.+0      	; 0xd1ba <bmpDraw+0x360>
    d1ba:	00 d0       	rcall	.+0      	; 0xd1bc <bmpDraw+0x362>
    d1bc:	ed b7       	in	r30, 0x3d	; 61
    d1be:	fe b7       	in	r31, 0x3e	; 62
    d1c0:	31 96       	adiw	r30, 0x01	; 1
    d1c2:	8d e3       	ldi	r24, 0x3D	; 61
    d1c4:	9b e0       	ldi	r25, 0x0B	; 11
    d1c6:	ad b7       	in	r26, 0x3d	; 61
    d1c8:	be b7       	in	r27, 0x3e	; 62
    d1ca:	12 96       	adiw	r26, 0x02	; 2
    d1cc:	9c 93       	st	X, r25
    d1ce:	8e 93       	st	-X, r24
    d1d0:	11 97       	sbiw	r26, 0x01	; 1
    d1d2:	c3 55       	subi	r28, 0x53	; 83
    d1d4:	df 4f       	sbci	r29, 0xFF	; 255
    d1d6:	28 81       	ld	r18, Y
    d1d8:	39 81       	ldd	r19, Y+1	; 0x01
    d1da:	cd 5a       	subi	r28, 0xAD	; 173
    d1dc:	d0 40       	sbci	r29, 0x00	; 0
    d1de:	33 83       	std	Z+3, r19	; 0x03
    d1e0:	22 83       	std	Z+2, r18	; 0x02
    d1e2:	55 82       	std	Z+5, r5	; 0x05
    d1e4:	44 82       	std	Z+4, r4	; 0x04
    d1e6:	0e 94 1e 20 	call	0x403c	; 0x403c <xprintf>
	rowSize = (bmpWidth * 3 + 3) & ~3;					// BMP rows are padded (if needed) to 4-byte boundary
    d1ea:	95 01       	movw	r18, r10
    d1ec:	2f 5f       	subi	r18, 0xFF	; 255
    d1ee:	3f 4f       	sbci	r19, 0xFF	; 255
    d1f0:	c9 01       	movw	r24, r18
    d1f2:	88 0f       	add	r24, r24
    d1f4:	99 1f       	adc	r25, r25
    d1f6:	82 0f       	add	r24, r18
    d1f8:	93 1f       	adc	r25, r19
    d1fa:	8c 7f       	andi	r24, 0xFC	; 252
    d1fc:	9c 01       	movw	r18, r24
    d1fe:	44 27       	eor	r20, r20
    d200:	37 fd       	sbrc	r19, 7
    d202:	40 95       	com	r20
    d204:	54 2f       	mov	r21, r20
    d206:	cb 55       	subi	r28, 0x5B	; 91
    d208:	df 4f       	sbci	r29, 0xFF	; 255
    d20a:	28 83       	st	Y, r18
    d20c:	39 83       	std	Y+1, r19	; 0x01
    d20e:	4a 83       	std	Y+2, r20	; 0x02
    d210:	5b 83       	std	Y+3, r21	; 0x03
    d212:	c5 5a       	subi	r28, 0xA5	; 165
    d214:	d0 40       	sbci	r29, 0x00	; 0
	// If bmpHeight is negative, image is in top-down order.
	// This is not canon but has been observed in the wild.
	if(bmpHeight < 0) {
    d216:	4d b7       	in	r20, 0x3d	; 61
    d218:	5e b7       	in	r21, 0x3e	; 62
    d21a:	4a 5f       	subi	r20, 0xFA	; 250
    d21c:	5f 4f       	sbci	r21, 0xFF	; 255
    d21e:	0f b6       	in	r0, 0x3f	; 63
    d220:	f8 94       	cli
    d222:	5e bf       	out	0x3e, r21	; 62
    d224:	0f be       	out	0x3f, r0	; 63
    d226:	4d bf       	out	0x3d, r20	; 61
    d228:	57 fc       	sbrc	r5, 7
    d22a:	a6 c1       	rjmp	.+844    	; 0xd578 <bmpDraw+0x71e>
    d22c:	88 24       	eor	r8, r8
    d22e:	83 94       	inc	r8
		flip      = 0;
	}
	// Crop area to be loaded
	w = bmpWidth;
	h = bmpHeight;
	if((x+w-1) >= st7735_width)  w = st7735_width  - x;
    d230:	4e 2d       	mov	r20, r14
    d232:	50 e0       	ldi	r21, 0x00	; 0
    d234:	80 91 17 07 	lds	r24, 0x0717
    d238:	28 2f       	mov	r18, r24
    d23a:	30 e0       	ldi	r19, 0x00	; 0
    d23c:	c5 01       	movw	r24, r10
    d23e:	84 0f       	add	r24, r20
    d240:	95 1f       	adc	r25, r21
    d242:	28 17       	cp	r18, r24
    d244:	39 07       	cpc	r19, r25
    d246:	0c f4       	brge	.+2      	; 0xd24a <bmpDraw+0x3f0>
    d248:	8d c1       	rjmp	.+794    	; 0xd564 <bmpDraw+0x70a>
    d24a:	cd 55       	subi	r28, 0x5D	; 93
    d24c:	df 4f       	sbci	r29, 0xFF	; 255
    d24e:	b9 82       	std	Y+1, r11	; 0x01
    d250:	a8 82       	st	Y, r10
    d252:	c3 5a       	subi	r28, 0xA3	; 163
    d254:	d0 40       	sbci	r29, 0x00	; 0
	if((y+h-1) >= st7735_height) h = st7735_height - y;
    d256:	4c 2d       	mov	r20, r12
    d258:	50 e0       	ldi	r21, 0x00	; 0
    d25a:	80 91 18 07 	lds	r24, 0x0718
    d25e:	28 2f       	mov	r18, r24
    d260:	30 e0       	ldi	r19, 0x00	; 0
    d262:	c8 01       	movw	r24, r16
    d264:	84 0f       	add	r24, r20
    d266:	95 1f       	adc	r25, r21
    d268:	28 17       	cp	r18, r24
    d26a:	39 07       	cpc	r19, r25
    d26c:	0c f4       	brge	.+2      	; 0xd270 <bmpDraw+0x416>
    d26e:	70 c1       	rjmp	.+736    	; 0xd550 <bmpDraw+0x6f6>
    d270:	cf 55       	subi	r28, 0x5F	; 95
    d272:	df 4f       	sbci	r29, 0xFF	; 255
    d274:	19 83       	std	Y+1, r17	; 0x01
    d276:	08 83       	st	Y, r16
    d278:	c1 5a       	subi	r28, 0xA1	; 161
    d27a:	d0 40       	sbci	r29, 0x00	; 0
	
	// Set TFT address window to clipped image bounds
	chSemWait(&spiUSE);
    d27c:	89 e7       	ldi	r24, 0x79	; 121
    d27e:	94 e1       	ldi	r25, 0x14	; 20
    d280:	40 e0       	ldi	r20, 0x00	; 0
    d282:	50 e0       	ldi	r21, 0x00	; 0
    d284:	60 e0       	ldi	r22, 0x00	; 0
    d286:	70 e0       	ldi	r23, 0x00	; 0
    d288:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
	st7735_set_addr_win(x, y, x+w-1, y+h-1);
    d28c:	4e 2d       	mov	r20, r14
    d28e:	41 50       	subi	r20, 0x01	; 1
    d290:	cd 55       	subi	r28, 0x5D	; 93
    d292:	df 4f       	sbci	r29, 0xFF	; 255
    d294:	b8 81       	ld	r27, Y
    d296:	c3 5a       	subi	r28, 0xA3	; 163
    d298:	d0 40       	sbci	r29, 0x00	; 0
    d29a:	4b 0f       	add	r20, r27
    d29c:	2c 2d       	mov	r18, r12
    d29e:	21 50       	subi	r18, 0x01	; 1
    d2a0:	cf 55       	subi	r28, 0x5F	; 95
    d2a2:	df 4f       	sbci	r29, 0xFF	; 255
    d2a4:	e8 81       	ld	r30, Y
    d2a6:	c1 5a       	subi	r28, 0xA1	; 161
    d2a8:	d0 40       	sbci	r29, 0x00	; 0
    d2aa:	2e 0f       	add	r18, r30
    d2ac:	8e 2d       	mov	r24, r14
    d2ae:	6c 2d       	mov	r22, r12
    d2b0:	0e 94 d3 15 	call	0x2ba6	; 0x2ba6 <st7735_set_addr_win>
	chSemSignal(&spiUSE);
    d2b4:	89 e7       	ldi	r24, 0x79	; 121
    d2b6:	94 e1       	ldi	r25, 0x14	; 20
    d2b8:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
	
	for (row=0; row<h; row++) { 						// For each scanline...
    d2bc:	cf 55       	subi	r28, 0x5F	; 95
    d2be:	df 4f       	sbci	r29, 0xFF	; 255
    d2c0:	28 81       	ld	r18, Y
    d2c2:	39 81       	ldd	r19, Y+1	; 0x01
    d2c4:	c1 5a       	subi	r28, 0xA1	; 161
    d2c6:	d0 40       	sbci	r29, 0x00	; 0
    d2c8:	12 16       	cp	r1, r18
    d2ca:	13 06       	cpc	r1, r19
    d2cc:	0c f0       	brlt	.+2      	; 0xd2d0 <bmpDraw+0x476>
    d2ce:	1a c1       	rjmp	.+564    	; 0xd504 <bmpDraw+0x6aa>
    d2d0:	cb 55       	subi	r28, 0x5B	; 91
    d2d2:	df 4f       	sbci	r29, 0xFF	; 255
    d2d4:	88 81       	ld	r24, Y
    d2d6:	99 81       	ldd	r25, Y+1	; 0x01
    d2d8:	aa 81       	ldd	r26, Y+2	; 0x02
    d2da:	bb 81       	ldd	r27, Y+3	; 0x03
    d2dc:	c5 5a       	subi	r28, 0xA5	; 165
    d2de:	d0 40       	sbci	r29, 0x00	; 0
    d2e0:	b0 95       	com	r27
    d2e2:	a0 95       	com	r26
    d2e4:	90 95       	com	r25
    d2e6:	81 95       	neg	r24
    d2e8:	9f 4f       	sbci	r25, 0xFF	; 255
    d2ea:	af 4f       	sbci	r26, 0xFF	; 255
    d2ec:	bf 4f       	sbci	r27, 0xFF	; 255
    d2ee:	c5 56       	subi	r28, 0x65	; 101
    d2f0:	df 4f       	sbci	r29, 0xFF	; 255
    d2f2:	88 83       	st	Y, r24
    d2f4:	99 83       	std	Y+1, r25	; 0x01
    d2f6:	aa 83       	std	Y+2, r26	; 0x02
    d2f8:	bb 83       	std	Y+3, r27	; 0x03
    d2fa:	cb 59       	subi	r28, 0x9B	; 155
    d2fc:	d0 40       	sbci	r29, 0x00	; 0
    d2fe:	01 50       	subi	r16, 0x01	; 1
    d300:	10 40       	sbci	r17, 0x00	; 0
    d302:	98 01       	movw	r18, r16
    d304:	44 27       	eor	r20, r20
    d306:	37 fd       	sbrc	r19, 7
    d308:	40 95       	com	r20
    d30a:	54 2f       	mov	r21, r20
    d30c:	cb 55       	subi	r28, 0x5B	; 91
    d30e:	df 4f       	sbci	r29, 0xFF	; 255
    d310:	68 81       	ld	r22, Y
    d312:	79 81       	ldd	r23, Y+1	; 0x01
    d314:	8a 81       	ldd	r24, Y+2	; 0x02
    d316:	9b 81       	ldd	r25, Y+3	; 0x03
    d318:	c5 5a       	subi	r28, 0xA5	; 165
    d31a:	d0 40       	sbci	r29, 0x00	; 0
    d31c:	0e 94 bb 7f 	call	0xff76	; 0xff76 <__mulsi3>
    d320:	1b 01       	movw	r2, r22
    d322:	2c 01       	movw	r4, r24
    d324:	c7 55       	subi	r28, 0x57	; 87
    d326:	df 4f       	sbci	r29, 0xFF	; 255
    d328:	28 81       	ld	r18, Y
    d32a:	39 81       	ldd	r19, Y+1	; 0x01
    d32c:	4a 81       	ldd	r20, Y+2	; 0x02
    d32e:	5b 81       	ldd	r21, Y+3	; 0x03
    d330:	c9 5a       	subi	r28, 0xA9	; 169
    d332:	d0 40       	sbci	r29, 0x00	; 0
    d334:	22 0e       	add	r2, r18
    d336:	33 1e       	adc	r3, r19
    d338:	44 1e       	adc	r4, r20
    d33a:	55 1e       	adc	r5, r21
    d33c:	c1 56       	subi	r28, 0x61	; 97
    d33e:	df 4f       	sbci	r29, 0xFF	; 255
    d340:	19 82       	std	Y+1, r1	; 0x01
    d342:	18 82       	st	Y, r1
    d344:	cf 59       	subi	r28, 0x9F	; 159
    d346:	d0 40       	sbci	r29, 0x00	; 0
    d348:	e3 e2       	ldi	r30, 0x23	; 35
    d34a:	6e 2e       	mov	r6, r30
    d34c:	71 2c       	mov	r7, r1
    d34e:	6c 0e       	add	r6, r28
    d350:	7d 1e       	adc	r7, r29
	// method covers a lot of gritty details like cropping
	// and scanline padding.  Also, the seek only takes
	// place if the file position actually needs to change
	// (avoids a lot of cluster math in SD library).
    
		if(flip) {											// Bitmap is stored bottom-to-top order (normal BMP)
    d352:	88 20       	and	r8, r8
    d354:	09 f4       	brne	.+2      	; 0xd358 <bmpDraw+0x4fe>
    d356:	e7 c0       	rjmp	.+462    	; 0xd526 <bmpDraw+0x6cc>
    d358:	c2 2c       	mov	r12, r2
    d35a:	e3 2c       	mov	r14, r3
    d35c:	82 01       	movw	r16, r4
		}	
		else {										    	// Bitmap is stored top-to-bottom
			pos = bmpImageoffset + row * rowSize;
		}      
		
        chSemWait(&spiUSE);	
    d35e:	89 e7       	ldi	r24, 0x79	; 121
    d360:	94 e1       	ldi	r25, 0x14	; 20
    d362:	40 e0       	ldi	r20, 0x00	; 0
    d364:	50 e0       	ldi	r21, 0x00	; 0
    d366:	60 e0       	ldi	r22, 0x00	; 0
    d368:	70 e0       	ldi	r23, 0x00	; 0
    d36a:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
		f_lseek(&bmpFile, pos);
    d36e:	ce 01       	movw	r24, r28
    d370:	03 96       	adiw	r24, 0x03	; 3
    d372:	4c 2d       	mov	r20, r12
    d374:	5e 2d       	mov	r21, r14
    d376:	b8 01       	movw	r22, r16
    d378:	0e 94 1d 2b 	call	0x563a	; 0x563a <f_lseek>
		chSemSignal(&spiUSE);
    d37c:	89 e7       	ldi	r24, 0x79	; 121
    d37e:	94 e1       	ldi	r25, 0x14	; 20
    d380:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
		
		buffidx = SIZE_OF_SDBUFFER; 					// Force buffer reload

		for (col=0; col<w; col++) { 					// For each pixel...
    d384:	cd 55       	subi	r28, 0x5D	; 93
    d386:	df 4f       	sbci	r29, 0xFF	; 255
    d388:	48 81       	ld	r20, Y
    d38a:	59 81       	ldd	r21, Y+1	; 0x01
    d38c:	c3 5a       	subi	r28, 0xA3	; 163
    d38e:	d0 40       	sbci	r29, 0x00	; 0
    d390:	14 16       	cp	r1, r20
    d392:	15 06       	cpc	r1, r21
    d394:	0c f0       	brlt	.+2      	; 0xd398 <bmpDraw+0x53e>
    d396:	70 c0       	rjmp	.+224    	; 0xd478 <bmpDraw+0x61e>
    d398:	78 e7       	ldi	r23, 0x78	; 120
    d39a:	97 2e       	mov	r9, r23
    d39c:	aa 24       	eor	r10, r10
    d39e:	bb 24       	eor	r11, r11
    d3a0:	48 c0       	rjmp	.+144    	; 0xd432 <bmpDraw+0x5d8>
			// Time to read more pixel data?
			if (buffidx >= SIZE_OF_SDBUFFER) { 		// Indeed
    d3a2:	29 2d       	mov	r18, r9
    d3a4:	30 e0       	ldi	r19, 0x00	; 0
    d3a6:	89 2d       	mov	r24, r9
    d3a8:	8f 5f       	subi	r24, 0xFF	; 255
    d3aa:	a8 2f       	mov	r26, r24
    d3ac:	b0 e0       	ldi	r27, 0x00	; 0
    d3ae:	8f 5f       	subi	r24, 0xFF	; 255
    d3b0:	48 2f       	mov	r20, r24
    d3b2:	50 e0       	ldi	r21, 0x00	; 0
    d3b4:	98 2e       	mov	r9, r24
    d3b6:	93 94       	inc	r9
				f_read(&bmpFile, sdbuffer, SIZE_OF_SDBUFFER, &br);
				chSemSignal(&spiUSE);
				buffidx = 0; 							// Set index to beginning
			}			
			// Convert pixel from BMP to TFT format, push to display
			b = sdbuffer[buffidx++];
    d3b8:	26 0d       	add	r18, r6
    d3ba:	37 1d       	adc	r19, r7
    d3bc:	f9 01       	movw	r30, r18
    d3be:	c0 80       	ld	r12, Z
			g = sdbuffer[buffidx++];
    d3c0:	a6 0d       	add	r26, r6
    d3c2:	b7 1d       	adc	r27, r7
    d3c4:	ec 90       	ld	r14, X
			r = sdbuffer[buffidx++];
    d3c6:	46 0d       	add	r20, r6
    d3c8:	57 1d       	adc	r21, r7
    d3ca:	da 01       	movw	r26, r20
    d3cc:	0c 91       	ld	r16, X
			chSemWait(&spiUSE);
    d3ce:	89 e7       	ldi	r24, 0x79	; 121
    d3d0:	94 e1       	ldi	r25, 0x14	; 20
    d3d2:	40 e0       	ldi	r20, 0x00	; 0
    d3d4:	50 e0       	ldi	r21, 0x00	; 0
    d3d6:	60 e0       	ldi	r22, 0x00	; 0
    d3d8:	70 e0       	ldi	r23, 0x00	; 0
    d3da:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
			st7735_write_self_color(st7735_color(r,g,b)); //exposed from underlying api
    d3de:	10 e0       	ldi	r17, 0x00	; 0
    d3e0:	08 7f       	andi	r16, 0xF8	; 248
    d3e2:	10 70       	andi	r17, 0x00	; 0
    d3e4:	10 2f       	mov	r17, r16
    d3e6:	00 27       	eor	r16, r16
    d3e8:	ff 24       	eor	r15, r15
    d3ea:	bc ef       	ldi	r27, 0xFC	; 252
    d3ec:	eb 22       	and	r14, r27
    d3ee:	ff 24       	eor	r15, r15
    d3f0:	ee 0c       	add	r14, r14
    d3f2:	ff 1c       	adc	r15, r15
    d3f4:	ee 0c       	add	r14, r14
    d3f6:	ff 1c       	adc	r15, r15
    d3f8:	ee 0c       	add	r14, r14
    d3fa:	ff 1c       	adc	r15, r15
    d3fc:	0e 29       	or	r16, r14
    d3fe:	1f 29       	or	r17, r15
    d400:	c6 94       	lsr	r12
    d402:	c6 94       	lsr	r12
    d404:	c6 94       	lsr	r12
    d406:	dd 24       	eor	r13, r13
    d408:	c8 01       	movw	r24, r16
    d40a:	8c 29       	or	r24, r12
    d40c:	9d 29       	or	r25, r13
    d40e:	0e 94 14 15 	call	0x2a28	; 0x2a28 <st7735_write_self_color>
			chSemSignal(&spiUSE);
    d412:	89 e7       	ldi	r24, 0x79	; 121
    d414:	94 e1       	ldi	r25, 0x14	; 20
    d416:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
		f_lseek(&bmpFile, pos);
		chSemSignal(&spiUSE);
		
		buffidx = SIZE_OF_SDBUFFER; 					// Force buffer reload

		for (col=0; col<w; col++) { 					// For each pixel...
    d41a:	08 94       	sec
    d41c:	a1 1c       	adc	r10, r1
    d41e:	b1 1c       	adc	r11, r1
    d420:	cd 55       	subi	r28, 0x5D	; 93
    d422:	df 4f       	sbci	r29, 0xFF	; 255
    d424:	e8 81       	ld	r30, Y
    d426:	f9 81       	ldd	r31, Y+1	; 0x01
    d428:	c3 5a       	subi	r28, 0xA3	; 163
    d42a:	d0 40       	sbci	r29, 0x00	; 0
    d42c:	ae 16       	cp	r10, r30
    d42e:	bf 06       	cpc	r11, r31
    d430:	1c f5       	brge	.+70     	; 0xd478 <bmpDraw+0x61e>
			// Time to read more pixel data?
			if (buffidx >= SIZE_OF_SDBUFFER) { 		// Indeed
    d432:	57 e7       	ldi	r21, 0x77	; 119
    d434:	59 15       	cp	r21, r9
    d436:	08 f0       	brcs	.+2      	; 0xd43a <bmpDraw+0x5e0>
    d438:	b4 cf       	rjmp	.-152    	; 0xd3a2 <bmpDraw+0x548>
				chSemWait(&spiUSE);
    d43a:	89 e7       	ldi	r24, 0x79	; 121
    d43c:	94 e1       	ldi	r25, 0x14	; 20
    d43e:	40 e0       	ldi	r20, 0x00	; 0
    d440:	50 e0       	ldi	r21, 0x00	; 0
    d442:	60 e0       	ldi	r22, 0x00	; 0
    d444:	70 e0       	ldi	r23, 0x00	; 0
    d446:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
				f_read(&bmpFile, sdbuffer, SIZE_OF_SDBUFFER, &br);
    d44a:	ce 01       	movw	r24, r28
    d44c:	03 96       	adiw	r24, 0x03	; 3
    d44e:	b3 01       	movw	r22, r6
    d450:	48 e7       	ldi	r20, 0x78	; 120
    d452:	50 e0       	ldi	r21, 0x00	; 0
    d454:	9e 01       	movw	r18, r28
    d456:	2f 5f       	subi	r18, 0xFF	; 255
    d458:	3f 4f       	sbci	r19, 0xFF	; 255
    d45a:	0e 94 ab 35 	call	0x6b56	; 0x6b56 <f_read>
				chSemSignal(&spiUSE);
    d45e:	89 e7       	ldi	r24, 0x79	; 121
    d460:	94 e1       	ldi	r25, 0x14	; 20
    d462:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
    d466:	20 e0       	ldi	r18, 0x00	; 0
    d468:	30 e0       	ldi	r19, 0x00	; 0
    d46a:	a1 e0       	ldi	r26, 0x01	; 1
    d46c:	b0 e0       	ldi	r27, 0x00	; 0
    d46e:	42 e0       	ldi	r20, 0x02	; 2
    d470:	50 e0       	ldi	r21, 0x00	; 0
    d472:	63 e0       	ldi	r22, 0x03	; 3
    d474:	96 2e       	mov	r9, r22
    d476:	a0 cf       	rjmp	.-192    	; 0xd3b8 <bmpDraw+0x55e>
	// Set TFT address window to clipped image bounds
	chSemWait(&spiUSE);
	st7735_set_addr_win(x, y, x+w-1, y+h-1);
	chSemSignal(&spiUSE);
	
	for (row=0; row<h; row++) { 						// For each scanline...
    d478:	c1 56       	subi	r28, 0x61	; 97
    d47a:	df 4f       	sbci	r29, 0xFF	; 255
    d47c:	28 81       	ld	r18, Y
    d47e:	39 81       	ldd	r19, Y+1	; 0x01
    d480:	cf 59       	subi	r28, 0x9F	; 159
    d482:	d0 40       	sbci	r29, 0x00	; 0
    d484:	2f 5f       	subi	r18, 0xFF	; 255
    d486:	3f 4f       	sbci	r19, 0xFF	; 255
    d488:	c1 56       	subi	r28, 0x61	; 97
    d48a:	df 4f       	sbci	r29, 0xFF	; 255
    d48c:	39 83       	std	Y+1, r19	; 0x01
    d48e:	28 83       	st	Y, r18
    d490:	cf 59       	subi	r28, 0x9F	; 159
    d492:	d0 40       	sbci	r29, 0x00	; 0
    d494:	c5 56       	subi	r28, 0x65	; 101
    d496:	df 4f       	sbci	r29, 0xFF	; 255
    d498:	88 81       	ld	r24, Y
    d49a:	99 81       	ldd	r25, Y+1	; 0x01
    d49c:	aa 81       	ldd	r26, Y+2	; 0x02
    d49e:	bb 81       	ldd	r27, Y+3	; 0x03
    d4a0:	cb 59       	subi	r28, 0x9B	; 155
    d4a2:	d0 40       	sbci	r29, 0x00	; 0
    d4a4:	28 0e       	add	r2, r24
    d4a6:	39 1e       	adc	r3, r25
    d4a8:	4a 1e       	adc	r4, r26
    d4aa:	5b 1e       	adc	r5, r27
    d4ac:	c7 55       	subi	r28, 0x57	; 87
    d4ae:	df 4f       	sbci	r29, 0xFF	; 255
    d4b0:	28 81       	ld	r18, Y
    d4b2:	39 81       	ldd	r19, Y+1	; 0x01
    d4b4:	4a 81       	ldd	r20, Y+2	; 0x02
    d4b6:	5b 81       	ldd	r21, Y+3	; 0x03
    d4b8:	c9 5a       	subi	r28, 0xA9	; 169
    d4ba:	d0 40       	sbci	r29, 0x00	; 0
    d4bc:	cb 55       	subi	r28, 0x5B	; 91
    d4be:	df 4f       	sbci	r29, 0xFF	; 255
    d4c0:	88 81       	ld	r24, Y
    d4c2:	99 81       	ldd	r25, Y+1	; 0x01
    d4c4:	aa 81       	ldd	r26, Y+2	; 0x02
    d4c6:	bb 81       	ldd	r27, Y+3	; 0x03
    d4c8:	c5 5a       	subi	r28, 0xA5	; 165
    d4ca:	d0 40       	sbci	r29, 0x00	; 0
    d4cc:	28 0f       	add	r18, r24
    d4ce:	39 1f       	adc	r19, r25
    d4d0:	4a 1f       	adc	r20, r26
    d4d2:	5b 1f       	adc	r21, r27
    d4d4:	c7 55       	subi	r28, 0x57	; 87
    d4d6:	df 4f       	sbci	r29, 0xFF	; 255
    d4d8:	28 83       	st	Y, r18
    d4da:	39 83       	std	Y+1, r19	; 0x01
    d4dc:	4a 83       	std	Y+2, r20	; 0x02
    d4de:	5b 83       	std	Y+3, r21	; 0x03
    d4e0:	c9 5a       	subi	r28, 0xA9	; 169
    d4e2:	d0 40       	sbci	r29, 0x00	; 0
    d4e4:	cf 55       	subi	r28, 0x5F	; 95
    d4e6:	df 4f       	sbci	r29, 0xFF	; 255
    d4e8:	a8 81       	ld	r26, Y
    d4ea:	b9 81       	ldd	r27, Y+1	; 0x01
    d4ec:	c1 5a       	subi	r28, 0xA1	; 161
    d4ee:	d0 40       	sbci	r29, 0x00	; 0
    d4f0:	c1 56       	subi	r28, 0x61	; 97
    d4f2:	df 4f       	sbci	r29, 0xFF	; 255
    d4f4:	e8 81       	ld	r30, Y
    d4f6:	f9 81       	ldd	r31, Y+1	; 0x01
    d4f8:	cf 59       	subi	r28, 0x9F	; 159
    d4fa:	d0 40       	sbci	r29, 0x00	; 0
    d4fc:	ea 17       	cp	r30, r26
    d4fe:	fb 07       	cpc	r31, r27
    d500:	0c f4       	brge	.+2      	; 0xd504 <bmpDraw+0x6aa>
    d502:	27 cf       	rjmp	.-434    	; 0xd352 <bmpDraw+0x4f8>
			st7735_write_self_color(st7735_color(r,g,b)); //exposed from underlying api
			chSemSignal(&spiUSE);
		} // end pixel
	} // end scanline
	
	chSemWait(&spiUSE);
    d504:	89 e7       	ldi	r24, 0x79	; 121
    d506:	94 e1       	ldi	r25, 0x14	; 20
    d508:	40 e0       	ldi	r20, 0x00	; 0
    d50a:	50 e0       	ldi	r21, 0x00	; 0
    d50c:	60 e0       	ldi	r22, 0x00	; 0
    d50e:	70 e0       	ldi	r23, 0x00	; 0
    d510:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
	f_close(&bmpFile);
    d514:	ce 01       	movw	r24, r28
    d516:	03 96       	adiw	r24, 0x03	; 3
    d518:	0e 94 43 3f 	call	0x7e86	; 0x7e86 <f_close>
	chSemSignal(&spiUSE);
    d51c:	89 e7       	ldi	r24, 0x79	; 121
    d51e:	94 e1       	ldi	r25, 0x14	; 20
    d520:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
    d524:	c4 cc       	rjmp	.-1656   	; 0xceae <bmpDraw+0x54>
	// method covers a lot of gritty details like cropping
	// and scanline padding.  Also, the seek only takes
	// place if the file position actually needs to change
	// (avoids a lot of cluster math in SD library).
    
		if(flip) {											// Bitmap is stored bottom-to-top order (normal BMP)
    d526:	c7 55       	subi	r28, 0x57	; 87
    d528:	df 4f       	sbci	r29, 0xFF	; 255
    d52a:	c8 80       	ld	r12, Y
    d52c:	c9 5a       	subi	r28, 0xA9	; 169
    d52e:	d0 40       	sbci	r29, 0x00	; 0
    d530:	c6 55       	subi	r28, 0x56	; 86
    d532:	df 4f       	sbci	r29, 0xFF	; 255
    d534:	e8 80       	ld	r14, Y
    d536:	ca 5a       	subi	r28, 0xAA	; 170
    d538:	d0 40       	sbci	r29, 0x00	; 0
    d53a:	c5 55       	subi	r28, 0x55	; 85
    d53c:	df 4f       	sbci	r29, 0xFF	; 255
    d53e:	08 81       	ld	r16, Y
    d540:	cb 5a       	subi	r28, 0xAB	; 171
    d542:	d0 40       	sbci	r29, 0x00	; 0
    d544:	c4 55       	subi	r28, 0x54	; 84
    d546:	df 4f       	sbci	r29, 0xFF	; 255
    d548:	18 81       	ld	r17, Y
    d54a:	cc 5a       	subi	r28, 0xAC	; 172
    d54c:	d0 40       	sbci	r29, 0x00	; 0
    d54e:	07 cf       	rjmp	.-498    	; 0xd35e <bmpDraw+0x504>
	}
	// Crop area to be loaded
	w = bmpWidth;
	h = bmpHeight;
	if((x+w-1) >= st7735_width)  w = st7735_width  - x;
	if((y+h-1) >= st7735_height) h = st7735_height - y;
    d550:	d9 01       	movw	r26, r18
    d552:	a4 1b       	sub	r26, r20
    d554:	b5 0b       	sbc	r27, r21
    d556:	cf 55       	subi	r28, 0x5F	; 95
    d558:	df 4f       	sbci	r29, 0xFF	; 255
    d55a:	b9 83       	std	Y+1, r27	; 0x01
    d55c:	a8 83       	st	Y, r26
    d55e:	c1 5a       	subi	r28, 0xA1	; 161
    d560:	d0 40       	sbci	r29, 0x00	; 0
    d562:	8c ce       	rjmp	.-744    	; 0xd27c <bmpDraw+0x422>
		flip      = 0;
	}
	// Crop area to be loaded
	w = bmpWidth;
	h = bmpHeight;
	if((x+w-1) >= st7735_width)  w = st7735_width  - x;
    d564:	c9 01       	movw	r24, r18
    d566:	84 1b       	sub	r24, r20
    d568:	95 0b       	sbc	r25, r21
    d56a:	cd 55       	subi	r28, 0x5D	; 93
    d56c:	df 4f       	sbci	r29, 0xFF	; 255
    d56e:	99 83       	std	Y+1, r25	; 0x01
    d570:	88 83       	st	Y, r24
    d572:	c3 5a       	subi	r28, 0xA3	; 163
    d574:	d0 40       	sbci	r29, 0x00	; 0
    d576:	6f ce       	rjmp	.-802    	; 0xd256 <bmpDraw+0x3fc>
	xprintf(PSTR("Image size: %d by %d pixels \r\n"), bmpWidth, bmpHeight);
	rowSize = (bmpWidth * 3 + 3) & ~3;					// BMP rows are padded (if needed) to 4-byte boundary
	// If bmpHeight is negative, image is in top-down order.
	// This is not canon but has been observed in the wild.
	if(bmpHeight < 0) {
		bmpHeight = -1*bmpHeight;
    d578:	10 95       	com	r17
    d57a:	01 95       	neg	r16
    d57c:	1f 4f       	sbci	r17, 0xFF	; 255
    d57e:	88 24       	eor	r8, r8
    d580:	57 ce       	rjmp	.-850    	; 0xd230 <bmpDraw+0x3d6>
	
	xprintf(PSTR("Bit Depth: %d \r\n"), bmpDepth);
	
	chSemWait(&spiUSE);
	if((bmpDepth != 24) && (read32(&bmpFile) != 0)) { 	// 0 = uncompressed
		xputs(PSTR("invalid depth or compression \r\n"));
    d582:	8c e5       	ldi	r24, 0x5C	; 92
    d584:	9b e0       	ldi	r25, 0x0B	; 11
    d586:	0e 94 7b 1b 	call	0x36f6	; 0x36f6 <xputs>
		chSemSignal(&spiUSE);
    d58a:	89 e7       	ldi	r24, 0x79	; 121
    d58c:	94 e1       	ldi	r25, 0x14	; 20
    d58e:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
    d592:	8d cc       	rjmp	.-1766   	; 0xceae <bmpDraw+0x54>

0000d594 <Thread12>:
}//THREAD11

/*********************************************************************************
 * Thread 12 - HeartBeat 
 *********************************************************************************/
THD_FUNCTION(Thread12, arg) {
    d594:	df 93       	push	r29
    d596:	cf 93       	push	r28
    d598:	cd b7       	in	r28, 0x3d	; 61
    d59a:	de b7       	in	r29, 0x3e	; 62
    d59c:	c6 58       	subi	r28, 0x86	; 134
    d59e:	d0 40       	sbci	r29, 0x00	; 0
    d5a0:	0f b6       	in	r0, 0x3f	; 63
    d5a2:	f8 94       	cli
    d5a4:	de bf       	out	0x3e, r29	; 62
    d5a6:	0f be       	out	0x3f, r0	; 63
    d5a8:	cd bf       	out	0x3d, r28	; 61
	(void)arg;
	tp[11] = chThdGetSelfX();
    d5aa:	80 91 ce 07 	lds	r24, 0x07CE
    d5ae:	90 91 cf 07 	lds	r25, 0x07CF
    d5b2:	90 93 ad 07 	sts	0x07AD, r25
    d5b6:	80 93 ac 07 	sts	0x07AC, r24
	int32_t coeff = 5L;
	int32_t attack_max = 35L;
	
	uint8_t i;
	
	int32_t SPO2_circular_buffer[7] = {100L,100L,100L,100L,100L,100L,100L};
    d5ba:	de 01       	movw	r26, r28
    d5bc:	13 96       	adiw	r26, 0x03	; 3
    d5be:	e8 ed       	ldi	r30, 0xD8	; 216
    d5c0:	f6 e0       	ldi	r31, 0x06	; 6
    d5c2:	8c e1       	ldi	r24, 0x1C	; 28
    d5c4:	01 90       	ld	r0, Z+
    d5c6:	0d 92       	st	X+, r0
    d5c8:	81 50       	subi	r24, 0x01	; 1
    d5ca:	e1 f7       	brne	.-8      	; 0xd5c4 <Thread12+0x30>
	IR_SPO2_state.baseline = 0;
	IR_SPO2_state.spread = 0;
	IR_SPO2_state.status = 0;	
	
	/* initialize the Red HR state variable*/
	Red_HR_state.maybe_peak = 0;
    d5cc:	10 92 38 2f 	sts	0x2F38, r1
	Red_HR_state.maybe_valley = 0;
    d5d0:	10 92 39 2f 	sts	0x2F39, r1
	Red_HR_state.peak_detect = 0;
    d5d4:	10 92 3a 2f 	sts	0x2F3A, r1
	Red_HR_state.valley_detect = 0;
    d5d8:	10 92 3b 2f 	sts	0x2F3B, r1
	Red_HR_state.fiar = 0; //stands for five-in-a-row
    d5dc:	10 92 3c 2f 	sts	0x2F3C, r1
	Red_HR_state.valley_min = 0L;
    d5e0:	10 92 3d 2f 	sts	0x2F3D, r1
    d5e4:	10 92 3e 2f 	sts	0x2F3E, r1
    d5e8:	10 92 3f 2f 	sts	0x2F3F, r1
    d5ec:	10 92 40 2f 	sts	0x2F40, r1
	Red_HR_state.peak_max = 0L;
    d5f0:	10 92 41 2f 	sts	0x2F41, r1
    d5f4:	10 92 42 2f 	sts	0x2F42, r1
    d5f8:	10 92 43 2f 	sts	0x2F43, r1
    d5fc:	10 92 44 2f 	sts	0x2F44, r1
	Red_HR_state.offset_DC = 0;
    d600:	10 92 45 2f 	sts	0x2F45, r1
	Red_HR_state.offset_filt = 0;
    d604:	10 92 46 2f 	sts	0x2F46, r1
    d608:	a7 e4       	ldi	r26, 0x47	; 71
    d60a:	bf e2       	ldi	r27, 0x2F	; 47
    d60c:	80 e0       	ldi	r24, 0x00	; 0
    d60e:	90 e0       	ldi	r25, 0x00	; 0
	for(i = 0; i < 32; i++){
		if (i < 4){
    d610:	84 30       	cpi	r24, 0x04	; 4
    d612:	70 f4       	brcc	.+28     	; 0xd630 <Thread12+0x9c>
			Red_HR_state.xbuf_DC[i] = 0L;
    d614:	1d 92       	st	X+, r1
    d616:	1d 92       	st	X+, r1
    d618:	1d 92       	st	X+, r1
    d61a:	1c 92       	st	X, r1
    d61c:	13 97       	sbiw	r26, 0x03	; 3
			Red_HR_state.abuf_DC[i] = 0L;
    d61e:	a0 58       	subi	r26, 0x80	; 128
    d620:	bf 4f       	sbci	r27, 0xFF	; 255
    d622:	1d 92       	st	X+, r1
    d624:	1d 92       	st	X+, r1
    d626:	1d 92       	st	X+, r1
    d628:	1c 92       	st	X, r1
    d62a:	13 97       	sbiw	r26, 0x03	; 3
    d62c:	a0 58       	subi	r26, 0x80	; 128
    d62e:	b0 40       	sbci	r27, 0x00	; 0
		}	
		Red_HR_state.cbuf[i]= 0L;
    d630:	fc 01       	movw	r30, r24
    d632:	ee 0f       	add	r30, r30
    d634:	ff 1f       	adc	r31, r31
    d636:	ee 0f       	add	r30, r30
    d638:	ff 1f       	adc	r31, r31
    d63a:	e9 5b       	subi	r30, 0xB9	; 185
    d63c:	ff 4c       	sbci	r31, 0xCF	; 207
    d63e:	10 82       	st	Z, r1
    d640:	11 82       	std	Z+1, r1	; 0x01
    d642:	12 82       	std	Z+2, r1	; 0x02
    d644:	13 82       	std	Z+3, r1	; 0x03
    d646:	01 96       	adiw	r24, 0x01	; 1
    d648:	14 96       	adiw	r26, 0x04	; 4
	Red_HR_state.fiar = 0; //stands for five-in-a-row
	Red_HR_state.valley_min = 0L;
	Red_HR_state.peak_max = 0L;
	Red_HR_state.offset_DC = 0;
	Red_HR_state.offset_filt = 0;
	for(i = 0; i < 32; i++){
    d64a:	80 32       	cpi	r24, 0x20	; 32
    d64c:	91 05       	cpc	r25, r1
    d64e:	01 f7       	brne	.-64     	; 0xd610 <Thread12+0x7c>
		}	
		Red_HR_state.cbuf[i]= 0L;
	}
	
		/* initialize the HR state variable*/
	IR_HR_state.maybe_peak = 0;
    d650:	10 92 3a 0f 	sts	0x0F3A, r1
	IR_HR_state.maybe_valley = 0;
    d654:	10 92 3b 0f 	sts	0x0F3B, r1
	IR_HR_state.peak_detect = 0;
    d658:	10 92 3c 0f 	sts	0x0F3C, r1
	IR_HR_state.valley_detect = 0;
    d65c:	10 92 3d 0f 	sts	0x0F3D, r1
	IR_HR_state.fiar = 0; //stands for five-in-a-row
    d660:	10 92 3e 0f 	sts	0x0F3E, r1
	IR_HR_state.valley_min = 0L;
    d664:	10 92 3f 0f 	sts	0x0F3F, r1
    d668:	10 92 40 0f 	sts	0x0F40, r1
    d66c:	10 92 41 0f 	sts	0x0F41, r1
    d670:	10 92 42 0f 	sts	0x0F42, r1
	IR_HR_state.peak_max = 0L;
    d674:	10 92 43 0f 	sts	0x0F43, r1
    d678:	10 92 44 0f 	sts	0x0F44, r1
    d67c:	10 92 45 0f 	sts	0x0F45, r1
    d680:	10 92 46 0f 	sts	0x0F46, r1
	IR_HR_state.offset_DC = 0;
    d684:	10 92 47 0f 	sts	0x0F47, r1
	IR_HR_state.offset_filt = 0;
    d688:	10 92 48 0f 	sts	0x0F48, r1
    d68c:	a9 e4       	ldi	r26, 0x49	; 73
    d68e:	bf e0       	ldi	r27, 0x0F	; 15
    d690:	80 e0       	ldi	r24, 0x00	; 0
    d692:	90 e0       	ldi	r25, 0x00	; 0
	for(i = 0; i < 32; i++){
		if (i < 4){
    d694:	84 30       	cpi	r24, 0x04	; 4
    d696:	70 f4       	brcc	.+28     	; 0xd6b4 <Thread12+0x120>
			IR_HR_state.xbuf_DC[i] = 0L;
    d698:	1d 92       	st	X+, r1
    d69a:	1d 92       	st	X+, r1
    d69c:	1d 92       	st	X+, r1
    d69e:	1c 92       	st	X, r1
    d6a0:	13 97       	sbiw	r26, 0x03	; 3
			IR_HR_state.abuf_DC[i] = 0L;
    d6a2:	a0 58       	subi	r26, 0x80	; 128
    d6a4:	bf 4f       	sbci	r27, 0xFF	; 255
    d6a6:	1d 92       	st	X+, r1
    d6a8:	1d 92       	st	X+, r1
    d6aa:	1d 92       	st	X+, r1
    d6ac:	1c 92       	st	X, r1
    d6ae:	13 97       	sbiw	r26, 0x03	; 3
    d6b0:	a0 58       	subi	r26, 0x80	; 128
    d6b2:	b0 40       	sbci	r27, 0x00	; 0
		}	
		IR_HR_state.cbuf[i]= 0L;
    d6b4:	fc 01       	movw	r30, r24
    d6b6:	ee 0f       	add	r30, r30
    d6b8:	ff 1f       	adc	r31, r31
    d6ba:	ee 0f       	add	r30, r30
    d6bc:	ff 1f       	adc	r31, r31
    d6be:	e7 5b       	subi	r30, 0xB7	; 183
    d6c0:	ff 4e       	sbci	r31, 0xEF	; 239
    d6c2:	10 82       	st	Z, r1
    d6c4:	11 82       	std	Z+1, r1	; 0x01
    d6c6:	12 82       	std	Z+2, r1	; 0x02
    d6c8:	13 82       	std	Z+3, r1	; 0x03
    d6ca:	01 96       	adiw	r24, 0x01	; 1
    d6cc:	14 96       	adiw	r26, 0x04	; 4
	IR_HR_state.fiar = 0; //stands for five-in-a-row
	IR_HR_state.valley_min = 0L;
	IR_HR_state.peak_max = 0L;
	IR_HR_state.offset_DC = 0;
	IR_HR_state.offset_filt = 0;
	for(i = 0; i < 32; i++){
    d6ce:	80 32       	cpi	r24, 0x20	; 32
    d6d0:	91 05       	cpc	r25, r1
    d6d2:	01 f7       	brne	.-64     	; 0xd694 <Thread12+0x100>
		}	
		IR_HR_state.cbuf[i]= 0L;
	}

	
	chThdSleepMilliseconds(300);
    d6d4:	60 e7       	ldi	r22, 0x70	; 112
    d6d6:	77 e1       	ldi	r23, 0x17	; 23
    d6d8:	80 e0       	ldi	r24, 0x00	; 0
    d6da:	90 e0       	ldi	r25, 0x00	; 0
    d6dc:	0e 94 f4 08 	call	0x11e8	; 0x11e8 <chThdSleep>
	
	chSemWait(&i2cUSE);
    d6e0:	80 e0       	ldi	r24, 0x00	; 0
    d6e2:	94 e1       	ldi	r25, 0x14	; 20
    d6e4:	40 e0       	ldi	r20, 0x00	; 0
    d6e6:	50 e0       	ldi	r21, 0x00	; 0
    d6e8:	60 e0       	ldi	r22, 0x00	; 0
    d6ea:	70 e0       	ldi	r23, 0x00	; 0
    d6ec:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
	i2c_init();
    d6f0:	0e 94 8f 14 	call	0x291e	; 0x291e <i2c_init>
	if (!MAX30105_init()) {//Use default I2C port, 400kHz speed
    d6f4:	0e 94 ea 4a 	call	0x95d4	; 0x95d4 <MAX30105_init>
    d6f8:	88 23       	and	r24, r24
    d6fa:	11 f4       	brne	.+4      	; 0xd700 <Thread12+0x16c>
    d6fc:	0c 94 81 73 	jmp	0xe702	; 0xe702 <Thread12+0x116e>
    d700:	ba ec       	ldi	r27, 0xCA	; 202
    d702:	cb 2e       	mov	r12, r27
    d704:	b6 e0       	ldi	r27, 0x06	; 6
    d706:	db 2e       	mov	r13, r27
		chSemWait(&usartUSE);
		fprintf_P(&usart_out,PSTR("MAX30105 was not found. Please check wiring/power. \r\n"));
		chSemSignal(&usartUSE);
	}
	
	if (USART_HB_LOGGING_ON ==1){
    d708:	80 91 4f 05 	lds	r24, 0x054F
    d70c:	81 30       	cpi	r24, 0x01	; 1
    d70e:	09 f4       	brne	.+2      	; 0xd712 <Thread12+0x17e>
    d710:	f5 c7       	rjmp	.+4074   	; 0xe6fc <Thread12+0x1168>
	else {
		if (SD_HB_LOGGING_ON ==1){
			MAX30105_setup(0x3F, 4, 2, 400, 411, 4096); //Configure sensor with default settings
		}
		else {
			MAX30105_setup(0x3F, 4, 2, 400, 411, 4096); //Configure sensor with default settings
    d712:	8f e3       	ldi	r24, 0x3F	; 63
    d714:	64 e0       	ldi	r22, 0x04	; 4
    d716:	42 e0       	ldi	r20, 0x02	; 2
    d718:	20 e9       	ldi	r18, 0x90	; 144
    d71a:	31 e0       	ldi	r19, 0x01	; 1
    d71c:	0b e9       	ldi	r16, 0x9B	; 155
    d71e:	11 e0       	ldi	r17, 0x01	; 1
    d720:	e1 2c       	mov	r14, r1
    d722:	f0 e1       	ldi	r31, 0x10	; 16
    d724:	ff 2e       	mov	r15, r31
    d726:	0e 94 36 4d 	call	0x9a6c	; 0x9a6c <MAX30105_setup>
		}	
	}
	chSemSignal(&i2cUSE);
    d72a:	80 e0       	ldi	r24, 0x00	; 0
    d72c:	94 e1       	ldi	r25, 0x14	; 20
    d72e:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
	
	chSemWait(&usartUSE);
    d732:	87 ec       	ldi	r24, 0xC7	; 199
    d734:	90 e3       	ldi	r25, 0x30	; 48
    d736:	40 e0       	ldi	r20, 0x00	; 0
    d738:	50 e0       	ldi	r21, 0x00	; 0
    d73a:	60 e0       	ldi	r22, 0x00	; 0
    d73c:	70 e0       	ldi	r23, 0x00	; 0
    d73e:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
	fprintf_P(&usart_out,PSTR("MAX30105 set up .. lets go. \r\n"));
    d742:	00 d0       	rcall	.+0      	; 0xd744 <Thread12+0x1b0>
    d744:	00 d0       	rcall	.+0      	; 0xd746 <Thread12+0x1b2>
    d746:	ed b7       	in	r30, 0x3d	; 61
    d748:	fe b7       	in	r31, 0x3e	; 62
    d74a:	d2 82       	std	Z+2, r13	; 0x02
    d74c:	c1 82       	std	Z+1, r12	; 0x01
    d74e:	8a e2       	ldi	r24, 0x2A	; 42
    d750:	97 e0       	ldi	r25, 0x07	; 7
    d752:	94 83       	std	Z+4, r25	; 0x04
    d754:	83 83       	std	Z+3, r24	; 0x03
    d756:	0e 94 9a 82 	call	0x10534	; 0x10534 <fprintf_P>
	chSemSignal(&usartUSE);
    d75a:	0f 90       	pop	r0
    d75c:	0f 90       	pop	r0
    d75e:	0f 90       	pop	r0
    d760:	0f 90       	pop	r0
    d762:	87 ec       	ldi	r24, 0xC7	; 199
    d764:	90 e3       	ldi	r25, 0x30	; 48
    d766:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>

	//	immediately start to measure heartbeat - no coming back from this while loop
	chThdSleepMilliseconds(500);
    d76a:	60 e1       	ldi	r22, 0x10	; 16
    d76c:	77 e2       	ldi	r23, 0x27	; 39
    d76e:	80 e0       	ldi	r24, 0x00	; 0
    d770:	90 e0       	ldi	r25, 0x00	; 0
    d772:	0e 94 f4 08 	call	0x11e8	; 0x11e8 <chThdSleep>
	
	chSemWait(&sdUSE);	
    d776:	80 e0       	ldi	r24, 0x00	; 0
    d778:	96 e2       	ldi	r25, 0x26	; 38
    d77a:	40 e0       	ldi	r20, 0x00	; 0
    d77c:	50 e0       	ldi	r21, 0x00	; 0
    d77e:	60 e0       	ldi	r22, 0x00	; 0
    d780:	70 e0       	ldi	r23, 0x00	; 0
    d782:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
	chSemWait(&spiUSE);
    d786:	89 e7       	ldi	r24, 0x79	; 121
    d788:	94 e1       	ldi	r25, 0x14	; 20
    d78a:	40 e0       	ldi	r20, 0x00	; 0
    d78c:	50 e0       	ldi	r21, 0x00	; 0
    d78e:	60 e0       	ldi	r22, 0x00	; 0
    d790:	70 e0       	ldi	r23, 0x00	; 0
    d792:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
	res = disk_initialize(0);
    d796:	80 e0       	ldi	r24, 0x00	; 0
    d798:	0e 94 94 23 	call	0x4728	; 0x4728 <disk_initialize>
    d79c:	18 2f       	mov	r17, r24
	chSemSignal(&spiUSE);
    d79e:	89 e7       	ldi	r24, 0x79	; 121
    d7a0:	94 e1       	ldi	r25, 0x14	; 20
    d7a2:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
	
	chThdSleepMilliseconds(500);
    d7a6:	60 e1       	ldi	r22, 0x10	; 16
    d7a8:	77 e2       	ldi	r23, 0x27	; 39
    d7aa:	80 e0       	ldi	r24, 0x00	; 0
    d7ac:	90 e0       	ldi	r25, 0x00	; 0
    d7ae:	0e 94 f4 08 	call	0x11e8	; 0x11e8 <chThdSleep>
	
	chSemWait(&usartUSE);
    d7b2:	87 ec       	ldi	r24, 0xC7	; 199
    d7b4:	90 e3       	ldi	r25, 0x30	; 48
    d7b6:	40 e0       	ldi	r20, 0x00	; 0
    d7b8:	50 e0       	ldi	r21, 0x00	; 0
    d7ba:	60 e0       	ldi	r22, 0x00	; 0
    d7bc:	70 e0       	ldi	r23, 0x00	; 0
    d7be:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
	fprintf_P(&usart_out,PSTR("Disk Init: %d (0 = OK) \r\n"), res);
    d7c2:	00 d0       	rcall	.+0      	; 0xd7c4 <Thread12+0x230>
    d7c4:	00 d0       	rcall	.+0      	; 0xd7c6 <Thread12+0x232>
    d7c6:	00 d0       	rcall	.+0      	; 0xd7c8 <Thread12+0x234>
    d7c8:	ed b7       	in	r30, 0x3d	; 61
    d7ca:	fe b7       	in	r31, 0x3e	; 62
    d7cc:	31 96       	adiw	r30, 0x01	; 1
    d7ce:	ad b7       	in	r26, 0x3d	; 61
    d7d0:	be b7       	in	r27, 0x3e	; 62
    d7d2:	12 96       	adiw	r26, 0x02	; 2
    d7d4:	dc 92       	st	X, r13
    d7d6:	ce 92       	st	-X, r12
    d7d8:	11 97       	sbiw	r26, 0x01	; 1
    d7da:	80 e1       	ldi	r24, 0x10	; 16
    d7dc:	97 e0       	ldi	r25, 0x07	; 7
    d7de:	93 83       	std	Z+3, r25	; 0x03
    d7e0:	82 83       	std	Z+2, r24	; 0x02
    d7e2:	14 83       	std	Z+4, r17	; 0x04
    d7e4:	15 82       	std	Z+5, r1	; 0x05
    d7e6:	0e 94 9a 82 	call	0x10534	; 0x10534 <fprintf_P>
	chSemSignal(&usartUSE);
    d7ea:	ed b7       	in	r30, 0x3d	; 61
    d7ec:	fe b7       	in	r31, 0x3e	; 62
    d7ee:	36 96       	adiw	r30, 0x06	; 6
    d7f0:	0f b6       	in	r0, 0x3f	; 63
    d7f2:	f8 94       	cli
    d7f4:	fe bf       	out	0x3e, r31	; 62
    d7f6:	0f be       	out	0x3f, r0	; 63
    d7f8:	ed bf       	out	0x3d, r30	; 61
    d7fa:	87 ec       	ldi	r24, 0xC7	; 199
    d7fc:	90 e3       	ldi	r25, 0x30	; 48
    d7fe:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
	
	chSemWait(&spiUSE);
    d802:	89 e7       	ldi	r24, 0x79	; 121
    d804:	94 e1       	ldi	r25, 0x14	; 20
    d806:	40 e0       	ldi	r20, 0x00	; 0
    d808:	50 e0       	ldi	r21, 0x00	; 0
    d80a:	60 e0       	ldi	r22, 0x00	; 0
    d80c:	70 e0       	ldi	r23, 0x00	; 0
    d80e:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
	res = f_mount(0, &Fatfs[0]);
    d812:	80 e0       	ldi	r24, 0x00	; 0
    d814:	63 ed       	ldi	r22, 0xD3	; 211
    d816:	7b e0       	ldi	r23, 0x0B	; 11
    d818:	0e 94 60 26 	call	0x4cc0	; 0x4cc0 <f_mount>
    d81c:	18 2f       	mov	r17, r24
	chSemSignal(&spiUSE);
    d81e:	89 e7       	ldi	r24, 0x79	; 121
    d820:	94 e1       	ldi	r25, 0x14	; 20
    d822:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
	
	chThdSleepMilliseconds(500);
    d826:	60 e1       	ldi	r22, 0x10	; 16
    d828:	77 e2       	ldi	r23, 0x27	; 39
    d82a:	80 e0       	ldi	r24, 0x00	; 0
    d82c:	90 e0       	ldi	r25, 0x00	; 0
    d82e:	0e 94 f4 08 	call	0x11e8	; 0x11e8 <chThdSleep>
	
	chSemWait(&usartUSE);
    d832:	87 ec       	ldi	r24, 0xC7	; 199
    d834:	90 e3       	ldi	r25, 0x30	; 48
    d836:	40 e0       	ldi	r20, 0x00	; 0
    d838:	50 e0       	ldi	r21, 0x00	; 0
    d83a:	60 e0       	ldi	r22, 0x00	; 0
    d83c:	70 e0       	ldi	r23, 0x00	; 0
    d83e:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
	fprintf_P(&usart_out,PSTR("f_mount: %d (0 = OK) \r\n"), res);
    d842:	00 d0       	rcall	.+0      	; 0xd844 <Thread12+0x2b0>
    d844:	00 d0       	rcall	.+0      	; 0xd846 <Thread12+0x2b2>
    d846:	00 d0       	rcall	.+0      	; 0xd848 <Thread12+0x2b4>
    d848:	ed b7       	in	r30, 0x3d	; 61
    d84a:	fe b7       	in	r31, 0x3e	; 62
    d84c:	31 96       	adiw	r30, 0x01	; 1
    d84e:	ad b7       	in	r26, 0x3d	; 61
    d850:	be b7       	in	r27, 0x3e	; 62
    d852:	12 96       	adiw	r26, 0x02	; 2
    d854:	dc 92       	st	X, r13
    d856:	ce 92       	st	-X, r12
    d858:	11 97       	sbiw	r26, 0x01	; 1
    d85a:	88 ef       	ldi	r24, 0xF8	; 248
    d85c:	96 e0       	ldi	r25, 0x06	; 6
    d85e:	93 83       	std	Z+3, r25	; 0x03
    d860:	82 83       	std	Z+2, r24	; 0x02
    d862:	14 83       	std	Z+4, r17	; 0x04
    d864:	15 82       	std	Z+5, r1	; 0x05
    d866:	0e 94 9a 82 	call	0x10534	; 0x10534 <fprintf_P>
	chSemSignal(&usartUSE);
    d86a:	ed b7       	in	r30, 0x3d	; 61
    d86c:	fe b7       	in	r31, 0x3e	; 62
    d86e:	36 96       	adiw	r30, 0x06	; 6
    d870:	0f b6       	in	r0, 0x3f	; 63
    d872:	f8 94       	cli
    d874:	fe bf       	out	0x3e, r31	; 62
    d876:	0f be       	out	0x3f, r0	; 63
    d878:	ed bf       	out	0x3d, r30	; 61
    d87a:	87 ec       	ldi	r24, 0xC7	; 199
    d87c:	90 e3       	ldi	r25, 0x30	; 48
    d87e:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
	
	chSemWait(&spiUSE);
    d882:	89 e7       	ldi	r24, 0x79	; 121
    d884:	94 e1       	ldi	r25, 0x14	; 20
    d886:	40 e0       	ldi	r20, 0x00	; 0
    d888:	50 e0       	ldi	r21, 0x00	; 0
    d88a:	60 e0       	ldi	r22, 0x00	; 0
    d88c:	70 e0       	ldi	r23, 0x00	; 0
    d88e:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
	res = f_open(&fdst, "hrm_data.bin", FA_WRITE | FA_OPEN_ALWAYS);
    d892:	8e 01       	movw	r16, r28
    d894:	01 5e       	subi	r16, 0xE1	; 225
    d896:	1f 4f       	sbci	r17, 0xFF	; 255
    d898:	cb 57       	subi	r28, 0x7B	; 123
    d89a:	df 4f       	sbci	r29, 0xFF	; 255
    d89c:	19 83       	std	Y+1, r17	; 0x01
    d89e:	08 83       	st	Y, r16
    d8a0:	c5 58       	subi	r28, 0x85	; 133
    d8a2:	d0 40       	sbci	r29, 0x00	; 0
    d8a4:	c8 01       	movw	r24, r16
    d8a6:	6f ef       	ldi	r22, 0xFF	; 255
    d8a8:	74 e0       	ldi	r23, 0x04	; 4
    d8aa:	42 e1       	ldi	r20, 0x12	; 18
    d8ac:	0e 94 0c 3c 	call	0x7818	; 0x7818 <f_open>
    d8b0:	18 2f       	mov	r17, r24
	chSemSignal(&spiUSE);
    d8b2:	89 e7       	ldi	r24, 0x79	; 121
    d8b4:	94 e1       	ldi	r25, 0x14	; 20
    d8b6:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
	
	chThdSleepMilliseconds(500);		
    d8ba:	60 e1       	ldi	r22, 0x10	; 16
    d8bc:	77 e2       	ldi	r23, 0x27	; 39
    d8be:	80 e0       	ldi	r24, 0x00	; 0
    d8c0:	90 e0       	ldi	r25, 0x00	; 0
    d8c2:	0e 94 f4 08 	call	0x11e8	; 0x11e8 <chThdSleep>

	chSemWait(&usartUSE);
    d8c6:	87 ec       	ldi	r24, 0xC7	; 199
    d8c8:	90 e3       	ldi	r25, 0x30	; 48
    d8ca:	40 e0       	ldi	r20, 0x00	; 0
    d8cc:	50 e0       	ldi	r21, 0x00	; 0
    d8ce:	60 e0       	ldi	r22, 0x00	; 0
    d8d0:	70 e0       	ldi	r23, 0x00	; 0
    d8d2:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
	fprintf_P(&usart_out,PSTR("f_open: %d (0 = OK) \r\n"), res);
    d8d6:	00 d0       	rcall	.+0      	; 0xd8d8 <Thread12+0x344>
    d8d8:	00 d0       	rcall	.+0      	; 0xd8da <Thread12+0x346>
    d8da:	00 d0       	rcall	.+0      	; 0xd8dc <Thread12+0x348>
    d8dc:	ed b7       	in	r30, 0x3d	; 61
    d8de:	fe b7       	in	r31, 0x3e	; 62
    d8e0:	31 96       	adiw	r30, 0x01	; 1
    d8e2:	ad b7       	in	r26, 0x3d	; 61
    d8e4:	be b7       	in	r27, 0x3e	; 62
    d8e6:	12 96       	adiw	r26, 0x02	; 2
    d8e8:	dc 92       	st	X, r13
    d8ea:	ce 92       	st	-X, r12
    d8ec:	11 97       	sbiw	r26, 0x01	; 1
    d8ee:	81 ee       	ldi	r24, 0xE1	; 225
    d8f0:	96 e0       	ldi	r25, 0x06	; 6
    d8f2:	93 83       	std	Z+3, r25	; 0x03
    d8f4:	82 83       	std	Z+2, r24	; 0x02
    d8f6:	14 83       	std	Z+4, r17	; 0x04
    d8f8:	15 82       	std	Z+5, r1	; 0x05
    d8fa:	0e 94 9a 82 	call	0x10534	; 0x10534 <fprintf_P>
	chSemSignal(&usartUSE);
    d8fe:	ed b7       	in	r30, 0x3d	; 61
    d900:	fe b7       	in	r31, 0x3e	; 62
    d902:	36 96       	adiw	r30, 0x06	; 6
    d904:	0f b6       	in	r0, 0x3f	; 63
    d906:	f8 94       	cli
    d908:	fe bf       	out	0x3e, r31	; 62
    d90a:	0f be       	out	0x3f, r0	; 63
    d90c:	ed bf       	out	0x3d, r30	; 61
    d90e:	87 ec       	ldi	r24, 0xC7	; 199
    d910:	90 e3       	ldi	r25, 0x30	; 48
    d912:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
	
	chSemWait(&spiUSE);
    d916:	89 e7       	ldi	r24, 0x79	; 121
    d918:	94 e1       	ldi	r25, 0x14	; 20
    d91a:	40 e0       	ldi	r20, 0x00	; 0
    d91c:	50 e0       	ldi	r21, 0x00	; 0
    d91e:	60 e0       	ldi	r22, 0x00	; 0
    d920:	70 e0       	ldi	r23, 0x00	; 0
    d922:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
	res = f_lseek(&fdst, f_size(&fdst));
    d926:	49 a5       	ldd	r20, Y+41	; 0x29
    d928:	5a a5       	ldd	r21, Y+42	; 0x2a
    d92a:	6b a5       	ldd	r22, Y+43	; 0x2b
    d92c:	7c a5       	ldd	r23, Y+44	; 0x2c
    d92e:	ce 01       	movw	r24, r28
    d930:	4f 96       	adiw	r24, 0x1f	; 31
    d932:	0e 94 1d 2b 	call	0x563a	; 0x563a <f_lseek>
    d936:	18 2f       	mov	r17, r24
	chSemSignal(&spiUSE);
    d938:	89 e7       	ldi	r24, 0x79	; 121
    d93a:	94 e1       	ldi	r25, 0x14	; 20
    d93c:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
	
	chThdSleepMilliseconds(500);
    d940:	60 e1       	ldi	r22, 0x10	; 16
    d942:	77 e2       	ldi	r23, 0x27	; 39
    d944:	80 e0       	ldi	r24, 0x00	; 0
    d946:	90 e0       	ldi	r25, 0x00	; 0
    d948:	0e 94 f4 08 	call	0x11e8	; 0x11e8 <chThdSleep>
	
	chSemWait(&usartUSE);
    d94c:	87 ec       	ldi	r24, 0xC7	; 199
    d94e:	90 e3       	ldi	r25, 0x30	; 48
    d950:	40 e0       	ldi	r20, 0x00	; 0
    d952:	50 e0       	ldi	r21, 0x00	; 0
    d954:	60 e0       	ldi	r22, 0x00	; 0
    d956:	70 e0       	ldi	r23, 0x00	; 0
    d958:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
	fprintf_P(&usart_out,PSTR("f_lseek: %d (0 = OK) \r\n"), res);
    d95c:	00 d0       	rcall	.+0      	; 0xd95e <Thread12+0x3ca>
    d95e:	00 d0       	rcall	.+0      	; 0xd960 <Thread12+0x3cc>
    d960:	00 d0       	rcall	.+0      	; 0xd962 <Thread12+0x3ce>
    d962:	ed b7       	in	r30, 0x3d	; 61
    d964:	fe b7       	in	r31, 0x3e	; 62
    d966:	31 96       	adiw	r30, 0x01	; 1
    d968:	ad b7       	in	r26, 0x3d	; 61
    d96a:	be b7       	in	r27, 0x3e	; 62
    d96c:	12 96       	adiw	r26, 0x02	; 2
    d96e:	dc 92       	st	X, r13
    d970:	ce 92       	st	-X, r12
    d972:	11 97       	sbiw	r26, 0x01	; 1
    d974:	89 ec       	ldi	r24, 0xC9	; 201
    d976:	96 e0       	ldi	r25, 0x06	; 6
    d978:	93 83       	std	Z+3, r25	; 0x03
    d97a:	82 83       	std	Z+2, r24	; 0x02
    d97c:	14 83       	std	Z+4, r17	; 0x04
    d97e:	15 82       	std	Z+5, r1	; 0x05
    d980:	0e 94 9a 82 	call	0x10534	; 0x10534 <fprintf_P>
	chSemSignal(&usartUSE);
    d984:	ed b7       	in	r30, 0x3d	; 61
    d986:	fe b7       	in	r31, 0x3e	; 62
    d988:	36 96       	adiw	r30, 0x06	; 6
    d98a:	0f b6       	in	r0, 0x3f	; 63
    d98c:	f8 94       	cli
    d98e:	fe bf       	out	0x3e, r31	; 62
    d990:	0f be       	out	0x3f, r0	; 63
    d992:	ed bf       	out	0x3d, r30	; 61
    d994:	87 ec       	ldi	r24, 0xC7	; 199
    d996:	90 e3       	ldi	r25, 0x30	; 48
    d998:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
	
	chSemWait(&spiUSE);
    d99c:	89 e7       	ldi	r24, 0x79	; 121
    d99e:	94 e1       	ldi	r25, 0x14	; 20
    d9a0:	40 e0       	ldi	r20, 0x00	; 0
    d9a2:	50 e0       	ldi	r21, 0x00	; 0
    d9a4:	60 e0       	ldi	r22, 0x00	; 0
    d9a6:	70 e0       	ldi	r23, 0x00	; 0
    d9a8:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
	res = f_write(&fdst, "New data\r\n", 10, &bw); 
    d9ac:	ce 01       	movw	r24, r28
    d9ae:	4f 96       	adiw	r24, 0x1f	; 31
    d9b0:	6c e0       	ldi	r22, 0x0C	; 12
    d9b2:	75 e0       	ldi	r23, 0x05	; 5
    d9b4:	4a e0       	ldi	r20, 0x0A	; 10
    d9b6:	50 e0       	ldi	r21, 0x00	; 0
    d9b8:	9e 01       	movw	r18, r28
    d9ba:	2f 5f       	subi	r18, 0xFF	; 255
    d9bc:	3f 4f       	sbci	r19, 0xFF	; 255
    d9be:	0e 94 b7 32 	call	0x656e	; 0x656e <f_write>
    d9c2:	18 2f       	mov	r17, r24
	chSemSignal(&spiUSE);
    d9c4:	89 e7       	ldi	r24, 0x79	; 121
    d9c6:	94 e1       	ldi	r25, 0x14	; 20
    d9c8:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>

	chThdSleepMilliseconds(500);
    d9cc:	60 e1       	ldi	r22, 0x10	; 16
    d9ce:	77 e2       	ldi	r23, 0x27	; 39
    d9d0:	80 e0       	ldi	r24, 0x00	; 0
    d9d2:	90 e0       	ldi	r25, 0x00	; 0
    d9d4:	0e 94 f4 08 	call	0x11e8	; 0x11e8 <chThdSleep>
	
	chSemWait(&usartUSE);
    d9d8:	87 ec       	ldi	r24, 0xC7	; 199
    d9da:	90 e3       	ldi	r25, 0x30	; 48
    d9dc:	40 e0       	ldi	r20, 0x00	; 0
    d9de:	50 e0       	ldi	r21, 0x00	; 0
    d9e0:	60 e0       	ldi	r22, 0x00	; 0
    d9e2:	70 e0       	ldi	r23, 0x00	; 0
    d9e4:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
	fprintf_P(&usart_out,PSTR("f_write1: %d (0 = OK) \r\n"), res);
    d9e8:	00 d0       	rcall	.+0      	; 0xd9ea <Thread12+0x456>
    d9ea:	00 d0       	rcall	.+0      	; 0xd9ec <Thread12+0x458>
    d9ec:	00 d0       	rcall	.+0      	; 0xd9ee <Thread12+0x45a>
    d9ee:	ed b7       	in	r30, 0x3d	; 61
    d9f0:	fe b7       	in	r31, 0x3e	; 62
    d9f2:	31 96       	adiw	r30, 0x01	; 1
    d9f4:	ad b7       	in	r26, 0x3d	; 61
    d9f6:	be b7       	in	r27, 0x3e	; 62
    d9f8:	12 96       	adiw	r26, 0x02	; 2
    d9fa:	dc 92       	st	X, r13
    d9fc:	ce 92       	st	-X, r12
    d9fe:	11 97       	sbiw	r26, 0x01	; 1
    da00:	80 eb       	ldi	r24, 0xB0	; 176
    da02:	96 e0       	ldi	r25, 0x06	; 6
    da04:	93 83       	std	Z+3, r25	; 0x03
    da06:	82 83       	std	Z+2, r24	; 0x02
    da08:	14 83       	std	Z+4, r17	; 0x04
    da0a:	15 82       	std	Z+5, r1	; 0x05
    da0c:	0e 94 9a 82 	call	0x10534	; 0x10534 <fprintf_P>
	chSemSignal(&usartUSE);
    da10:	ed b7       	in	r30, 0x3d	; 61
    da12:	fe b7       	in	r31, 0x3e	; 62
    da14:	36 96       	adiw	r30, 0x06	; 6
    da16:	0f b6       	in	r0, 0x3f	; 63
    da18:	f8 94       	cli
    da1a:	fe bf       	out	0x3e, r31	; 62
    da1c:	0f be       	out	0x3f, r0	; 63
    da1e:	ed bf       	out	0x3d, r30	; 61
    da20:	87 ec       	ldi	r24, 0xC7	; 199
    da22:	90 e3       	ldi	r25, 0x30	; 48
    da24:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
		
	f_sync(&fdst);
    da28:	ce 01       	movw	r24, r28
    da2a:	4f 96       	adiw	r24, 0x1f	; 31
    da2c:	0e 94 4d 3e 	call	0x7c9a	; 0x7c9a <f_sync>
	chThdSleepMilliseconds(500);
    da30:	60 e1       	ldi	r22, 0x10	; 16
    da32:	77 e2       	ldi	r23, 0x27	; 39
    da34:	80 e0       	ldi	r24, 0x00	; 0
    da36:	90 e0       	ldi	r25, 0x00	; 0
    da38:	0e 94 f4 08 	call	0x11e8	; 0x11e8 <chThdSleep>
	chSemSignal(&sdUSE);
    da3c:	80 e0       	ldi	r24, 0x00	; 0
    da3e:	96 e2       	ldi	r25, 0x26	; 38
    da40:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
	
	xdev_out(usart_putchar_printf);
    da44:	80 e1       	ldi	r24, 0x10	; 16
    da46:	91 e2       	ldi	r25, 0x21	; 33
    da48:	90 93 93 09 	sts	0x0993, r25
    da4c:	80 93 92 09 	sts	0x0992, r24
	
	HB_baseline = chVTGetSystemTimeX();	 
    da50:	20 90 d2 07 	lds	r2, 0x07D2
    da54:	30 90 d3 07 	lds	r3, 0x07D3
    da58:	40 90 d4 07 	lds	r4, 0x07D4
    da5c:	50 90 d5 07 	lds	r5, 0x07D5
    da60:	cc 57       	subi	r28, 0x7C	; 124
    da62:	df 4f       	sbci	r29, 0xFF	; 255
    da64:	18 82       	st	Y, r1
    da66:	c4 58       	subi	r28, 0x84	; 132
    da68:	d0 40       	sbci	r29, 0x00	; 0
    da6a:	e5 e5       	ldi	r30, 0x55	; 85
    da6c:	6e 2e       	mov	r6, r30
    da6e:	71 2c       	mov	r7, r1
    da70:	81 2c       	mov	r8, r1
    da72:	91 2c       	mov	r9, r1
    da74:	c0 58       	subi	r28, 0x80	; 128
    da76:	df 4f       	sbci	r29, 0xFF	; 255
    da78:	18 82       	st	Y, r1
    da7a:	19 82       	std	Y+1, r1	; 0x01
    da7c:	1a 82       	std	Y+2, r1	; 0x02
    da7e:	1b 82       	std	Y+3, r1	; 0x03
    da80:	c0 58       	subi	r28, 0x80	; 128
    da82:	d0 40       	sbci	r29, 0x00	; 0
    da84:	c1 58       	subi	r28, 0x81	; 129
    da86:	df 4f       	sbci	r29, 0xFF	; 255
    da88:	18 82       	st	Y, r1
    da8a:	cf 57       	subi	r28, 0x7F	; 127
    da8c:	d0 40       	sbci	r29, 0x00	; 0
    da8e:	ef 96       	adiw	r28, 0x3f	; 63
    da90:	1f ae       	std	Y+63, r1	; 0x3f
    da92:	ef 97       	sbiw	r28, 0x3f	; 63
    da94:	ee 96       	adiw	r28, 0x3e	; 62
    da96:	1c ae       	std	Y+60, r1	; 0x3c
    da98:	1d ae       	std	Y+61, r1	; 0x3d
    da9a:	1e ae       	std	Y+62, r1	; 0x3e
    da9c:	1f ae       	std	Y+63, r1	; 0x3f
    da9e:	ee 97       	sbiw	r28, 0x3e	; 62
    daa0:	ea 96       	adiw	r28, 0x3a	; 58
    daa2:	1c ae       	std	Y+60, r1	; 0x3c
    daa4:	1d ae       	std	Y+61, r1	; 0x3d
    daa6:	1e ae       	std	Y+62, r1	; 0x3e
    daa8:	1f ae       	std	Y+63, r1	; 0x3f
    daaa:	ea 97       	sbiw	r28, 0x3a	; 58
    daac:	2e c0       	rjmp	.+92     	; 0xdb0a <Thread12+0x576>
		if(chEvtWaitAnyTimeout((eventmask_t)4, TIME_IMMEDIATE) == 4){
			just_entered=1;
		}
		
		// get current heartbeat 
		chSemWait(&i2cUSE);
    daae:	80 e0       	ldi	r24, 0x00	; 0
    dab0:	94 e1       	ldi	r25, 0x14	; 20
    dab2:	40 e0       	ldi	r20, 0x00	; 0
    dab4:	50 e0       	ldi	r21, 0x00	; 0
    dab6:	60 e0       	ldi	r22, 0x00	; 0
    dab8:	70 e0       	ldi	r23, 0x00	; 0
    daba:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
		p1 = MAX30105_getRedIR(LED_data_vector); 
    dabe:	84 e7       	ldi	r24, 0x74	; 116
    dac0:	97 e0       	ldi	r25, 0x07	; 7
    dac2:	0e 94 5a 4c 	call	0x98b4	; 0x98b4 <MAX30105_getRedIR>
    dac6:	60 93 7c 07 	sts	0x077C, r22
    daca:	70 93 7d 07 	sts	0x077D, r23
    dace:	80 93 7e 07 	sts	0x077E, r24
    dad2:	90 93 7f 07 	sts	0x077F, r25
		chSemSignal(&i2cUSE);
    dad6:	80 e0       	ldi	r24, 0x00	; 0
    dad8:	94 e1       	ldi	r25, 0x14	; 20
    dada:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
		if (p1 > 0){//new data
    dade:	80 91 7c 07 	lds	r24, 0x077C
    dae2:	90 91 7d 07 	lds	r25, 0x077D
    dae6:	a0 91 7e 07 	lds	r26, 0x077E
    daea:	b0 91 7f 07 	lds	r27, 0x077F
    daee:	00 97       	sbiw	r24, 0x00	; 0
    daf0:	a1 05       	cpc	r26, r1
    daf2:	b1 05       	cpc	r27, r1
    daf4:	79 f5       	brne	.+94     	; 0xdb54 <Thread12+0x5c0>
    daf6:	64 01       	movw	r12, r8
    daf8:	53 01       	movw	r10, r6
					IR_SPO2_state.status = 0;
					Red_SPO2_state.status = 0;
				}
			}//red detected
		}//if (p2 > 0) - new data
		chThdSleepMilliseconds(2);
    dafa:	68 e2       	ldi	r22, 0x28	; 40
    dafc:	70 e0       	ldi	r23, 0x00	; 0
    dafe:	80 e0       	ldi	r24, 0x00	; 0
    db00:	90 e0       	ldi	r25, 0x00	; 0
    db02:	0e 94 f4 08 	call	0x11e8	; 0x11e8 <chThdSleep>
    db06:	35 01       	movw	r6, r10
    db08:	46 01       	movw	r8, r12
	
	HB_baseline = chVTGetSystemTimeX();	 

	
	while (1) {	
		if(chEvtWaitAnyTimeout((eventmask_t)1, TIME_IMMEDIATE) == 1){
    db0a:	81 e0       	ldi	r24, 0x01	; 1
    db0c:	4f ef       	ldi	r20, 0xFF	; 255
    db0e:	5f ef       	ldi	r21, 0xFF	; 255
    db10:	6f ef       	ldi	r22, 0xFF	; 255
    db12:	7f ef       	ldi	r23, 0xFF	; 255
    db14:	0e 94 b4 08 	call	0x1168	; 0x1168 <chEvtWaitAnyTimeout>
    db18:	81 30       	cpi	r24, 0x01	; 1
    db1a:	09 f4       	brne	.+2      	; 0xdb1e <Thread12+0x58a>
    db1c:	3e c1       	rjmp	.+636    	; 0xdd9a <Thread12+0x806>
			chSemSignal(&spiUSE);
			chSemWait(&sdUSE);
			bmpDraw("img00001.bmp",0,0); 
			chSemSignal(&sdUSE);
		}
		if(chEvtWaitAnyTimeout((eventmask_t)2, TIME_IMMEDIATE) == 2){
    db1e:	82 e0       	ldi	r24, 0x02	; 2
    db20:	4f ef       	ldi	r20, 0xFF	; 255
    db22:	5f ef       	ldi	r21, 0xFF	; 255
    db24:	6f ef       	ldi	r22, 0xFF	; 255
    db26:	7f ef       	ldi	r23, 0xFF	; 255
    db28:	0e 94 b4 08 	call	0x1168	; 0x1168 <chEvtWaitAnyTimeout>
    db2c:	82 30       	cpi	r24, 0x02	; 2
    db2e:	09 f4       	brne	.+2      	; 0xdb32 <Thread12+0x59e>
    db30:	29 c1       	rjmp	.+594    	; 0xdd84 <Thread12+0x7f0>
			st7735_setTextSize(1);
			lcd_context_count[11] = 1; //reset to HB mode
			chSemSignal(&lcdUSE);//thread 12 releases LCD
		}
		
		if(chEvtWaitAnyTimeout((eventmask_t)4, TIME_IMMEDIATE) == 4){
    db32:	84 e0       	ldi	r24, 0x04	; 4
    db34:	4f ef       	ldi	r20, 0xFF	; 255
    db36:	5f ef       	ldi	r21, 0xFF	; 255
    db38:	6f ef       	ldi	r22, 0xFF	; 255
    db3a:	7f ef       	ldi	r23, 0xFF	; 255
    db3c:	0e 94 b4 08 	call	0x1168	; 0x1168 <chEvtWaitAnyTimeout>
    db40:	84 30       	cpi	r24, 0x04	; 4
    db42:	09 f0       	breq	.+2      	; 0xdb46 <Thread12+0x5b2>
    db44:	b4 cf       	rjmp	.-152    	; 0xdaae <Thread12+0x51a>
    db46:	11 e0       	ldi	r17, 0x01	; 1
    db48:	cc 57       	subi	r28, 0x7C	; 124
    db4a:	df 4f       	sbci	r29, 0xFF	; 255
    db4c:	18 83       	st	Y, r17
    db4e:	c4 58       	subi	r28, 0x84	; 132
    db50:	d0 40       	sbci	r29, 0x00	; 0
    db52:	ad cf       	rjmp	.-166    	; 0xdaae <Thread12+0x51a>
		// get current heartbeat 
		chSemWait(&i2cUSE);
		p1 = MAX30105_getRedIR(LED_data_vector); 
		chSemSignal(&i2cUSE);
		if (p1 > 0){//new data
			IR_result = checkForBeat(IR_LED_output, &IR_dc_avg, LED_data_vector[1], &IR_HR_state);//always
    db54:	20 91 78 07 	lds	r18, 0x0778
    db58:	30 91 79 07 	lds	r19, 0x0779
    db5c:	40 91 7a 07 	lds	r20, 0x077A
    db60:	50 91 7b 07 	lds	r21, 0x077B
    db64:	8a e5       	ldi	r24, 0x5A	; 90
    db66:	97 e0       	ldi	r25, 0x07	; 7
    db68:	6e e6       	ldi	r22, 0x6E	; 110
    db6a:	77 e0       	ldi	r23, 0x07	; 7
    db6c:	0a e3       	ldi	r16, 0x3A	; 58
    db6e:	1f e0       	ldi	r17, 0x0F	; 15
    db70:	0e 94 ef 46 	call	0x8dde	; 0x8dde <checkForBeat>
    db74:	80 93 73 07 	sts	0x0773, r24
			if (lcd_context_count[11] == 2) { // in SPO2 mode, need red
    db78:	80 91 3e 05 	lds	r24, 0x053E
    db7c:	82 30       	cpi	r24, 0x02	; 2
    db7e:	09 f4       	brne	.+2      	; 0xdb82 <Thread12+0x5ee>
    db80:	ec c2       	rjmp	.+1496   	; 0xe15a <Thread12+0xbc6>
				Red_result = checkForBeat(Red_LED_output, &Red_dc_avg, LED_data_vector[0], &Red_HR_state);
			}	
			/***********************************
			* logging
			***********************************/
			if ((USART_HB_LOGGING_ON ==1) || (SD_HB_LOGGING_ON ==1)){
    db82:	80 91 4f 05 	lds	r24, 0x054F
    db86:	81 30       	cpi	r24, 0x01	; 1
    db88:	09 f4       	brne	.+2      	; 0xdb8c <Thread12+0x5f8>
    db8a:	45 c1       	rjmp	.+650    	; 0xde16 <Thread12+0x882>
    db8c:	80 91 30 07 	lds	r24, 0x0730
    db90:	81 30       	cpi	r24, 0x01	; 1
    db92:	09 f4       	brne	.+2      	; 0xdb96 <Thread12+0x602>
    db94:	40 c1       	rjmp	.+640    	; 0xde16 <Thread12+0x882>
			}
			/***********************************
			* logging
			***********************************/
			
			if (IR_result == 1) { //found peak, happens rarely
    db96:	80 91 73 07 	lds	r24, 0x0773
    db9a:	81 30       	cpi	r24, 0x01	; 1
    db9c:	09 f4       	brne	.+2      	; 0xdba0 <Thread12+0x60c>
    db9e:	25 c2       	rjmp	.+1098   	; 0xdfea <Thread12+0xa56>
						}
					}	
				}//ms_elapsed > blanking_time
			}//IR_result==1, found peak
			else {//result = 0, didn't find peak, finish HB visualization
				ms_elapsed_since_last_right_now = ST2MS(chVTTimeElapsedSinceX(HB_baseline)) - ms_old_beat;
    dba0:	80 91 86 07 	lds	r24, 0x0786
    dba4:	90 91 87 07 	lds	r25, 0x0787
    dba8:	a0 91 88 07 	lds	r26, 0x0788
    dbac:	b0 91 89 07 	lds	r27, 0x0789
    dbb0:	51 e0       	ldi	r21, 0x01	; 1
    dbb2:	e5 2e       	mov	r14, r21
    dbb4:	f1 2c       	mov	r15, r1
    dbb6:	01 2d       	mov	r16, r1
    dbb8:	11 2d       	mov	r17, r1
    dbba:	e8 1a       	sub	r14, r24
    dbbc:	f9 0a       	sbc	r15, r25
    dbbe:	0a 0b       	sbc	r16, r26
    dbc0:	1b 0b       	sbc	r17, r27
    dbc2:	60 91 d2 07 	lds	r22, 0x07D2
    dbc6:	70 91 d3 07 	lds	r23, 0x07D3
    dbca:	80 91 d4 07 	lds	r24, 0x07D4
    dbce:	90 91 d5 07 	lds	r25, 0x07D5
    dbd2:	61 50       	subi	r22, 0x01	; 1
    dbd4:	70 40       	sbci	r23, 0x00	; 0
    dbd6:	80 40       	sbci	r24, 0x00	; 0
    dbd8:	90 40       	sbci	r25, 0x00	; 0
    dbda:	62 19       	sub	r22, r2
    dbdc:	73 09       	sbc	r23, r3
    dbde:	84 09       	sbc	r24, r4
    dbe0:	95 09       	sbc	r25, r5
    dbe2:	24 e1       	ldi	r18, 0x14	; 20
    dbe4:	30 e0       	ldi	r19, 0x00	; 0
    dbe6:	40 e0       	ldi	r20, 0x00	; 0
    dbe8:	50 e0       	ldi	r21, 0x00	; 0
    dbea:	0e 94 0d 80 	call	0x1001a	; 0x1001a <__udivmodsi4>
    dbee:	e2 0e       	add	r14, r18
    dbf0:	f3 1e       	adc	r15, r19
    dbf2:	04 1f       	adc	r16, r20
    dbf4:	15 1f       	adc	r17, r21
    dbf6:	e0 92 8e 07 	sts	0x078E, r14
    dbfa:	f0 92 8f 07 	sts	0x078F, r15
    dbfe:	00 93 90 07 	sts	0x0790, r16
    dc02:	10 93 91 07 	sts	0x0791, r17
				// HEART BEAT LCD FLASHER - LOGIC
				if (( HB_ON == 1) && (ms_elapsed_since_last_right_now > ((ms_elapsed_since_last)>>2))) {
    dc06:	80 91 80 07 	lds	r24, 0x0780
    dc0a:	81 30       	cpi	r24, 0x01	; 1
    dc0c:	09 f4       	brne	.+2      	; 0xdc10 <Thread12+0x67c>
    dc0e:	53 c2       	rjmp	.+1190   	; 0xe0b6 <Thread12+0xb22>
						if (lcd_context_count[11] == 1) { // in HB mode
							chSemWait(&spiUSE);
							st7735_setCursor(35,86);
							st7735_setTextSize(2);
							fprintf_P(&st7735_out,PSTR(" "));
							chSemSignal(&spiUSE);
    dc10:	64 01       	movw	r12, r8
    dc12:	53 01       	movw	r10, r6
						}
					}	
				}
			}

			if ((lcd_context_count[11] == 2)&&(IR_SPO2_state.status == 1)&&(Red_result == 1)){ //SPO2, in a good HB regime, IR SPO2 is good, Red found 
    dc14:	80 91 3e 05 	lds	r24, 0x053E
    dc18:	82 30       	cpi	r24, 0x02	; 2
    dc1a:	09 f0       	breq	.+2      	; 0xdc1e <Thread12+0x68a>
    dc1c:	6e cf       	rjmp	.-292    	; 0xdafa <Thread12+0x566>
    dc1e:	ef 96       	adiw	r28, 0x3f	; 63
    dc20:	0f ad       	ldd	r16, Y+63	; 0x3f
    dc22:	ef 97       	sbiw	r28, 0x3f	; 63
    dc24:	01 30       	cpi	r16, 0x01	; 1
    dc26:	09 f0       	breq	.+2      	; 0xdc2a <Thread12+0x696>
    dc28:	68 cf       	rjmp	.-304    	; 0xdafa <Thread12+0x566>
    dc2a:	80 91 72 07 	lds	r24, 0x0772
    dc2e:	81 30       	cpi	r24, 0x01	; 1
    dc30:	09 f0       	breq	.+2      	; 0xdc34 <Thread12+0x6a0>
    dc32:	63 cf       	rjmp	.-314    	; 0xdafa <Thread12+0x566>
				Red_SPO2_state.status = 1;
				if (Red_SPO2_state.status == 1) {//calculate SPO2
					//calculate SPO2
					R1 = (100L*Red_SPO2_state.spread)/IR_SPO2_state.spread;
					R2 = (100L*IR_SPO2_state.baseline)/Red_SPO2_state.baseline;
					R = (R1*R2)/10L;
    dc34:	ea 96       	adiw	r28, 0x3a	; 58
    dc36:	6c ad       	ldd	r22, Y+60	; 0x3c
    dc38:	7d ad       	ldd	r23, Y+61	; 0x3d
    dc3a:	8e ad       	ldd	r24, Y+62	; 0x3e
    dc3c:	9f ad       	ldd	r25, Y+63	; 0x3f
    dc3e:	ea 97       	sbiw	r28, 0x3a	; 58
    dc40:	24 e6       	ldi	r18, 0x64	; 100
    dc42:	30 e0       	ldi	r19, 0x00	; 0
    dc44:	40 e0       	ldi	r20, 0x00	; 0
    dc46:	50 e0       	ldi	r21, 0x00	; 0
    dc48:	0e 94 bb 7f 	call	0xff76	; 0xff76 <__mulsi3>
    dc4c:	20 91 6a 07 	lds	r18, 0x076A
    dc50:	30 91 6b 07 	lds	r19, 0x076B
    dc54:	40 91 6c 07 	lds	r20, 0x076C
    dc58:	50 91 6d 07 	lds	r21, 0x076D
    dc5c:	0e 94 2f 80 	call	0x1005e	; 0x1005e <__divmodsi4>
    dc60:	79 01       	movw	r14, r18
    dc62:	8a 01       	movw	r16, r20
    dc64:	60 91 41 2f 	lds	r22, 0x2F41
    dc68:	70 91 42 2f 	lds	r23, 0x2F42
    dc6c:	80 91 43 2f 	lds	r24, 0x2F43
    dc70:	90 91 44 2f 	lds	r25, 0x2F44
    dc74:	20 91 3d 2f 	lds	r18, 0x2F3D
    dc78:	30 91 3e 2f 	lds	r19, 0x2F3E
    dc7c:	40 91 3f 2f 	lds	r20, 0x2F3F
    dc80:	50 91 40 2f 	lds	r21, 0x2F40
    dc84:	62 1b       	sub	r22, r18
    dc86:	73 0b       	sbc	r23, r19
    dc88:	84 0b       	sbc	r24, r20
    dc8a:	95 0b       	sbc	r25, r21
    dc8c:	24 e6       	ldi	r18, 0x64	; 100
    dc8e:	30 e0       	ldi	r19, 0x00	; 0
    dc90:	40 e0       	ldi	r20, 0x00	; 0
    dc92:	50 e0       	ldi	r21, 0x00	; 0
    dc94:	0e 94 bb 7f 	call	0xff76	; 0xff76 <__mulsi3>
    dc98:	ee 96       	adiw	r28, 0x3e	; 62
    dc9a:	2c ad       	ldd	r18, Y+60	; 0x3c
    dc9c:	3d ad       	ldd	r19, Y+61	; 0x3d
    dc9e:	4e ad       	ldd	r20, Y+62	; 0x3e
    dca0:	5f ad       	ldd	r21, Y+63	; 0x3f
    dca2:	ee 97       	sbiw	r28, 0x3e	; 62
    dca4:	0e 94 2f 80 	call	0x1005e	; 0x1005e <__divmodsi4>
    dca8:	c8 01       	movw	r24, r16
    dcaa:	b7 01       	movw	r22, r14
    dcac:	0e 94 bb 7f 	call	0xff76	; 0xff76 <__mulsi3>
    dcb0:	2a e0       	ldi	r18, 0x0A	; 10
    dcb2:	30 e0       	ldi	r19, 0x00	; 0
    dcb4:	40 e0       	ldi	r20, 0x00	; 0
    dcb6:	50 e0       	ldi	r21, 0x00	; 0
    dcb8:	0e 94 2f 80 	call	0x1005e	; 0x1005e <__divmodsi4>
    dcbc:	79 01       	movw	r14, r18
    dcbe:	8a 01       	movw	r16, r20
					if ((R>300L) && (R<2300L)){
    dcc0:	d8 01       	movw	r26, r16
    dcc2:	c7 01       	movw	r24, r14
    dcc4:	8d 52       	subi	r24, 0x2D	; 45
    dcc6:	91 40       	sbci	r25, 0x01	; 1
    dcc8:	a0 40       	sbci	r26, 0x00	; 0
    dcca:	b0 40       	sbci	r27, 0x00	; 0
    dccc:	8f 5c       	subi	r24, 0xCF	; 207
    dcce:	97 40       	sbci	r25, 0x07	; 7
    dcd0:	a0 40       	sbci	r26, 0x00	; 0
    dcd2:	b0 40       	sbci	r27, 0x00	; 0
    dcd4:	c0 f5       	brcc	.+112    	; 0xdd46 <Thread12+0x7b2>
						//SPO2 = 106900L - ((39L*R)/10L) - ((156L*R*R)/10000L);
						SPO2 = 110000L - 25L*R; //simpler to start
    dcd6:	c8 01       	movw	r24, r16
    dcd8:	b7 01       	movw	r22, r14
    dcda:	27 ee       	ldi	r18, 0xE7	; 231
    dcdc:	3f ef       	ldi	r19, 0xFF	; 255
    dcde:	4f ef       	ldi	r20, 0xFF	; 255
    dce0:	5f ef       	ldi	r21, 0xFF	; 255
    dce2:	0e 94 bb 7f 	call	0xff76	; 0xff76 <__mulsi3>
    dce6:	60 55       	subi	r22, 0x50	; 80
    dce8:	72 45       	sbci	r23, 0x52	; 82
    dcea:	8e 4f       	sbci	r24, 0xFE	; 254
    dcec:	9f 4f       	sbci	r25, 0xFF	; 255
						SPO2 /= 1000L;
						//fill and average circular buffer
						SPO2_circular_buffer[SPO2_circular_buffer_index] = SPO2;
    dcee:	c1 58       	subi	r28, 0x81	; 129
    dcf0:	df 4f       	sbci	r29, 0xFF	; 255
    dcf2:	38 81       	ld	r19, Y
    dcf4:	cf 57       	subi	r28, 0x7F	; 127
    dcf6:	d0 40       	sbci	r29, 0x00	; 0
    dcf8:	03 2f       	mov	r16, r19
    dcfa:	10 e0       	ldi	r17, 0x00	; 0
    dcfc:	00 0f       	add	r16, r16
    dcfe:	11 1f       	adc	r17, r17
    dd00:	00 0f       	add	r16, r16
    dd02:	11 1f       	adc	r17, r17
    dd04:	41 e0       	ldi	r20, 0x01	; 1
    dd06:	50 e0       	ldi	r21, 0x00	; 0
    dd08:	4c 0f       	add	r20, r28
    dd0a:	5d 1f       	adc	r21, r29
    dd0c:	04 0f       	add	r16, r20
    dd0e:	15 1f       	adc	r17, r21
    dd10:	28 ee       	ldi	r18, 0xE8	; 232
    dd12:	33 e0       	ldi	r19, 0x03	; 3
    dd14:	40 e0       	ldi	r20, 0x00	; 0
    dd16:	50 e0       	ldi	r21, 0x00	; 0
    dd18:	0e 94 2f 80 	call	0x1005e	; 0x1005e <__divmodsi4>
    dd1c:	d8 01       	movw	r26, r16
    dd1e:	12 96       	adiw	r26, 0x02	; 2
    dd20:	2d 93       	st	X+, r18
    dd22:	3d 93       	st	X+, r19
    dd24:	4d 93       	st	X+, r20
    dd26:	5c 93       	st	X, r21
    dd28:	15 97       	sbiw	r26, 0x05	; 5
						SPO2_circular_buffer_index++;
						SPO2_circular_buffer_index %= 7; //Wrap condition
    dd2a:	c1 58       	subi	r28, 0x81	; 129
    dd2c:	df 4f       	sbci	r29, 0xFF	; 255
    dd2e:	88 81       	ld	r24, Y
    dd30:	cf 57       	subi	r28, 0x7F	; 127
    dd32:	d0 40       	sbci	r29, 0x00	; 0
    dd34:	8f 5f       	subi	r24, 0xFF	; 255
    dd36:	67 e0       	ldi	r22, 0x07	; 7
    dd38:	0e 94 da 7f 	call	0xffb4	; 0xffb4 <__udivmodqi4>
    dd3c:	c1 58       	subi	r28, 0x81	; 129
    dd3e:	df 4f       	sbci	r29, 0xFF	; 255
    dd40:	98 83       	st	Y, r25
    dd42:	cf 57       	subi	r28, 0x7F	; 127
    dd44:	d0 40       	sbci	r29, 0x00	; 0
    dd46:	fe 01       	movw	r30, r28
    dd48:	33 96       	adiw	r30, 0x03	; 3
    dd4a:	66 24       	eor	r6, r6
    dd4c:	77 24       	eor	r7, r7
    dd4e:	43 01       	movw	r8, r6
					}
					SPO2_sum = 0L;
					for(SPO2_index = 0; SPO2_index < 7; SPO2_index++){
						SPO2_sum += SPO2_circular_buffer[SPO2_index];
    dd50:	81 91       	ld	r24, Z+
    dd52:	91 91       	ld	r25, Z+
    dd54:	a1 91       	ld	r26, Z+
    dd56:	b1 91       	ld	r27, Z+
    dd58:	68 0e       	add	r6, r24
    dd5a:	79 1e       	adc	r7, r25
    dd5c:	8a 1e       	adc	r8, r26
    dd5e:	9b 1e       	adc	r9, r27
						SPO2_circular_buffer[SPO2_circular_buffer_index] = SPO2;
						SPO2_circular_buffer_index++;
						SPO2_circular_buffer_index %= 7; //Wrap condition
					}
					SPO2_sum = 0L;
					for(SPO2_index = 0; SPO2_index < 7; SPO2_index++){
    dd60:	cb 57       	subi	r28, 0x7B	; 123
    dd62:	df 4f       	sbci	r29, 0xFF	; 255
    dd64:	e8 80       	ld	r14, Y
    dd66:	f9 80       	ldd	r15, Y+1	; 0x01
    dd68:	c5 58       	subi	r28, 0x85	; 133
    dd6a:	d0 40       	sbci	r29, 0x00	; 0
    dd6c:	ee 15       	cp	r30, r14
    dd6e:	ff 05       	cpc	r31, r15
    dd70:	79 f7       	brne	.-34     	; 0xdd50 <Thread12+0x7bc>
						SPO2_sum += SPO2_circular_buffer[SPO2_index];
					}
					SPO2_sum /= 7L;
					if(lcd_context ==12){
    dd72:	80 91 32 05 	lds	r24, 0x0532
    dd76:	8c 30       	cpi	r24, 0x0C	; 12
    dd78:	09 f4       	brne	.+2      	; 0xdd7c <Thread12+0x7e8>
    dd7a:	56 c4       	rjmp	.+2220   	; 0xe628 <Thread12+0x1094>
						st7735_setTextSize(2);
						fprintf_P(&st7735_out,PSTR(" "));
						st7735_setCursor(50,86);
						st7735_setTextSize(3);
						fprintf_P(&st7735_out,PSTR("%3ld"), SPO2_sum);
						chSemSignal(&spiUSE);
    dd7c:	ef 96       	adiw	r28, 0x3f	; 63
    dd7e:	1f ae       	std	Y+63, r1	; 0x3f
    dd80:	ef 97       	sbiw	r28, 0x3f	; 63
    dd82:	bb ce       	rjmp	.-650    	; 0xdafa <Thread12+0x566>
			chSemWait(&sdUSE);
			bmpDraw("img00001.bmp",0,0); 
			chSemSignal(&sdUSE);
		}
		if(chEvtWaitAnyTimeout((eventmask_t)2, TIME_IMMEDIATE) == 2){
			st7735_setTextSize(1);
    dd84:	81 e0       	ldi	r24, 0x01	; 1
    dd86:	0e 94 cb 19 	call	0x3396	; 0x3396 <st7735_setTextSize>
			lcd_context_count[11] = 1; //reset to HB mode
    dd8a:	81 e0       	ldi	r24, 0x01	; 1
    dd8c:	80 93 3e 05 	sts	0x053E, r24
			chSemSignal(&lcdUSE);//thread 12 releases LCD
    dd90:	8d ef       	ldi	r24, 0xFD	; 253
    dd92:	93 e1       	ldi	r25, 0x13	; 19
    dd94:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
    dd98:	cc ce       	rjmp	.-616    	; 0xdb32 <Thread12+0x59e>
	HB_baseline = chVTGetSystemTimeX();	 

	
	while (1) {	
		if(chEvtWaitAnyTimeout((eventmask_t)1, TIME_IMMEDIATE) == 1){
			chSemWait(&lcdUSE); //grab the lcd/
    dd9a:	8d ef       	ldi	r24, 0xFD	; 253
    dd9c:	93 e1       	ldi	r25, 0x13	; 19
    dd9e:	40 e0       	ldi	r20, 0x00	; 0
    dda0:	50 e0       	ldi	r21, 0x00	; 0
    dda2:	60 e0       	ldi	r22, 0x00	; 0
    dda4:	70 e0       	ldi	r23, 0x00	; 0
    dda6:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
			//switch lcd_context to thread 5
			lcd_context = 12;
    ddaa:	fc e0       	ldi	r31, 0x0C	; 12
    ddac:	f0 93 32 05 	sts	0x0532, r31
			just_entered = 1;
			chSemWait(&spiUSE);
    ddb0:	89 e7       	ldi	r24, 0x79	; 121
    ddb2:	94 e1       	ldi	r25, 0x14	; 20
    ddb4:	40 e0       	ldi	r20, 0x00	; 0
    ddb6:	50 e0       	ldi	r21, 0x00	; 0
    ddb8:	60 e0       	ldi	r22, 0x00	; 0
    ddba:	70 e0       	ldi	r23, 0x00	; 0
    ddbc:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
			st7735_fill_rect(0, 0, 160, 128, ST7735_COLOR_BLACK);//lcd_clear();
    ddc0:	80 e0       	ldi	r24, 0x00	; 0
    ddc2:	60 e0       	ldi	r22, 0x00	; 0
    ddc4:	40 ea       	ldi	r20, 0xA0	; 160
    ddc6:	20 e8       	ldi	r18, 0x80	; 128
    ddc8:	00 e0       	ldi	r16, 0x00	; 0
    ddca:	10 e0       	ldi	r17, 0x00	; 0
    ddcc:	0e 94 59 16 	call	0x2cb2	; 0x2cb2 <st7735_fill_rect>
			st7735_setCursor(5,10);
    ddd0:	85 e0       	ldi	r24, 0x05	; 5
    ddd2:	90 e0       	ldi	r25, 0x00	; 0
    ddd4:	6a e0       	ldi	r22, 0x0A	; 10
    ddd6:	70 e0       	ldi	r23, 0x00	; 0
    ddd8:	0e 94 c2 19 	call	0x3384	; 0x3384 <st7735_setCursor>
			chSemSignal(&spiUSE);
    dddc:	89 e7       	ldi	r24, 0x79	; 121
    ddde:	94 e1       	ldi	r25, 0x14	; 20
    dde0:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
			chSemWait(&sdUSE);
    dde4:	80 e0       	ldi	r24, 0x00	; 0
    dde6:	96 e2       	ldi	r25, 0x26	; 38
    dde8:	40 e0       	ldi	r20, 0x00	; 0
    ddea:	50 e0       	ldi	r21, 0x00	; 0
    ddec:	60 e0       	ldi	r22, 0x00	; 0
    ddee:	70 e0       	ldi	r23, 0x00	; 0
    ddf0:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
			bmpDraw("img00001.bmp",0,0); 
    ddf4:	87 e1       	ldi	r24, 0x17	; 23
    ddf6:	95 e0       	ldi	r25, 0x05	; 5
    ddf8:	60 e0       	ldi	r22, 0x00	; 0
    ddfa:	40 e0       	ldi	r20, 0x00	; 0
    ddfc:	0e 94 2d 67 	call	0xce5a	; 0xce5a <bmpDraw>
			chSemSignal(&sdUSE);
    de00:	80 e0       	ldi	r24, 0x00	; 0
    de02:	96 e2       	ldi	r25, 0x26	; 38
    de04:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
    de08:	01 e0       	ldi	r16, 0x01	; 1
    de0a:	cc 57       	subi	r28, 0x7C	; 124
    de0c:	df 4f       	sbci	r29, 0xFF	; 255
    de0e:	08 83       	st	Y, r16
    de10:	c4 58       	subi	r28, 0x84	; 132
    de12:	d0 40       	sbci	r29, 0x00	; 0
    de14:	84 ce       	rjmp	.-760    	; 0xdb1e <Thread12+0x58a>
			/***********************************
			* logging
			***********************************/
			if ((USART_HB_LOGGING_ON ==1) || (SD_HB_LOGGING_ON ==1)){
				time_now = ST2MS(chVTTimeElapsedSinceX(HB_baseline));	//MS_2ST
				xsprintf_P(data_string, PSTR("%010lu,%11ld,%11ld,%11ld,%1u,%3ld\r\n"), time_now, LED_data_vector[1], IR_dc_avg, IR_LED_output[0], IR_result,current_HB_estimate); 
    de16:	2d b7       	in	r18, 0x3d	; 61
    de18:	3e b7       	in	r19, 0x3e	; 62
    de1a:	2a 51       	subi	r18, 0x1A	; 26
    de1c:	30 40       	sbci	r19, 0x00	; 0
    de1e:	0f b6       	in	r0, 0x3f	; 63
    de20:	f8 94       	cli
    de22:	3e bf       	out	0x3e, r19	; 62
    de24:	0f be       	out	0x3f, r0	; 63
    de26:	2d bf       	out	0x3d, r18	; 61
    de28:	0d b7       	in	r16, 0x3d	; 61
    de2a:	1e b7       	in	r17, 0x3e	; 62
    de2c:	0f 5f       	subi	r16, 0xFF	; 255
    de2e:	1f 4f       	sbci	r17, 0xFF	; 255
    de30:	ef e3       	ldi	r30, 0x3F	; 63
    de32:	f0 e0       	ldi	r31, 0x00	; 0
    de34:	ec 0f       	add	r30, r28
    de36:	fd 1f       	adc	r31, r29
    de38:	ad b7       	in	r26, 0x3d	; 61
    de3a:	be b7       	in	r27, 0x3e	; 62
    de3c:	12 96       	adiw	r26, 0x02	; 2
    de3e:	fc 93       	st	X, r31
    de40:	ee 93       	st	-X, r30
    de42:	11 97       	sbiw	r26, 0x01	; 1
    de44:	ec e8       	ldi	r30, 0x8C	; 140
    de46:	f6 e0       	ldi	r31, 0x06	; 6
    de48:	d8 01       	movw	r26, r16
    de4a:	13 96       	adiw	r26, 0x03	; 3
    de4c:	fc 93       	st	X, r31
    de4e:	ee 93       	st	-X, r30
    de50:	12 97       	sbiw	r26, 0x02	; 2
    de52:	60 91 d2 07 	lds	r22, 0x07D2
    de56:	70 91 d3 07 	lds	r23, 0x07D3
    de5a:	80 91 d4 07 	lds	r24, 0x07D4
    de5e:	90 91 d5 07 	lds	r25, 0x07D5
    de62:	61 50       	subi	r22, 0x01	; 1
    de64:	70 40       	sbci	r23, 0x00	; 0
    de66:	80 40       	sbci	r24, 0x00	; 0
    de68:	90 40       	sbci	r25, 0x00	; 0
    de6a:	62 19       	sub	r22, r2
    de6c:	73 09       	sbc	r23, r3
    de6e:	84 09       	sbc	r24, r4
    de70:	95 09       	sbc	r25, r5
    de72:	24 e1       	ldi	r18, 0x14	; 20
    de74:	30 e0       	ldi	r19, 0x00	; 0
    de76:	40 e0       	ldi	r20, 0x00	; 0
    de78:	50 e0       	ldi	r21, 0x00	; 0
    de7a:	0e 94 0d 80 	call	0x1001a	; 0x1001a <__udivmodsi4>
    de7e:	2f 5f       	subi	r18, 0xFF	; 255
    de80:	3f 4f       	sbci	r19, 0xFF	; 255
    de82:	4f 4f       	sbci	r20, 0xFF	; 255
    de84:	5f 4f       	sbci	r21, 0xFF	; 255
    de86:	d8 01       	movw	r26, r16
    de88:	14 96       	adiw	r26, 0x04	; 4
    de8a:	2d 93       	st	X+, r18
    de8c:	3d 93       	st	X+, r19
    de8e:	4d 93       	st	X+, r20
    de90:	5c 93       	st	X, r21
    de92:	17 97       	sbiw	r26, 0x07	; 7
    de94:	80 91 78 07 	lds	r24, 0x0778
    de98:	90 91 79 07 	lds	r25, 0x0779
    de9c:	a0 91 7a 07 	lds	r26, 0x077A
    dea0:	b0 91 7b 07 	lds	r27, 0x077B
    dea4:	f8 01       	movw	r30, r16
    dea6:	80 87       	std	Z+8, r24	; 0x08
    dea8:	91 87       	std	Z+9, r25	; 0x09
    deaa:	a2 87       	std	Z+10, r26	; 0x0a
    deac:	b3 87       	std	Z+11, r27	; 0x0b
    deae:	80 91 6e 07 	lds	r24, 0x076E
    deb2:	90 91 6f 07 	lds	r25, 0x076F
    deb6:	a0 91 70 07 	lds	r26, 0x0770
    deba:	b0 91 71 07 	lds	r27, 0x0771
    debe:	84 87       	std	Z+12, r24	; 0x0c
    dec0:	95 87       	std	Z+13, r25	; 0x0d
    dec2:	a6 87       	std	Z+14, r26	; 0x0e
    dec4:	b7 87       	std	Z+15, r27	; 0x0f
    dec6:	80 91 5a 07 	lds	r24, 0x075A
    deca:	90 91 5b 07 	lds	r25, 0x075B
    dece:	a0 91 5c 07 	lds	r26, 0x075C
    ded2:	b0 91 5d 07 	lds	r27, 0x075D
    ded6:	80 8b       	std	Z+16, r24	; 0x10
    ded8:	91 8b       	std	Z+17, r25	; 0x11
    deda:	a2 8b       	std	Z+18, r26	; 0x12
    dedc:	b3 8b       	std	Z+19, r27	; 0x13
    dede:	80 91 73 07 	lds	r24, 0x0773
    dee2:	84 8b       	std	Z+20, r24	; 0x14
    dee4:	15 8a       	std	Z+21, r1	; 0x15
    dee6:	c0 58       	subi	r28, 0x80	; 128
    dee8:	df 4f       	sbci	r29, 0xFF	; 255
    deea:	28 81       	ld	r18, Y
    deec:	39 81       	ldd	r19, Y+1	; 0x01
    deee:	4a 81       	ldd	r20, Y+2	; 0x02
    def0:	5b 81       	ldd	r21, Y+3	; 0x03
    def2:	c0 58       	subi	r28, 0x80	; 128
    def4:	d0 40       	sbci	r29, 0x00	; 0
    def6:	d8 01       	movw	r26, r16
    def8:	56 96       	adiw	r26, 0x16	; 22
    defa:	2d 93       	st	X+, r18
    defc:	3d 93       	st	X+, r19
    defe:	4d 93       	st	X+, r20
    df00:	5c 93       	st	X, r21
    df02:	59 97       	sbiw	r26, 0x19	; 25
    df04:	0e 94 b3 1f 	call	0x3f66	; 0x3f66 <xsprintf_P>
//				sprintf_P(data_string, PSTR("%010lu,% 011ld,% 011ld,% 011ld,%01u,%03u\r\n"), time_now, IR_SPO2_state.spread, Red_SPO2_state.spread, R,IR_result,current_HB_estimate); 
			}
			 
			if (USART_HB_LOGGING_ON ==1){
    df08:	ed b7       	in	r30, 0x3d	; 61
    df0a:	fe b7       	in	r31, 0x3e	; 62
    df0c:	7a 96       	adiw	r30, 0x1a	; 26
    df0e:	0f b6       	in	r0, 0x3f	; 63
    df10:	f8 94       	cli
    df12:	fe bf       	out	0x3e, r31	; 62
    df14:	0f be       	out	0x3f, r0	; 63
    df16:	ed bf       	out	0x3d, r30	; 61
    df18:	80 91 4f 05 	lds	r24, 0x054F
    df1c:	81 30       	cpi	r24, 0x01	; 1
    df1e:	99 f5       	brne	.+102    	; 0xdf86 <Thread12+0x9f2>
				chSemWait(&usartUSE);
    df20:	87 ec       	ldi	r24, 0xC7	; 199
    df22:	90 e3       	ldi	r25, 0x30	; 48
    df24:	40 e0       	ldi	r20, 0x00	; 0
    df26:	50 e0       	ldi	r21, 0x00	; 0
    df28:	60 e0       	ldi	r22, 0x00	; 0
    df2a:	70 e0       	ldi	r23, 0x00	; 0
    df2c:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
				xfprintf_P(xfunc_out,PSTR("%s"),data_string);
    df30:	00 d0       	rcall	.+0      	; 0xdf32 <Thread12+0x99e>
    df32:	00 d0       	rcall	.+0      	; 0xdf34 <Thread12+0x9a0>
    df34:	00 d0       	rcall	.+0      	; 0xdf36 <Thread12+0x9a2>
    df36:	ed b7       	in	r30, 0x3d	; 61
    df38:	fe b7       	in	r31, 0x3e	; 62
    df3a:	31 96       	adiw	r30, 0x01	; 1
    df3c:	80 91 92 09 	lds	r24, 0x0992
    df40:	90 91 93 09 	lds	r25, 0x0993
    df44:	ad b7       	in	r26, 0x3d	; 61
    df46:	be b7       	in	r27, 0x3e	; 62
    df48:	12 96       	adiw	r26, 0x02	; 2
    df4a:	9c 93       	st	X, r25
    df4c:	8e 93       	st	-X, r24
    df4e:	11 97       	sbiw	r26, 0x01	; 1
    df50:	79 e8       	ldi	r23, 0x89	; 137
    df52:	e7 2e       	mov	r14, r23
    df54:	76 e0       	ldi	r23, 0x06	; 6
    df56:	f7 2e       	mov	r15, r23
    df58:	f3 82       	std	Z+3, r15	; 0x03
    df5a:	e2 82       	std	Z+2, r14	; 0x02
    df5c:	0f e3       	ldi	r16, 0x3F	; 63
    df5e:	10 e0       	ldi	r17, 0x00	; 0
    df60:	0c 0f       	add	r16, r28
    df62:	1d 1f       	adc	r17, r29
    df64:	15 83       	std	Z+5, r17	; 0x05
    df66:	04 83       	std	Z+4, r16	; 0x04
    df68:	0e 94 92 1f 	call	0x3f24	; 0x3f24 <xfprintf_P>
				//xfprintf_P(usart_putchar_printf,PSTR("%s"),data_string);
				
				chSemSignal(&usartUSE);
    df6c:	2d b7       	in	r18, 0x3d	; 61
    df6e:	3e b7       	in	r19, 0x3e	; 62
    df70:	2a 5f       	subi	r18, 0xFA	; 250
    df72:	3f 4f       	sbci	r19, 0xFF	; 255
    df74:	0f b6       	in	r0, 0x3f	; 63
    df76:	f8 94       	cli
    df78:	3e bf       	out	0x3e, r19	; 62
    df7a:	0f be       	out	0x3f, r0	; 63
    df7c:	2d bf       	out	0x3d, r18	; 61
    df7e:	87 ec       	ldi	r24, 0xC7	; 199
    df80:	90 e3       	ldi	r25, 0x30	; 48
    df82:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
			}
			
			if (SD_HB_LOGGING_ON ==1){
    df86:	80 91 30 07 	lds	r24, 0x0730
    df8a:	81 30       	cpi	r24, 0x01	; 1
    df8c:	09 f0       	breq	.+2      	; 0xdf90 <Thread12+0x9fc>
    df8e:	03 ce       	rjmp	.-1018   	; 0xdb96 <Thread12+0x602>
				chSemWait(&sdUSE);
    df90:	80 e0       	ldi	r24, 0x00	; 0
    df92:	96 e2       	ldi	r25, 0x26	; 38
    df94:	40 e0       	ldi	r20, 0x00	; 0
    df96:	50 e0       	ldi	r21, 0x00	; 0
    df98:	60 e0       	ldi	r22, 0x00	; 0
    df9a:	70 e0       	ldi	r23, 0x00	; 0
    df9c:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
				chSemWait(&spiUSE);
    dfa0:	89 e7       	ldi	r24, 0x79	; 121
    dfa2:	94 e1       	ldi	r25, 0x14	; 20
    dfa4:	40 e0       	ldi	r20, 0x00	; 0
    dfa6:	50 e0       	ldi	r21, 0x00	; 0
    dfa8:	60 e0       	ldi	r22, 0x00	; 0
    dfaa:	70 e0       	ldi	r23, 0x00	; 0
    dfac:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
				res = f_write(&fdst, data_string,54, &bw); 
    dfb0:	ce 01       	movw	r24, r28
    dfb2:	4f 96       	adiw	r24, 0x1f	; 31
    dfb4:	be 01       	movw	r22, r28
    dfb6:	61 5c       	subi	r22, 0xC1	; 193
    dfb8:	7f 4f       	sbci	r23, 0xFF	; 255
    dfba:	46 e3       	ldi	r20, 0x36	; 54
    dfbc:	50 e0       	ldi	r21, 0x00	; 0
    dfbe:	9e 01       	movw	r18, r28
    dfc0:	2f 5f       	subi	r18, 0xFF	; 255
    dfc2:	3f 4f       	sbci	r19, 0xFF	; 255
    dfc4:	0e 94 b7 32 	call	0x656e	; 0x656e <f_write>
				f_sync(&fdst);
    dfc8:	ce 01       	movw	r24, r28
    dfca:	4f 96       	adiw	r24, 0x1f	; 31
    dfcc:	0e 94 4d 3e 	call	0x7c9a	; 0x7c9a <f_sync>
				chSemSignal(&spiUSE);
    dfd0:	89 e7       	ldi	r24, 0x79	; 121
    dfd2:	94 e1       	ldi	r25, 0x14	; 20
    dfd4:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
				chSemSignal(&sdUSE);
    dfd8:	80 e0       	ldi	r24, 0x00	; 0
    dfda:	96 e2       	ldi	r25, 0x26	; 38
    dfdc:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
			}
			/***********************************
			* logging
			***********************************/
			
			if (IR_result == 1) { //found peak, happens rarely
    dfe0:	80 91 73 07 	lds	r24, 0x0773
    dfe4:	81 30       	cpi	r24, 0x01	; 1
    dfe6:	09 f0       	breq	.+2      	; 0xdfea <Thread12+0xa56>
    dfe8:	db cd       	rjmp	.-1098   	; 0xdba0 <Thread12+0x60c>
				ms_current_beat = ST2MS(chVTTimeElapsedSinceX(HB_baseline));
    dfea:	60 91 d2 07 	lds	r22, 0x07D2
    dfee:	70 91 d3 07 	lds	r23, 0x07D3
    dff2:	80 91 d4 07 	lds	r24, 0x07D4
    dff6:	90 91 d5 07 	lds	r25, 0x07D5
    dffa:	61 50       	subi	r22, 0x01	; 1
    dffc:	70 40       	sbci	r23, 0x00	; 0
    dffe:	80 40       	sbci	r24, 0x00	; 0
    e000:	90 40       	sbci	r25, 0x00	; 0
    e002:	62 19       	sub	r22, r2
    e004:	73 09       	sbc	r23, r3
    e006:	84 09       	sbc	r24, r4
    e008:	95 09       	sbc	r25, r5
    e00a:	24 e1       	ldi	r18, 0x14	; 20
    e00c:	30 e0       	ldi	r19, 0x00	; 0
    e00e:	40 e0       	ldi	r20, 0x00	; 0
    e010:	50 e0       	ldi	r21, 0x00	; 0
    e012:	0e 94 0d 80 	call	0x1001a	; 0x1001a <__udivmodsi4>
    e016:	2f 5f       	subi	r18, 0xFF	; 255
    e018:	3f 4f       	sbci	r19, 0xFF	; 255
    e01a:	4f 4f       	sbci	r20, 0xFF	; 255
    e01c:	5f 4f       	sbci	r21, 0xFF	; 255
    e01e:	20 93 82 07 	sts	0x0782, r18
    e022:	30 93 83 07 	sts	0x0783, r19
    e026:	40 93 84 07 	sts	0x0784, r20
    e02a:	50 93 85 07 	sts	0x0785, r21
				//need to be careful here if it is a double, we throw it out ... get times right!!!
				ms_elapsed_since_last = ms_current_beat - ms_old_beat;
    e02e:	80 91 86 07 	lds	r24, 0x0786
    e032:	90 91 87 07 	lds	r25, 0x0787
    e036:	a0 91 88 07 	lds	r26, 0x0788
    e03a:	b0 91 89 07 	lds	r27, 0x0789
    e03e:	79 01       	movw	r14, r18
    e040:	8a 01       	movw	r16, r20
    e042:	e8 1a       	sub	r14, r24
    e044:	f9 0a       	sbc	r15, r25
    e046:	0a 0b       	sbc	r16, r26
    e048:	1b 0b       	sbc	r17, r27
    e04a:	e0 92 8a 07 	sts	0x078A, r14
    e04e:	f0 92 8b 07 	sts	0x078B, r15
    e052:	00 93 8c 07 	sts	0x078C, r16
    e056:	10 93 8d 07 	sts	0x078D, r17
				ms_old_beat = ms_current_beat;
    e05a:	20 93 86 07 	sts	0x0786, r18
    e05e:	30 93 87 07 	sts	0x0787, r19
    e062:	40 93 88 07 	sts	0x0788, r20
    e066:	50 93 89 07 	sts	0x0789, r21
				if (just_entered ==1){
    e06a:	cc 57       	subi	r28, 0x7C	; 124
    e06c:	df 4f       	sbci	r29, 0xFF	; 255
    e06e:	08 81       	ld	r16, Y
    e070:	c4 58       	subi	r28, 0x84	; 132
    e072:	d0 40       	sbci	r29, 0x00	; 0
    e074:	01 30       	cpi	r16, 0x01	; 1
    e076:	09 f4       	brne	.+2      	; 0xe07a <Thread12+0xae6>
    e078:	aa c0       	rjmp	.+340    	; 0xe1ce <Thread12+0xc3a>
							}
					}
					just_entered =0;
					blanking_time = 0UL;
				}//if just_entered ==1
				if (ms_elapsed_since_last > blanking_time) {
    e07a:	20 91 8a 07 	lds	r18, 0x078A
    e07e:	30 91 8b 07 	lds	r19, 0x078B
    e082:	40 91 8c 07 	lds	r20, 0x078C
    e086:	50 91 8d 07 	lds	r21, 0x078D
    e08a:	80 91 92 07 	lds	r24, 0x0792
    e08e:	90 91 93 07 	lds	r25, 0x0793
    e092:	a0 91 94 07 	lds	r26, 0x0794
    e096:	b0 91 95 07 	lds	r27, 0x0795
    e09a:	82 17       	cp	r24, r18
    e09c:	93 07       	cpc	r25, r19
    e09e:	a4 07       	cpc	r26, r20
    e0a0:	b5 07       	cpc	r27, r21
    e0a2:	08 f4       	brcc	.+2      	; 0xe0a6 <Thread12+0xb12>
    e0a4:	6d c0       	rjmp	.+218    	; 0xe180 <Thread12+0xbec>
    e0a6:	64 01       	movw	r12, r8
    e0a8:	53 01       	movw	r10, r6
    e0aa:	cc 57       	subi	r28, 0x7C	; 124
    e0ac:	df 4f       	sbci	r29, 0xFF	; 255
    e0ae:	18 82       	st	Y, r1
    e0b0:	c4 58       	subi	r28, 0x84	; 132
    e0b2:	d0 40       	sbci	r29, 0x00	; 0
    e0b4:	af cd       	rjmp	.-1186   	; 0xdc14 <Thread12+0x680>
				}//ms_elapsed > blanking_time
			}//IR_result==1, found peak
			else {//result = 0, didn't find peak, finish HB visualization
				ms_elapsed_since_last_right_now = ST2MS(chVTTimeElapsedSinceX(HB_baseline)) - ms_old_beat;
				// HEART BEAT LCD FLASHER - LOGIC
				if (( HB_ON == 1) && (ms_elapsed_since_last_right_now > ((ms_elapsed_since_last)>>2))) {
    e0b6:	80 91 8a 07 	lds	r24, 0x078A
    e0ba:	90 91 8b 07 	lds	r25, 0x078B
    e0be:	a0 91 8c 07 	lds	r26, 0x078C
    e0c2:	b0 91 8d 07 	lds	r27, 0x078D
    e0c6:	b6 95       	lsr	r27
    e0c8:	a7 95       	ror	r26
    e0ca:	97 95       	ror	r25
    e0cc:	87 95       	ror	r24
    e0ce:	b6 95       	lsr	r27
    e0d0:	a7 95       	ror	r26
    e0d2:	97 95       	ror	r25
    e0d4:	87 95       	ror	r24
    e0d6:	8e 15       	cp	r24, r14
    e0d8:	9f 05       	cpc	r25, r15
    e0da:	a0 07       	cpc	r26, r16
    e0dc:	b1 07       	cpc	r27, r17
    e0de:	08 f0       	brcs	.+2      	; 0xe0e2 <Thread12+0xb4e>
    e0e0:	97 cd       	rjmp	.-1234   	; 0xdc10 <Thread12+0x67c>
					HB_ON = 0;
    e0e2:	10 92 80 07 	sts	0x0780, r1
					if(lcd_context ==12){
    e0e6:	80 91 32 05 	lds	r24, 0x0532
    e0ea:	8c 30       	cpi	r24, 0x0C	; 12
    e0ec:	09 f0       	breq	.+2      	; 0xe0f0 <Thread12+0xb5c>
    e0ee:	90 cd       	rjmp	.-1248   	; 0xdc10 <Thread12+0x67c>
						if (lcd_context_count[11] == 1) { // in HB mode
    e0f0:	80 91 3e 05 	lds	r24, 0x053E
    e0f4:	81 30       	cpi	r24, 0x01	; 1
    e0f6:	09 f0       	breq	.+2      	; 0xe0fa <Thread12+0xb66>
    e0f8:	8b cd       	rjmp	.-1258   	; 0xdc10 <Thread12+0x67c>
							chSemWait(&spiUSE);
    e0fa:	89 e7       	ldi	r24, 0x79	; 121
    e0fc:	94 e1       	ldi	r25, 0x14	; 20
    e0fe:	40 e0       	ldi	r20, 0x00	; 0
    e100:	50 e0       	ldi	r21, 0x00	; 0
    e102:	60 e0       	ldi	r22, 0x00	; 0
    e104:	70 e0       	ldi	r23, 0x00	; 0
    e106:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
							st7735_setCursor(35,86);
    e10a:	83 e2       	ldi	r24, 0x23	; 35
    e10c:	90 e0       	ldi	r25, 0x00	; 0
    e10e:	66 e5       	ldi	r22, 0x56	; 86
    e110:	70 e0       	ldi	r23, 0x00	; 0
    e112:	0e 94 c2 19 	call	0x3384	; 0x3384 <st7735_setCursor>
							st7735_setTextSize(2);
    e116:	82 e0       	ldi	r24, 0x02	; 2
    e118:	0e 94 cb 19 	call	0x3396	; 0x3396 <st7735_setTextSize>
							fprintf_P(&st7735_out,PSTR(" "));
    e11c:	00 d0       	rcall	.+0      	; 0xe11e <Thread12+0xb8a>
    e11e:	00 d0       	rcall	.+0      	; 0xe120 <Thread12+0xb8c>
    e120:	ec eb       	ldi	r30, 0xBC	; 188
    e122:	f6 e0       	ldi	r31, 0x06	; 6
    e124:	ad b7       	in	r26, 0x3d	; 61
    e126:	be b7       	in	r27, 0x3e	; 62
    e128:	12 96       	adiw	r26, 0x02	; 2
    e12a:	fc 93       	st	X, r31
    e12c:	ee 93       	st	-X, r30
    e12e:	11 97       	sbiw	r26, 0x01	; 1
    e130:	32 e7       	ldi	r19, 0x72	; 114
    e132:	e3 2e       	mov	r14, r19
    e134:	36 e0       	ldi	r19, 0x06	; 6
    e136:	f3 2e       	mov	r15, r19
    e138:	14 96       	adiw	r26, 0x04	; 4
    e13a:	fc 92       	st	X, r15
    e13c:	ee 92       	st	-X, r14
    e13e:	13 97       	sbiw	r26, 0x03	; 3
    e140:	0e 94 9a 82 	call	0x10534	; 0x10534 <fprintf_P>
							chSemSignal(&spiUSE);
    e144:	0f 90       	pop	r0
    e146:	0f 90       	pop	r0
    e148:	0f 90       	pop	r0
    e14a:	0f 90       	pop	r0
    e14c:	89 e7       	ldi	r24, 0x79	; 121
    e14e:	94 e1       	ldi	r25, 0x14	; 20
    e150:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
    e154:	64 01       	movw	r12, r8
    e156:	53 01       	movw	r10, r6
    e158:	5d cd       	rjmp	.-1350   	; 0xdc14 <Thread12+0x680>
		p1 = MAX30105_getRedIR(LED_data_vector); 
		chSemSignal(&i2cUSE);
		if (p1 > 0){//new data
			IR_result = checkForBeat(IR_LED_output, &IR_dc_avg, LED_data_vector[1], &IR_HR_state);//always
			if (lcd_context_count[11] == 2) { // in SPO2 mode, need red
				Red_result = checkForBeat(Red_LED_output, &Red_dc_avg, LED_data_vector[0], &Red_HR_state);
    e15a:	20 91 74 07 	lds	r18, 0x0774
    e15e:	30 91 75 07 	lds	r19, 0x0775
    e162:	40 91 76 07 	lds	r20, 0x0776
    e166:	50 91 77 07 	lds	r21, 0x0777
    e16a:	8a e4       	ldi	r24, 0x4A	; 74
    e16c:	97 e0       	ldi	r25, 0x07	; 7
    e16e:	6a e6       	ldi	r22, 0x6A	; 106
    e170:	77 e0       	ldi	r23, 0x07	; 7
    e172:	08 e3       	ldi	r16, 0x38	; 56
    e174:	1f e2       	ldi	r17, 0x2F	; 47
    e176:	0e 94 ef 46 	call	0x8dde	; 0x8dde <checkForBeat>
    e17a:	80 93 72 07 	sts	0x0772, r24
    e17e:	01 cd       	rjmp	.-1534   	; 0xdb82 <Thread12+0x5ee>
					}
					just_entered =0;
					blanking_time = 0UL;
				}//if just_entered ==1
				if (ms_elapsed_since_last > blanking_time) {
					current_HB_estimate = 60000L/(int32_t)ms_elapsed_since_last;
    e180:	60 e6       	ldi	r22, 0x60	; 96
    e182:	7a ee       	ldi	r23, 0xEA	; 234
    e184:	80 e0       	ldi	r24, 0x00	; 0
    e186:	90 e0       	ldi	r25, 0x00	; 0
    e188:	0e 94 2f 80 	call	0x1005e	; 0x1005e <__divmodsi4>
    e18c:	79 01       	movw	r14, r18
    e18e:	8a 01       	movw	r16, r20
    e190:	c0 58       	subi	r28, 0x80	; 128
    e192:	df 4f       	sbci	r29, 0xFF	; 255
    e194:	e8 82       	st	Y, r14
    e196:	f9 82       	std	Y+1, r15	; 0x01
    e198:	0a 83       	std	Y+2, r16	; 0x02
    e19a:	1b 83       	std	Y+3, r17	; 0x03
    e19c:	c0 58       	subi	r28, 0x80	; 128
    e19e:	d0 40       	sbci	r29, 0x00	; 0
					if ((current_HB_estimate < 20L) || (current_HB_estimate > 230L)) { //then we have a bad value
    e1a0:	d8 01       	movw	r26, r16
    e1a2:	c7 01       	movw	r24, r14
    e1a4:	44 97       	sbiw	r24, 0x14	; 20
    e1a6:	a1 09       	sbc	r26, r1
    e1a8:	b1 09       	sbc	r27, r1
    e1aa:	83 3d       	cpi	r24, 0xD3	; 211
    e1ac:	91 05       	cpc	r25, r1
    e1ae:	a1 05       	cpc	r26, r1
    e1b0:	b1 05       	cpc	r27, r1
    e1b2:	d8 f0       	brcs	.+54     	; 0xe1ea <Thread12+0xc56>
    e1b4:	64 01       	movw	r12, r8
    e1b6:	53 01       	movw	r10, r6
						else {
							HB_locked = 0;
						}	
					}//HB filter		
					
					if(lcd_context ==12){
    e1b8:	80 91 32 05 	lds	r24, 0x0532
    e1bc:	8c 30       	cpi	r24, 0x0C	; 12
    e1be:	09 f4       	brne	.+2      	; 0xe1c2 <Thread12+0xc2e>
    e1c0:	aa c0       	rjmp	.+340    	; 0xe316 <Thread12+0xd82>
						if (lcd_context_count[11] == 1) { // in HB mode
							chSemWait(&spiUSE);
							st7735_setCursor(35,86);
							st7735_setTextSize(2);
							fprintf_P(&st7735_out,PSTR(" "));
							chSemSignal(&spiUSE);
    e1c2:	cc 57       	subi	r28, 0x7C	; 124
    e1c4:	df 4f       	sbci	r29, 0xFF	; 255
    e1c6:	18 82       	st	Y, r1
    e1c8:	c4 58       	subi	r28, 0x84	; 132
    e1ca:	d0 40       	sbci	r29, 0x00	; 0
    e1cc:	23 cd       	rjmp	.-1466   	; 0xdc14 <Thread12+0x680>
				ms_current_beat = ST2MS(chVTTimeElapsedSinceX(HB_baseline));
				//need to be careful here if it is a double, we throw it out ... get times right!!!
				ms_elapsed_since_last = ms_current_beat - ms_old_beat;
				ms_old_beat = ms_current_beat;
				if (just_entered ==1){
					if(lcd_context ==12){
    e1ce:	80 91 32 05 	lds	r24, 0x0532
    e1d2:	8c 30       	cpi	r24, 0x0C	; 12
    e1d4:	09 f4       	brne	.+2      	; 0xe1d8 <Thread12+0xc44>
    e1d6:	0a c1       	rjmp	.+532    	; 0xe3ec <Thread12+0xe58>
								fprintf_P(&st7735_out, PSTR("2"));
								chSemSignal(&spiUSE);
							}
					}
					just_entered =0;
					blanking_time = 0UL;
    e1d8:	10 92 92 07 	sts	0x0792, r1
    e1dc:	10 92 93 07 	sts	0x0793, r1
    e1e0:	10 92 94 07 	sts	0x0794, r1
    e1e4:	10 92 95 07 	sts	0x0795, r1
    e1e8:	48 cf       	rjmp	.-368    	; 0xe07a <Thread12+0xae6>
					}
					else {
						//HEART BEAT FILTER & test whether its "locked"
						//ADJUST HB with a partial step to current value
						current_HB_average_last = current_HB_average;
						HB_ON = 1;
    e1ea:	81 e0       	ldi	r24, 0x01	; 1
    e1ec:	80 93 80 07 	sts	0x0780, r24
						if ((current_HB_estimate>(current_HB_average>>2)) && (current_HB_estimate < (current_HB_average<<2))){
    e1f0:	d4 01       	movw	r26, r8
    e1f2:	c3 01       	movw	r24, r6
    e1f4:	b5 95       	asr	r27
    e1f6:	a7 95       	ror	r26
    e1f8:	97 95       	ror	r25
    e1fa:	87 95       	ror	r24
    e1fc:	b5 95       	asr	r27
    e1fe:	a7 95       	ror	r26
    e200:	97 95       	ror	r25
    e202:	87 95       	ror	r24
    e204:	c0 58       	subi	r28, 0x80	; 128
    e206:	df 4f       	sbci	r29, 0xFF	; 255
    e208:	28 81       	ld	r18, Y
    e20a:	39 81       	ldd	r19, Y+1	; 0x01
    e20c:	4a 81       	ldd	r20, Y+2	; 0x02
    e20e:	5b 81       	ldd	r21, Y+3	; 0x03
    e210:	c0 58       	subi	r28, 0x80	; 128
    e212:	d0 40       	sbci	r29, 0x00	; 0
    e214:	82 17       	cp	r24, r18
    e216:	93 07       	cpc	r25, r19
    e218:	a4 07       	cpc	r26, r20
    e21a:	b5 07       	cpc	r27, r21
    e21c:	0c f0       	brlt	.+2      	; 0xe220 <Thread12+0xc8c>
    e21e:	bc c0       	rjmp	.+376    	; 0xe398 <Thread12+0xe04>
    e220:	d4 01       	movw	r26, r8
    e222:	c3 01       	movw	r24, r6
    e224:	88 0f       	add	r24, r24
    e226:	99 1f       	adc	r25, r25
    e228:	aa 1f       	adc	r26, r26
    e22a:	bb 1f       	adc	r27, r27
    e22c:	88 0f       	add	r24, r24
    e22e:	99 1f       	adc	r25, r25
    e230:	aa 1f       	adc	r26, r26
    e232:	bb 1f       	adc	r27, r27
    e234:	28 17       	cp	r18, r24
    e236:	39 07       	cpc	r19, r25
    e238:	4a 07       	cpc	r20, r26
    e23a:	5b 07       	cpc	r21, r27
    e23c:	0c f0       	brlt	.+2      	; 0xe240 <Thread12+0xcac>
    e23e:	ac c0       	rjmp	.+344    	; 0xe398 <Thread12+0xe04>
							coeff =  (90L*60L*3L)/(8L*current_HB_average);
    e240:	9c 01       	movw	r18, r24
    e242:	ad 01       	movw	r20, r26
    e244:	22 0f       	add	r18, r18
    e246:	33 1f       	adc	r19, r19
    e248:	44 1f       	adc	r20, r20
    e24a:	55 1f       	adc	r21, r21
    e24c:	68 e4       	ldi	r22, 0x48	; 72
    e24e:	7f e3       	ldi	r23, 0x3F	; 63
    e250:	80 e0       	ldi	r24, 0x00	; 0
    e252:	90 e0       	ldi	r25, 0x00	; 0
    e254:	0e 94 2f 80 	call	0x1005e	; 0x1005e <__divmodsi4>
    e258:	c9 01       	movw	r24, r18
    e25a:	da 01       	movw	r26, r20
    e25c:	bc 01       	movw	r22, r24
    e25e:	cd 01       	movw	r24, r26
    e260:	64 32       	cpi	r22, 0x24	; 36
    e262:	71 05       	cpc	r23, r1
    e264:	81 05       	cpc	r24, r1
    e266:	91 05       	cpc	r25, r1
    e268:	24 f0       	brlt	.+8      	; 0xe272 <Thread12+0xcde>
    e26a:	63 e2       	ldi	r22, 0x23	; 35
    e26c:	70 e0       	ldi	r23, 0x00	; 0
    e26e:	80 e0       	ldi	r24, 0x00	; 0
    e270:	90 e0       	ldi	r25, 0x00	; 0
							if (coeff > attack_max) coeff = attack_max; 
						}		
						else coeff = 5L;
						if (current_HB_average > current_HB_estimate) {
    e272:	e6 14       	cp	r14, r6
    e274:	f7 04       	cpc	r15, r7
    e276:	08 05       	cpc	r16, r8
    e278:	19 05       	cpc	r17, r9
    e27a:	0c f0       	brlt	.+2      	; 0xe27e <Thread12+0xcea>
    e27c:	97 c0       	rjmp	.+302    	; 0xe3ac <Thread12+0xe18>
							//K --;
							unlock_test = current_HB_average - current_HB_estimate;
    e27e:	a4 01       	movw	r20, r8
    e280:	93 01       	movw	r18, r6
    e282:	2e 19       	sub	r18, r14
    e284:	3f 09       	sbc	r19, r15
    e286:	40 0b       	sbc	r20, r16
    e288:	51 0b       	sbc	r21, r17
    e28a:	79 01       	movw	r14, r18
    e28c:	8a 01       	movw	r16, r20
							current_HB_average -= (coeff*(current_HB_average-current_HB_estimate))/100;
    e28e:	0e 94 bb 7f 	call	0xff76	; 0xff76 <__mulsi3>
    e292:	2c e9       	ldi	r18, 0x9C	; 156
    e294:	3f ef       	ldi	r19, 0xFF	; 255
    e296:	4f ef       	ldi	r20, 0xFF	; 255
    e298:	5f ef       	ldi	r21, 0xFF	; 255
    e29a:	0e 94 2f 80 	call	0x1005e	; 0x1005e <__divmodsi4>
    e29e:	59 01       	movw	r10, r18
    e2a0:	6a 01       	movw	r12, r20
    e2a2:	a6 0c       	add	r10, r6
    e2a4:	b7 1c       	adc	r11, r7
    e2a6:	c8 1c       	adc	r12, r8
    e2a8:	d9 1c       	adc	r13, r9
						else {
							//K++;
							unlock_test = current_HB_estimate - current_HB_average;
							current_HB_average += (coeff*(current_HB_estimate-current_HB_average))/100;
						}
						if (current_HB_average <=0) current_HB_average = current_HB_average_last;
    e2aa:	1a 14       	cp	r1, r10
    e2ac:	1b 04       	cpc	r1, r11
    e2ae:	1c 04       	cpc	r1, r12
    e2b0:	1d 04       	cpc	r1, r13
    e2b2:	0c f0       	brlt	.+2      	; 0xe2b6 <Thread12+0xd22>
    e2b4:	95 c0       	rjmp	.+298    	; 0xe3e0 <Thread12+0xe4c>
						blanking_time = 30000L/(uint32_t)current_HB_average;
    e2b6:	60 e3       	ldi	r22, 0x30	; 48
    e2b8:	75 e7       	ldi	r23, 0x75	; 117
    e2ba:	80 e0       	ldi	r24, 0x00	; 0
    e2bc:	90 e0       	ldi	r25, 0x00	; 0
    e2be:	a6 01       	movw	r20, r12
    e2c0:	95 01       	movw	r18, r10
    e2c2:	0e 94 0d 80 	call	0x1001a	; 0x1001a <__udivmodsi4>
    e2c6:	20 93 92 07 	sts	0x0792, r18
    e2ca:	30 93 93 07 	sts	0x0793, r19
    e2ce:	40 93 94 07 	sts	0x0794, r20
    e2d2:	50 93 95 07 	sts	0x0795, r21
						if ((100L*unlock_test) < (10L*current_HB_average_last)){
    e2d6:	c8 01       	movw	r24, r16
    e2d8:	b7 01       	movw	r22, r14
    e2da:	24 e6       	ldi	r18, 0x64	; 100
    e2dc:	30 e0       	ldi	r19, 0x00	; 0
    e2de:	40 e0       	ldi	r20, 0x00	; 0
    e2e0:	50 e0       	ldi	r21, 0x00	; 0
    e2e2:	0e 94 bb 7f 	call	0xff76	; 0xff76 <__mulsi3>
    e2e6:	7b 01       	movw	r14, r22
    e2e8:	8c 01       	movw	r16, r24
    e2ea:	c4 01       	movw	r24, r8
    e2ec:	b3 01       	movw	r22, r6
    e2ee:	2a e0       	ldi	r18, 0x0A	; 10
    e2f0:	30 e0       	ldi	r19, 0x00	; 0
    e2f2:	40 e0       	ldi	r20, 0x00	; 0
    e2f4:	50 e0       	ldi	r21, 0x00	; 0
    e2f6:	0e 94 bb 7f 	call	0xff76	; 0xff76 <__mulsi3>
    e2fa:	e6 16       	cp	r14, r22
    e2fc:	f7 06       	cpc	r15, r23
    e2fe:	08 07       	cpc	r16, r24
    e300:	19 07       	cpc	r17, r25
    e302:	0c f0       	brlt	.+2      	; 0xe306 <Thread12+0xd72>
    e304:	70 c0       	rjmp	.+224    	; 0xe3e6 <Thread12+0xe52>
							HB_locked = 1;
    e306:	81 e0       	ldi	r24, 0x01	; 1
    e308:	80 93 81 07 	sts	0x0781, r24
						else {
							HB_locked = 0;
						}	
					}//HB filter		
					
					if(lcd_context ==12){
    e30c:	80 91 32 05 	lds	r24, 0x0532
    e310:	8c 30       	cpi	r24, 0x0C	; 12
    e312:	09 f0       	breq	.+2      	; 0xe316 <Thread12+0xd82>
    e314:	56 cf       	rjmp	.-340    	; 0xe1c2 <Thread12+0xc2e>
						if (lcd_context_count[11] == 1) { // in HB mode
    e316:	80 91 3e 05 	lds	r24, 0x053E
    e31a:	81 30       	cpi	r24, 0x01	; 1
    e31c:	09 f4       	brne	.+2      	; 0xe320 <Thread12+0xd8c>
    e31e:	e5 c0       	rjmp	.+458    	; 0xe4ea <Thread12+0xf56>
							st7735_setCursor(35,86);
							st7735_setTextSize(2);
							fprintf_P(&st7735_out,PSTR("%c"), 0x03);//should print heart
							chSemSignal(&spiUSE);
						}
						if ((lcd_context_count[11] == 2) && (HB_locked ==1)) { // in SPO2 mode, validated peak, grab IR data
    e320:	80 91 3e 05 	lds	r24, 0x053E
    e324:	82 30       	cpi	r24, 0x02	; 2
    e326:	09 f0       	breq	.+2      	; 0xe32a <Thread12+0xd96>
    e328:	4c cf       	rjmp	.-360    	; 0xe1c2 <Thread12+0xc2e>
    e32a:	80 91 81 07 	lds	r24, 0x0781
    e32e:	81 30       	cpi	r24, 0x01	; 1
    e330:	09 f0       	breq	.+2      	; 0xe334 <Thread12+0xda0>
    e332:	47 cf       	rjmp	.-370    	; 0xe1c2 <Thread12+0xc2e>
							IR_SPO2_state.baseline = IR_dc_avg;
    e334:	80 91 6e 07 	lds	r24, 0x076E
    e338:	90 91 6f 07 	lds	r25, 0x076F
    e33c:	a0 91 70 07 	lds	r26, 0x0770
    e340:	b0 91 71 07 	lds	r27, 0x0771
    e344:	ea 96       	adiw	r28, 0x3a	; 58
    e346:	8c af       	std	Y+60, r24	; 0x3c
    e348:	9d af       	std	Y+61, r25	; 0x3d
    e34a:	ae af       	std	Y+62, r26	; 0x3e
    e34c:	bf af       	std	Y+63, r27	; 0x3f
    e34e:	ea 97       	sbiw	r28, 0x3a	; 58
							IR_SPO2_state.spread = IR_HR_state.peak_max - IR_HR_state.valley_min;
    e350:	e0 90 43 0f 	lds	r14, 0x0F43
    e354:	f0 90 44 0f 	lds	r15, 0x0F44
    e358:	00 91 45 0f 	lds	r16, 0x0F45
    e35c:	10 91 46 0f 	lds	r17, 0x0F46
    e360:	80 91 3f 0f 	lds	r24, 0x0F3F
    e364:	90 91 40 0f 	lds	r25, 0x0F40
    e368:	a0 91 41 0f 	lds	r26, 0x0F41
    e36c:	b0 91 42 0f 	lds	r27, 0x0F42
    e370:	e8 1a       	sub	r14, r24
    e372:	f9 0a       	sbc	r15, r25
    e374:	0a 0b       	sbc	r16, r26
    e376:	1b 0b       	sbc	r17, r27
    e378:	ee 96       	adiw	r28, 0x3e	; 62
    e37a:	ec ae       	std	Y+60, r14	; 0x3c
    e37c:	fd ae       	std	Y+61, r15	; 0x3d
    e37e:	0e af       	std	Y+62, r16	; 0x3e
    e380:	1f af       	std	Y+63, r17	; 0x3f
    e382:	ee 97       	sbiw	r28, 0x3e	; 62
    e384:	cc 57       	subi	r28, 0x7C	; 124
    e386:	df 4f       	sbci	r29, 0xFF	; 255
    e388:	18 82       	st	Y, r1
    e38a:	c4 58       	subi	r28, 0x84	; 132
    e38c:	d0 40       	sbci	r29, 0x00	; 0
    e38e:	01 e0       	ldi	r16, 0x01	; 1
    e390:	ef 96       	adiw	r28, 0x3f	; 63
    e392:	0f af       	std	Y+63, r16	; 0x3f
    e394:	ef 97       	sbiw	r28, 0x3f	; 63
    e396:	3e cc       	rjmp	.-1924   	; 0xdc14 <Thread12+0x680>
						//HEART BEAT FILTER & test whether its "locked"
						//ADJUST HB with a partial step to current value
						current_HB_average_last = current_HB_average;
						HB_ON = 1;
						if ((current_HB_estimate>(current_HB_average>>2)) && (current_HB_estimate < (current_HB_average<<2))){
							coeff =  (90L*60L*3L)/(8L*current_HB_average);
    e398:	65 e0       	ldi	r22, 0x05	; 5
    e39a:	70 e0       	ldi	r23, 0x00	; 0
    e39c:	80 e0       	ldi	r24, 0x00	; 0
    e39e:	90 e0       	ldi	r25, 0x00	; 0
							if (coeff > attack_max) coeff = attack_max; 
						}		
						else coeff = 5L;
						if (current_HB_average > current_HB_estimate) {
    e3a0:	e6 14       	cp	r14, r6
    e3a2:	f7 04       	cpc	r15, r7
    e3a4:	08 05       	cpc	r16, r8
    e3a6:	19 05       	cpc	r17, r9
    e3a8:	0c f4       	brge	.+2      	; 0xe3ac <Thread12+0xe18>
    e3aa:	69 cf       	rjmp	.-302    	; 0xe27e <Thread12+0xcea>
							unlock_test = current_HB_average - current_HB_estimate;
							current_HB_average -= (coeff*(current_HB_average-current_HB_estimate))/100;
						}		
						else {
							//K++;
							unlock_test = current_HB_estimate - current_HB_average;
    e3ac:	e6 18       	sub	r14, r6
    e3ae:	f7 08       	sbc	r15, r7
    e3b0:	08 09       	sbc	r16, r8
    e3b2:	19 09       	sbc	r17, r9
							current_HB_average += (coeff*(current_HB_estimate-current_HB_average))/100;
    e3b4:	a8 01       	movw	r20, r16
    e3b6:	97 01       	movw	r18, r14
    e3b8:	0e 94 bb 7f 	call	0xff76	; 0xff76 <__mulsi3>
    e3bc:	24 e6       	ldi	r18, 0x64	; 100
    e3be:	30 e0       	ldi	r19, 0x00	; 0
    e3c0:	40 e0       	ldi	r20, 0x00	; 0
    e3c2:	50 e0       	ldi	r21, 0x00	; 0
    e3c4:	0e 94 2f 80 	call	0x1005e	; 0x1005e <__divmodsi4>
    e3c8:	59 01       	movw	r10, r18
    e3ca:	6a 01       	movw	r12, r20
    e3cc:	a6 0c       	add	r10, r6
    e3ce:	b7 1c       	adc	r11, r7
    e3d0:	c8 1c       	adc	r12, r8
    e3d2:	d9 1c       	adc	r13, r9
						}
						if (current_HB_average <=0) current_HB_average = current_HB_average_last;
    e3d4:	1a 14       	cp	r1, r10
    e3d6:	1b 04       	cpc	r1, r11
    e3d8:	1c 04       	cpc	r1, r12
    e3da:	1d 04       	cpc	r1, r13
    e3dc:	0c f4       	brge	.+2      	; 0xe3e0 <Thread12+0xe4c>
    e3de:	6b cf       	rjmp	.-298    	; 0xe2b6 <Thread12+0xd22>
    e3e0:	64 01       	movw	r12, r8
    e3e2:	53 01       	movw	r10, r6
    e3e4:	68 cf       	rjmp	.-304    	; 0xe2b6 <Thread12+0xd22>
						blanking_time = 30000L/(uint32_t)current_HB_average;
						if ((100L*unlock_test) < (10L*current_HB_average_last)){
							HB_locked = 1;
						}
						else {
							HB_locked = 0;
    e3e6:	10 92 81 07 	sts	0x0781, r1
    e3ea:	e6 ce       	rjmp	.-564    	; 0xe1b8 <Thread12+0xc24>
				//need to be careful here if it is a double, we throw it out ... get times right!!!
				ms_elapsed_since_last = ms_current_beat - ms_old_beat;
				ms_old_beat = ms_current_beat;
				if (just_entered ==1){
					if(lcd_context ==12){
							if (lcd_context_count[11] == 1) { // in HB mode
    e3ec:	80 91 3e 05 	lds	r24, 0x053E
    e3f0:	81 30       	cpi	r24, 0x01	; 1
    e3f2:	09 f4       	brne	.+2      	; 0xe3f6 <Thread12+0xe62>
    e3f4:	e3 c0       	rjmp	.+454    	; 0xe5bc <Thread12+0x1028>
								st7735_setCursor(107,86);
								st7735_setTextSize(1);
								fprintf_P(&st7735_out, PSTR("BPM"));    
								chSemSignal(&spiUSE);
							}
							if (lcd_context_count[11] == 2) { // in SPO2 mode
    e3f6:	80 91 3e 05 	lds	r24, 0x053E
    e3fa:	82 30       	cpi	r24, 0x02	; 2
    e3fc:	09 f0       	breq	.+2      	; 0xe400 <Thread12+0xe6c>
    e3fe:	ec ce       	rjmp	.-552    	; 0xe1d8 <Thread12+0xc44>
								chSemWait(&spiUSE);
    e400:	89 e7       	ldi	r24, 0x79	; 121
    e402:	94 e1       	ldi	r25, 0x14	; 20
    e404:	40 e0       	ldi	r20, 0x00	; 0
    e406:	50 e0       	ldi	r21, 0x00	; 0
    e408:	60 e0       	ldi	r22, 0x00	; 0
    e40a:	70 e0       	ldi	r23, 0x00	; 0
    e40c:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
								st7735_fill_rect(32, 83, 96, 30, ST7735_COLOR_BLACK);//second coordinates are offset!!!
    e410:	80 e2       	ldi	r24, 0x20	; 32
    e412:	63 e5       	ldi	r22, 0x53	; 83
    e414:	40 e6       	ldi	r20, 0x60	; 96
    e416:	2e e1       	ldi	r18, 0x1E	; 30
    e418:	00 e0       	ldi	r16, 0x00	; 0
    e41a:	10 e0       	ldi	r17, 0x00	; 0
    e41c:	0e 94 59 16 	call	0x2cb2	; 0x2cb2 <st7735_fill_rect>
								st7735_setCursor(50,86);
    e420:	82 e3       	ldi	r24, 0x32	; 50
    e422:	90 e0       	ldi	r25, 0x00	; 0
    e424:	66 e5       	ldi	r22, 0x56	; 86
    e426:	70 e0       	ldi	r23, 0x00	; 0
    e428:	0e 94 c2 19 	call	0x3384	; 0x3384 <st7735_setCursor>
								st7735_setTextSize(3);
    e42c:	83 e0       	ldi	r24, 0x03	; 3
    e42e:	0e 94 cb 19 	call	0x3396	; 0x3396 <st7735_setTextSize>
								fprintf_P(&st7735_out,PSTR("---"));
    e432:	00 d0       	rcall	.+0      	; 0xe434 <Thread12+0xea0>
    e434:	00 d0       	rcall	.+0      	; 0xe436 <Thread12+0xea2>
    e436:	ec eb       	ldi	r30, 0xBC	; 188
    e438:	f6 e0       	ldi	r31, 0x06	; 6
    e43a:	ad b7       	in	r26, 0x3d	; 61
    e43c:	be b7       	in	r27, 0x3e	; 62
    e43e:	12 96       	adiw	r26, 0x02	; 2
    e440:	fc 93       	st	X, r31
    e442:	ee 93       	st	-X, r30
    e444:	11 97       	sbiw	r26, 0x01	; 1
    e446:	51 e8       	ldi	r21, 0x81	; 129
    e448:	e5 2e       	mov	r14, r21
    e44a:	56 e0       	ldi	r21, 0x06	; 6
    e44c:	f5 2e       	mov	r15, r21
    e44e:	14 96       	adiw	r26, 0x04	; 4
    e450:	fc 92       	st	X, r15
    e452:	ee 92       	st	-X, r14
    e454:	13 97       	sbiw	r26, 0x03	; 3
    e456:	0e 94 9a 82 	call	0x10534	; 0x10534 <fprintf_P>
								st7735_setCursor(107,86);
    e45a:	0f 90       	pop	r0
    e45c:	0f 90       	pop	r0
    e45e:	0f 90       	pop	r0
    e460:	0f 90       	pop	r0
    e462:	8b e6       	ldi	r24, 0x6B	; 107
    e464:	90 e0       	ldi	r25, 0x00	; 0
    e466:	66 e5       	ldi	r22, 0x56	; 86
    e468:	70 e0       	ldi	r23, 0x00	; 0
    e46a:	0e 94 c2 19 	call	0x3384	; 0x3384 <st7735_setCursor>
								st7735_setTextSize(1);
    e46e:	81 e0       	ldi	r24, 0x01	; 1
    e470:	0e 94 cb 19 	call	0x3396	; 0x3396 <st7735_setTextSize>
								fprintf_P(&st7735_out, PSTR("%%O"));
    e474:	00 d0       	rcall	.+0      	; 0xe476 <Thread12+0xee2>
    e476:	00 d0       	rcall	.+0      	; 0xe478 <Thread12+0xee4>
    e478:	ec eb       	ldi	r30, 0xBC	; 188
    e47a:	f6 e0       	ldi	r31, 0x06	; 6
    e47c:	ad b7       	in	r26, 0x3d	; 61
    e47e:	be b7       	in	r27, 0x3e	; 62
    e480:	12 96       	adiw	r26, 0x02	; 2
    e482:	fc 93       	st	X, r31
    e484:	ee 93       	st	-X, r30
    e486:	11 97       	sbiw	r26, 0x01	; 1
    e488:	4d e7       	ldi	r20, 0x7D	; 125
    e48a:	e4 2e       	mov	r14, r20
    e48c:	46 e0       	ldi	r20, 0x06	; 6
    e48e:	f4 2e       	mov	r15, r20
    e490:	14 96       	adiw	r26, 0x04	; 4
    e492:	fc 92       	st	X, r15
    e494:	ee 92       	st	-X, r14
    e496:	13 97       	sbiw	r26, 0x03	; 3
    e498:	0e 94 9a 82 	call	0x10534	; 0x10534 <fprintf_P>
								st7735_setCursor(119,90);
    e49c:	0f 90       	pop	r0
    e49e:	0f 90       	pop	r0
    e4a0:	0f 90       	pop	r0
    e4a2:	0f 90       	pop	r0
    e4a4:	87 e7       	ldi	r24, 0x77	; 119
    e4a6:	90 e0       	ldi	r25, 0x00	; 0
    e4a8:	6a e5       	ldi	r22, 0x5A	; 90
    e4aa:	70 e0       	ldi	r23, 0x00	; 0
    e4ac:	0e 94 c2 19 	call	0x3384	; 0x3384 <st7735_setCursor>
								fprintf_P(&st7735_out, PSTR("2"));
    e4b0:	00 d0       	rcall	.+0      	; 0xe4b2 <Thread12+0xf1e>
    e4b2:	00 d0       	rcall	.+0      	; 0xe4b4 <Thread12+0xf20>
    e4b4:	ec eb       	ldi	r30, 0xBC	; 188
    e4b6:	f6 e0       	ldi	r31, 0x06	; 6
    e4b8:	ad b7       	in	r26, 0x3d	; 61
    e4ba:	be b7       	in	r27, 0x3e	; 62
    e4bc:	12 96       	adiw	r26, 0x02	; 2
    e4be:	fc 93       	st	X, r31
    e4c0:	ee 93       	st	-X, r30
    e4c2:	11 97       	sbiw	r26, 0x01	; 1
    e4c4:	3b e7       	ldi	r19, 0x7B	; 123
    e4c6:	e3 2e       	mov	r14, r19
    e4c8:	36 e0       	ldi	r19, 0x06	; 6
    e4ca:	f3 2e       	mov	r15, r19
    e4cc:	14 96       	adiw	r26, 0x04	; 4
    e4ce:	fc 92       	st	X, r15
    e4d0:	ee 92       	st	-X, r14
    e4d2:	13 97       	sbiw	r26, 0x03	; 3
    e4d4:	0e 94 9a 82 	call	0x10534	; 0x10534 <fprintf_P>
								chSemSignal(&spiUSE);
    e4d8:	0f 90       	pop	r0
    e4da:	0f 90       	pop	r0
    e4dc:	0f 90       	pop	r0
    e4de:	0f 90       	pop	r0
    e4e0:	89 e7       	ldi	r24, 0x79	; 121
    e4e2:	94 e1       	ldi	r25, 0x14	; 20
    e4e4:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
    e4e8:	77 ce       	rjmp	.-786    	; 0xe1d8 <Thread12+0xc44>
						}	
					}//HB filter		
					
					if(lcd_context ==12){
						if (lcd_context_count[11] == 1) { // in HB mode
							chSemWait(&spiUSE);
    e4ea:	89 e7       	ldi	r24, 0x79	; 121
    e4ec:	94 e1       	ldi	r25, 0x14	; 20
    e4ee:	40 e0       	ldi	r20, 0x00	; 0
    e4f0:	50 e0       	ldi	r21, 0x00	; 0
    e4f2:	60 e0       	ldi	r22, 0x00	; 0
    e4f4:	70 e0       	ldi	r23, 0x00	; 0
    e4f6:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
							st7735_setCursor(50,86);
    e4fa:	82 e3       	ldi	r24, 0x32	; 50
    e4fc:	90 e0       	ldi	r25, 0x00	; 0
    e4fe:	66 e5       	ldi	r22, 0x56	; 86
    e500:	70 e0       	ldi	r23, 0x00	; 0
    e502:	0e 94 c2 19 	call	0x3384	; 0x3384 <st7735_setCursor>
							st7735_setTextSize(3);
    e506:	83 e0       	ldi	r24, 0x03	; 3
    e508:	0e 94 cb 19 	call	0x3396	; 0x3396 <st7735_setTextSize>
							fprintf_P(&st7735_out,PSTR("%3d"), current_HB_average);
    e50c:	4d b7       	in	r20, 0x3d	; 61
    e50e:	5e b7       	in	r21, 0x3e	; 62
    e510:	48 50       	subi	r20, 0x08	; 8
    e512:	50 40       	sbci	r21, 0x00	; 0
    e514:	0f b6       	in	r0, 0x3f	; 63
    e516:	f8 94       	cli
    e518:	5e bf       	out	0x3e, r21	; 62
    e51a:	0f be       	out	0x3f, r0	; 63
    e51c:	4d bf       	out	0x3d, r20	; 61
    e51e:	ed b7       	in	r30, 0x3d	; 61
    e520:	fe b7       	in	r31, 0x3e	; 62
    e522:	31 96       	adiw	r30, 0x01	; 1
    e524:	7c eb       	ldi	r23, 0xBC	; 188
    e526:	e7 2e       	mov	r14, r23
    e528:	76 e0       	ldi	r23, 0x06	; 6
    e52a:	f7 2e       	mov	r15, r23
    e52c:	ad b7       	in	r26, 0x3d	; 61
    e52e:	be b7       	in	r27, 0x3e	; 62
    e530:	12 96       	adiw	r26, 0x02	; 2
    e532:	fc 92       	st	X, r15
    e534:	ee 92       	st	-X, r14
    e536:	11 97       	sbiw	r26, 0x01	; 1
    e538:	07 e7       	ldi	r16, 0x77	; 119
    e53a:	16 e0       	ldi	r17, 0x06	; 6
    e53c:	13 83       	std	Z+3, r17	; 0x03
    e53e:	02 83       	std	Z+2, r16	; 0x02
    e540:	a4 82       	std	Z+4, r10	; 0x04
    e542:	b5 82       	std	Z+5, r11	; 0x05
    e544:	c6 82       	std	Z+6, r12	; 0x06
    e546:	d7 82       	std	Z+7, r13	; 0x07
    e548:	0e 94 9a 82 	call	0x10534	; 0x10534 <fprintf_P>
							st7735_setCursor(35,86);
    e54c:	2d b7       	in	r18, 0x3d	; 61
    e54e:	3e b7       	in	r19, 0x3e	; 62
    e550:	28 5f       	subi	r18, 0xF8	; 248
    e552:	3f 4f       	sbci	r19, 0xFF	; 255
    e554:	0f b6       	in	r0, 0x3f	; 63
    e556:	f8 94       	cli
    e558:	3e bf       	out	0x3e, r19	; 62
    e55a:	0f be       	out	0x3f, r0	; 63
    e55c:	2d bf       	out	0x3d, r18	; 61
    e55e:	83 e2       	ldi	r24, 0x23	; 35
    e560:	90 e0       	ldi	r25, 0x00	; 0
    e562:	66 e5       	ldi	r22, 0x56	; 86
    e564:	70 e0       	ldi	r23, 0x00	; 0
    e566:	0e 94 c2 19 	call	0x3384	; 0x3384 <st7735_setCursor>
							st7735_setTextSize(2);
    e56a:	82 e0       	ldi	r24, 0x02	; 2
    e56c:	0e 94 cb 19 	call	0x3396	; 0x3396 <st7735_setTextSize>
							fprintf_P(&st7735_out,PSTR("%c"), 0x03);//should print heart
    e570:	00 d0       	rcall	.+0      	; 0xe572 <Thread12+0xfde>
    e572:	00 d0       	rcall	.+0      	; 0xe574 <Thread12+0xfe0>
    e574:	00 d0       	rcall	.+0      	; 0xe576 <Thread12+0xfe2>
    e576:	ed b7       	in	r30, 0x3d	; 61
    e578:	fe b7       	in	r31, 0x3e	; 62
    e57a:	31 96       	adiw	r30, 0x01	; 1
    e57c:	ad b7       	in	r26, 0x3d	; 61
    e57e:	be b7       	in	r27, 0x3e	; 62
    e580:	12 96       	adiw	r26, 0x02	; 2
    e582:	fc 92       	st	X, r15
    e584:	ee 92       	st	-X, r14
    e586:	11 97       	sbiw	r26, 0x01	; 1
    e588:	64 e7       	ldi	r22, 0x74	; 116
    e58a:	e6 2e       	mov	r14, r22
    e58c:	66 e0       	ldi	r22, 0x06	; 6
    e58e:	f6 2e       	mov	r15, r22
    e590:	f3 82       	std	Z+3, r15	; 0x03
    e592:	e2 82       	std	Z+2, r14	; 0x02
    e594:	03 e0       	ldi	r16, 0x03	; 3
    e596:	10 e0       	ldi	r17, 0x00	; 0
    e598:	15 83       	std	Z+5, r17	; 0x05
    e59a:	04 83       	std	Z+4, r16	; 0x04
    e59c:	0e 94 9a 82 	call	0x10534	; 0x10534 <fprintf_P>
							chSemSignal(&spiUSE);
    e5a0:	2d b7       	in	r18, 0x3d	; 61
    e5a2:	3e b7       	in	r19, 0x3e	; 62
    e5a4:	2a 5f       	subi	r18, 0xFA	; 250
    e5a6:	3f 4f       	sbci	r19, 0xFF	; 255
    e5a8:	0f b6       	in	r0, 0x3f	; 63
    e5aa:	f8 94       	cli
    e5ac:	3e bf       	out	0x3e, r19	; 62
    e5ae:	0f be       	out	0x3f, r0	; 63
    e5b0:	2d bf       	out	0x3d, r18	; 61
    e5b2:	89 e7       	ldi	r24, 0x79	; 121
    e5b4:	94 e1       	ldi	r25, 0x14	; 20
    e5b6:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
    e5ba:	b2 ce       	rjmp	.-668    	; 0xe320 <Thread12+0xd8c>
				ms_elapsed_since_last = ms_current_beat - ms_old_beat;
				ms_old_beat = ms_current_beat;
				if (just_entered ==1){
					if(lcd_context ==12){
							if (lcd_context_count[11] == 1) { // in HB mode
								chSemWait(&spiUSE);
    e5bc:	89 e7       	ldi	r24, 0x79	; 121
    e5be:	94 e1       	ldi	r25, 0x14	; 20
    e5c0:	40 e0       	ldi	r20, 0x00	; 0
    e5c2:	50 e0       	ldi	r21, 0x00	; 0
    e5c4:	60 e0       	ldi	r22, 0x00	; 0
    e5c6:	70 e0       	ldi	r23, 0x00	; 0
    e5c8:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
								st7735_fill_rect(32, 83, 96, 30, ST7735_COLOR_BLACK);//second coordinates are offset!!!
    e5cc:	80 e2       	ldi	r24, 0x20	; 32
    e5ce:	63 e5       	ldi	r22, 0x53	; 83
    e5d0:	40 e6       	ldi	r20, 0x60	; 96
    e5d2:	2e e1       	ldi	r18, 0x1E	; 30
    e5d4:	00 e0       	ldi	r16, 0x00	; 0
    e5d6:	10 e0       	ldi	r17, 0x00	; 0
    e5d8:	0e 94 59 16 	call	0x2cb2	; 0x2cb2 <st7735_fill_rect>
								st7735_setCursor(107,86);
    e5dc:	8b e6       	ldi	r24, 0x6B	; 107
    e5de:	90 e0       	ldi	r25, 0x00	; 0
    e5e0:	66 e5       	ldi	r22, 0x56	; 86
    e5e2:	70 e0       	ldi	r23, 0x00	; 0
    e5e4:	0e 94 c2 19 	call	0x3384	; 0x3384 <st7735_setCursor>
								st7735_setTextSize(1);
    e5e8:	81 e0       	ldi	r24, 0x01	; 1
    e5ea:	0e 94 cb 19 	call	0x3396	; 0x3396 <st7735_setTextSize>
								fprintf_P(&st7735_out, PSTR("BPM"));    
    e5ee:	00 d0       	rcall	.+0      	; 0xe5f0 <Thread12+0x105c>
    e5f0:	00 d0       	rcall	.+0      	; 0xe5f2 <Thread12+0x105e>
    e5f2:	ec eb       	ldi	r30, 0xBC	; 188
    e5f4:	f6 e0       	ldi	r31, 0x06	; 6
    e5f6:	ad b7       	in	r26, 0x3d	; 61
    e5f8:	be b7       	in	r27, 0x3e	; 62
    e5fa:	12 96       	adiw	r26, 0x02	; 2
    e5fc:	fc 93       	st	X, r31
    e5fe:	ee 93       	st	-X, r30
    e600:	11 97       	sbiw	r26, 0x01	; 1
    e602:	65 e8       	ldi	r22, 0x85	; 133
    e604:	e6 2e       	mov	r14, r22
    e606:	66 e0       	ldi	r22, 0x06	; 6
    e608:	f6 2e       	mov	r15, r22
    e60a:	14 96       	adiw	r26, 0x04	; 4
    e60c:	fc 92       	st	X, r15
    e60e:	ee 92       	st	-X, r14
    e610:	13 97       	sbiw	r26, 0x03	; 3
    e612:	0e 94 9a 82 	call	0x10534	; 0x10534 <fprintf_P>
								chSemSignal(&spiUSE);
    e616:	0f 90       	pop	r0
    e618:	0f 90       	pop	r0
    e61a:	0f 90       	pop	r0
    e61c:	0f 90       	pop	r0
    e61e:	89 e7       	ldi	r24, 0x79	; 121
    e620:	94 e1       	ldi	r25, 0x14	; 20
    e622:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
    e626:	e7 ce       	rjmp	.-562    	; 0xe3f6 <Thread12+0xe62>
					for(SPO2_index = 0; SPO2_index < 7; SPO2_index++){
						SPO2_sum += SPO2_circular_buffer[SPO2_index];
					}
					SPO2_sum /= 7L;
					if(lcd_context ==12){
						chSemWait(&spiUSE);
    e628:	89 e7       	ldi	r24, 0x79	; 121
    e62a:	94 e1       	ldi	r25, 0x14	; 20
    e62c:	40 e0       	ldi	r20, 0x00	; 0
    e62e:	50 e0       	ldi	r21, 0x00	; 0
    e630:	60 e0       	ldi	r22, 0x00	; 0
    e632:	70 e0       	ldi	r23, 0x00	; 0
    e634:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
						st7735_setCursor(35,86);
    e638:	83 e2       	ldi	r24, 0x23	; 35
    e63a:	90 e0       	ldi	r25, 0x00	; 0
    e63c:	66 e5       	ldi	r22, 0x56	; 86
    e63e:	70 e0       	ldi	r23, 0x00	; 0
    e640:	0e 94 c2 19 	call	0x3384	; 0x3384 <st7735_setCursor>
						st7735_setTextSize(2);
    e644:	82 e0       	ldi	r24, 0x02	; 2
    e646:	0e 94 cb 19 	call	0x3396	; 0x3396 <st7735_setTextSize>
						fprintf_P(&st7735_out,PSTR(" "));
    e64a:	00 d0       	rcall	.+0      	; 0xe64c <Thread12+0x10b8>
    e64c:	00 d0       	rcall	.+0      	; 0xe64e <Thread12+0x10ba>
    e64e:	ec eb       	ldi	r30, 0xBC	; 188
    e650:	f6 e0       	ldi	r31, 0x06	; 6
    e652:	ad b7       	in	r26, 0x3d	; 61
    e654:	be b7       	in	r27, 0x3e	; 62
    e656:	12 96       	adiw	r26, 0x02	; 2
    e658:	fc 93       	st	X, r31
    e65a:	ee 93       	st	-X, r30
    e65c:	11 97       	sbiw	r26, 0x01	; 1
    e65e:	10 e7       	ldi	r17, 0x70	; 112
    e660:	e1 2e       	mov	r14, r17
    e662:	16 e0       	ldi	r17, 0x06	; 6
    e664:	f1 2e       	mov	r15, r17
    e666:	14 96       	adiw	r26, 0x04	; 4
    e668:	fc 92       	st	X, r15
    e66a:	ee 92       	st	-X, r14
    e66c:	13 97       	sbiw	r26, 0x03	; 3
    e66e:	0e 94 9a 82 	call	0x10534	; 0x10534 <fprintf_P>
						st7735_setCursor(50,86);
    e672:	0f 90       	pop	r0
    e674:	0f 90       	pop	r0
    e676:	0f 90       	pop	r0
    e678:	0f 90       	pop	r0
    e67a:	82 e3       	ldi	r24, 0x32	; 50
    e67c:	90 e0       	ldi	r25, 0x00	; 0
    e67e:	66 e5       	ldi	r22, 0x56	; 86
    e680:	70 e0       	ldi	r23, 0x00	; 0
    e682:	0e 94 c2 19 	call	0x3384	; 0x3384 <st7735_setCursor>
						st7735_setTextSize(3);
    e686:	83 e0       	ldi	r24, 0x03	; 3
    e688:	0e 94 cb 19 	call	0x3396	; 0x3396 <st7735_setTextSize>
						fprintf_P(&st7735_out,PSTR("%3ld"), SPO2_sum);
    e68c:	0d b7       	in	r16, 0x3d	; 61
    e68e:	1e b7       	in	r17, 0x3e	; 62
    e690:	08 50       	subi	r16, 0x08	; 8
    e692:	10 40       	sbci	r17, 0x00	; 0
    e694:	0f b6       	in	r0, 0x3f	; 63
    e696:	f8 94       	cli
    e698:	1e bf       	out	0x3e, r17	; 62
    e69a:	0f be       	out	0x3f, r0	; 63
    e69c:	0d bf       	out	0x3d, r16	; 61
    e69e:	0f 5f       	subi	r16, 0xFF	; 255
    e6a0:	1f 4f       	sbci	r17, 0xFF	; 255
    e6a2:	ec eb       	ldi	r30, 0xBC	; 188
    e6a4:	f6 e0       	ldi	r31, 0x06	; 6
    e6a6:	ad b7       	in	r26, 0x3d	; 61
    e6a8:	be b7       	in	r27, 0x3e	; 62
    e6aa:	12 96       	adiw	r26, 0x02	; 2
    e6ac:	fc 93       	st	X, r31
    e6ae:	ee 93       	st	-X, r30
    e6b0:	11 97       	sbiw	r26, 0x01	; 1
    e6b2:	eb e6       	ldi	r30, 0x6B	; 107
    e6b4:	f6 e0       	ldi	r31, 0x06	; 6
    e6b6:	d8 01       	movw	r26, r16
    e6b8:	13 96       	adiw	r26, 0x03	; 3
    e6ba:	fc 93       	st	X, r31
    e6bc:	ee 93       	st	-X, r30
    e6be:	12 97       	sbiw	r26, 0x02	; 2
    e6c0:	c4 01       	movw	r24, r8
    e6c2:	b3 01       	movw	r22, r6
    e6c4:	27 e0       	ldi	r18, 0x07	; 7
    e6c6:	30 e0       	ldi	r19, 0x00	; 0
    e6c8:	40 e0       	ldi	r20, 0x00	; 0
    e6ca:	50 e0       	ldi	r21, 0x00	; 0
    e6cc:	0e 94 2f 80 	call	0x1005e	; 0x1005e <__divmodsi4>
    e6d0:	d8 01       	movw	r26, r16
    e6d2:	14 96       	adiw	r26, 0x04	; 4
    e6d4:	2d 93       	st	X+, r18
    e6d6:	3d 93       	st	X+, r19
    e6d8:	4d 93       	st	X+, r20
    e6da:	5c 93       	st	X, r21
    e6dc:	17 97       	sbiw	r26, 0x07	; 7
    e6de:	0e 94 9a 82 	call	0x10534	; 0x10534 <fprintf_P>
						chSemSignal(&spiUSE);
    e6e2:	ed b7       	in	r30, 0x3d	; 61
    e6e4:	fe b7       	in	r31, 0x3e	; 62
    e6e6:	38 96       	adiw	r30, 0x08	; 8
    e6e8:	0f b6       	in	r0, 0x3f	; 63
    e6ea:	f8 94       	cli
    e6ec:	fe bf       	out	0x3e, r31	; 62
    e6ee:	0f be       	out	0x3f, r0	; 63
    e6f0:	ed bf       	out	0x3d, r30	; 61
    e6f2:	89 e7       	ldi	r24, 0x79	; 121
    e6f4:	94 e1       	ldi	r25, 0x14	; 20
    e6f6:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
    e6fa:	40 cb       	rjmp	.-2432   	; 0xdd7c <Thread12+0x7e8>
		fprintf_P(&usart_out,PSTR("MAX30105 was not found. Please check wiring/power. \r\n"));
		chSemSignal(&usartUSE);
	}
	
	if (USART_HB_LOGGING_ON ==1){
		MAX30105_setup(0x3F, 8, 2, 400, 411, 4096); //Configure sensor with default settings
    e6fc:	8f e3       	ldi	r24, 0x3F	; 63
    e6fe:	68 e0       	ldi	r22, 0x08	; 8
    e700:	0a c8       	rjmp	.-4076   	; 0xd716 <Thread12+0x182>
	chThdSleepMilliseconds(300);
	
	chSemWait(&i2cUSE);
	i2c_init();
	if (!MAX30105_init()) {//Use default I2C port, 400kHz speed
		chSemWait(&usartUSE);
    e702:	87 ec       	ldi	r24, 0xC7	; 199
    e704:	90 e3       	ldi	r25, 0x30	; 48
    e706:	40 e0       	ldi	r20, 0x00	; 0
    e708:	50 e0       	ldi	r21, 0x00	; 0
    e70a:	60 e0       	ldi	r22, 0x00	; 0
    e70c:	70 e0       	ldi	r23, 0x00	; 0
    e70e:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
		fprintf_P(&usart_out,PSTR("MAX30105 was not found. Please check wiring/power. \r\n"));
    e712:	00 d0       	rcall	.+0      	; 0xe714 <Thread12+0x1180>
    e714:	00 d0       	rcall	.+0      	; 0xe716 <Thread12+0x1182>
    e716:	aa ec       	ldi	r26, 0xCA	; 202
    e718:	ca 2e       	mov	r12, r26
    e71a:	a6 e0       	ldi	r26, 0x06	; 6
    e71c:	da 2e       	mov	r13, r26
    e71e:	ad b7       	in	r26, 0x3d	; 61
    e720:	be b7       	in	r27, 0x3e	; 62
    e722:	12 96       	adiw	r26, 0x02	; 2
    e724:	dc 92       	st	X, r13
    e726:	ce 92       	st	-X, r12
    e728:	11 97       	sbiw	r26, 0x01	; 1
    e72a:	89 e4       	ldi	r24, 0x49	; 73
    e72c:	97 e0       	ldi	r25, 0x07	; 7
    e72e:	14 96       	adiw	r26, 0x04	; 4
    e730:	9c 93       	st	X, r25
    e732:	8e 93       	st	-X, r24
    e734:	13 97       	sbiw	r26, 0x03	; 3
    e736:	0e 94 9a 82 	call	0x10534	; 0x10534 <fprintf_P>
		chSemSignal(&usartUSE);
    e73a:	0f 90       	pop	r0
    e73c:	0f 90       	pop	r0
    e73e:	0f 90       	pop	r0
    e740:	0f 90       	pop	r0
    e742:	87 ec       	ldi	r24, 0xC7	; 199
    e744:	90 e3       	ldi	r25, 0x30	; 48
    e746:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
    e74a:	0c 94 84 6b 	jmp	0xd708	; 0xd708 <Thread12+0x174>

0000e74e <Thread3>:
	(void)arg;
	// initialize the SD card
	BYTE res1, res2;
	uint8_t pic_is_drawn = 0;

	tp[2] = chThdGetSelfX();
    e74e:	80 91 ce 07 	lds	r24, 0x07CE
    e752:	90 91 cf 07 	lds	r25, 0x07CF
    e756:	90 93 9b 07 	sts	0x079B, r25
    e75a:	80 93 9a 07 	sts	0x079A, r24
    e75e:	cc eb       	ldi	r28, 0xBC	; 188
    e760:	d6 e0       	ldi	r29, 0x06	; 6
    e762:	90 ef       	ldi	r25, 0xF0	; 240
    e764:	c9 2e       	mov	r12, r25
    e766:	9a e0       	ldi	r25, 0x0A	; 10
    e768:	d9 2e       	mov	r13, r25
		chSysLock();
		msg = chThdSuspendTimeoutS(&trp[2], TIME_INFINITE);
		chSysUnlock();
		chSemWait(&lcdUSE);
		/*switch lcd_context to thread 5*/
		lcd_context = 3;
    e76a:	83 e0       	ldi	r24, 0x03	; 3
    e76c:	b8 2e       	mov	r11, r24
    e76e:	f8 94       	cli
	msg_t msg;
	
	while (true) {
		/* Waiting for signal to show a picture - transfer via a message*/
		chSysLock();
		msg = chThdSuspendTimeoutS(&trp[2], TIME_INFINITE);
    e770:	86 eb       	ldi	r24, 0xB6	; 182
    e772:	97 e0       	ldi	r25, 0x07	; 7
    e774:	40 e0       	ldi	r20, 0x00	; 0
    e776:	50 e0       	ldi	r21, 0x00	; 0
    e778:	60 e0       	ldi	r22, 0x00	; 0
    e77a:	70 e0       	ldi	r23, 0x00	; 0
    e77c:	0e 94 fc 08 	call	0x11f8	; 0x11f8 <chThdSuspendTimeoutS>
    e780:	e8 2e       	mov	r14, r24
    e782:	78 94       	sei
		chSysUnlock();
		chSemWait(&lcdUSE);
    e784:	8d ef       	ldi	r24, 0xFD	; 253
    e786:	93 e1       	ldi	r25, 0x13	; 19
    e788:	40 e0       	ldi	r20, 0x00	; 0
    e78a:	50 e0       	ldi	r21, 0x00	; 0
    e78c:	60 e0       	ldi	r22, 0x00	; 0
    e78e:	70 e0       	ldi	r23, 0x00	; 0
    e790:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
		/*switch lcd_context to thread 5*/
		lcd_context = 3;
    e794:	b0 92 32 05 	sts	0x0532, r11
		
		chSemWait(&spiUSE);
    e798:	89 e7       	ldi	r24, 0x79	; 121
    e79a:	94 e1       	ldi	r25, 0x14	; 20
    e79c:	40 e0       	ldi	r20, 0x00	; 0
    e79e:	50 e0       	ldi	r21, 0x00	; 0
    e7a0:	60 e0       	ldi	r22, 0x00	; 0
    e7a2:	70 e0       	ldi	r23, 0x00	; 0
    e7a4:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
		st7735_fill_rect(0, 0, 160, 128, ST7735_COLOR_BLACK);//lcd_clear();
    e7a8:	80 e0       	ldi	r24, 0x00	; 0
    e7aa:	60 e0       	ldi	r22, 0x00	; 0
    e7ac:	40 ea       	ldi	r20, 0xA0	; 160
    e7ae:	20 e8       	ldi	r18, 0x80	; 128
    e7b0:	00 e0       	ldi	r16, 0x00	; 0
    e7b2:	10 e0       	ldi	r17, 0x00	; 0
    e7b4:	0e 94 59 16 	call	0x2cb2	; 0x2cb2 <st7735_fill_rect>
		st7735_setCursor(5,10);
    e7b8:	85 e0       	ldi	r24, 0x05	; 5
    e7ba:	90 e0       	ldi	r25, 0x00	; 0
    e7bc:	6a e0       	ldi	r22, 0x0A	; 10
    e7be:	70 e0       	ldi	r23, 0x00	; 0
    e7c0:	0e 94 c2 19 	call	0x3384	; 0x3384 <st7735_setCursor>
		chSemSignal(&spiUSE);
    e7c4:	89 e7       	ldi	r24, 0x79	; 121
    e7c6:	94 e1       	ldi	r25, 0x14	; 20
    e7c8:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
		
		chSemWait(&sdUSE);
    e7cc:	80 e0       	ldi	r24, 0x00	; 0
    e7ce:	96 e2       	ldi	r25, 0x26	; 38
    e7d0:	40 e0       	ldi	r20, 0x00	; 0
    e7d2:	50 e0       	ldi	r21, 0x00	; 0
    e7d4:	60 e0       	ldi	r22, 0x00	; 0
    e7d6:	70 e0       	ldi	r23, 0x00	; 0
    e7d8:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
		chSemWait(&spiUSE);
    e7dc:	89 e7       	ldi	r24, 0x79	; 121
    e7de:	94 e1       	ldi	r25, 0x14	; 20
    e7e0:	40 e0       	ldi	r20, 0x00	; 0
    e7e2:	50 e0       	ldi	r21, 0x00	; 0
    e7e4:	60 e0       	ldi	r22, 0x00	; 0
    e7e6:	70 e0       	ldi	r23, 0x00	; 0
    e7e8:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
		res1 = disk_initialize(0);
    e7ec:	80 e0       	ldi	r24, 0x00	; 0
    e7ee:	0e 94 94 23 	call	0x4728	; 0x4728 <disk_initialize>
    e7f2:	08 2f       	mov	r16, r24
		chSemSignal(&spiUSE);
    e7f4:	89 e7       	ldi	r24, 0x79	; 121
    e7f6:	94 e1       	ldi	r25, 0x14	; 20
    e7f8:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
		chSemSignal(&sdUSE);
    e7fc:	80 e0       	ldi	r24, 0x00	; 0
    e7fe:	96 e2       	ldi	r25, 0x26	; 38
    e800:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
		
		//fprintf_P(&st7735_out,PSTR("Disk Init: %d (0 = OK)"), res1);
		chThdSleepMilliseconds(500);
    e804:	60 e1       	ldi	r22, 0x10	; 16
    e806:	77 e2       	ldi	r23, 0x27	; 39
    e808:	80 e0       	ldi	r24, 0x00	; 0
    e80a:	90 e0       	ldi	r25, 0x00	; 0
    e80c:	0e 94 f4 08 	call	0x11e8	; 0x11e8 <chThdSleep>
		//st7735_setCursor(5,20);
		
		chSemWait(&sdUSE);
    e810:	80 e0       	ldi	r24, 0x00	; 0
    e812:	96 e2       	ldi	r25, 0x26	; 38
    e814:	40 e0       	ldi	r20, 0x00	; 0
    e816:	50 e0       	ldi	r21, 0x00	; 0
    e818:	60 e0       	ldi	r22, 0x00	; 0
    e81a:	70 e0       	ldi	r23, 0x00	; 0
    e81c:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
		chSemWait(&spiUSE);
    e820:	89 e7       	ldi	r24, 0x79	; 121
    e822:	94 e1       	ldi	r25, 0x14	; 20
    e824:	40 e0       	ldi	r20, 0x00	; 0
    e826:	50 e0       	ldi	r21, 0x00	; 0
    e828:	60 e0       	ldi	r22, 0x00	; 0
    e82a:	70 e0       	ldi	r23, 0x00	; 0
    e82c:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
		res2 = f_mount(0, &Fatfs[0]);
    e830:	80 e0       	ldi	r24, 0x00	; 0
    e832:	63 ed       	ldi	r22, 0xD3	; 211
    e834:	7b e0       	ldi	r23, 0x0B	; 11
    e836:	0e 94 60 26 	call	0x4cc0	; 0x4cc0 <f_mount>
    e83a:	f8 2e       	mov	r15, r24
		chSemSignal(&spiUSE);
    e83c:	89 e7       	ldi	r24, 0x79	; 121
    e83e:	94 e1       	ldi	r25, 0x14	; 20
    e840:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
		chSemSignal(&sdUSE);
    e844:	80 e0       	ldi	r24, 0x00	; 0
    e846:	96 e2       	ldi	r25, 0x26	; 38
    e848:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
		
		//fprintf_P(&st7735_out,PSTR("f_mount: %d (0 = OK)"), res2);
		
		chThdSleepMilliseconds(500);
    e84c:	60 e1       	ldi	r22, 0x10	; 16
    e84e:	77 e2       	ldi	r23, 0x27	; 39
    e850:	80 e0       	ldi	r24, 0x00	; 0
    e852:	90 e0       	ldi	r25, 0x00	; 0
    e854:	0e 94 f4 08 	call	0x11e8	; 0x11e8 <chThdSleep>
    e858:	10 e0       	ldi	r17, 0x00	; 0
		
		while(true) {
            if(chEvtWaitAnyTimeout((eventmask_t)2, TIME_IMMEDIATE) == 2){
    e85a:	82 e0       	ldi	r24, 0x02	; 2
    e85c:	4f ef       	ldi	r20, 0xFF	; 255
    e85e:	5f ef       	ldi	r21, 0xFF	; 255
    e860:	6f ef       	ldi	r22, 0xFF	; 255
    e862:	7f ef       	ldi	r23, 0xFF	; 255
    e864:	0e 94 b4 08 	call	0x1168	; 0x1168 <chEvtWaitAnyTimeout>
    e868:	82 30       	cpi	r24, 0x02	; 2
    e86a:	09 f4       	brne	.+2      	; 0xe86e <Thread3+0x120>
    e86c:	46 c0       	rjmp	.+140    	; 0xe8fa <Thread3+0x1ac>
				pic_is_drawn = 0;
				chSemSignal(&lcdUSE); /*thread 3 gives back the LCD*/
				break;
			}		
			if ((!res1) && (!res2) && (!pic_is_drawn)) {	
    e86e:	00 23       	and	r16, r16
    e870:	39 f5       	brne	.+78     	; 0xe8c0 <Thread3+0x172>
    e872:	ff 20       	and	r15, r15
    e874:	29 f5       	brne	.+74     	; 0xe8c0 <Thread3+0x172>
    e876:	11 23       	and	r17, r17
    e878:	39 f4       	brne	.+14     	; 0xe888 <Thread3+0x13a>
				if ((uint8_t)msg == 1) {
    e87a:	81 e0       	ldi	r24, 0x01	; 1
    e87c:	e8 16       	cp	r14, r24
    e87e:	09 f4       	brne	.+2      	; 0xe882 <Thread3+0x134>
    e880:	41 c0       	rjmp	.+130    	; 0xe904 <Thread3+0x1b6>
					chSemWait(&sdUSE);
					bmpDraw("img00001.bmp",0,0);
					chSemSignal(&sdUSE);
				}
				if ((uint8_t)msg == 2) {
    e882:	e2 e0       	ldi	r30, 0x02	; 2
    e884:	ee 16       	cp	r14, r30
    e886:	41 f0       	breq	.+16     	; 0xe898 <Thread3+0x14a>
				pic_is_drawn = 1;
			} 
			else if (!pic_is_drawn) {
					chSemWait(&spiUSE);
					fprintf_P(&st7735_out,PSTR("can't open file"));
					chSemSignal(&spiUSE);
    e888:	11 e0       	ldi	r17, 0x01	; 1
			}	
			chThdSleepMilliseconds(300);
    e88a:	60 e7       	ldi	r22, 0x70	; 112
    e88c:	77 e1       	ldi	r23, 0x17	; 23
    e88e:	80 e0       	ldi	r24, 0x00	; 0
    e890:	90 e0       	ldi	r25, 0x00	; 0
    e892:	0e 94 f4 08 	call	0x11e8	; 0x11e8 <chThdSleep>
    e896:	e1 cf       	rjmp	.-62     	; 0xe85a <Thread3+0x10c>
					chSemWait(&sdUSE);
					bmpDraw("img00001.bmp",0,0);
					chSemSignal(&sdUSE);
				}
				if ((uint8_t)msg == 2) {
					chSemWait(&sdUSE);
    e898:	80 e0       	ldi	r24, 0x00	; 0
    e89a:	96 e2       	ldi	r25, 0x26	; 38
    e89c:	40 e0       	ldi	r20, 0x00	; 0
    e89e:	50 e0       	ldi	r21, 0x00	; 0
    e8a0:	60 e0       	ldi	r22, 0x00	; 0
    e8a2:	70 e0       	ldi	r23, 0x00	; 0
    e8a4:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
					bmpDraw("img00002.bmp",0,0);
    e8a8:	84 e2       	ldi	r24, 0x24	; 36
    e8aa:	95 e0       	ldi	r25, 0x05	; 5
    e8ac:	60 e0       	ldi	r22, 0x00	; 0
    e8ae:	40 e0       	ldi	r20, 0x00	; 0
    e8b0:	0e 94 2d 67 	call	0xce5a	; 0xce5a <bmpDraw>
					chSemSignal(&sdUSE);
    e8b4:	80 e0       	ldi	r24, 0x00	; 0
    e8b6:	96 e2       	ldi	r25, 0x26	; 38
    e8b8:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
    e8bc:	11 e0       	ldi	r17, 0x01	; 1
    e8be:	e5 cf       	rjmp	.-54     	; 0xe88a <Thread3+0x13c>
				}
				pic_is_drawn = 1;
			} 
			else if (!pic_is_drawn) {
    e8c0:	11 23       	and	r17, r17
    e8c2:	11 f7       	brne	.-60     	; 0xe888 <Thread3+0x13a>
					chSemWait(&spiUSE);
    e8c4:	89 e7       	ldi	r24, 0x79	; 121
    e8c6:	94 e1       	ldi	r25, 0x14	; 20
    e8c8:	40 e0       	ldi	r20, 0x00	; 0
    e8ca:	50 e0       	ldi	r21, 0x00	; 0
    e8cc:	60 e0       	ldi	r22, 0x00	; 0
    e8ce:	70 e0       	ldi	r23, 0x00	; 0
    e8d0:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
					fprintf_P(&st7735_out,PSTR("can't open file"));
    e8d4:	00 d0       	rcall	.+0      	; 0xe8d6 <Thread3+0x188>
    e8d6:	00 d0       	rcall	.+0      	; 0xe8d8 <Thread3+0x18a>
    e8d8:	ed b7       	in	r30, 0x3d	; 61
    e8da:	fe b7       	in	r31, 0x3e	; 62
    e8dc:	d2 83       	std	Z+2, r29	; 0x02
    e8de:	c1 83       	std	Z+1, r28	; 0x01
    e8e0:	d4 82       	std	Z+4, r13	; 0x04
    e8e2:	c3 82       	std	Z+3, r12	; 0x03
    e8e4:	0e 94 9a 82 	call	0x10534	; 0x10534 <fprintf_P>
					chSemSignal(&spiUSE);
    e8e8:	0f 90       	pop	r0
    e8ea:	0f 90       	pop	r0
    e8ec:	0f 90       	pop	r0
    e8ee:	0f 90       	pop	r0
    e8f0:	89 e7       	ldi	r24, 0x79	; 121
    e8f2:	94 e1       	ldi	r25, 0x14	; 20
    e8f4:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
    e8f8:	c8 cf       	rjmp	.-112    	; 0xe88a <Thread3+0x13c>
		chThdSleepMilliseconds(500);
		
		while(true) {
            if(chEvtWaitAnyTimeout((eventmask_t)2, TIME_IMMEDIATE) == 2){
				pic_is_drawn = 0;
				chSemSignal(&lcdUSE); /*thread 3 gives back the LCD*/
    e8fa:	8d ef       	ldi	r24, 0xFD	; 253
    e8fc:	93 e1       	ldi	r25, 0x13	; 19
    e8fe:	0e 94 2e 09 	call	0x125c	; 0x125c <chSemSignal>
    e902:	35 cf       	rjmp	.-406    	; 0xe76e <Thread3+0x20>
				break;
			}		
			if ((!res1) && (!res2) && (!pic_is_drawn)) {	
				if ((uint8_t)msg == 1) {
					chSemWait(&sdUSE);
    e904:	80 e0       	ldi	r24, 0x00	; 0
    e906:	96 e2       	ldi	r25, 0x26	; 38
    e908:	40 e0       	ldi	r20, 0x00	; 0
    e90a:	50 e0       	ldi	r21, 0x00	; 0
    e90c:	60 e0       	ldi	r22, 0x00	; 0
    e90e:	70 e0       	ldi	r23, 0x00	; 0
    e910:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chSemWaitTimeout>
					bmpDraw("img00001.bmp",0,0);
    e914:	87 e1       	ldi	r24, 0x17	; 23
    e916:	95 e0       	ldi	r25, 0x05	; 5
    e918:	c9 cf       	rjmp	.-110    	; 0xe8ac <Thread3+0x15e>

0000e91a <vfprintf>:
    e91a:	2f 92       	push	r2
    e91c:	3f 92       	push	r3
    e91e:	4f 92       	push	r4
    e920:	5f 92       	push	r5
    e922:	6f 92       	push	r6
    e924:	7f 92       	push	r7
    e926:	8f 92       	push	r8
    e928:	9f 92       	push	r9
    e92a:	af 92       	push	r10
    e92c:	bf 92       	push	r11
    e92e:	cf 92       	push	r12
    e930:	df 92       	push	r13
    e932:	ef 92       	push	r14
    e934:	ff 92       	push	r15
    e936:	0f 93       	push	r16
    e938:	1f 93       	push	r17
    e93a:	df 93       	push	r29
    e93c:	cf 93       	push	r28
    e93e:	cd b7       	in	r28, 0x3d	; 61
    e940:	de b7       	in	r29, 0x3e	; 62
    e942:	61 97       	sbiw	r28, 0x11	; 17
    e944:	0f b6       	in	r0, 0x3f	; 63
    e946:	f8 94       	cli
    e948:	de bf       	out	0x3e, r29	; 62
    e94a:	0f be       	out	0x3f, r0	; 63
    e94c:	cd bf       	out	0x3d, r28	; 61
    e94e:	3c 01       	movw	r6, r24
    e950:	7f 87       	std	Y+15, r23	; 0x0f
    e952:	6e 87       	std	Y+14, r22	; 0x0e
    e954:	6a 01       	movw	r12, r20
    e956:	fc 01       	movw	r30, r24
    e958:	17 82       	std	Z+7, r1	; 0x07
    e95a:	16 82       	std	Z+6, r1	; 0x06
    e95c:	83 81       	ldd	r24, Z+3	; 0x03
    e95e:	81 fd       	sbrc	r24, 1
    e960:	03 c0       	rjmp	.+6      	; 0xe968 <vfprintf+0x4e>
    e962:	6f ef       	ldi	r22, 0xFF	; 255
    e964:	7f ef       	ldi	r23, 0xFF	; 255
    e966:	6f c3       	rjmp	.+1758   	; 0xf046 <vfprintf+0x72c>
    e968:	9e 01       	movw	r18, r28
    e96a:	2f 5f       	subi	r18, 0xFF	; 255
    e96c:	3f 4f       	sbci	r19, 0xFF	; 255
    e96e:	39 8b       	std	Y+17, r19	; 0x11
    e970:	28 8b       	std	Y+16, r18	; 0x10
    e972:	f3 01       	movw	r30, r6
    e974:	23 81       	ldd	r18, Z+3	; 0x03
    e976:	ee 85       	ldd	r30, Y+14	; 0x0e
    e978:	ff 85       	ldd	r31, Y+15	; 0x0f
    e97a:	23 fd       	sbrc	r18, 3
    e97c:	85 91       	lpm	r24, Z+
    e97e:	23 ff       	sbrs	r18, 3
    e980:	81 91       	ld	r24, Z+
    e982:	ff 87       	std	Y+15, r31	; 0x0f
    e984:	ee 87       	std	Y+14, r30	; 0x0e
    e986:	88 23       	and	r24, r24
    e988:	09 f4       	brne	.+2      	; 0xe98c <vfprintf+0x72>
    e98a:	5a c3       	rjmp	.+1716   	; 0xf040 <vfprintf+0x726>
    e98c:	85 32       	cpi	r24, 0x25	; 37
    e98e:	51 f4       	brne	.+20     	; 0xe9a4 <vfprintf+0x8a>
    e990:	ee 85       	ldd	r30, Y+14	; 0x0e
    e992:	ff 85       	ldd	r31, Y+15	; 0x0f
    e994:	23 fd       	sbrc	r18, 3
    e996:	85 91       	lpm	r24, Z+
    e998:	23 ff       	sbrs	r18, 3
    e99a:	81 91       	ld	r24, Z+
    e99c:	ff 87       	std	Y+15, r31	; 0x0f
    e99e:	ee 87       	std	Y+14, r30	; 0x0e
    e9a0:	85 32       	cpi	r24, 0x25	; 37
    e9a2:	29 f4       	brne	.+10     	; 0xe9ae <vfprintf+0x94>
    e9a4:	90 e0       	ldi	r25, 0x00	; 0
    e9a6:	b3 01       	movw	r22, r6
    e9a8:	0e 94 b8 82 	call	0x10570	; 0x10570 <fputc>
    e9ac:	e2 cf       	rjmp	.-60     	; 0xe972 <vfprintf+0x58>
    e9ae:	98 2f       	mov	r25, r24
    e9b0:	10 e0       	ldi	r17, 0x00	; 0
    e9b2:	88 24       	eor	r8, r8
    e9b4:	99 24       	eor	r9, r9
    e9b6:	10 32       	cpi	r17, 0x20	; 32
    e9b8:	b0 f4       	brcc	.+44     	; 0xe9e6 <vfprintf+0xcc>
    e9ba:	9b 32       	cpi	r25, 0x2B	; 43
    e9bc:	69 f0       	breq	.+26     	; 0xe9d8 <vfprintf+0xbe>
    e9be:	9c 32       	cpi	r25, 0x2C	; 44
    e9c0:	28 f4       	brcc	.+10     	; 0xe9cc <vfprintf+0xb2>
    e9c2:	90 32       	cpi	r25, 0x20	; 32
    e9c4:	51 f0       	breq	.+20     	; 0xe9da <vfprintf+0xc0>
    e9c6:	93 32       	cpi	r25, 0x23	; 35
    e9c8:	71 f4       	brne	.+28     	; 0xe9e6 <vfprintf+0xcc>
    e9ca:	0b c0       	rjmp	.+22     	; 0xe9e2 <vfprintf+0xc8>
    e9cc:	9d 32       	cpi	r25, 0x2D	; 45
    e9ce:	39 f0       	breq	.+14     	; 0xe9de <vfprintf+0xc4>
    e9d0:	90 33       	cpi	r25, 0x30	; 48
    e9d2:	49 f4       	brne	.+18     	; 0xe9e6 <vfprintf+0xcc>
    e9d4:	11 60       	ori	r17, 0x01	; 1
    e9d6:	28 c0       	rjmp	.+80     	; 0xea28 <vfprintf+0x10e>
    e9d8:	12 60       	ori	r17, 0x02	; 2
    e9da:	14 60       	ori	r17, 0x04	; 4
    e9dc:	25 c0       	rjmp	.+74     	; 0xea28 <vfprintf+0x10e>
    e9de:	18 60       	ori	r17, 0x08	; 8
    e9e0:	23 c0       	rjmp	.+70     	; 0xea28 <vfprintf+0x10e>
    e9e2:	10 61       	ori	r17, 0x10	; 16
    e9e4:	21 c0       	rjmp	.+66     	; 0xea28 <vfprintf+0x10e>
    e9e6:	17 fd       	sbrc	r17, 7
    e9e8:	2a c0       	rjmp	.+84     	; 0xea3e <vfprintf+0x124>
    e9ea:	89 2f       	mov	r24, r25
    e9ec:	80 53       	subi	r24, 0x30	; 48
    e9ee:	8a 30       	cpi	r24, 0x0A	; 10
    e9f0:	78 f4       	brcc	.+30     	; 0xea10 <vfprintf+0xf6>
    e9f2:	16 ff       	sbrs	r17, 6
    e9f4:	06 c0       	rjmp	.+12     	; 0xea02 <vfprintf+0xe8>
    e9f6:	fa e0       	ldi	r31, 0x0A	; 10
    e9f8:	9f 9e       	mul	r9, r31
    e9fa:	90 2c       	mov	r9, r0
    e9fc:	11 24       	eor	r1, r1
    e9fe:	98 0e       	add	r9, r24
    ea00:	13 c0       	rjmp	.+38     	; 0xea28 <vfprintf+0x10e>
    ea02:	3a e0       	ldi	r19, 0x0A	; 10
    ea04:	83 9e       	mul	r8, r19
    ea06:	80 2c       	mov	r8, r0
    ea08:	11 24       	eor	r1, r1
    ea0a:	88 0e       	add	r8, r24
    ea0c:	10 62       	ori	r17, 0x20	; 32
    ea0e:	0c c0       	rjmp	.+24     	; 0xea28 <vfprintf+0x10e>
    ea10:	9e 32       	cpi	r25, 0x2E	; 46
    ea12:	21 f4       	brne	.+8      	; 0xea1c <vfprintf+0x102>
    ea14:	16 fd       	sbrc	r17, 6
    ea16:	14 c3       	rjmp	.+1576   	; 0xf040 <vfprintf+0x726>
    ea18:	10 64       	ori	r17, 0x40	; 64
    ea1a:	06 c0       	rjmp	.+12     	; 0xea28 <vfprintf+0x10e>
    ea1c:	9c 36       	cpi	r25, 0x6C	; 108
    ea1e:	11 f4       	brne	.+4      	; 0xea24 <vfprintf+0x10a>
    ea20:	10 68       	ori	r17, 0x80	; 128
    ea22:	02 c0       	rjmp	.+4      	; 0xea28 <vfprintf+0x10e>
    ea24:	98 36       	cpi	r25, 0x68	; 104
    ea26:	59 f4       	brne	.+22     	; 0xea3e <vfprintf+0x124>
    ea28:	ee 85       	ldd	r30, Y+14	; 0x0e
    ea2a:	ff 85       	ldd	r31, Y+15	; 0x0f
    ea2c:	23 fd       	sbrc	r18, 3
    ea2e:	95 91       	lpm	r25, Z+
    ea30:	23 ff       	sbrs	r18, 3
    ea32:	91 91       	ld	r25, Z+
    ea34:	ff 87       	std	Y+15, r31	; 0x0f
    ea36:	ee 87       	std	Y+14, r30	; 0x0e
    ea38:	99 23       	and	r25, r25
    ea3a:	09 f0       	breq	.+2      	; 0xea3e <vfprintf+0x124>
    ea3c:	bc cf       	rjmp	.-136    	; 0xe9b6 <vfprintf+0x9c>
    ea3e:	89 2f       	mov	r24, r25
    ea40:	85 54       	subi	r24, 0x45	; 69
    ea42:	83 30       	cpi	r24, 0x03	; 3
    ea44:	20 f4       	brcc	.+8      	; 0xea4e <vfprintf+0x134>
    ea46:	81 2f       	mov	r24, r17
    ea48:	80 61       	ori	r24, 0x10	; 16
    ea4a:	90 5e       	subi	r25, 0xE0	; 224
    ea4c:	07 c0       	rjmp	.+14     	; 0xea5c <vfprintf+0x142>
    ea4e:	89 2f       	mov	r24, r25
    ea50:	85 56       	subi	r24, 0x65	; 101
    ea52:	83 30       	cpi	r24, 0x03	; 3
    ea54:	08 f0       	brcs	.+2      	; 0xea58 <vfprintf+0x13e>
    ea56:	9f c1       	rjmp	.+830    	; 0xed96 <vfprintf+0x47c>
    ea58:	81 2f       	mov	r24, r17
    ea5a:	8f 7e       	andi	r24, 0xEF	; 239
    ea5c:	86 fd       	sbrc	r24, 6
    ea5e:	02 c0       	rjmp	.+4      	; 0xea64 <vfprintf+0x14a>
    ea60:	76 e0       	ldi	r23, 0x06	; 6
    ea62:	97 2e       	mov	r9, r23
    ea64:	6f e3       	ldi	r22, 0x3F	; 63
    ea66:	f6 2e       	mov	r15, r22
    ea68:	f8 22       	and	r15, r24
    ea6a:	95 36       	cpi	r25, 0x65	; 101
    ea6c:	19 f4       	brne	.+6      	; 0xea74 <vfprintf+0x15a>
    ea6e:	f0 e4       	ldi	r31, 0x40	; 64
    ea70:	ff 2a       	or	r15, r31
    ea72:	07 c0       	rjmp	.+14     	; 0xea82 <vfprintf+0x168>
    ea74:	96 36       	cpi	r25, 0x66	; 102
    ea76:	19 f4       	brne	.+6      	; 0xea7e <vfprintf+0x164>
    ea78:	20 e8       	ldi	r18, 0x80	; 128
    ea7a:	f2 2a       	or	r15, r18
    ea7c:	02 c0       	rjmp	.+4      	; 0xea82 <vfprintf+0x168>
    ea7e:	91 10       	cpse	r9, r1
    ea80:	9a 94       	dec	r9
    ea82:	f7 fe       	sbrs	r15, 7
    ea84:	0a c0       	rjmp	.+20     	; 0xea9a <vfprintf+0x180>
    ea86:	3b e3       	ldi	r19, 0x3B	; 59
    ea88:	39 15       	cp	r19, r9
    ea8a:	18 f4       	brcc	.+6      	; 0xea92 <vfprintf+0x178>
    ea8c:	5c e3       	ldi	r21, 0x3C	; 60
    ea8e:	b5 2e       	mov	r11, r21
    ea90:	02 c0       	rjmp	.+4      	; 0xea96 <vfprintf+0x17c>
    ea92:	b9 2c       	mov	r11, r9
    ea94:	b3 94       	inc	r11
    ea96:	27 e0       	ldi	r18, 0x07	; 7
    ea98:	09 c0       	rjmp	.+18     	; 0xeaac <vfprintf+0x192>
    ea9a:	47 e0       	ldi	r20, 0x07	; 7
    ea9c:	49 15       	cp	r20, r9
    ea9e:	20 f4       	brcc	.+8      	; 0xeaa8 <vfprintf+0x18e>
    eaa0:	bb 24       	eor	r11, r11
    eaa2:	47 e0       	ldi	r20, 0x07	; 7
    eaa4:	94 2e       	mov	r9, r20
    eaa6:	f7 cf       	rjmp	.-18     	; 0xea96 <vfprintf+0x17c>
    eaa8:	29 2d       	mov	r18, r9
    eaaa:	bb 24       	eor	r11, r11
    eaac:	c6 01       	movw	r24, r12
    eaae:	04 96       	adiw	r24, 0x04	; 4
    eab0:	9d 87       	std	Y+13, r25	; 0x0d
    eab2:	8c 87       	std	Y+12, r24	; 0x0c
    eab4:	f6 01       	movw	r30, r12
    eab6:	60 81       	ld	r22, Z
    eab8:	71 81       	ldd	r23, Z+1	; 0x01
    eaba:	82 81       	ldd	r24, Z+2	; 0x02
    eabc:	93 81       	ldd	r25, Z+3	; 0x03
    eabe:	ae 01       	movw	r20, r28
    eac0:	4f 5f       	subi	r20, 0xFF	; 255
    eac2:	5f 4f       	sbci	r21, 0xFF	; 255
    eac4:	0b 2d       	mov	r16, r11
    eac6:	0e 94 4f 81 	call	0x1029e	; 0x1029e <__ftoa_engine>
    eaca:	6c 01       	movw	r12, r24
    eacc:	09 81       	ldd	r16, Y+1	; 0x01
    eace:	20 2e       	mov	r2, r16
    ead0:	33 24       	eor	r3, r3
    ead2:	00 ff       	sbrs	r16, 0
    ead4:	04 c0       	rjmp	.+8      	; 0xeade <vfprintf+0x1c4>
    ead6:	03 fd       	sbrc	r16, 3
    ead8:	02 c0       	rjmp	.+4      	; 0xeade <vfprintf+0x1c4>
    eada:	1d e2       	ldi	r17, 0x2D	; 45
    eadc:	09 c0       	rjmp	.+18     	; 0xeaf0 <vfprintf+0x1d6>
    eade:	f1 fe       	sbrs	r15, 1
    eae0:	02 c0       	rjmp	.+4      	; 0xeae6 <vfprintf+0x1cc>
    eae2:	1b e2       	ldi	r17, 0x2B	; 43
    eae4:	05 c0       	rjmp	.+10     	; 0xeaf0 <vfprintf+0x1d6>
    eae6:	f2 fc       	sbrc	r15, 2
    eae8:	02 c0       	rjmp	.+4      	; 0xeaee <vfprintf+0x1d4>
    eaea:	10 e0       	ldi	r17, 0x00	; 0
    eaec:	01 c0       	rjmp	.+2      	; 0xeaf0 <vfprintf+0x1d6>
    eaee:	10 e2       	ldi	r17, 0x20	; 32
    eaf0:	c1 01       	movw	r24, r2
    eaf2:	8c 70       	andi	r24, 0x0C	; 12
    eaf4:	90 70       	andi	r25, 0x00	; 0
    eaf6:	89 2b       	or	r24, r25
    eaf8:	b9 f1       	breq	.+110    	; 0xeb68 <vfprintf+0x24e>
    eafa:	11 23       	and	r17, r17
    eafc:	11 f4       	brne	.+4      	; 0xeb02 <vfprintf+0x1e8>
    eafe:	83 e0       	ldi	r24, 0x03	; 3
    eb00:	01 c0       	rjmp	.+2      	; 0xeb04 <vfprintf+0x1ea>
    eb02:	84 e0       	ldi	r24, 0x04	; 4
    eb04:	88 15       	cp	r24, r8
    eb06:	10 f0       	brcs	.+4      	; 0xeb0c <vfprintf+0x1f2>
    eb08:	88 24       	eor	r8, r8
    eb0a:	0a c0       	rjmp	.+20     	; 0xeb20 <vfprintf+0x206>
    eb0c:	88 1a       	sub	r8, r24
    eb0e:	f3 fc       	sbrc	r15, 3
    eb10:	07 c0       	rjmp	.+14     	; 0xeb20 <vfprintf+0x206>
    eb12:	80 e2       	ldi	r24, 0x20	; 32
    eb14:	90 e0       	ldi	r25, 0x00	; 0
    eb16:	b3 01       	movw	r22, r6
    eb18:	0e 94 b8 82 	call	0x10570	; 0x10570 <fputc>
    eb1c:	8a 94       	dec	r8
    eb1e:	c9 f7       	brne	.-14     	; 0xeb12 <vfprintf+0x1f8>
    eb20:	11 23       	and	r17, r17
    eb22:	29 f0       	breq	.+10     	; 0xeb2e <vfprintf+0x214>
    eb24:	81 2f       	mov	r24, r17
    eb26:	90 e0       	ldi	r25, 0x00	; 0
    eb28:	b3 01       	movw	r22, r6
    eb2a:	0e 94 b8 82 	call	0x10570	; 0x10570 <fputc>
    eb2e:	23 fe       	sbrs	r2, 3
    eb30:	03 c0       	rjmp	.+6      	; 0xeb38 <vfprintf+0x21e>
    eb32:	09 e9       	ldi	r16, 0x99	; 153
    eb34:	1c e0       	ldi	r17, 0x0C	; 12
    eb36:	0e c0       	rjmp	.+28     	; 0xeb54 <vfprintf+0x23a>
    eb38:	0d e9       	ldi	r16, 0x9D	; 157
    eb3a:	1c e0       	ldi	r17, 0x0C	; 12
    eb3c:	0b c0       	rjmp	.+22     	; 0xeb54 <vfprintf+0x23a>
    eb3e:	e1 14       	cp	r14, r1
    eb40:	f1 04       	cpc	r15, r1
    eb42:	09 f0       	breq	.+2      	; 0xeb46 <vfprintf+0x22c>
    eb44:	80 52       	subi	r24, 0x20	; 32
    eb46:	90 e0       	ldi	r25, 0x00	; 0
    eb48:	b3 01       	movw	r22, r6
    eb4a:	0e 94 b8 82 	call	0x10570	; 0x10570 <fputc>
    eb4e:	0f 5f       	subi	r16, 0xFF	; 255
    eb50:	1f 4f       	sbci	r17, 0xFF	; 255
    eb52:	05 c0       	rjmp	.+10     	; 0xeb5e <vfprintf+0x244>
    eb54:	ef 2c       	mov	r14, r15
    eb56:	ff 24       	eor	r15, r15
    eb58:	f0 e1       	ldi	r31, 0x10	; 16
    eb5a:	ef 22       	and	r14, r31
    eb5c:	ff 24       	eor	r15, r15
    eb5e:	f8 01       	movw	r30, r16
    eb60:	84 91       	lpm	r24, Z+
    eb62:	88 23       	and	r24, r24
    eb64:	61 f7       	brne	.-40     	; 0xeb3e <vfprintf+0x224>
    eb66:	14 c1       	rjmp	.+552    	; 0xed90 <vfprintf+0x476>
    eb68:	f7 fe       	sbrs	r15, 7
    eb6a:	12 c0       	rjmp	.+36     	; 0xeb90 <vfprintf+0x276>
    eb6c:	bc 0c       	add	r11, r12
    eb6e:	24 fe       	sbrs	r2, 4
    eb70:	04 c0       	rjmp	.+8      	; 0xeb7a <vfprintf+0x260>
    eb72:	8a 81       	ldd	r24, Y+2	; 0x02
    eb74:	81 33       	cpi	r24, 0x31	; 49
    eb76:	09 f4       	brne	.+2      	; 0xeb7a <vfprintf+0x260>
    eb78:	ba 94       	dec	r11
    eb7a:	1b 14       	cp	r1, r11
    eb7c:	1c f0       	brlt	.+6      	; 0xeb84 <vfprintf+0x26a>
    eb7e:	bb 24       	eor	r11, r11
    eb80:	b3 94       	inc	r11
    eb82:	2d c0       	rjmp	.+90     	; 0xebde <vfprintf+0x2c4>
    eb84:	f8 e0       	ldi	r31, 0x08	; 8
    eb86:	fb 15       	cp	r31, r11
    eb88:	50 f5       	brcc	.+84     	; 0xebde <vfprintf+0x2c4>
    eb8a:	38 e0       	ldi	r19, 0x08	; 8
    eb8c:	b3 2e       	mov	r11, r19
    eb8e:	27 c0       	rjmp	.+78     	; 0xebde <vfprintf+0x2c4>
    eb90:	f6 fc       	sbrc	r15, 6
    eb92:	25 c0       	rjmp	.+74     	; 0xebde <vfprintf+0x2c4>
    eb94:	89 2d       	mov	r24, r9
    eb96:	90 e0       	ldi	r25, 0x00	; 0
    eb98:	8c 15       	cp	r24, r12
    eb9a:	9d 05       	cpc	r25, r13
    eb9c:	4c f0       	brlt	.+18     	; 0xebb0 <vfprintf+0x296>
    eb9e:	2c ef       	ldi	r18, 0xFC	; 252
    eba0:	c2 16       	cp	r12, r18
    eba2:	2f ef       	ldi	r18, 0xFF	; 255
    eba4:	d2 06       	cpc	r13, r18
    eba6:	24 f0       	brlt	.+8      	; 0xebb0 <vfprintf+0x296>
    eba8:	30 e8       	ldi	r19, 0x80	; 128
    ebaa:	f3 2a       	or	r15, r19
    ebac:	01 c0       	rjmp	.+2      	; 0xebb0 <vfprintf+0x296>
    ebae:	9a 94       	dec	r9
    ebb0:	99 20       	and	r9, r9
    ebb2:	49 f0       	breq	.+18     	; 0xebc6 <vfprintf+0x2ac>
    ebb4:	e2 e0       	ldi	r30, 0x02	; 2
    ebb6:	f0 e0       	ldi	r31, 0x00	; 0
    ebb8:	ec 0f       	add	r30, r28
    ebba:	fd 1f       	adc	r31, r29
    ebbc:	e9 0d       	add	r30, r9
    ebbe:	f1 1d       	adc	r31, r1
    ebc0:	80 81       	ld	r24, Z
    ebc2:	80 33       	cpi	r24, 0x30	; 48
    ebc4:	a1 f3       	breq	.-24     	; 0xebae <vfprintf+0x294>
    ebc6:	f7 fe       	sbrs	r15, 7
    ebc8:	0a c0       	rjmp	.+20     	; 0xebde <vfprintf+0x2c4>
    ebca:	b9 2c       	mov	r11, r9
    ebcc:	b3 94       	inc	r11
    ebce:	89 2d       	mov	r24, r9
    ebd0:	90 e0       	ldi	r25, 0x00	; 0
    ebd2:	c8 16       	cp	r12, r24
    ebd4:	d9 06       	cpc	r13, r25
    ebd6:	14 f0       	brlt	.+4      	; 0xebdc <vfprintf+0x2c2>
    ebd8:	99 24       	eor	r9, r9
    ebda:	01 c0       	rjmp	.+2      	; 0xebde <vfprintf+0x2c4>
    ebdc:	9c 18       	sub	r9, r12
    ebde:	f7 fc       	sbrc	r15, 7
    ebe0:	03 c0       	rjmp	.+6      	; 0xebe8 <vfprintf+0x2ce>
    ebe2:	25 e0       	ldi	r18, 0x05	; 5
    ebe4:	30 e0       	ldi	r19, 0x00	; 0
    ebe6:	09 c0       	rjmp	.+18     	; 0xebfa <vfprintf+0x2e0>
    ebe8:	1c 14       	cp	r1, r12
    ebea:	1d 04       	cpc	r1, r13
    ebec:	1c f0       	brlt	.+6      	; 0xebf4 <vfprintf+0x2da>
    ebee:	21 e0       	ldi	r18, 0x01	; 1
    ebf0:	30 e0       	ldi	r19, 0x00	; 0
    ebf2:	03 c0       	rjmp	.+6      	; 0xebfa <vfprintf+0x2e0>
    ebf4:	96 01       	movw	r18, r12
    ebf6:	2f 5f       	subi	r18, 0xFF	; 255
    ebf8:	3f 4f       	sbci	r19, 0xFF	; 255
    ebfa:	11 23       	and	r17, r17
    ebfc:	11 f0       	breq	.+4      	; 0xec02 <vfprintf+0x2e8>
    ebfe:	2f 5f       	subi	r18, 0xFF	; 255
    ec00:	3f 4f       	sbci	r19, 0xFF	; 255
    ec02:	99 20       	and	r9, r9
    ec04:	29 f0       	breq	.+10     	; 0xec10 <vfprintf+0x2f6>
    ec06:	89 2d       	mov	r24, r9
    ec08:	90 e0       	ldi	r25, 0x00	; 0
    ec0a:	01 96       	adiw	r24, 0x01	; 1
    ec0c:	28 0f       	add	r18, r24
    ec0e:	39 1f       	adc	r19, r25
    ec10:	88 2d       	mov	r24, r8
    ec12:	90 e0       	ldi	r25, 0x00	; 0
    ec14:	28 17       	cp	r18, r24
    ec16:	39 07       	cpc	r19, r25
    ec18:	14 f0       	brlt	.+4      	; 0xec1e <vfprintf+0x304>
    ec1a:	88 24       	eor	r8, r8
    ec1c:	01 c0       	rjmp	.+2      	; 0xec20 <vfprintf+0x306>
    ec1e:	82 1a       	sub	r8, r18
    ec20:	4f 2c       	mov	r4, r15
    ec22:	55 24       	eor	r5, r5
    ec24:	c2 01       	movw	r24, r4
    ec26:	89 70       	andi	r24, 0x09	; 9
    ec28:	90 70       	andi	r25, 0x00	; 0
    ec2a:	89 2b       	or	r24, r25
    ec2c:	39 f0       	breq	.+14     	; 0xec3c <vfprintf+0x322>
    ec2e:	08 c0       	rjmp	.+16     	; 0xec40 <vfprintf+0x326>
    ec30:	80 e2       	ldi	r24, 0x20	; 32
    ec32:	90 e0       	ldi	r25, 0x00	; 0
    ec34:	b3 01       	movw	r22, r6
    ec36:	0e 94 b8 82 	call	0x10570	; 0x10570 <fputc>
    ec3a:	8a 94       	dec	r8
    ec3c:	88 20       	and	r8, r8
    ec3e:	c1 f7       	brne	.-16     	; 0xec30 <vfprintf+0x316>
    ec40:	11 23       	and	r17, r17
    ec42:	29 f0       	breq	.+10     	; 0xec4e <vfprintf+0x334>
    ec44:	81 2f       	mov	r24, r17
    ec46:	90 e0       	ldi	r25, 0x00	; 0
    ec48:	b3 01       	movw	r22, r6
    ec4a:	0e 94 b8 82 	call	0x10570	; 0x10570 <fputc>
    ec4e:	43 fe       	sbrs	r4, 3
    ec50:	07 c0       	rjmp	.+14     	; 0xec60 <vfprintf+0x346>
    ec52:	08 c0       	rjmp	.+16     	; 0xec64 <vfprintf+0x34a>
    ec54:	80 e3       	ldi	r24, 0x30	; 48
    ec56:	90 e0       	ldi	r25, 0x00	; 0
    ec58:	b3 01       	movw	r22, r6
    ec5a:	0e 94 b8 82 	call	0x10570	; 0x10570 <fputc>
    ec5e:	8a 94       	dec	r8
    ec60:	88 20       	and	r8, r8
    ec62:	c1 f7       	brne	.-16     	; 0xec54 <vfprintf+0x33a>
    ec64:	f7 fe       	sbrs	r15, 7
    ec66:	46 c0       	rjmp	.+140    	; 0xecf4 <vfprintf+0x3da>
    ec68:	86 01       	movw	r16, r12
    ec6a:	d7 fe       	sbrs	r13, 7
    ec6c:	02 c0       	rjmp	.+4      	; 0xec72 <vfprintf+0x358>
    ec6e:	00 e0       	ldi	r16, 0x00	; 0
    ec70:	10 e0       	ldi	r17, 0x00	; 0
    ec72:	76 01       	movw	r14, r12
    ec74:	08 94       	sec
    ec76:	e1 1c       	adc	r14, r1
    ec78:	f1 1c       	adc	r15, r1
    ec7a:	e0 1a       	sub	r14, r16
    ec7c:	f1 0a       	sbc	r15, r17
    ec7e:	41 e0       	ldi	r20, 0x01	; 1
    ec80:	50 e0       	ldi	r21, 0x00	; 0
    ec82:	4c 0f       	add	r20, r28
    ec84:	5d 1f       	adc	r21, r29
    ec86:	e4 0e       	add	r14, r20
    ec88:	f5 1e       	adc	r15, r21
    ec8a:	26 01       	movw	r4, r12
    ec8c:	4b 18       	sub	r4, r11
    ec8e:	51 08       	sbc	r5, r1
    ec90:	89 2d       	mov	r24, r9
    ec92:	90 e0       	ldi	r25, 0x00	; 0
    ec94:	aa 24       	eor	r10, r10
    ec96:	bb 24       	eor	r11, r11
    ec98:	a8 1a       	sub	r10, r24
    ec9a:	b9 0a       	sbc	r11, r25
    ec9c:	5f ef       	ldi	r21, 0xFF	; 255
    ec9e:	0f 3f       	cpi	r16, 0xFF	; 255
    eca0:	15 07       	cpc	r17, r21
    eca2:	29 f4       	brne	.+10     	; 0xecae <vfprintf+0x394>
    eca4:	8e e2       	ldi	r24, 0x2E	; 46
    eca6:	90 e0       	ldi	r25, 0x00	; 0
    eca8:	b3 01       	movw	r22, r6
    ecaa:	0e 94 b8 82 	call	0x10570	; 0x10570 <fputc>
    ecae:	c0 16       	cp	r12, r16
    ecb0:	d1 06       	cpc	r13, r17
    ecb2:	34 f0       	brlt	.+12     	; 0xecc0 <vfprintf+0x3a6>
    ecb4:	40 16       	cp	r4, r16
    ecb6:	51 06       	cpc	r5, r17
    ecb8:	1c f4       	brge	.+6      	; 0xecc0 <vfprintf+0x3a6>
    ecba:	f7 01       	movw	r30, r14
    ecbc:	80 81       	ld	r24, Z
    ecbe:	01 c0       	rjmp	.+2      	; 0xecc2 <vfprintf+0x3a8>
    ecc0:	80 e3       	ldi	r24, 0x30	; 48
    ecc2:	01 50       	subi	r16, 0x01	; 1
    ecc4:	10 40       	sbci	r17, 0x00	; 0
    ecc6:	08 94       	sec
    ecc8:	e1 1c       	adc	r14, r1
    ecca:	f1 1c       	adc	r15, r1
    eccc:	0a 15       	cp	r16, r10
    ecce:	1b 05       	cpc	r17, r11
    ecd0:	2c f0       	brlt	.+10     	; 0xecdc <vfprintf+0x3c2>
    ecd2:	90 e0       	ldi	r25, 0x00	; 0
    ecd4:	b3 01       	movw	r22, r6
    ecd6:	0e 94 b8 82 	call	0x10570	; 0x10570 <fputc>
    ecda:	e0 cf       	rjmp	.-64     	; 0xec9c <vfprintf+0x382>
    ecdc:	0c 15       	cp	r16, r12
    ecde:	1d 05       	cpc	r17, r13
    ece0:	39 f4       	brne	.+14     	; 0xecf0 <vfprintf+0x3d6>
    ece2:	9a 81       	ldd	r25, Y+2	; 0x02
    ece4:	96 33       	cpi	r25, 0x36	; 54
    ece6:	18 f4       	brcc	.+6      	; 0xecee <vfprintf+0x3d4>
    ece8:	95 33       	cpi	r25, 0x35	; 53
    ecea:	11 f4       	brne	.+4      	; 0xecf0 <vfprintf+0x3d6>
    ecec:	24 fe       	sbrs	r2, 4
    ecee:	81 e3       	ldi	r24, 0x31	; 49
    ecf0:	90 e0       	ldi	r25, 0x00	; 0
    ecf2:	4b c0       	rjmp	.+150    	; 0xed8a <vfprintf+0x470>
    ecf4:	8a 81       	ldd	r24, Y+2	; 0x02
    ecf6:	81 33       	cpi	r24, 0x31	; 49
    ecf8:	09 f0       	breq	.+2      	; 0xecfc <vfprintf+0x3e2>
    ecfa:	0f 7e       	andi	r16, 0xEF	; 239
    ecfc:	90 e0       	ldi	r25, 0x00	; 0
    ecfe:	b3 01       	movw	r22, r6
    ed00:	0e 94 b8 82 	call	0x10570	; 0x10570 <fputc>
    ed04:	99 20       	and	r9, r9
    ed06:	a1 f0       	breq	.+40     	; 0xed30 <vfprintf+0x416>
    ed08:	8e e2       	ldi	r24, 0x2E	; 46
    ed0a:	90 e0       	ldi	r25, 0x00	; 0
    ed0c:	b3 01       	movw	r22, r6
    ed0e:	0e 94 b8 82 	call	0x10570	; 0x10570 <fputc>
    ed12:	12 e0       	ldi	r17, 0x02	; 2
    ed14:	e1 e0       	ldi	r30, 0x01	; 1
    ed16:	f0 e0       	ldi	r31, 0x00	; 0
    ed18:	ec 0f       	add	r30, r28
    ed1a:	fd 1f       	adc	r31, r29
    ed1c:	e1 0f       	add	r30, r17
    ed1e:	f1 1d       	adc	r31, r1
    ed20:	1f 5f       	subi	r17, 0xFF	; 255
    ed22:	80 81       	ld	r24, Z
    ed24:	90 e0       	ldi	r25, 0x00	; 0
    ed26:	b3 01       	movw	r22, r6
    ed28:	0e 94 b8 82 	call	0x10570	; 0x10570 <fputc>
    ed2c:	9a 94       	dec	r9
    ed2e:	91 f7       	brne	.-28     	; 0xed14 <vfprintf+0x3fa>
    ed30:	44 fc       	sbrc	r4, 4
    ed32:	03 c0       	rjmp	.+6      	; 0xed3a <vfprintf+0x420>
    ed34:	85 e6       	ldi	r24, 0x65	; 101
    ed36:	90 e0       	ldi	r25, 0x00	; 0
    ed38:	02 c0       	rjmp	.+4      	; 0xed3e <vfprintf+0x424>
    ed3a:	85 e4       	ldi	r24, 0x45	; 69
    ed3c:	90 e0       	ldi	r25, 0x00	; 0
    ed3e:	b3 01       	movw	r22, r6
    ed40:	0e 94 b8 82 	call	0x10570	; 0x10570 <fputc>
    ed44:	d7 fc       	sbrc	r13, 7
    ed46:	05 c0       	rjmp	.+10     	; 0xed52 <vfprintf+0x438>
    ed48:	c1 14       	cp	r12, r1
    ed4a:	d1 04       	cpc	r13, r1
    ed4c:	41 f4       	brne	.+16     	; 0xed5e <vfprintf+0x444>
    ed4e:	04 ff       	sbrs	r16, 4
    ed50:	06 c0       	rjmp	.+12     	; 0xed5e <vfprintf+0x444>
    ed52:	d0 94       	com	r13
    ed54:	c1 94       	neg	r12
    ed56:	d1 08       	sbc	r13, r1
    ed58:	d3 94       	inc	r13
    ed5a:	8d e2       	ldi	r24, 0x2D	; 45
    ed5c:	01 c0       	rjmp	.+2      	; 0xed60 <vfprintf+0x446>
    ed5e:	8b e2       	ldi	r24, 0x2B	; 43
    ed60:	90 e0       	ldi	r25, 0x00	; 0
    ed62:	b3 01       	movw	r22, r6
    ed64:	0e 94 b8 82 	call	0x10570	; 0x10570 <fputc>
    ed68:	80 e3       	ldi	r24, 0x30	; 48
    ed6a:	05 c0       	rjmp	.+10     	; 0xed76 <vfprintf+0x45c>
    ed6c:	8f 5f       	subi	r24, 0xFF	; 255
    ed6e:	26 ef       	ldi	r18, 0xF6	; 246
    ed70:	3f ef       	ldi	r19, 0xFF	; 255
    ed72:	c2 0e       	add	r12, r18
    ed74:	d3 1e       	adc	r13, r19
    ed76:	3a e0       	ldi	r19, 0x0A	; 10
    ed78:	c3 16       	cp	r12, r19
    ed7a:	d1 04       	cpc	r13, r1
    ed7c:	bc f7       	brge	.-18     	; 0xed6c <vfprintf+0x452>
    ed7e:	90 e0       	ldi	r25, 0x00	; 0
    ed80:	b3 01       	movw	r22, r6
    ed82:	0e 94 b8 82 	call	0x10570	; 0x10570 <fputc>
    ed86:	c6 01       	movw	r24, r12
    ed88:	c0 96       	adiw	r24, 0x30	; 48
    ed8a:	b3 01       	movw	r22, r6
    ed8c:	0e 94 b8 82 	call	0x10570	; 0x10570 <fputc>
    ed90:	cc 84       	ldd	r12, Y+12	; 0x0c
    ed92:	dd 84       	ldd	r13, Y+13	; 0x0d
    ed94:	52 c1       	rjmp	.+676    	; 0xf03a <vfprintf+0x720>
    ed96:	93 36       	cpi	r25, 0x63	; 99
    ed98:	31 f0       	breq	.+12     	; 0xeda6 <vfprintf+0x48c>
    ed9a:	93 37       	cpi	r25, 0x73	; 115
    ed9c:	99 f0       	breq	.+38     	; 0xedc4 <vfprintf+0x4aa>
    ed9e:	93 35       	cpi	r25, 0x53	; 83
    eda0:	09 f0       	breq	.+2      	; 0xeda4 <vfprintf+0x48a>
    eda2:	59 c0       	rjmp	.+178    	; 0xee56 <vfprintf+0x53c>
    eda4:	23 c0       	rjmp	.+70     	; 0xedec <vfprintf+0x4d2>
    eda6:	f6 01       	movw	r30, r12
    eda8:	80 81       	ld	r24, Z
    edaa:	89 83       	std	Y+1, r24	; 0x01
    edac:	5e 01       	movw	r10, r28
    edae:	08 94       	sec
    edb0:	a1 1c       	adc	r10, r1
    edb2:	b1 1c       	adc	r11, r1
    edb4:	22 e0       	ldi	r18, 0x02	; 2
    edb6:	30 e0       	ldi	r19, 0x00	; 0
    edb8:	c2 0e       	add	r12, r18
    edba:	d3 1e       	adc	r13, r19
    edbc:	21 e0       	ldi	r18, 0x01	; 1
    edbe:	e2 2e       	mov	r14, r18
    edc0:	f1 2c       	mov	r15, r1
    edc2:	12 c0       	rjmp	.+36     	; 0xede8 <vfprintf+0x4ce>
    edc4:	f6 01       	movw	r30, r12
    edc6:	a0 80       	ld	r10, Z
    edc8:	b1 80       	ldd	r11, Z+1	; 0x01
    edca:	16 fd       	sbrc	r17, 6
    edcc:	03 c0       	rjmp	.+6      	; 0xedd4 <vfprintf+0x4ba>
    edce:	6f ef       	ldi	r22, 0xFF	; 255
    edd0:	7f ef       	ldi	r23, 0xFF	; 255
    edd2:	02 c0       	rjmp	.+4      	; 0xedd8 <vfprintf+0x4be>
    edd4:	69 2d       	mov	r22, r9
    edd6:	70 e0       	ldi	r23, 0x00	; 0
    edd8:	22 e0       	ldi	r18, 0x02	; 2
    edda:	30 e0       	ldi	r19, 0x00	; 0
    eddc:	c2 0e       	add	r12, r18
    edde:	d3 1e       	adc	r13, r19
    ede0:	c5 01       	movw	r24, r10
    ede2:	0e 94 4d 82 	call	0x1049a	; 0x1049a <strnlen>
    ede6:	7c 01       	movw	r14, r24
    ede8:	1f 77       	andi	r17, 0x7F	; 127
    edea:	13 c0       	rjmp	.+38     	; 0xee12 <vfprintf+0x4f8>
    edec:	f6 01       	movw	r30, r12
    edee:	a0 80       	ld	r10, Z
    edf0:	b1 80       	ldd	r11, Z+1	; 0x01
    edf2:	16 fd       	sbrc	r17, 6
    edf4:	03 c0       	rjmp	.+6      	; 0xedfc <vfprintf+0x4e2>
    edf6:	6f ef       	ldi	r22, 0xFF	; 255
    edf8:	7f ef       	ldi	r23, 0xFF	; 255
    edfa:	02 c0       	rjmp	.+4      	; 0xee00 <vfprintf+0x4e6>
    edfc:	69 2d       	mov	r22, r9
    edfe:	70 e0       	ldi	r23, 0x00	; 0
    ee00:	22 e0       	ldi	r18, 0x02	; 2
    ee02:	30 e0       	ldi	r19, 0x00	; 0
    ee04:	c2 0e       	add	r12, r18
    ee06:	d3 1e       	adc	r13, r19
    ee08:	c5 01       	movw	r24, r10
    ee0a:	0e 94 42 82 	call	0x10484	; 0x10484 <strnlen_P>
    ee0e:	7c 01       	movw	r14, r24
    ee10:	10 68       	ori	r17, 0x80	; 128
    ee12:	13 ff       	sbrs	r17, 3
    ee14:	07 c0       	rjmp	.+14     	; 0xee24 <vfprintf+0x50a>
    ee16:	1b c0       	rjmp	.+54     	; 0xee4e <vfprintf+0x534>
    ee18:	80 e2       	ldi	r24, 0x20	; 32
    ee1a:	90 e0       	ldi	r25, 0x00	; 0
    ee1c:	b3 01       	movw	r22, r6
    ee1e:	0e 94 b8 82 	call	0x10570	; 0x10570 <fputc>
    ee22:	8a 94       	dec	r8
    ee24:	88 2d       	mov	r24, r8
    ee26:	90 e0       	ldi	r25, 0x00	; 0
    ee28:	e8 16       	cp	r14, r24
    ee2a:	f9 06       	cpc	r15, r25
    ee2c:	a8 f3       	brcs	.-22     	; 0xee18 <vfprintf+0x4fe>
    ee2e:	0f c0       	rjmp	.+30     	; 0xee4e <vfprintf+0x534>
    ee30:	f5 01       	movw	r30, r10
    ee32:	17 fd       	sbrc	r17, 7
    ee34:	85 91       	lpm	r24, Z+
    ee36:	17 ff       	sbrs	r17, 7
    ee38:	81 91       	ld	r24, Z+
    ee3a:	5f 01       	movw	r10, r30
    ee3c:	90 e0       	ldi	r25, 0x00	; 0
    ee3e:	b3 01       	movw	r22, r6
    ee40:	0e 94 b8 82 	call	0x10570	; 0x10570 <fputc>
    ee44:	81 10       	cpse	r8, r1
    ee46:	8a 94       	dec	r8
    ee48:	08 94       	sec
    ee4a:	e1 08       	sbc	r14, r1
    ee4c:	f1 08       	sbc	r15, r1
    ee4e:	e1 14       	cp	r14, r1
    ee50:	f1 04       	cpc	r15, r1
    ee52:	71 f7       	brne	.-36     	; 0xee30 <vfprintf+0x516>
    ee54:	f2 c0       	rjmp	.+484    	; 0xf03a <vfprintf+0x720>
    ee56:	94 36       	cpi	r25, 0x64	; 100
    ee58:	11 f0       	breq	.+4      	; 0xee5e <vfprintf+0x544>
    ee5a:	99 36       	cpi	r25, 0x69	; 105
    ee5c:	89 f5       	brne	.+98     	; 0xeec0 <vfprintf+0x5a6>
    ee5e:	17 ff       	sbrs	r17, 7
    ee60:	08 c0       	rjmp	.+16     	; 0xee72 <vfprintf+0x558>
    ee62:	f6 01       	movw	r30, r12
    ee64:	20 81       	ld	r18, Z
    ee66:	31 81       	ldd	r19, Z+1	; 0x01
    ee68:	42 81       	ldd	r20, Z+2	; 0x02
    ee6a:	53 81       	ldd	r21, Z+3	; 0x03
    ee6c:	84 e0       	ldi	r24, 0x04	; 4
    ee6e:	90 e0       	ldi	r25, 0x00	; 0
    ee70:	0a c0       	rjmp	.+20     	; 0xee86 <vfprintf+0x56c>
    ee72:	f6 01       	movw	r30, r12
    ee74:	80 81       	ld	r24, Z
    ee76:	91 81       	ldd	r25, Z+1	; 0x01
    ee78:	9c 01       	movw	r18, r24
    ee7a:	44 27       	eor	r20, r20
    ee7c:	37 fd       	sbrc	r19, 7
    ee7e:	40 95       	com	r20
    ee80:	54 2f       	mov	r21, r20
    ee82:	82 e0       	ldi	r24, 0x02	; 2
    ee84:	90 e0       	ldi	r25, 0x00	; 0
    ee86:	c8 0e       	add	r12, r24
    ee88:	d9 1e       	adc	r13, r25
    ee8a:	9f e6       	ldi	r25, 0x6F	; 111
    ee8c:	f9 2e       	mov	r15, r25
    ee8e:	f1 22       	and	r15, r17
    ee90:	57 ff       	sbrs	r21, 7
    ee92:	09 c0       	rjmp	.+18     	; 0xeea6 <vfprintf+0x58c>
    ee94:	50 95       	com	r21
    ee96:	40 95       	com	r20
    ee98:	30 95       	com	r19
    ee9a:	21 95       	neg	r18
    ee9c:	3f 4f       	sbci	r19, 0xFF	; 255
    ee9e:	4f 4f       	sbci	r20, 0xFF	; 255
    eea0:	5f 4f       	sbci	r21, 0xFF	; 255
    eea2:	90 e8       	ldi	r25, 0x80	; 128
    eea4:	f9 2a       	or	r15, r25
    eea6:	ca 01       	movw	r24, r20
    eea8:	b9 01       	movw	r22, r18
    eeaa:	ae 01       	movw	r20, r28
    eeac:	4f 5f       	subi	r20, 0xFF	; 255
    eeae:	5f 4f       	sbci	r21, 0xFF	; 255
    eeb0:	2a e0       	ldi	r18, 0x0A	; 10
    eeb2:	30 e0       	ldi	r19, 0x00	; 0
    eeb4:	0e 94 fe 82 	call	0x105fc	; 0x105fc <__ultoa_invert>
    eeb8:	e8 2e       	mov	r14, r24
    eeba:	e8 89       	ldd	r30, Y+16	; 0x10
    eebc:	ee 1a       	sub	r14, r30
    eebe:	41 c0       	rjmp	.+130    	; 0xef42 <vfprintf+0x628>
    eec0:	95 37       	cpi	r25, 0x75	; 117
    eec2:	21 f4       	brne	.+8      	; 0xeecc <vfprintf+0x5b2>
    eec4:	1f 7e       	andi	r17, 0xEF	; 239
    eec6:	2a e0       	ldi	r18, 0x0A	; 10
    eec8:	30 e0       	ldi	r19, 0x00	; 0
    eeca:	1c c0       	rjmp	.+56     	; 0xef04 <vfprintf+0x5ea>
    eecc:	19 7f       	andi	r17, 0xF9	; 249
    eece:	9f 36       	cpi	r25, 0x6F	; 111
    eed0:	61 f0       	breq	.+24     	; 0xeeea <vfprintf+0x5d0>
    eed2:	90 37       	cpi	r25, 0x70	; 112
    eed4:	20 f4       	brcc	.+8      	; 0xeede <vfprintf+0x5c4>
    eed6:	98 35       	cpi	r25, 0x58	; 88
    eed8:	09 f0       	breq	.+2      	; 0xeedc <vfprintf+0x5c2>
    eeda:	b2 c0       	rjmp	.+356    	; 0xf040 <vfprintf+0x726>
    eedc:	0f c0       	rjmp	.+30     	; 0xeefc <vfprintf+0x5e2>
    eede:	90 37       	cpi	r25, 0x70	; 112
    eee0:	39 f0       	breq	.+14     	; 0xeef0 <vfprintf+0x5d6>
    eee2:	98 37       	cpi	r25, 0x78	; 120
    eee4:	09 f0       	breq	.+2      	; 0xeee8 <vfprintf+0x5ce>
    eee6:	ac c0       	rjmp	.+344    	; 0xf040 <vfprintf+0x726>
    eee8:	04 c0       	rjmp	.+8      	; 0xeef2 <vfprintf+0x5d8>
    eeea:	28 e0       	ldi	r18, 0x08	; 8
    eeec:	30 e0       	ldi	r19, 0x00	; 0
    eeee:	0a c0       	rjmp	.+20     	; 0xef04 <vfprintf+0x5ea>
    eef0:	10 61       	ori	r17, 0x10	; 16
    eef2:	14 fd       	sbrc	r17, 4
    eef4:	14 60       	ori	r17, 0x04	; 4
    eef6:	20 e1       	ldi	r18, 0x10	; 16
    eef8:	30 e0       	ldi	r19, 0x00	; 0
    eefa:	04 c0       	rjmp	.+8      	; 0xef04 <vfprintf+0x5ea>
    eefc:	14 fd       	sbrc	r17, 4
    eefe:	16 60       	ori	r17, 0x06	; 6
    ef00:	20 e1       	ldi	r18, 0x10	; 16
    ef02:	32 e0       	ldi	r19, 0x02	; 2
    ef04:	17 ff       	sbrs	r17, 7
    ef06:	08 c0       	rjmp	.+16     	; 0xef18 <vfprintf+0x5fe>
    ef08:	f6 01       	movw	r30, r12
    ef0a:	60 81       	ld	r22, Z
    ef0c:	71 81       	ldd	r23, Z+1	; 0x01
    ef0e:	82 81       	ldd	r24, Z+2	; 0x02
    ef10:	93 81       	ldd	r25, Z+3	; 0x03
    ef12:	44 e0       	ldi	r20, 0x04	; 4
    ef14:	50 e0       	ldi	r21, 0x00	; 0
    ef16:	08 c0       	rjmp	.+16     	; 0xef28 <vfprintf+0x60e>
    ef18:	f6 01       	movw	r30, r12
    ef1a:	80 81       	ld	r24, Z
    ef1c:	91 81       	ldd	r25, Z+1	; 0x01
    ef1e:	bc 01       	movw	r22, r24
    ef20:	80 e0       	ldi	r24, 0x00	; 0
    ef22:	90 e0       	ldi	r25, 0x00	; 0
    ef24:	42 e0       	ldi	r20, 0x02	; 2
    ef26:	50 e0       	ldi	r21, 0x00	; 0
    ef28:	c4 0e       	add	r12, r20
    ef2a:	d5 1e       	adc	r13, r21
    ef2c:	ae 01       	movw	r20, r28
    ef2e:	4f 5f       	subi	r20, 0xFF	; 255
    ef30:	5f 4f       	sbci	r21, 0xFF	; 255
    ef32:	0e 94 fe 82 	call	0x105fc	; 0x105fc <__ultoa_invert>
    ef36:	e8 2e       	mov	r14, r24
    ef38:	58 89       	ldd	r21, Y+16	; 0x10
    ef3a:	e5 1a       	sub	r14, r21
    ef3c:	8f e7       	ldi	r24, 0x7F	; 127
    ef3e:	f8 2e       	mov	r15, r24
    ef40:	f1 22       	and	r15, r17
    ef42:	f6 fe       	sbrs	r15, 6
    ef44:	0b c0       	rjmp	.+22     	; 0xef5c <vfprintf+0x642>
    ef46:	8e ef       	ldi	r24, 0xFE	; 254
    ef48:	f8 22       	and	r15, r24
    ef4a:	e9 14       	cp	r14, r9
    ef4c:	38 f4       	brcc	.+14     	; 0xef5c <vfprintf+0x642>
    ef4e:	f4 fe       	sbrs	r15, 4
    ef50:	07 c0       	rjmp	.+14     	; 0xef60 <vfprintf+0x646>
    ef52:	f2 fc       	sbrc	r15, 2
    ef54:	05 c0       	rjmp	.+10     	; 0xef60 <vfprintf+0x646>
    ef56:	9f ee       	ldi	r25, 0xEF	; 239
    ef58:	f9 22       	and	r15, r25
    ef5a:	02 c0       	rjmp	.+4      	; 0xef60 <vfprintf+0x646>
    ef5c:	1e 2d       	mov	r17, r14
    ef5e:	01 c0       	rjmp	.+2      	; 0xef62 <vfprintf+0x648>
    ef60:	19 2d       	mov	r17, r9
    ef62:	f4 fe       	sbrs	r15, 4
    ef64:	0d c0       	rjmp	.+26     	; 0xef80 <vfprintf+0x666>
    ef66:	fe 01       	movw	r30, r28
    ef68:	ee 0d       	add	r30, r14
    ef6a:	f1 1d       	adc	r31, r1
    ef6c:	80 81       	ld	r24, Z
    ef6e:	80 33       	cpi	r24, 0x30	; 48
    ef70:	19 f4       	brne	.+6      	; 0xef78 <vfprintf+0x65e>
    ef72:	e9 ee       	ldi	r30, 0xE9	; 233
    ef74:	fe 22       	and	r15, r30
    ef76:	08 c0       	rjmp	.+16     	; 0xef88 <vfprintf+0x66e>
    ef78:	1f 5f       	subi	r17, 0xFF	; 255
    ef7a:	f2 fe       	sbrs	r15, 2
    ef7c:	05 c0       	rjmp	.+10     	; 0xef88 <vfprintf+0x66e>
    ef7e:	03 c0       	rjmp	.+6      	; 0xef86 <vfprintf+0x66c>
    ef80:	8f 2d       	mov	r24, r15
    ef82:	86 78       	andi	r24, 0x86	; 134
    ef84:	09 f0       	breq	.+2      	; 0xef88 <vfprintf+0x66e>
    ef86:	1f 5f       	subi	r17, 0xFF	; 255
    ef88:	0f 2d       	mov	r16, r15
    ef8a:	f3 fc       	sbrc	r15, 3
    ef8c:	14 c0       	rjmp	.+40     	; 0xefb6 <vfprintf+0x69c>
    ef8e:	f0 fe       	sbrs	r15, 0
    ef90:	0f c0       	rjmp	.+30     	; 0xefb0 <vfprintf+0x696>
    ef92:	18 15       	cp	r17, r8
    ef94:	10 f0       	brcs	.+4      	; 0xef9a <vfprintf+0x680>
    ef96:	9e 2c       	mov	r9, r14
    ef98:	0b c0       	rjmp	.+22     	; 0xefb0 <vfprintf+0x696>
    ef9a:	9e 2c       	mov	r9, r14
    ef9c:	98 0c       	add	r9, r8
    ef9e:	91 1a       	sub	r9, r17
    efa0:	18 2d       	mov	r17, r8
    efa2:	06 c0       	rjmp	.+12     	; 0xefb0 <vfprintf+0x696>
    efa4:	80 e2       	ldi	r24, 0x20	; 32
    efa6:	90 e0       	ldi	r25, 0x00	; 0
    efa8:	b3 01       	movw	r22, r6
    efaa:	0e 94 b8 82 	call	0x10570	; 0x10570 <fputc>
    efae:	1f 5f       	subi	r17, 0xFF	; 255
    efb0:	18 15       	cp	r17, r8
    efb2:	c0 f3       	brcs	.-16     	; 0xefa4 <vfprintf+0x68a>
    efb4:	04 c0       	rjmp	.+8      	; 0xefbe <vfprintf+0x6a4>
    efb6:	18 15       	cp	r17, r8
    efb8:	10 f4       	brcc	.+4      	; 0xefbe <vfprintf+0x6a4>
    efba:	81 1a       	sub	r8, r17
    efbc:	01 c0       	rjmp	.+2      	; 0xefc0 <vfprintf+0x6a6>
    efbe:	88 24       	eor	r8, r8
    efc0:	04 ff       	sbrs	r16, 4
    efc2:	0f c0       	rjmp	.+30     	; 0xefe2 <vfprintf+0x6c8>
    efc4:	80 e3       	ldi	r24, 0x30	; 48
    efc6:	90 e0       	ldi	r25, 0x00	; 0
    efc8:	b3 01       	movw	r22, r6
    efca:	0e 94 b8 82 	call	0x10570	; 0x10570 <fputc>
    efce:	02 ff       	sbrs	r16, 2
    efd0:	1d c0       	rjmp	.+58     	; 0xf00c <vfprintf+0x6f2>
    efd2:	01 fd       	sbrc	r16, 1
    efd4:	03 c0       	rjmp	.+6      	; 0xefdc <vfprintf+0x6c2>
    efd6:	88 e7       	ldi	r24, 0x78	; 120
    efd8:	90 e0       	ldi	r25, 0x00	; 0
    efda:	0e c0       	rjmp	.+28     	; 0xeff8 <vfprintf+0x6de>
    efdc:	88 e5       	ldi	r24, 0x58	; 88
    efde:	90 e0       	ldi	r25, 0x00	; 0
    efe0:	0b c0       	rjmp	.+22     	; 0xeff8 <vfprintf+0x6de>
    efe2:	80 2f       	mov	r24, r16
    efe4:	86 78       	andi	r24, 0x86	; 134
    efe6:	91 f0       	breq	.+36     	; 0xf00c <vfprintf+0x6f2>
    efe8:	01 ff       	sbrs	r16, 1
    efea:	02 c0       	rjmp	.+4      	; 0xeff0 <vfprintf+0x6d6>
    efec:	8b e2       	ldi	r24, 0x2B	; 43
    efee:	01 c0       	rjmp	.+2      	; 0xeff2 <vfprintf+0x6d8>
    eff0:	80 e2       	ldi	r24, 0x20	; 32
    eff2:	f7 fc       	sbrc	r15, 7
    eff4:	8d e2       	ldi	r24, 0x2D	; 45
    eff6:	90 e0       	ldi	r25, 0x00	; 0
    eff8:	b3 01       	movw	r22, r6
    effa:	0e 94 b8 82 	call	0x10570	; 0x10570 <fputc>
    effe:	06 c0       	rjmp	.+12     	; 0xf00c <vfprintf+0x6f2>
    f000:	80 e3       	ldi	r24, 0x30	; 48
    f002:	90 e0       	ldi	r25, 0x00	; 0
    f004:	b3 01       	movw	r22, r6
    f006:	0e 94 b8 82 	call	0x10570	; 0x10570 <fputc>
    f00a:	9a 94       	dec	r9
    f00c:	e9 14       	cp	r14, r9
    f00e:	c0 f3       	brcs	.-16     	; 0xf000 <vfprintf+0x6e6>
    f010:	ea 94       	dec	r14
    f012:	e1 e0       	ldi	r30, 0x01	; 1
    f014:	f0 e0       	ldi	r31, 0x00	; 0
    f016:	ec 0f       	add	r30, r28
    f018:	fd 1f       	adc	r31, r29
    f01a:	ee 0d       	add	r30, r14
    f01c:	f1 1d       	adc	r31, r1
    f01e:	80 81       	ld	r24, Z
    f020:	90 e0       	ldi	r25, 0x00	; 0
    f022:	b3 01       	movw	r22, r6
    f024:	0e 94 b8 82 	call	0x10570	; 0x10570 <fputc>
    f028:	ee 20       	and	r14, r14
    f02a:	91 f7       	brne	.-28     	; 0xf010 <vfprintf+0x6f6>
    f02c:	06 c0       	rjmp	.+12     	; 0xf03a <vfprintf+0x720>
    f02e:	80 e2       	ldi	r24, 0x20	; 32
    f030:	90 e0       	ldi	r25, 0x00	; 0
    f032:	b3 01       	movw	r22, r6
    f034:	0e 94 b8 82 	call	0x10570	; 0x10570 <fputc>
    f038:	8a 94       	dec	r8
    f03a:	88 20       	and	r8, r8
    f03c:	c1 f7       	brne	.-16     	; 0xf02e <vfprintf+0x714>
    f03e:	99 cc       	rjmp	.-1742   	; 0xe972 <vfprintf+0x58>
    f040:	f3 01       	movw	r30, r6
    f042:	66 81       	ldd	r22, Z+6	; 0x06
    f044:	77 81       	ldd	r23, Z+7	; 0x07
    f046:	cb 01       	movw	r24, r22
    f048:	61 96       	adiw	r28, 0x11	; 17
    f04a:	0f b6       	in	r0, 0x3f	; 63
    f04c:	f8 94       	cli
    f04e:	de bf       	out	0x3e, r29	; 62
    f050:	0f be       	out	0x3f, r0	; 63
    f052:	cd bf       	out	0x3d, r28	; 61
    f054:	cf 91       	pop	r28
    f056:	df 91       	pop	r29
    f058:	1f 91       	pop	r17
    f05a:	0f 91       	pop	r16
    f05c:	ff 90       	pop	r15
    f05e:	ef 90       	pop	r14
    f060:	df 90       	pop	r13
    f062:	cf 90       	pop	r12
    f064:	bf 90       	pop	r11
    f066:	af 90       	pop	r10
    f068:	9f 90       	pop	r9
    f06a:	8f 90       	pop	r8
    f06c:	7f 90       	pop	r7
    f06e:	6f 90       	pop	r6
    f070:	5f 90       	pop	r5
    f072:	4f 90       	pop	r4
    f074:	3f 90       	pop	r3
    f076:	2f 90       	pop	r2
    f078:	08 95       	ret

0000f07a <putval>:
    f07a:	fc 01       	movw	r30, r24
    f07c:	20 fd       	sbrc	r18, 0
    f07e:	08 c0       	rjmp	.+16     	; 0xf090 <putval+0x16>
    f080:	23 fd       	sbrc	r18, 3
    f082:	05 c0       	rjmp	.+10     	; 0xf08e <putval+0x14>
    f084:	22 ff       	sbrs	r18, 2
    f086:	02 c0       	rjmp	.+4      	; 0xf08c <putval+0x12>
    f088:	73 83       	std	Z+3, r23	; 0x03
    f08a:	62 83       	std	Z+2, r22	; 0x02
    f08c:	51 83       	std	Z+1, r21	; 0x01
    f08e:	40 83       	st	Z, r20
    f090:	08 95       	ret

0000f092 <mulacc>:
    f092:	ef 92       	push	r14
    f094:	ff 92       	push	r15
    f096:	0f 93       	push	r16
    f098:	1f 93       	push	r17
    f09a:	44 ff       	sbrs	r20, 4
    f09c:	02 c0       	rjmp	.+4      	; 0xf0a2 <mulacc+0x10>
    f09e:	33 e0       	ldi	r19, 0x03	; 3
    f0a0:	11 c0       	rjmp	.+34     	; 0xf0c4 <mulacc+0x32>
    f0a2:	46 ff       	sbrs	r20, 6
    f0a4:	02 c0       	rjmp	.+4      	; 0xf0aa <mulacc+0x18>
    f0a6:	34 e0       	ldi	r19, 0x04	; 4
    f0a8:	0d c0       	rjmp	.+26     	; 0xf0c4 <mulacc+0x32>
    f0aa:	db 01       	movw	r26, r22
    f0ac:	fc 01       	movw	r30, r24
    f0ae:	aa 0f       	add	r26, r26
    f0b0:	bb 1f       	adc	r27, r27
    f0b2:	ee 1f       	adc	r30, r30
    f0b4:	ff 1f       	adc	r31, r31
    f0b6:	10 94       	com	r1
    f0b8:	d1 f7       	brne	.-12     	; 0xf0ae <mulacc+0x1c>
    f0ba:	6a 0f       	add	r22, r26
    f0bc:	7b 1f       	adc	r23, r27
    f0be:	8e 1f       	adc	r24, r30
    f0c0:	9f 1f       	adc	r25, r31
    f0c2:	31 e0       	ldi	r19, 0x01	; 1
    f0c4:	66 0f       	add	r22, r22
    f0c6:	77 1f       	adc	r23, r23
    f0c8:	88 1f       	adc	r24, r24
    f0ca:	99 1f       	adc	r25, r25
    f0cc:	31 50       	subi	r19, 0x01	; 1
    f0ce:	d1 f7       	brne	.-12     	; 0xf0c4 <mulacc+0x32>
    f0d0:	7b 01       	movw	r14, r22
    f0d2:	8c 01       	movw	r16, r24
    f0d4:	e2 0e       	add	r14, r18
    f0d6:	f1 1c       	adc	r15, r1
    f0d8:	01 1d       	adc	r16, r1
    f0da:	11 1d       	adc	r17, r1
    f0dc:	a8 01       	movw	r20, r16
    f0de:	97 01       	movw	r18, r14
    f0e0:	b7 01       	movw	r22, r14
    f0e2:	ca 01       	movw	r24, r20
    f0e4:	1f 91       	pop	r17
    f0e6:	0f 91       	pop	r16
    f0e8:	ff 90       	pop	r15
    f0ea:	ef 90       	pop	r14
    f0ec:	08 95       	ret

0000f0ee <skip_spaces>:
    f0ee:	0f 93       	push	r16
    f0f0:	1f 93       	push	r17
    f0f2:	cf 93       	push	r28
    f0f4:	df 93       	push	r29
    f0f6:	8c 01       	movw	r16, r24
    f0f8:	c8 01       	movw	r24, r16
    f0fa:	0e 94 58 82 	call	0x104b0	; 0x104b0 <fgetc>
    f0fe:	ec 01       	movw	r28, r24
    f100:	97 fd       	sbrc	r25, 7
    f102:	08 c0       	rjmp	.+16     	; 0xf114 <skip_spaces+0x26>
    f104:	0e 94 27 82 	call	0x1044e	; 0x1044e <isspace>
    f108:	89 2b       	or	r24, r25
    f10a:	b1 f7       	brne	.-20     	; 0xf0f8 <skip_spaces+0xa>
    f10c:	ce 01       	movw	r24, r28
    f10e:	b8 01       	movw	r22, r16
    f110:	0e 94 e4 82 	call	0x105c8	; 0x105c8 <ungetc>
    f114:	ce 01       	movw	r24, r28
    f116:	df 91       	pop	r29
    f118:	cf 91       	pop	r28
    f11a:	1f 91       	pop	r17
    f11c:	0f 91       	pop	r16
    f11e:	08 95       	ret

0000f120 <conv_int>:
    f120:	8f 92       	push	r8
    f122:	9f 92       	push	r9
    f124:	af 92       	push	r10
    f126:	bf 92       	push	r11
    f128:	df 92       	push	r13
    f12a:	ef 92       	push	r14
    f12c:	ff 92       	push	r15
    f12e:	0f 93       	push	r16
    f130:	1f 93       	push	r17
    f132:	cf 93       	push	r28
    f134:	df 93       	push	r29
    f136:	5c 01       	movw	r10, r24
    f138:	eb 01       	movw	r28, r22
    f13a:	4a 01       	movw	r8, r20
    f13c:	12 2f       	mov	r17, r18
    f13e:	0e 94 58 82 	call	0x104b0	; 0x104b0 <fgetc>
    f142:	ac 01       	movw	r20, r24
    f144:	8b 32       	cpi	r24, 0x2B	; 43
    f146:	19 f0       	breq	.+6      	; 0xf14e <conv_int+0x2e>
    f148:	8d 32       	cpi	r24, 0x2D	; 45
    f14a:	51 f4       	brne	.+20     	; 0xf160 <conv_int+0x40>
    f14c:	10 68       	ori	r17, 0x80	; 128
    f14e:	21 97       	sbiw	r28, 0x01	; 1
    f150:	09 f4       	brne	.+2      	; 0xf154 <conv_int+0x34>
    f152:	6d c0       	rjmp	.+218    	; 0xf22e <conv_int+0x10e>
    f154:	c5 01       	movw	r24, r10
    f156:	0e 94 58 82 	call	0x104b0	; 0x104b0 <fgetc>
    f15a:	ac 01       	movw	r20, r24
    f15c:	97 fd       	sbrc	r25, 7
    f15e:	67 c0       	rjmp	.+206    	; 0xf22e <conv_int+0x10e>
    f160:	6d ef       	ldi	r22, 0xFD	; 253
    f162:	d6 2e       	mov	r13, r22
    f164:	d1 22       	and	r13, r17
    f166:	8d 2d       	mov	r24, r13
    f168:	80 73       	andi	r24, 0x30	; 48
    f16a:	01 f5       	brne	.+64     	; 0xf1ac <conv_int+0x8c>
    f16c:	40 33       	cpi	r20, 0x30	; 48
    f16e:	f1 f4       	brne	.+60     	; 0xf1ac <conv_int+0x8c>
    f170:	21 97       	sbiw	r28, 0x01	; 1
    f172:	09 f4       	brne	.+2      	; 0xf176 <conv_int+0x56>
    f174:	47 c0       	rjmp	.+142    	; 0xf204 <conv_int+0xe4>
    f176:	c5 01       	movw	r24, r10
    f178:	0e 94 58 82 	call	0x104b0	; 0x104b0 <fgetc>
    f17c:	ac 01       	movw	r20, r24
    f17e:	97 fd       	sbrc	r25, 7
    f180:	41 c0       	rjmp	.+130    	; 0xf204 <conv_int+0xe4>
    f182:	82 e0       	ldi	r24, 0x02	; 2
    f184:	d8 2a       	or	r13, r24
    f186:	48 37       	cpi	r20, 0x78	; 120
    f188:	11 f0       	breq	.+4      	; 0xf18e <conv_int+0x6e>
    f18a:	48 35       	cpi	r20, 0x58	; 88
    f18c:	59 f4       	brne	.+22     	; 0xf1a4 <conv_int+0x84>
    f18e:	80 e4       	ldi	r24, 0x40	; 64
    f190:	d8 2a       	or	r13, r24
    f192:	21 97       	sbiw	r28, 0x01	; 1
    f194:	b9 f1       	breq	.+110    	; 0xf204 <conv_int+0xe4>
    f196:	c5 01       	movw	r24, r10
    f198:	0e 94 58 82 	call	0x104b0	; 0x104b0 <fgetc>
    f19c:	ac 01       	movw	r20, r24
    f19e:	99 23       	and	r25, r25
    f1a0:	2c f4       	brge	.+10     	; 0xf1ac <conv_int+0x8c>
    f1a2:	30 c0       	rjmp	.+96     	; 0xf204 <conv_int+0xe4>
    f1a4:	d6 fc       	sbrc	r13, 6
    f1a6:	02 c0       	rjmp	.+4      	; 0xf1ac <conv_int+0x8c>
    f1a8:	80 e1       	ldi	r24, 0x10	; 16
    f1aa:	d8 2a       	or	r13, r24
    f1ac:	ee 24       	eor	r14, r14
    f1ae:	ff 24       	eor	r15, r15
    f1b0:	87 01       	movw	r16, r14
    f1b2:	24 2f       	mov	r18, r20
    f1b4:	20 53       	subi	r18, 0x30	; 48
    f1b6:	28 30       	cpi	r18, 0x08	; 8
    f1b8:	88 f0       	brcs	.+34     	; 0xf1dc <conv_int+0xbc>
    f1ba:	d4 fc       	sbrc	r13, 4
    f1bc:	09 c0       	rjmp	.+18     	; 0xf1d0 <conv_int+0xb0>
    f1be:	2a 30       	cpi	r18, 0x0A	; 10
    f1c0:	68 f0       	brcs	.+26     	; 0xf1dc <conv_int+0xbc>
    f1c2:	d6 fe       	sbrs	r13, 6
    f1c4:	05 c0       	rjmp	.+10     	; 0xf1d0 <conv_int+0xb0>
    f1c6:	2f 7d       	andi	r18, 0xDF	; 223
    f1c8:	82 2f       	mov	r24, r18
    f1ca:	81 51       	subi	r24, 0x11	; 17
    f1cc:	86 30       	cpi	r24, 0x06	; 6
    f1ce:	28 f0       	brcs	.+10     	; 0xf1da <conv_int+0xba>
    f1d0:	ca 01       	movw	r24, r20
    f1d2:	b5 01       	movw	r22, r10
    f1d4:	0e 94 e4 82 	call	0x105c8	; 0x105c8 <ungetc>
    f1d8:	12 c0       	rjmp	.+36     	; 0xf1fe <conv_int+0xde>
    f1da:	27 50       	subi	r18, 0x07	; 7
    f1dc:	c8 01       	movw	r24, r16
    f1de:	b7 01       	movw	r22, r14
    f1e0:	4d 2d       	mov	r20, r13
    f1e2:	0e 94 49 78 	call	0xf092	; 0xf092 <mulacc>
    f1e6:	7b 01       	movw	r14, r22
    f1e8:	8c 01       	movw	r16, r24
    f1ea:	82 e0       	ldi	r24, 0x02	; 2
    f1ec:	d8 2a       	or	r13, r24
    f1ee:	21 97       	sbiw	r28, 0x01	; 1
    f1f0:	61 f0       	breq	.+24     	; 0xf20a <conv_int+0xea>
    f1f2:	c5 01       	movw	r24, r10
    f1f4:	0e 94 58 82 	call	0x104b0	; 0x104b0 <fgetc>
    f1f8:	ac 01       	movw	r20, r24
    f1fa:	97 ff       	sbrs	r25, 7
    f1fc:	da cf       	rjmp	.-76     	; 0xf1b2 <conv_int+0x92>
    f1fe:	d1 fc       	sbrc	r13, 1
    f200:	04 c0       	rjmp	.+8      	; 0xf20a <conv_int+0xea>
    f202:	15 c0       	rjmp	.+42     	; 0xf22e <conv_int+0x10e>
    f204:	ee 24       	eor	r14, r14
    f206:	ff 24       	eor	r15, r15
    f208:	87 01       	movw	r16, r14
    f20a:	d7 fe       	sbrs	r13, 7
    f20c:	08 c0       	rjmp	.+16     	; 0xf21e <conv_int+0xfe>
    f20e:	10 95       	com	r17
    f210:	00 95       	com	r16
    f212:	f0 94       	com	r15
    f214:	e0 94       	com	r14
    f216:	e1 1c       	adc	r14, r1
    f218:	f1 1c       	adc	r15, r1
    f21a:	01 1d       	adc	r16, r1
    f21c:	11 1d       	adc	r17, r1
    f21e:	c4 01       	movw	r24, r8
    f220:	b8 01       	movw	r22, r16
    f222:	a7 01       	movw	r20, r14
    f224:	2d 2d       	mov	r18, r13
    f226:	0e 94 3d 78 	call	0xf07a	; 0xf07a <putval>
    f22a:	81 e0       	ldi	r24, 0x01	; 1
    f22c:	01 c0       	rjmp	.+2      	; 0xf230 <conv_int+0x110>
    f22e:	80 e0       	ldi	r24, 0x00	; 0
    f230:	df 91       	pop	r29
    f232:	cf 91       	pop	r28
    f234:	1f 91       	pop	r17
    f236:	0f 91       	pop	r16
    f238:	ff 90       	pop	r15
    f23a:	ef 90       	pop	r14
    f23c:	df 90       	pop	r13
    f23e:	bf 90       	pop	r11
    f240:	af 90       	pop	r10
    f242:	9f 90       	pop	r9
    f244:	8f 90       	pop	r8
    f246:	08 95       	ret

0000f248 <conv_brk>:
    f248:	6f 92       	push	r6
    f24a:	7f 92       	push	r7
    f24c:	8f 92       	push	r8
    f24e:	9f 92       	push	r9
    f250:	af 92       	push	r10
    f252:	bf 92       	push	r11
    f254:	cf 92       	push	r12
    f256:	df 92       	push	r13
    f258:	ef 92       	push	r14
    f25a:	ff 92       	push	r15
    f25c:	0f 93       	push	r16
    f25e:	1f 93       	push	r17
    f260:	df 93       	push	r29
    f262:	cf 93       	push	r28
    f264:	cd b7       	in	r28, 0x3d	; 61
    f266:	de b7       	in	r29, 0x3e	; 62
    f268:	a0 97       	sbiw	r28, 0x20	; 32
    f26a:	0f b6       	in	r0, 0x3f	; 63
    f26c:	f8 94       	cli
    f26e:	de bf       	out	0x3e, r29	; 62
    f270:	0f be       	out	0x3f, r0	; 63
    f272:	cd bf       	out	0x3d, r28	; 61
    f274:	5c 01       	movw	r10, r24
    f276:	6b 01       	movw	r12, r22
    f278:	8a 01       	movw	r16, r20
    f27a:	79 01       	movw	r14, r18
    f27c:	fe 01       	movw	r30, r28
    f27e:	31 96       	adiw	r30, 0x01	; 1
    f280:	80 e2       	ldi	r24, 0x20	; 32
    f282:	df 01       	movw	r26, r30
    f284:	1d 92       	st	X+, r1
    f286:	8a 95       	dec	r24
    f288:	e9 f7       	brne	.-6      	; 0xf284 <conv_brk+0x3c>
    f28a:	70 e0       	ldi	r23, 0x00	; 0
    f28c:	30 e0       	ldi	r19, 0x00	; 0
    f28e:	60 e0       	ldi	r22, 0x00	; 0
    f290:	40 e0       	ldi	r20, 0x00	; 0
    f292:	50 e0       	ldi	r21, 0x00	; 0
    f294:	3f 01       	movw	r6, r30
    f296:	a1 e0       	ldi	r26, 0x01	; 1
    f298:	b0 e0       	ldi	r27, 0x00	; 0
    f29a:	f5 01       	movw	r30, r10
    f29c:	83 81       	ldd	r24, Z+3	; 0x03
    f29e:	f7 01       	movw	r30, r14
    f2a0:	83 fd       	sbrc	r24, 3
    f2a2:	25 91       	lpm	r18, Z+
    f2a4:	83 ff       	sbrs	r24, 3
    f2a6:	21 91       	ld	r18, Z+
    f2a8:	7f 01       	movw	r14, r30
    f2aa:	22 23       	and	r18, r18
    f2ac:	09 f4       	brne	.+2      	; 0xf2b0 <conv_brk+0x68>
    f2ae:	81 c0       	rjmp	.+258    	; 0xf3b2 <conv_brk+0x16a>
    f2b0:	2e 35       	cpi	r18, 0x5E	; 94
    f2b2:	19 f4       	brne	.+6      	; 0xf2ba <conv_brk+0x72>
    f2b4:	41 15       	cp	r20, r1
    f2b6:	51 05       	cpc	r21, r1
    f2b8:	69 f1       	breq	.+90     	; 0xf314 <conv_brk+0xcc>
    f2ba:	87 2f       	mov	r24, r23
    f2bc:	90 e0       	ldi	r25, 0x00	; 0
    f2be:	84 17       	cp	r24, r20
    f2c0:	95 07       	cpc	r25, r21
    f2c2:	44 f4       	brge	.+16     	; 0xf2d4 <conv_brk+0x8c>
    f2c4:	2d 35       	cpi	r18, 0x5D	; 93
    f2c6:	51 f1       	breq	.+84     	; 0xf31c <conv_brk+0xd4>
    f2c8:	2d 32       	cpi	r18, 0x2D	; 45
    f2ca:	21 f4       	brne	.+8      	; 0xf2d4 <conv_brk+0x8c>
    f2cc:	33 23       	and	r19, r19
    f2ce:	29 f4       	brne	.+10     	; 0xf2da <conv_brk+0x92>
    f2d0:	31 e0       	ldi	r19, 0x01	; 1
    f2d2:	21 c0       	rjmp	.+66     	; 0xf316 <conv_brk+0xce>
    f2d4:	33 23       	and	r19, r19
    f2d6:	09 f4       	brne	.+2      	; 0xf2da <conv_brk+0x92>
    f2d8:	62 2f       	mov	r22, r18
    f2da:	32 2f       	mov	r19, r18
    f2dc:	83 2f       	mov	r24, r19
    f2de:	86 95       	lsr	r24
    f2e0:	86 95       	lsr	r24
    f2e2:	86 95       	lsr	r24
    f2e4:	f3 01       	movw	r30, r6
    f2e6:	e8 0f       	add	r30, r24
    f2e8:	f1 1d       	adc	r31, r1
    f2ea:	83 2f       	mov	r24, r19
    f2ec:	87 70       	andi	r24, 0x07	; 7
    f2ee:	4d 01       	movw	r8, r26
    f2f0:	02 c0       	rjmp	.+4      	; 0xf2f6 <conv_brk+0xae>
    f2f2:	88 0c       	add	r8, r8
    f2f4:	99 1c       	adc	r9, r9
    f2f6:	8a 95       	dec	r24
    f2f8:	e2 f7       	brpl	.-8      	; 0xf2f2 <conv_brk+0xaa>
    f2fa:	20 81       	ld	r18, Z
    f2fc:	28 29       	or	r18, r8
    f2fe:	20 83       	st	Z, r18
    f300:	36 17       	cp	r19, r22
    f302:	11 f4       	brne	.+4      	; 0xf308 <conv_brk+0xc0>
    f304:	30 e0       	ldi	r19, 0x00	; 0
    f306:	07 c0       	rjmp	.+14     	; 0xf316 <conv_brk+0xce>
    f308:	36 17       	cp	r19, r22
    f30a:	10 f4       	brcc	.+4      	; 0xf310 <conv_brk+0xc8>
    f30c:	3f 5f       	subi	r19, 0xFF	; 255
    f30e:	e6 cf       	rjmp	.-52     	; 0xf2dc <conv_brk+0x94>
    f310:	31 50       	subi	r19, 0x01	; 1
    f312:	e4 cf       	rjmp	.-56     	; 0xf2dc <conv_brk+0x94>
    f314:	71 e0       	ldi	r23, 0x01	; 1
    f316:	4f 5f       	subi	r20, 0xFF	; 255
    f318:	5f 4f       	sbci	r21, 0xFF	; 255
    f31a:	bf cf       	rjmp	.-130    	; 0xf29a <conv_brk+0x52>
    f31c:	33 23       	and	r19, r19
    f31e:	19 f0       	breq	.+6      	; 0xf326 <conv_brk+0xde>
    f320:	8e 81       	ldd	r24, Y+6	; 0x06
    f322:	80 62       	ori	r24, 0x20	; 32
    f324:	8e 83       	std	Y+6, r24	; 0x06
    f326:	77 23       	and	r23, r23
    f328:	59 f0       	breq	.+22     	; 0xf340 <conv_brk+0xf8>
    f32a:	fe 01       	movw	r30, r28
    f32c:	31 96       	adiw	r30, 0x01	; 1
    f32e:	9e 01       	movw	r18, r28
    f330:	2f 5d       	subi	r18, 0xDF	; 223
    f332:	3f 4f       	sbci	r19, 0xFF	; 255
    f334:	80 81       	ld	r24, Z
    f336:	80 95       	com	r24
    f338:	81 93       	st	Z+, r24
    f33a:	e2 17       	cp	r30, r18
    f33c:	f3 07       	cpc	r31, r19
    f33e:	d1 f7       	brne	.-12     	; 0xf334 <conv_brk+0xec>
    f340:	99 24       	eor	r9, r9
    f342:	93 94       	inc	r9
    f344:	3e 01       	movw	r6, r28
    f346:	08 94       	sec
    f348:	61 1c       	adc	r6, r1
    f34a:	71 1c       	adc	r7, r1
    f34c:	c5 01       	movw	r24, r10
    f34e:	0e 94 58 82 	call	0x104b0	; 0x104b0 <fgetc>
    f352:	ac 01       	movw	r20, r24
    f354:	97 fd       	sbrc	r25, 7
    f356:	25 c0       	rjmp	.+74     	; 0xf3a2 <conv_brk+0x15a>
    f358:	86 95       	lsr	r24
    f35a:	86 95       	lsr	r24
    f35c:	86 95       	lsr	r24
    f35e:	f3 01       	movw	r30, r6
    f360:	e8 0f       	add	r30, r24
    f362:	f1 1d       	adc	r31, r1
    f364:	80 81       	ld	r24, Z
    f366:	90 e0       	ldi	r25, 0x00	; 0
    f368:	9a 01       	movw	r18, r20
    f36a:	27 70       	andi	r18, 0x07	; 7
    f36c:	30 70       	andi	r19, 0x00	; 0
    f36e:	02 c0       	rjmp	.+4      	; 0xf374 <conv_brk+0x12c>
    f370:	95 95       	asr	r25
    f372:	87 95       	ror	r24
    f374:	2a 95       	dec	r18
    f376:	e2 f7       	brpl	.-8      	; 0xf370 <conv_brk+0x128>
    f378:	80 fd       	sbrc	r24, 0
    f37a:	05 c0       	rjmp	.+10     	; 0xf386 <conv_brk+0x13e>
    f37c:	ca 01       	movw	r24, r20
    f37e:	b5 01       	movw	r22, r10
    f380:	0e 94 e4 82 	call	0x105c8	; 0x105c8 <ungetc>
    f384:	0e c0       	rjmp	.+28     	; 0xf3a2 <conv_brk+0x15a>
    f386:	01 15       	cp	r16, r1
    f388:	11 05       	cpc	r17, r1
    f38a:	19 f0       	breq	.+6      	; 0xf392 <conv_brk+0x14a>
    f38c:	d8 01       	movw	r26, r16
    f38e:	4d 93       	st	X+, r20
    f390:	8d 01       	movw	r16, r26
    f392:	08 94       	sec
    f394:	c1 08       	sbc	r12, r1
    f396:	d1 08       	sbc	r13, r1
    f398:	99 24       	eor	r9, r9
    f39a:	c1 14       	cp	r12, r1
    f39c:	d1 04       	cpc	r13, r1
    f39e:	b1 f6       	brne	.-84     	; 0xf34c <conv_brk+0x104>
    f3a0:	02 c0       	rjmp	.+4      	; 0xf3a6 <conv_brk+0x15e>
    f3a2:	99 20       	and	r9, r9
    f3a4:	31 f4       	brne	.+12     	; 0xf3b2 <conv_brk+0x16a>
    f3a6:	01 15       	cp	r16, r1
    f3a8:	11 05       	cpc	r17, r1
    f3aa:	29 f0       	breq	.+10     	; 0xf3b6 <conv_brk+0x16e>
    f3ac:	f8 01       	movw	r30, r16
    f3ae:	10 82       	st	Z, r1
    f3b0:	02 c0       	rjmp	.+4      	; 0xf3b6 <conv_brk+0x16e>
    f3b2:	ee 24       	eor	r14, r14
    f3b4:	ff 24       	eor	r15, r15
    f3b6:	c7 01       	movw	r24, r14
    f3b8:	a0 96       	adiw	r28, 0x20	; 32
    f3ba:	0f b6       	in	r0, 0x3f	; 63
    f3bc:	f8 94       	cli
    f3be:	de bf       	out	0x3e, r29	; 62
    f3c0:	0f be       	out	0x3f, r0	; 63
    f3c2:	cd bf       	out	0x3d, r28	; 61
    f3c4:	cf 91       	pop	r28
    f3c6:	df 91       	pop	r29
    f3c8:	1f 91       	pop	r17
    f3ca:	0f 91       	pop	r16
    f3cc:	ff 90       	pop	r15
    f3ce:	ef 90       	pop	r14
    f3d0:	df 90       	pop	r13
    f3d2:	cf 90       	pop	r12
    f3d4:	bf 90       	pop	r11
    f3d6:	af 90       	pop	r10
    f3d8:	9f 90       	pop	r9
    f3da:	8f 90       	pop	r8
    f3dc:	7f 90       	pop	r7
    f3de:	6f 90       	pop	r6
    f3e0:	08 95       	ret

0000f3e2 <conv_flt>:
    f3e2:	2f 92       	push	r2
    f3e4:	3f 92       	push	r3
    f3e6:	5f 92       	push	r5
    f3e8:	6f 92       	push	r6
    f3ea:	7f 92       	push	r7
    f3ec:	8f 92       	push	r8
    f3ee:	9f 92       	push	r9
    f3f0:	af 92       	push	r10
    f3f2:	bf 92       	push	r11
    f3f4:	cf 92       	push	r12
    f3f6:	df 92       	push	r13
    f3f8:	ef 92       	push	r14
    f3fa:	ff 92       	push	r15
    f3fc:	0f 93       	push	r16
    f3fe:	1f 93       	push	r17
    f400:	cf 93       	push	r28
    f402:	df 93       	push	r29
    f404:	3c 01       	movw	r6, r24
    f406:	7b 01       	movw	r14, r22
    f408:	1a 01       	movw	r2, r20
    f40a:	0e 94 58 82 	call	0x104b0	; 0x104b0 <fgetc>
    f40e:	ec 01       	movw	r28, r24
    f410:	8b 32       	cpi	r24, 0x2B	; 43
    f412:	39 f0       	breq	.+14     	; 0xf422 <conv_flt+0x40>
    f414:	8d 32       	cpi	r24, 0x2D	; 45
    f416:	11 f0       	breq	.+4      	; 0xf41c <conv_flt+0x3a>
    f418:	55 24       	eor	r5, r5
    f41a:	11 c0       	rjmp	.+34     	; 0xf43e <conv_flt+0x5c>
    f41c:	b0 e8       	ldi	r27, 0x80	; 128
    f41e:	5b 2e       	mov	r5, r27
    f420:	01 c0       	rjmp	.+2      	; 0xf424 <conv_flt+0x42>
    f422:	55 24       	eor	r5, r5
    f424:	08 94       	sec
    f426:	e1 08       	sbc	r14, r1
    f428:	f1 08       	sbc	r15, r1
    f42a:	e1 14       	cp	r14, r1
    f42c:	f1 04       	cpc	r15, r1
    f42e:	09 f4       	brne	.+2      	; 0xf432 <conv_flt+0x50>
    f430:	18 c1       	rjmp	.+560    	; 0xf662 <conv_flt+0x280>
    f432:	c3 01       	movw	r24, r6
    f434:	0e 94 58 82 	call	0x104b0	; 0x104b0 <fgetc>
    f438:	ec 01       	movw	r28, r24
    f43a:	97 fd       	sbrc	r25, 7
    f43c:	12 c1       	rjmp	.+548    	; 0xf662 <conv_flt+0x280>
    f43e:	ce 01       	movw	r24, r28
    f440:	0e 94 2f 82 	call	0x1045e	; 0x1045e <tolower>
    f444:	89 36       	cpi	r24, 0x69	; 105
    f446:	91 05       	cpc	r25, r1
    f448:	21 f0       	breq	.+8      	; 0xf452 <conv_flt+0x70>
    f44a:	8e 36       	cpi	r24, 0x6E	; 110
    f44c:	91 05       	cpc	r25, r1
    f44e:	99 f5       	brne	.+102    	; 0xf4b6 <conv_flt+0xd4>
    f450:	1d c0       	rjmp	.+58     	; 0xf48c <conv_flt+0xaa>
    f452:	06 eb       	ldi	r16, 0xB6	; 182
    f454:	1c e0       	ldi	r17, 0x0C	; 12
    f456:	1c c0       	rjmp	.+56     	; 0xf490 <conv_flt+0xae>
    f458:	08 94       	sec
    f45a:	e1 08       	sbc	r14, r1
    f45c:	f1 08       	sbc	r15, r1
    f45e:	e1 14       	cp	r14, r1
    f460:	f1 04       	cpc	r15, r1
    f462:	71 f0       	breq	.+28     	; 0xf480 <conv_flt+0x9e>
    f464:	c3 01       	movw	r24, r6
    f466:	0e 94 58 82 	call	0x104b0	; 0x104b0 <fgetc>
    f46a:	ec 01       	movw	r28, r24
    f46c:	97 fd       	sbrc	r25, 7
    f46e:	08 c0       	rjmp	.+16     	; 0xf480 <conv_flt+0x9e>
    f470:	0e 94 2f 82 	call	0x1045e	; 0x1045e <tolower>
    f474:	d8 16       	cp	r13, r24
    f476:	61 f0       	breq	.+24     	; 0xf490 <conv_flt+0xae>
    f478:	ce 01       	movw	r24, r28
    f47a:	b3 01       	movw	r22, r6
    f47c:	0e 94 e4 82 	call	0x105c8	; 0x105c8 <ungetc>
    f480:	2c e0       	ldi	r18, 0x0C	; 12
    f482:	09 3b       	cpi	r16, 0xB9	; 185
    f484:	12 07       	cpc	r17, r18
    f486:	09 f0       	breq	.+2      	; 0xf48a <conv_flt+0xa8>
    f488:	ec c0       	rjmp	.+472    	; 0xf662 <conv_flt+0x280>
    f48a:	08 c0       	rjmp	.+16     	; 0xf49c <conv_flt+0xba>
    f48c:	03 eb       	ldi	r16, 0xB3	; 179
    f48e:	1c e0       	ldi	r17, 0x0C	; 12
    f490:	f8 01       	movw	r30, r16
    f492:	0f 5f       	subi	r16, 0xFF	; 255
    f494:	1f 4f       	sbci	r17, 0xFF	; 255
    f496:	d4 90       	lpm	r13, Z+
    f498:	dd 20       	and	r13, r13
    f49a:	f1 f6       	brne	.-68     	; 0xf458 <conv_flt+0x76>
    f49c:	06 5b       	subi	r16, 0xB6	; 182
    f49e:	1c 40       	sbci	r17, 0x0C	; 12
    f4a0:	29 f0       	breq	.+10     	; 0xf4ac <conv_flt+0xca>
    f4a2:	80 e0       	ldi	r24, 0x00	; 0
    f4a4:	90 e0       	ldi	r25, 0x00	; 0
    f4a6:	a0 e8       	ldi	r26, 0x80	; 128
    f4a8:	bf e7       	ldi	r27, 0x7F	; 127
    f4aa:	cf c0       	rjmp	.+414    	; 0xf64a <conv_flt+0x268>
    f4ac:	80 e0       	ldi	r24, 0x00	; 0
    f4ae:	90 e0       	ldi	r25, 0x00	; 0
    f4b0:	a0 ec       	ldi	r26, 0xC0	; 192
    f4b2:	bf e7       	ldi	r27, 0x7F	; 127
    f4b4:	ca c0       	rjmp	.+404    	; 0xf64a <conv_flt+0x268>
    f4b6:	cc 24       	eor	r12, r12
    f4b8:	dd 24       	eor	r13, r13
    f4ba:	88 24       	eor	r8, r8
    f4bc:	99 24       	eor	r9, r9
    f4be:	54 01       	movw	r10, r8
    f4c0:	ae 01       	movw	r20, r28
    f4c2:	40 53       	subi	r20, 0x30	; 48
    f4c4:	24 2f       	mov	r18, r20
    f4c6:	4a 30       	cpi	r20, 0x0A	; 10
    f4c8:	38 f5       	brcc	.+78     	; 0xf518 <conv_flt+0x136>
    f4ca:	52 e0       	ldi	r21, 0x02	; 2
    f4cc:	55 2a       	or	r5, r21
    f4ce:	85 2d       	mov	r24, r5
    f4d0:	90 e0       	ldi	r25, 0x00	; 0
    f4d2:	ac 01       	movw	r20, r24
    f4d4:	48 70       	andi	r20, 0x08	; 8
    f4d6:	50 70       	andi	r21, 0x00	; 0
    f4d8:	52 fe       	sbrs	r5, 2
    f4da:	06 c0       	rjmp	.+12     	; 0xf4e8 <conv_flt+0x106>
    f4dc:	45 2b       	or	r20, r21
    f4de:	11 f5       	brne	.+68     	; 0xf524 <conv_flt+0x142>
    f4e0:	08 94       	sec
    f4e2:	c1 1c       	adc	r12, r1
    f4e4:	d1 1c       	adc	r13, r1
    f4e6:	1e c0       	rjmp	.+60     	; 0xf524 <conv_flt+0x142>
    f4e8:	45 2b       	or	r20, r21
    f4ea:	19 f0       	breq	.+6      	; 0xf4f2 <conv_flt+0x110>
    f4ec:	08 94       	sec
    f4ee:	c1 08       	sbc	r12, r1
    f4f0:	d1 08       	sbc	r13, r1
    f4f2:	c5 01       	movw	r24, r10
    f4f4:	b4 01       	movw	r22, r8
    f4f6:	40 e2       	ldi	r20, 0x20	; 32
    f4f8:	0e 94 49 78 	call	0xf092	; 0xf092 <mulacc>
    f4fc:	4b 01       	movw	r8, r22
    f4fe:	5c 01       	movw	r10, r24
    f500:	88 e9       	ldi	r24, 0x98	; 152
    f502:	88 16       	cp	r8, r24
    f504:	89 e9       	ldi	r24, 0x99	; 153
    f506:	98 06       	cpc	r9, r24
    f508:	89 e9       	ldi	r24, 0x99	; 153
    f50a:	a8 06       	cpc	r10, r24
    f50c:	89 e1       	ldi	r24, 0x19	; 25
    f50e:	b8 06       	cpc	r11, r24
    f510:	48 f0       	brcs	.+18     	; 0xf524 <conv_flt+0x142>
    f512:	94 e0       	ldi	r25, 0x04	; 4
    f514:	59 2a       	or	r5, r25
    f516:	06 c0       	rjmp	.+12     	; 0xf524 <conv_flt+0x142>
    f518:	4e 3f       	cpi	r20, 0xFE	; 254
    f51a:	81 f4       	brne	.+32     	; 0xf53c <conv_flt+0x15a>
    f51c:	53 fc       	sbrc	r5, 3
    f51e:	0e c0       	rjmp	.+28     	; 0xf53c <conv_flt+0x15a>
    f520:	e8 e0       	ldi	r30, 0x08	; 8
    f522:	5e 2a       	or	r5, r30
    f524:	08 94       	sec
    f526:	e1 08       	sbc	r14, r1
    f528:	f1 08       	sbc	r15, r1
    f52a:	e1 14       	cp	r14, r1
    f52c:	f1 04       	cpc	r15, r1
    f52e:	31 f0       	breq	.+12     	; 0xf53c <conv_flt+0x15a>
    f530:	c3 01       	movw	r24, r6
    f532:	0e 94 58 82 	call	0x104b0	; 0x104b0 <fgetc>
    f536:	ec 01       	movw	r28, r24
    f538:	97 ff       	sbrs	r25, 7
    f53a:	c2 cf       	rjmp	.-124    	; 0xf4c0 <conv_flt+0xde>
    f53c:	51 fe       	sbrs	r5, 1
    f53e:	91 c0       	rjmp	.+290    	; 0xf662 <conv_flt+0x280>
    f540:	c5 36       	cpi	r28, 0x65	; 101
    f542:	19 f0       	breq	.+6      	; 0xf54a <conv_flt+0x168>
    f544:	c5 34       	cpi	r28, 0x45	; 69
    f546:	09 f0       	breq	.+2      	; 0xf54a <conv_flt+0x168>
    f548:	46 c0       	rjmp	.+140    	; 0xf5d6 <conv_flt+0x1f4>
    f54a:	08 94       	sec
    f54c:	e1 08       	sbc	r14, r1
    f54e:	f1 08       	sbc	r15, r1
    f550:	e1 14       	cp	r14, r1
    f552:	f1 04       	cpc	r15, r1
    f554:	09 f4       	brne	.+2      	; 0xf558 <conv_flt+0x176>
    f556:	85 c0       	rjmp	.+266    	; 0xf662 <conv_flt+0x280>
    f558:	c3 01       	movw	r24, r6
    f55a:	0e 94 58 82 	call	0x104b0	; 0x104b0 <fgetc>
    f55e:	ec 01       	movw	r28, r24
    f560:	97 fd       	sbrc	r25, 7
    f562:	7f c0       	rjmp	.+254    	; 0xf662 <conv_flt+0x280>
    f564:	8b 32       	cpi	r24, 0x2B	; 43
    f566:	21 f0       	breq	.+8      	; 0xf570 <conv_flt+0x18e>
    f568:	8d 32       	cpi	r24, 0x2D	; 45
    f56a:	69 f4       	brne	.+26     	; 0xf586 <conv_flt+0x1a4>
    f56c:	f0 e1       	ldi	r31, 0x10	; 16
    f56e:	5f 2a       	or	r5, r31
    f570:	08 94       	sec
    f572:	e1 08       	sbc	r14, r1
    f574:	f1 08       	sbc	r15, r1
    f576:	e1 14       	cp	r14, r1
    f578:	f1 04       	cpc	r15, r1
    f57a:	09 f4       	brne	.+2      	; 0xf57e <conv_flt+0x19c>
    f57c:	72 c0       	rjmp	.+228    	; 0xf662 <conv_flt+0x280>
    f57e:	c3 01       	movw	r24, r6
    f580:	0e 94 58 82 	call	0x104b0	; 0x104b0 <fgetc>
    f584:	ec 01       	movw	r28, r24
    f586:	ce 01       	movw	r24, r28
    f588:	c0 97       	sbiw	r24, 0x30	; 48
    f58a:	0a 97       	sbiw	r24, 0x0a	; 10
    f58c:	08 f0       	brcs	.+2      	; 0xf590 <conv_flt+0x1ae>
    f58e:	69 c0       	rjmp	.+210    	; 0xf662 <conv_flt+0x280>
    f590:	00 e0       	ldi	r16, 0x00	; 0
    f592:	10 e0       	ldi	r17, 0x00	; 0
    f594:	b8 01       	movw	r22, r16
    f596:	88 27       	eor	r24, r24
    f598:	77 fd       	sbrc	r23, 7
    f59a:	80 95       	com	r24
    f59c:	98 2f       	mov	r25, r24
    f59e:	ae 01       	movw	r20, r28
    f5a0:	40 53       	subi	r20, 0x30	; 48
    f5a2:	24 2f       	mov	r18, r20
    f5a4:	40 e2       	ldi	r20, 0x20	; 32
    f5a6:	0e 94 49 78 	call	0xf092	; 0xf092 <mulacc>
    f5aa:	8b 01       	movw	r16, r22
    f5ac:	08 94       	sec
    f5ae:	e1 08       	sbc	r14, r1
    f5b0:	f1 08       	sbc	r15, r1
    f5b2:	e1 14       	cp	r14, r1
    f5b4:	f1 04       	cpc	r15, r1
    f5b6:	39 f0       	breq	.+14     	; 0xf5c6 <conv_flt+0x1e4>
    f5b8:	c3 01       	movw	r24, r6
    f5ba:	0e 94 58 82 	call	0x104b0	; 0x104b0 <fgetc>
    f5be:	ec 01       	movw	r28, r24
    f5c0:	c0 97       	sbiw	r24, 0x30	; 48
    f5c2:	0a 97       	sbiw	r24, 0x0a	; 10
    f5c4:	38 f3       	brcs	.-50     	; 0xf594 <conv_flt+0x1b2>
    f5c6:	b8 01       	movw	r22, r16
    f5c8:	54 fe       	sbrs	r5, 4
    f5ca:	03 c0       	rjmp	.+6      	; 0xf5d2 <conv_flt+0x1f0>
    f5cc:	70 95       	com	r23
    f5ce:	61 95       	neg	r22
    f5d0:	7f 4f       	sbci	r23, 0xFF	; 255
    f5d2:	c6 0e       	add	r12, r22
    f5d4:	d7 1e       	adc	r13, r23
    f5d6:	ef 28       	or	r14, r15
    f5d8:	31 f0       	breq	.+12     	; 0xf5e6 <conv_flt+0x204>
    f5da:	d7 fd       	sbrc	r29, 7
    f5dc:	04 c0       	rjmp	.+8      	; 0xf5e6 <conv_flt+0x204>
    f5de:	ce 01       	movw	r24, r28
    f5e0:	b3 01       	movw	r22, r6
    f5e2:	0e 94 e4 82 	call	0x105c8	; 0x105c8 <ungetc>
    f5e6:	c5 01       	movw	r24, r10
    f5e8:	b4 01       	movw	r22, r8
    f5ea:	0e 94 e2 7d 	call	0xfbc4	; 0xfbc4 <__floatunsisf>
    f5ee:	d7 fe       	sbrs	r13, 7
    f5f0:	0d c0       	rjmp	.+26     	; 0xf60c <conv_flt+0x22a>
    f5f2:	a2 ed       	ldi	r26, 0xD2	; 210
    f5f4:	ea 2e       	mov	r14, r26
    f5f6:	ac e0       	ldi	r26, 0x0C	; 12
    f5f8:	fa 2e       	mov	r15, r26
    f5fa:	d0 94       	com	r13
    f5fc:	c1 94       	neg	r12
    f5fe:	d1 08       	sbc	r13, r1
    f600:	d3 94       	inc	r13
    f602:	c0 e2       	ldi	r28, 0x20	; 32
    f604:	d0 e0       	ldi	r29, 0x00	; 0
    f606:	00 e0       	ldi	r16, 0x00	; 0
    f608:	10 e0       	ldi	r17, 0x00	; 0
    f60a:	0e c0       	rjmp	.+28     	; 0xf628 <conv_flt+0x246>
    f60c:	fa ee       	ldi	r31, 0xEA	; 234
    f60e:	ef 2e       	mov	r14, r31
    f610:	fc e0       	ldi	r31, 0x0C	; 12
    f612:	ff 2e       	mov	r15, r31
    f614:	f6 cf       	rjmp	.-20     	; 0xf602 <conv_flt+0x220>
    f616:	f7 01       	movw	r30, r14
    f618:	25 91       	lpm	r18, Z+
    f61a:	35 91       	lpm	r19, Z+
    f61c:	45 91       	lpm	r20, Z+
    f61e:	54 91       	lpm	r21, Z+
    f620:	0e 94 fe 7e 	call	0xfdfc	; 0xfdfc <__mulsf3>
    f624:	cc 1a       	sub	r12, r28
    f626:	dd 0a       	sbc	r13, r29
    f628:	cc 16       	cp	r12, r28
    f62a:	dd 06       	cpc	r13, r29
    f62c:	a0 f7       	brcc	.-24     	; 0xf616 <conv_flt+0x234>
    f62e:	d6 95       	lsr	r29
    f630:	c7 95       	ror	r28
    f632:	0f 5f       	subi	r16, 0xFF	; 255
    f634:	1f 4f       	sbci	r17, 0xFF	; 255
    f636:	06 30       	cpi	r16, 0x06	; 6
    f638:	11 05       	cpc	r17, r1
    f63a:	29 f0       	breq	.+10     	; 0xf646 <conv_flt+0x264>
    f63c:	ec ef       	ldi	r30, 0xFC	; 252
    f63e:	ff ef       	ldi	r31, 0xFF	; 255
    f640:	ee 0e       	add	r14, r30
    f642:	ff 1e       	adc	r15, r31
    f644:	f1 cf       	rjmp	.-30     	; 0xf628 <conv_flt+0x246>
    f646:	dc 01       	movw	r26, r24
    f648:	cb 01       	movw	r24, r22
    f64a:	57 fc       	sbrc	r5, 7
    f64c:	b0 58       	subi	r27, 0x80	; 128
    f64e:	21 14       	cp	r2, r1
    f650:	31 04       	cpc	r3, r1
    f652:	29 f0       	breq	.+10     	; 0xf65e <conv_flt+0x27c>
    f654:	f1 01       	movw	r30, r2
    f656:	80 83       	st	Z, r24
    f658:	91 83       	std	Z+1, r25	; 0x01
    f65a:	a2 83       	std	Z+2, r26	; 0x02
    f65c:	b3 83       	std	Z+3, r27	; 0x03
    f65e:	81 e0       	ldi	r24, 0x01	; 1
    f660:	01 c0       	rjmp	.+2      	; 0xf664 <conv_flt+0x282>
    f662:	80 e0       	ldi	r24, 0x00	; 0
    f664:	df 91       	pop	r29
    f666:	cf 91       	pop	r28
    f668:	1f 91       	pop	r17
    f66a:	0f 91       	pop	r16
    f66c:	ff 90       	pop	r15
    f66e:	ef 90       	pop	r14
    f670:	df 90       	pop	r13
    f672:	cf 90       	pop	r12
    f674:	bf 90       	pop	r11
    f676:	af 90       	pop	r10
    f678:	9f 90       	pop	r9
    f67a:	8f 90       	pop	r8
    f67c:	7f 90       	pop	r7
    f67e:	6f 90       	pop	r6
    f680:	5f 90       	pop	r5
    f682:	3f 90       	pop	r3
    f684:	2f 90       	pop	r2
    f686:	08 95       	ret

0000f688 <vfscanf>:
    f688:	5f 92       	push	r5
    f68a:	6f 92       	push	r6
    f68c:	7f 92       	push	r7
    f68e:	8f 92       	push	r8
    f690:	9f 92       	push	r9
    f692:	af 92       	push	r10
    f694:	bf 92       	push	r11
    f696:	cf 92       	push	r12
    f698:	df 92       	push	r13
    f69a:	ef 92       	push	r14
    f69c:	ff 92       	push	r15
    f69e:	0f 93       	push	r16
    f6a0:	1f 93       	push	r17
    f6a2:	cf 93       	push	r28
    f6a4:	df 93       	push	r29
    f6a6:	4c 01       	movw	r8, r24
    f6a8:	5b 01       	movw	r10, r22
    f6aa:	3a 01       	movw	r6, r20
    f6ac:	fc 01       	movw	r30, r24
    f6ae:	17 82       	std	Z+7, r1	; 0x07
    f6b0:	16 82       	std	Z+6, r1	; 0x06
    f6b2:	55 24       	eor	r5, r5
    f6b4:	04 c1       	rjmp	.+520    	; 0xf8be <vfscanf+0x236>
    f6b6:	81 2f       	mov	r24, r17
    f6b8:	90 e0       	ldi	r25, 0x00	; 0
    f6ba:	0e 94 27 82 	call	0x1044e	; 0x1044e <isspace>
    f6be:	89 2b       	or	r24, r25
    f6c0:	21 f0       	breq	.+8      	; 0xf6ca <vfscanf+0x42>
    f6c2:	c4 01       	movw	r24, r8
    f6c4:	0e 94 77 78 	call	0xf0ee	; 0xf0ee <skip_spaces>
    f6c8:	fa c0       	rjmp	.+500    	; 0xf8be <vfscanf+0x236>
    f6ca:	15 32       	cpi	r17, 0x25	; 37
    f6cc:	49 f4       	brne	.+18     	; 0xf6e0 <vfscanf+0x58>
    f6ce:	f5 01       	movw	r30, r10
    f6d0:	f3 fc       	sbrc	r15, 3
    f6d2:	65 91       	lpm	r22, Z+
    f6d4:	f3 fe       	sbrs	r15, 3
    f6d6:	61 91       	ld	r22, Z+
    f6d8:	5f 01       	movw	r10, r30
    f6da:	65 32       	cpi	r22, 0x25	; 37
    f6dc:	69 f4       	brne	.+26     	; 0xf6f8 <vfscanf+0x70>
    f6de:	15 e2       	ldi	r17, 0x25	; 37
    f6e0:	c4 01       	movw	r24, r8
    f6e2:	0e 94 58 82 	call	0x104b0	; 0x104b0 <fgetc>
    f6e6:	97 fd       	sbrc	r25, 7
    f6e8:	f6 c0       	rjmp	.+492    	; 0xf8d6 <vfscanf+0x24e>
    f6ea:	18 17       	cp	r17, r24
    f6ec:	09 f4       	brne	.+2      	; 0xf6f0 <vfscanf+0x68>
    f6ee:	e7 c0       	rjmp	.+462    	; 0xf8be <vfscanf+0x236>
    f6f0:	b4 01       	movw	r22, r8
    f6f2:	0e 94 e4 82 	call	0x105c8	; 0x105c8 <ungetc>
    f6f6:	f4 c0       	rjmp	.+488    	; 0xf8e0 <vfscanf+0x258>
    f6f8:	6a 32       	cpi	r22, 0x2A	; 42
    f6fa:	19 f0       	breq	.+6      	; 0xf702 <vfscanf+0x7a>
    f6fc:	16 2f       	mov	r17, r22
    f6fe:	00 e0       	ldi	r16, 0x00	; 0
    f700:	06 c0       	rjmp	.+12     	; 0xf70e <vfscanf+0x86>
    f702:	f3 fc       	sbrc	r15, 3
    f704:	15 91       	lpm	r17, Z+
    f706:	f3 fe       	sbrs	r15, 3
    f708:	11 91       	ld	r17, Z+
    f70a:	5f 01       	movw	r10, r30
    f70c:	01 e0       	ldi	r16, 0x01	; 1
    f70e:	cc 24       	eor	r12, r12
    f710:	dd 24       	eor	r13, r13
    f712:	0e c0       	rjmp	.+28     	; 0xf730 <vfscanf+0xa8>
    f714:	02 60       	ori	r16, 0x02	; 2
    f716:	b6 01       	movw	r22, r12
    f718:	80 e0       	ldi	r24, 0x00	; 0
    f71a:	90 e0       	ldi	r25, 0x00	; 0
    f71c:	40 e2       	ldi	r20, 0x20	; 32
    f71e:	0e 94 49 78 	call	0xf092	; 0xf092 <mulacc>
    f722:	6b 01       	movw	r12, r22
    f724:	f5 01       	movw	r30, r10
    f726:	f3 fc       	sbrc	r15, 3
    f728:	15 91       	lpm	r17, Z+
    f72a:	f3 fe       	sbrs	r15, 3
    f72c:	11 91       	ld	r17, Z+
    f72e:	5f 01       	movw	r10, r30
    f730:	21 2f       	mov	r18, r17
    f732:	20 53       	subi	r18, 0x30	; 48
    f734:	2a 30       	cpi	r18, 0x0A	; 10
    f736:	70 f3       	brcs	.-36     	; 0xf714 <vfscanf+0x8c>
    f738:	01 fd       	sbrc	r16, 1
    f73a:	04 c0       	rjmp	.+8      	; 0xf744 <vfscanf+0xbc>
    f73c:	cc 24       	eor	r12, r12
    f73e:	ca 94       	dec	r12
    f740:	dc 2c       	mov	r13, r12
    f742:	04 c0       	rjmp	.+8      	; 0xf74c <vfscanf+0xc4>
    f744:	c1 14       	cp	r12, r1
    f746:	d1 04       	cpc	r13, r1
    f748:	09 f4       	brne	.+2      	; 0xf74c <vfscanf+0xc4>
    f74a:	ca c0       	rjmp	.+404    	; 0xf8e0 <vfscanf+0x258>
    f74c:	18 36       	cpi	r17, 0x68	; 104
    f74e:	21 f0       	breq	.+8      	; 0xf758 <vfscanf+0xd0>
    f750:	1c 36       	cpi	r17, 0x6C	; 108
    f752:	99 f4       	brne	.+38     	; 0xf77a <vfscanf+0xf2>
    f754:	f5 01       	movw	r30, r10
    f756:	0b c0       	rjmp	.+22     	; 0xf76e <vfscanf+0xe6>
    f758:	f5 01       	movw	r30, r10
    f75a:	f3 fc       	sbrc	r15, 3
    f75c:	65 91       	lpm	r22, Z+
    f75e:	f3 fe       	sbrs	r15, 3
    f760:	61 91       	ld	r22, Z+
    f762:	68 36       	cpi	r22, 0x68	; 104
    f764:	19 f0       	breq	.+6      	; 0xf76c <vfscanf+0xe4>
    f766:	5f 01       	movw	r10, r30
    f768:	16 2f       	mov	r17, r22
    f76a:	07 c0       	rjmp	.+14     	; 0xf77a <vfscanf+0xf2>
    f76c:	08 60       	ori	r16, 0x08	; 8
    f76e:	04 60       	ori	r16, 0x04	; 4
    f770:	f3 fc       	sbrc	r15, 3
    f772:	15 91       	lpm	r17, Z+
    f774:	f3 fe       	sbrs	r15, 3
    f776:	11 91       	ld	r17, Z+
    f778:	5f 01       	movw	r10, r30
    f77a:	11 23       	and	r17, r17
    f77c:	09 f4       	brne	.+2      	; 0xf780 <vfscanf+0xf8>
    f77e:	b0 c0       	rjmp	.+352    	; 0xf8e0 <vfscanf+0x258>
    f780:	81 ea       	ldi	r24, 0xA1	; 161
    f782:	9c e0       	ldi	r25, 0x0C	; 12
    f784:	61 2f       	mov	r22, r17
    f786:	70 e0       	ldi	r23, 0x00	; 0
    f788:	0e 94 37 82 	call	0x1046e	; 0x1046e <strchr_P>
    f78c:	89 2b       	or	r24, r25
    f78e:	09 f4       	brne	.+2      	; 0xf792 <vfscanf+0x10a>
    f790:	a7 c0       	rjmp	.+334    	; 0xf8e0 <vfscanf+0x258>
    f792:	80 2f       	mov	r24, r16
    f794:	00 ff       	sbrs	r16, 0
    f796:	03 c0       	rjmp	.+6      	; 0xf79e <vfscanf+0x116>
    f798:	ee 24       	eor	r14, r14
    f79a:	ff 24       	eor	r15, r15
    f79c:	07 c0       	rjmp	.+14     	; 0xf7ac <vfscanf+0x124>
    f79e:	f3 01       	movw	r30, r6
    f7a0:	e0 80       	ld	r14, Z
    f7a2:	f1 80       	ldd	r15, Z+1	; 0x01
    f7a4:	22 e0       	ldi	r18, 0x02	; 2
    f7a6:	30 e0       	ldi	r19, 0x00	; 0
    f7a8:	62 0e       	add	r6, r18
    f7aa:	73 1e       	adc	r7, r19
    f7ac:	1e 36       	cpi	r17, 0x6E	; 110
    f7ae:	51 f4       	brne	.+20     	; 0xf7c4 <vfscanf+0x13c>
    f7b0:	f4 01       	movw	r30, r8
    f7b2:	46 81       	ldd	r20, Z+6	; 0x06
    f7b4:	57 81       	ldd	r21, Z+7	; 0x07
    f7b6:	60 e0       	ldi	r22, 0x00	; 0
    f7b8:	70 e0       	ldi	r23, 0x00	; 0
    f7ba:	c7 01       	movw	r24, r14
    f7bc:	20 2f       	mov	r18, r16
    f7be:	0e 94 3d 78 	call	0xf07a	; 0xf07a <putval>
    f7c2:	7d c0       	rjmp	.+250    	; 0xf8be <vfscanf+0x236>
    f7c4:	13 36       	cpi	r17, 0x63	; 99
    f7c6:	b9 f4       	brne	.+46     	; 0xf7f6 <vfscanf+0x16e>
    f7c8:	81 fd       	sbrc	r24, 1
    f7ca:	03 c0       	rjmp	.+6      	; 0xf7d2 <vfscanf+0x14a>
    f7cc:	11 e0       	ldi	r17, 0x01	; 1
    f7ce:	c1 2e       	mov	r12, r17
    f7d0:	d1 2c       	mov	r13, r1
    f7d2:	c4 01       	movw	r24, r8
    f7d4:	0e 94 58 82 	call	0x104b0	; 0x104b0 <fgetc>
    f7d8:	97 fd       	sbrc	r25, 7
    f7da:	7d c0       	rjmp	.+250    	; 0xf8d6 <vfscanf+0x24e>
    f7dc:	e1 14       	cp	r14, r1
    f7de:	f1 04       	cpc	r15, r1
    f7e0:	19 f0       	breq	.+6      	; 0xf7e8 <vfscanf+0x160>
    f7e2:	f7 01       	movw	r30, r14
    f7e4:	81 93       	st	Z+, r24
    f7e6:	7f 01       	movw	r14, r30
    f7e8:	08 94       	sec
    f7ea:	c1 08       	sbc	r12, r1
    f7ec:	d1 08       	sbc	r13, r1
    f7ee:	c1 14       	cp	r12, r1
    f7f0:	d1 04       	cpc	r13, r1
    f7f2:	79 f7       	brne	.-34     	; 0xf7d2 <vfscanf+0x14a>
    f7f4:	62 c0       	rjmp	.+196    	; 0xf8ba <vfscanf+0x232>
    f7f6:	1b 35       	cpi	r17, 0x5B	; 91
    f7f8:	59 f4       	brne	.+22     	; 0xf810 <vfscanf+0x188>
    f7fa:	c4 01       	movw	r24, r8
    f7fc:	b6 01       	movw	r22, r12
    f7fe:	a7 01       	movw	r20, r14
    f800:	95 01       	movw	r18, r10
    f802:	0e 94 24 79 	call	0xf248	; 0xf248 <conv_brk>
    f806:	5c 01       	movw	r10, r24
    f808:	00 97       	sbiw	r24, 0x00	; 0
    f80a:	09 f0       	breq	.+2      	; 0xf80e <vfscanf+0x186>
    f80c:	56 c0       	rjmp	.+172    	; 0xf8ba <vfscanf+0x232>
    f80e:	50 c0       	rjmp	.+160    	; 0xf8b0 <vfscanf+0x228>
    f810:	c4 01       	movw	r24, r8
    f812:	0e 94 77 78 	call	0xf0ee	; 0xf0ee <skip_spaces>
    f816:	97 fd       	sbrc	r25, 7
    f818:	5e c0       	rjmp	.+188    	; 0xf8d6 <vfscanf+0x24e>
    f81a:	1f 36       	cpi	r17, 0x6F	; 111
    f81c:	d1 f1       	breq	.+116    	; 0xf892 <vfscanf+0x20a>
    f81e:	10 37       	cpi	r17, 0x70	; 112
    f820:	38 f4       	brcc	.+14     	; 0xf830 <vfscanf+0x1a8>
    f822:	14 36       	cpi	r17, 0x64	; 100
    f824:	a1 f1       	breq	.+104    	; 0xf88e <vfscanf+0x206>
    f826:	19 36       	cpi	r17, 0x69	; 105
    f828:	a9 f1       	breq	.+106    	; 0xf894 <vfscanf+0x20c>
    f82a:	18 35       	cpi	r17, 0x58	; 88
    f82c:	d1 f5       	brne	.+116    	; 0xf8a2 <vfscanf+0x21a>
    f82e:	2d c0       	rjmp	.+90     	; 0xf88a <vfscanf+0x202>
    f830:	13 37       	cpi	r17, 0x73	; 115
    f832:	51 f0       	breq	.+20     	; 0xf848 <vfscanf+0x1c0>
    f834:	14 37       	cpi	r17, 0x74	; 116
    f836:	18 f4       	brcc	.+6      	; 0xf83e <vfscanf+0x1b6>
    f838:	10 37       	cpi	r17, 0x70	; 112
    f83a:	99 f5       	brne	.+102    	; 0xf8a2 <vfscanf+0x21a>
    f83c:	26 c0       	rjmp	.+76     	; 0xf88a <vfscanf+0x202>
    f83e:	15 37       	cpi	r17, 0x75	; 117
    f840:	31 f1       	breq	.+76     	; 0xf88e <vfscanf+0x206>
    f842:	18 37       	cpi	r17, 0x78	; 120
    f844:	71 f5       	brne	.+92     	; 0xf8a2 <vfscanf+0x21a>
    f846:	21 c0       	rjmp	.+66     	; 0xf88a <vfscanf+0x202>
    f848:	c4 01       	movw	r24, r8
    f84a:	0e 94 58 82 	call	0x104b0	; 0x104b0 <fgetc>
    f84e:	ec 01       	movw	r28, r24
    f850:	97 fd       	sbrc	r25, 7
    f852:	15 c0       	rjmp	.+42     	; 0xf87e <vfscanf+0x1f6>
    f854:	0e 94 27 82 	call	0x1044e	; 0x1044e <isspace>
    f858:	89 2b       	or	r24, r25
    f85a:	29 f0       	breq	.+10     	; 0xf866 <vfscanf+0x1de>
    f85c:	ce 01       	movw	r24, r28
    f85e:	b4 01       	movw	r22, r8
    f860:	0e 94 e4 82 	call	0x105c8	; 0x105c8 <ungetc>
    f864:	0c c0       	rjmp	.+24     	; 0xf87e <vfscanf+0x1f6>
    f866:	e1 14       	cp	r14, r1
    f868:	f1 04       	cpc	r15, r1
    f86a:	19 f0       	breq	.+6      	; 0xf872 <vfscanf+0x1ea>
    f86c:	f7 01       	movw	r30, r14
    f86e:	c1 93       	st	Z+, r28
    f870:	7f 01       	movw	r14, r30
    f872:	08 94       	sec
    f874:	c1 08       	sbc	r12, r1
    f876:	d1 08       	sbc	r13, r1
    f878:	c1 14       	cp	r12, r1
    f87a:	d1 04       	cpc	r13, r1
    f87c:	29 f7       	brne	.-54     	; 0xf848 <vfscanf+0x1c0>
    f87e:	e1 14       	cp	r14, r1
    f880:	f1 04       	cpc	r15, r1
    f882:	d9 f0       	breq	.+54     	; 0xf8ba <vfscanf+0x232>
    f884:	f7 01       	movw	r30, r14
    f886:	10 82       	st	Z, r1
    f888:	18 c0       	rjmp	.+48     	; 0xf8ba <vfscanf+0x232>
    f88a:	00 64       	ori	r16, 0x40	; 64
    f88c:	03 c0       	rjmp	.+6      	; 0xf894 <vfscanf+0x20c>
    f88e:	00 62       	ori	r16, 0x20	; 32
    f890:	01 c0       	rjmp	.+2      	; 0xf894 <vfscanf+0x20c>
    f892:	00 61       	ori	r16, 0x10	; 16
    f894:	c4 01       	movw	r24, r8
    f896:	b6 01       	movw	r22, r12
    f898:	a7 01       	movw	r20, r14
    f89a:	20 2f       	mov	r18, r16
    f89c:	0e 94 90 78 	call	0xf120	; 0xf120 <conv_int>
    f8a0:	05 c0       	rjmp	.+10     	; 0xf8ac <vfscanf+0x224>
    f8a2:	c4 01       	movw	r24, r8
    f8a4:	b6 01       	movw	r22, r12
    f8a6:	a7 01       	movw	r20, r14
    f8a8:	0e 94 f1 79 	call	0xf3e2	; 0xf3e2 <conv_flt>
    f8ac:	88 23       	and	r24, r24
    f8ae:	29 f4       	brne	.+10     	; 0xf8ba <vfscanf+0x232>
    f8b0:	f4 01       	movw	r30, r8
    f8b2:	83 81       	ldd	r24, Z+3	; 0x03
    f8b4:	80 73       	andi	r24, 0x30	; 48
    f8b6:	79 f4       	brne	.+30     	; 0xf8d6 <vfscanf+0x24e>
    f8b8:	13 c0       	rjmp	.+38     	; 0xf8e0 <vfscanf+0x258>
    f8ba:	00 ff       	sbrs	r16, 0
    f8bc:	53 94       	inc	r5
    f8be:	f4 01       	movw	r30, r8
    f8c0:	f3 80       	ldd	r15, Z+3	; 0x03
    f8c2:	f5 01       	movw	r30, r10
    f8c4:	f3 fc       	sbrc	r15, 3
    f8c6:	15 91       	lpm	r17, Z+
    f8c8:	f3 fe       	sbrs	r15, 3
    f8ca:	11 91       	ld	r17, Z+
    f8cc:	5f 01       	movw	r10, r30
    f8ce:	11 23       	and	r17, r17
    f8d0:	09 f0       	breq	.+2      	; 0xf8d4 <vfscanf+0x24c>
    f8d2:	f1 ce       	rjmp	.-542    	; 0xf6b6 <vfscanf+0x2e>
    f8d4:	05 c0       	rjmp	.+10     	; 0xf8e0 <vfscanf+0x258>
    f8d6:	55 20       	and	r5, r5
    f8d8:	19 f4       	brne	.+6      	; 0xf8e0 <vfscanf+0x258>
    f8da:	2f ef       	ldi	r18, 0xFF	; 255
    f8dc:	3f ef       	ldi	r19, 0xFF	; 255
    f8de:	02 c0       	rjmp	.+4      	; 0xf8e4 <vfscanf+0x25c>
    f8e0:	25 2d       	mov	r18, r5
    f8e2:	30 e0       	ldi	r19, 0x00	; 0
    f8e4:	c9 01       	movw	r24, r18
    f8e6:	df 91       	pop	r29
    f8e8:	cf 91       	pop	r28
    f8ea:	1f 91       	pop	r17
    f8ec:	0f 91       	pop	r16
    f8ee:	ff 90       	pop	r15
    f8f0:	ef 90       	pop	r14
    f8f2:	df 90       	pop	r13
    f8f4:	cf 90       	pop	r12
    f8f6:	bf 90       	pop	r11
    f8f8:	af 90       	pop	r10
    f8fa:	9f 90       	pop	r9
    f8fc:	8f 90       	pop	r8
    f8fe:	7f 90       	pop	r7
    f900:	6f 90       	pop	r6
    f902:	5f 90       	pop	r5
    f904:	08 95       	ret

0000f906 <__subsf3>:
    f906:	50 58       	subi	r21, 0x80	; 128

0000f908 <__addsf3>:
    f908:	bb 27       	eor	r27, r27
    f90a:	aa 27       	eor	r26, r26
    f90c:	0e d0       	rcall	.+28     	; 0xf92a <__addsf3x>
    f90e:	35 c2       	rjmp	.+1130   	; 0xfd7a <__fp_round>
    f910:	26 d2       	rcall	.+1100   	; 0xfd5e <__fp_pscA>
    f912:	30 f0       	brcs	.+12     	; 0xf920 <__addsf3+0x18>
    f914:	2b d2       	rcall	.+1110   	; 0xfd6c <__fp_pscB>
    f916:	20 f0       	brcs	.+8      	; 0xf920 <__addsf3+0x18>
    f918:	31 f4       	brne	.+12     	; 0xf926 <__addsf3+0x1e>
    f91a:	9f 3f       	cpi	r25, 0xFF	; 255
    f91c:	11 f4       	brne	.+4      	; 0xf922 <__addsf3+0x1a>
    f91e:	1e f4       	brtc	.+6      	; 0xf926 <__addsf3+0x1e>
    f920:	f6 c1       	rjmp	.+1004   	; 0xfd0e <__fp_nan>
    f922:	0e f4       	brtc	.+2      	; 0xf926 <__addsf3+0x1e>
    f924:	e0 95       	com	r30
    f926:	e7 fb       	bst	r30, 7
    f928:	ec c1       	rjmp	.+984    	; 0xfd02 <__fp_inf>

0000f92a <__addsf3x>:
    f92a:	e9 2f       	mov	r30, r25
    f92c:	37 d2       	rcall	.+1134   	; 0xfd9c <__fp_split3>
    f92e:	80 f3       	brcs	.-32     	; 0xf910 <__addsf3+0x8>
    f930:	ba 17       	cp	r27, r26
    f932:	62 07       	cpc	r22, r18
    f934:	73 07       	cpc	r23, r19
    f936:	84 07       	cpc	r24, r20
    f938:	95 07       	cpc	r25, r21
    f93a:	18 f0       	brcs	.+6      	; 0xf942 <__addsf3x+0x18>
    f93c:	71 f4       	brne	.+28     	; 0xf95a <__addsf3x+0x30>
    f93e:	9e f5       	brtc	.+102    	; 0xf9a6 <__addsf3x+0x7c>
    f940:	4f c2       	rjmp	.+1182   	; 0xfde0 <__fp_zero>
    f942:	0e f4       	brtc	.+2      	; 0xf946 <__addsf3x+0x1c>
    f944:	e0 95       	com	r30
    f946:	0b 2e       	mov	r0, r27
    f948:	ba 2f       	mov	r27, r26
    f94a:	a0 2d       	mov	r26, r0
    f94c:	0b 01       	movw	r0, r22
    f94e:	b9 01       	movw	r22, r18
    f950:	90 01       	movw	r18, r0
    f952:	0c 01       	movw	r0, r24
    f954:	ca 01       	movw	r24, r20
    f956:	a0 01       	movw	r20, r0
    f958:	11 24       	eor	r1, r1
    f95a:	ff 27       	eor	r31, r31
    f95c:	59 1b       	sub	r21, r25
    f95e:	99 f0       	breq	.+38     	; 0xf986 <__addsf3x+0x5c>
    f960:	59 3f       	cpi	r21, 0xF9	; 249
    f962:	50 f4       	brcc	.+20     	; 0xf978 <__addsf3x+0x4e>
    f964:	50 3e       	cpi	r21, 0xE0	; 224
    f966:	68 f1       	brcs	.+90     	; 0xf9c2 <__addsf3x+0x98>
    f968:	1a 16       	cp	r1, r26
    f96a:	f0 40       	sbci	r31, 0x00	; 0
    f96c:	a2 2f       	mov	r26, r18
    f96e:	23 2f       	mov	r18, r19
    f970:	34 2f       	mov	r19, r20
    f972:	44 27       	eor	r20, r20
    f974:	58 5f       	subi	r21, 0xF8	; 248
    f976:	f3 cf       	rjmp	.-26     	; 0xf95e <__addsf3x+0x34>
    f978:	46 95       	lsr	r20
    f97a:	37 95       	ror	r19
    f97c:	27 95       	ror	r18
    f97e:	a7 95       	ror	r26
    f980:	f0 40       	sbci	r31, 0x00	; 0
    f982:	53 95       	inc	r21
    f984:	c9 f7       	brne	.-14     	; 0xf978 <__addsf3x+0x4e>
    f986:	7e f4       	brtc	.+30     	; 0xf9a6 <__addsf3x+0x7c>
    f988:	1f 16       	cp	r1, r31
    f98a:	ba 0b       	sbc	r27, r26
    f98c:	62 0b       	sbc	r22, r18
    f98e:	73 0b       	sbc	r23, r19
    f990:	84 0b       	sbc	r24, r20
    f992:	ba f0       	brmi	.+46     	; 0xf9c2 <__addsf3x+0x98>
    f994:	91 50       	subi	r25, 0x01	; 1
    f996:	a1 f0       	breq	.+40     	; 0xf9c0 <__addsf3x+0x96>
    f998:	ff 0f       	add	r31, r31
    f99a:	bb 1f       	adc	r27, r27
    f99c:	66 1f       	adc	r22, r22
    f99e:	77 1f       	adc	r23, r23
    f9a0:	88 1f       	adc	r24, r24
    f9a2:	c2 f7       	brpl	.-16     	; 0xf994 <__addsf3x+0x6a>
    f9a4:	0e c0       	rjmp	.+28     	; 0xf9c2 <__addsf3x+0x98>
    f9a6:	ba 0f       	add	r27, r26
    f9a8:	62 1f       	adc	r22, r18
    f9aa:	73 1f       	adc	r23, r19
    f9ac:	84 1f       	adc	r24, r20
    f9ae:	48 f4       	brcc	.+18     	; 0xf9c2 <__addsf3x+0x98>
    f9b0:	87 95       	ror	r24
    f9b2:	77 95       	ror	r23
    f9b4:	67 95       	ror	r22
    f9b6:	b7 95       	ror	r27
    f9b8:	f7 95       	ror	r31
    f9ba:	9e 3f       	cpi	r25, 0xFE	; 254
    f9bc:	08 f0       	brcs	.+2      	; 0xf9c0 <__addsf3x+0x96>
    f9be:	b3 cf       	rjmp	.-154    	; 0xf926 <__addsf3+0x1e>
    f9c0:	93 95       	inc	r25
    f9c2:	88 0f       	add	r24, r24
    f9c4:	08 f0       	brcs	.+2      	; 0xf9c8 <__addsf3x+0x9e>
    f9c6:	99 27       	eor	r25, r25
    f9c8:	ee 0f       	add	r30, r30
    f9ca:	97 95       	ror	r25
    f9cc:	87 95       	ror	r24
    f9ce:	08 95       	ret
    f9d0:	c6 d1       	rcall	.+908    	; 0xfd5e <__fp_pscA>
    f9d2:	58 f0       	brcs	.+22     	; 0xf9ea <__addsf3x+0xc0>
    f9d4:	80 e8       	ldi	r24, 0x80	; 128
    f9d6:	91 e0       	ldi	r25, 0x01	; 1
    f9d8:	09 f4       	brne	.+2      	; 0xf9dc <__addsf3x+0xb2>
    f9da:	9e ef       	ldi	r25, 0xFE	; 254
    f9dc:	c7 d1       	rcall	.+910    	; 0xfd6c <__fp_pscB>
    f9de:	28 f0       	brcs	.+10     	; 0xf9ea <__addsf3x+0xc0>
    f9e0:	40 e8       	ldi	r20, 0x80	; 128
    f9e2:	51 e0       	ldi	r21, 0x01	; 1
    f9e4:	59 f4       	brne	.+22     	; 0xf9fc <atan2+0xe>
    f9e6:	5e ef       	ldi	r21, 0xFE	; 254
    f9e8:	09 c0       	rjmp	.+18     	; 0xf9fc <atan2+0xe>
    f9ea:	91 c1       	rjmp	.+802    	; 0xfd0e <__fp_nan>
    f9ec:	f9 c1       	rjmp	.+1010   	; 0xfde0 <__fp_zero>

0000f9ee <atan2>:
    f9ee:	e9 2f       	mov	r30, r25
    f9f0:	e0 78       	andi	r30, 0x80	; 128
    f9f2:	d4 d1       	rcall	.+936    	; 0xfd9c <__fp_split3>
    f9f4:	68 f3       	brcs	.-38     	; 0xf9d0 <__addsf3x+0xa6>
    f9f6:	09 2e       	mov	r0, r25
    f9f8:	05 2a       	or	r0, r21
    f9fa:	c1 f3       	breq	.-16     	; 0xf9ec <__addsf3x+0xc2>
    f9fc:	26 17       	cp	r18, r22
    f9fe:	37 07       	cpc	r19, r23
    fa00:	48 07       	cpc	r20, r24
    fa02:	59 07       	cpc	r21, r25
    fa04:	38 f0       	brcs	.+14     	; 0xfa14 <atan2+0x26>
    fa06:	0e 2e       	mov	r0, r30
    fa08:	07 f8       	bld	r0, 7
    fa0a:	e0 25       	eor	r30, r0
    fa0c:	69 f0       	breq	.+26     	; 0xfa28 <atan2+0x3a>
    fa0e:	e0 25       	eor	r30, r0
    fa10:	e0 64       	ori	r30, 0x40	; 64
    fa12:	0a c0       	rjmp	.+20     	; 0xfa28 <atan2+0x3a>
    fa14:	ef 63       	ori	r30, 0x3F	; 63
    fa16:	07 f8       	bld	r0, 7
    fa18:	00 94       	com	r0
    fa1a:	07 fa       	bst	r0, 7
    fa1c:	db 01       	movw	r26, r22
    fa1e:	b9 01       	movw	r22, r18
    fa20:	9d 01       	movw	r18, r26
    fa22:	dc 01       	movw	r26, r24
    fa24:	ca 01       	movw	r24, r20
    fa26:	ad 01       	movw	r20, r26
    fa28:	ef 93       	push	r30
    fa2a:	47 d0       	rcall	.+142    	; 0xfaba <__divsf3_pse>
    fa2c:	a6 d1       	rcall	.+844    	; 0xfd7a <__fp_round>
    fa2e:	0a d0       	rcall	.+20     	; 0xfa44 <atan>
    fa30:	5f 91       	pop	r21
    fa32:	55 23       	and	r21, r21
    fa34:	31 f0       	breq	.+12     	; 0xfa42 <atan2+0x54>
    fa36:	2b ed       	ldi	r18, 0xDB	; 219
    fa38:	3f e0       	ldi	r19, 0x0F	; 15
    fa3a:	49 e4       	ldi	r20, 0x49	; 73
    fa3c:	50 fd       	sbrc	r21, 0
    fa3e:	49 ec       	ldi	r20, 0xC9	; 201
    fa40:	63 cf       	rjmp	.-314    	; 0xf908 <__addsf3>
    fa42:	08 95       	ret

0000fa44 <atan>:
    fa44:	df 93       	push	r29
    fa46:	dd 27       	eor	r29, r29
    fa48:	b9 2f       	mov	r27, r25
    fa4a:	bf 77       	andi	r27, 0x7F	; 127
    fa4c:	40 e8       	ldi	r20, 0x80	; 128
    fa4e:	5f e3       	ldi	r21, 0x3F	; 63
    fa50:	16 16       	cp	r1, r22
    fa52:	17 06       	cpc	r1, r23
    fa54:	48 07       	cpc	r20, r24
    fa56:	5b 07       	cpc	r21, r27
    fa58:	10 f4       	brcc	.+4      	; 0xfa5e <atan+0x1a>
    fa5a:	d9 2f       	mov	r29, r25
    fa5c:	c8 d1       	rcall	.+912    	; 0xfdee <inverse>
    fa5e:	9f 93       	push	r25
    fa60:	8f 93       	push	r24
    fa62:	7f 93       	push	r23
    fa64:	6f 93       	push	r22
    fa66:	6f d2       	rcall	.+1246   	; 0xff46 <square>
    fa68:	ec e8       	ldi	r30, 0x8C	; 140
    fa6a:	f0 e0       	ldi	r31, 0x00	; 0
    fa6c:	53 d1       	rcall	.+678    	; 0xfd14 <__fp_powser>
    fa6e:	85 d1       	rcall	.+778    	; 0xfd7a <__fp_round>
    fa70:	2f 91       	pop	r18
    fa72:	3f 91       	pop	r19
    fa74:	4f 91       	pop	r20
    fa76:	5f 91       	pop	r21
    fa78:	cd d1       	rcall	.+922    	; 0xfe14 <__mulsf3x>
    fa7a:	dd 23       	and	r29, r29
    fa7c:	49 f0       	breq	.+18     	; 0xfa90 <atan+0x4c>
    fa7e:	90 58       	subi	r25, 0x80	; 128
    fa80:	a2 ea       	ldi	r26, 0xA2	; 162
    fa82:	2a ed       	ldi	r18, 0xDA	; 218
    fa84:	3f e0       	ldi	r19, 0x0F	; 15
    fa86:	49 ec       	ldi	r20, 0xC9	; 201
    fa88:	5f e3       	ldi	r21, 0x3F	; 63
    fa8a:	d0 78       	andi	r29, 0x80	; 128
    fa8c:	5d 27       	eor	r21, r29
    fa8e:	4d df       	rcall	.-358    	; 0xf92a <__addsf3x>
    fa90:	df 91       	pop	r29
    fa92:	73 c1       	rjmp	.+742    	; 0xfd7a <__fp_round>

0000fa94 <__cmpsf2>:
    fa94:	12 d1       	rcall	.+548    	; 0xfcba <__fp_cmp>
    fa96:	08 f4       	brcc	.+2      	; 0xfa9a <__cmpsf2+0x6>
    fa98:	81 e0       	ldi	r24, 0x01	; 1
    fa9a:	08 95       	ret

0000fa9c <__divsf3>:
    fa9c:	0c d0       	rcall	.+24     	; 0xfab6 <__divsf3x>
    fa9e:	6d c1       	rjmp	.+730    	; 0xfd7a <__fp_round>
    faa0:	65 d1       	rcall	.+714    	; 0xfd6c <__fp_pscB>
    faa2:	40 f0       	brcs	.+16     	; 0xfab4 <__divsf3+0x18>
    faa4:	5c d1       	rcall	.+696    	; 0xfd5e <__fp_pscA>
    faa6:	30 f0       	brcs	.+12     	; 0xfab4 <__divsf3+0x18>
    faa8:	21 f4       	brne	.+8      	; 0xfab2 <__divsf3+0x16>
    faaa:	5f 3f       	cpi	r21, 0xFF	; 255
    faac:	19 f0       	breq	.+6      	; 0xfab4 <__divsf3+0x18>
    faae:	29 c1       	rjmp	.+594    	; 0xfd02 <__fp_inf>
    fab0:	51 11       	cpse	r21, r1
    fab2:	97 c1       	rjmp	.+814    	; 0xfde2 <__fp_szero>
    fab4:	2c c1       	rjmp	.+600    	; 0xfd0e <__fp_nan>

0000fab6 <__divsf3x>:
    fab6:	72 d1       	rcall	.+740    	; 0xfd9c <__fp_split3>
    fab8:	98 f3       	brcs	.-26     	; 0xfaa0 <__divsf3+0x4>

0000faba <__divsf3_pse>:
    faba:	99 23       	and	r25, r25
    fabc:	c9 f3       	breq	.-14     	; 0xfab0 <__divsf3+0x14>
    fabe:	55 23       	and	r21, r21
    fac0:	b1 f3       	breq	.-20     	; 0xfaae <__divsf3+0x12>
    fac2:	95 1b       	sub	r25, r21
    fac4:	55 0b       	sbc	r21, r21
    fac6:	bb 27       	eor	r27, r27
    fac8:	aa 27       	eor	r26, r26
    faca:	62 17       	cp	r22, r18
    facc:	73 07       	cpc	r23, r19
    face:	84 07       	cpc	r24, r20
    fad0:	38 f0       	brcs	.+14     	; 0xfae0 <__divsf3_pse+0x26>
    fad2:	9f 5f       	subi	r25, 0xFF	; 255
    fad4:	5f 4f       	sbci	r21, 0xFF	; 255
    fad6:	22 0f       	add	r18, r18
    fad8:	33 1f       	adc	r19, r19
    fada:	44 1f       	adc	r20, r20
    fadc:	aa 1f       	adc	r26, r26
    fade:	a9 f3       	breq	.-22     	; 0xfaca <__divsf3_pse+0x10>
    fae0:	33 d0       	rcall	.+102    	; 0xfb48 <__divsf3_pse+0x8e>
    fae2:	0e 2e       	mov	r0, r30
    fae4:	3a f0       	brmi	.+14     	; 0xfaf4 <__divsf3_pse+0x3a>
    fae6:	e0 e8       	ldi	r30, 0x80	; 128
    fae8:	30 d0       	rcall	.+96     	; 0xfb4a <__divsf3_pse+0x90>
    faea:	91 50       	subi	r25, 0x01	; 1
    faec:	50 40       	sbci	r21, 0x00	; 0
    faee:	e6 95       	lsr	r30
    faf0:	00 1c       	adc	r0, r0
    faf2:	ca f7       	brpl	.-14     	; 0xfae6 <__divsf3_pse+0x2c>
    faf4:	29 d0       	rcall	.+82     	; 0xfb48 <__divsf3_pse+0x8e>
    faf6:	fe 2f       	mov	r31, r30
    faf8:	27 d0       	rcall	.+78     	; 0xfb48 <__divsf3_pse+0x8e>
    fafa:	66 0f       	add	r22, r22
    fafc:	77 1f       	adc	r23, r23
    fafe:	88 1f       	adc	r24, r24
    fb00:	bb 1f       	adc	r27, r27
    fb02:	26 17       	cp	r18, r22
    fb04:	37 07       	cpc	r19, r23
    fb06:	48 07       	cpc	r20, r24
    fb08:	ab 07       	cpc	r26, r27
    fb0a:	b0 e8       	ldi	r27, 0x80	; 128
    fb0c:	09 f0       	breq	.+2      	; 0xfb10 <__divsf3_pse+0x56>
    fb0e:	bb 0b       	sbc	r27, r27
    fb10:	80 2d       	mov	r24, r0
    fb12:	bf 01       	movw	r22, r30
    fb14:	ff 27       	eor	r31, r31
    fb16:	93 58       	subi	r25, 0x83	; 131
    fb18:	5f 4f       	sbci	r21, 0xFF	; 255
    fb1a:	2a f0       	brmi	.+10     	; 0xfb26 <__divsf3_pse+0x6c>
    fb1c:	9e 3f       	cpi	r25, 0xFE	; 254
    fb1e:	51 05       	cpc	r21, r1
    fb20:	68 f0       	brcs	.+26     	; 0xfb3c <__divsf3_pse+0x82>
    fb22:	ef c0       	rjmp	.+478    	; 0xfd02 <__fp_inf>
    fb24:	5e c1       	rjmp	.+700    	; 0xfde2 <__fp_szero>
    fb26:	5f 3f       	cpi	r21, 0xFF	; 255
    fb28:	ec f3       	brlt	.-6      	; 0xfb24 <__divsf3_pse+0x6a>
    fb2a:	98 3e       	cpi	r25, 0xE8	; 232
    fb2c:	dc f3       	brlt	.-10     	; 0xfb24 <__divsf3_pse+0x6a>
    fb2e:	86 95       	lsr	r24
    fb30:	77 95       	ror	r23
    fb32:	67 95       	ror	r22
    fb34:	b7 95       	ror	r27
    fb36:	f7 95       	ror	r31
    fb38:	9f 5f       	subi	r25, 0xFF	; 255
    fb3a:	c9 f7       	brne	.-14     	; 0xfb2e <__divsf3_pse+0x74>
    fb3c:	88 0f       	add	r24, r24
    fb3e:	91 1d       	adc	r25, r1
    fb40:	96 95       	lsr	r25
    fb42:	87 95       	ror	r24
    fb44:	97 f9       	bld	r25, 7
    fb46:	08 95       	ret
    fb48:	e1 e0       	ldi	r30, 0x01	; 1
    fb4a:	66 0f       	add	r22, r22
    fb4c:	77 1f       	adc	r23, r23
    fb4e:	88 1f       	adc	r24, r24
    fb50:	bb 1f       	adc	r27, r27
    fb52:	62 17       	cp	r22, r18
    fb54:	73 07       	cpc	r23, r19
    fb56:	84 07       	cpc	r24, r20
    fb58:	ba 07       	cpc	r27, r26
    fb5a:	20 f0       	brcs	.+8      	; 0xfb64 <__divsf3_pse+0xaa>
    fb5c:	62 1b       	sub	r22, r18
    fb5e:	73 0b       	sbc	r23, r19
    fb60:	84 0b       	sbc	r24, r20
    fb62:	ba 0b       	sbc	r27, r26
    fb64:	ee 1f       	adc	r30, r30
    fb66:	88 f7       	brcc	.-30     	; 0xfb4a <__divsf3_pse+0x90>
    fb68:	e0 95       	com	r30
    fb6a:	08 95       	ret

0000fb6c <__fixunssfsi>:
    fb6c:	1f d1       	rcall	.+574    	; 0xfdac <__fp_splitA>
    fb6e:	88 f0       	brcs	.+34     	; 0xfb92 <__fixunssfsi+0x26>
    fb70:	9f 57       	subi	r25, 0x7F	; 127
    fb72:	90 f0       	brcs	.+36     	; 0xfb98 <__fixunssfsi+0x2c>
    fb74:	b9 2f       	mov	r27, r25
    fb76:	99 27       	eor	r25, r25
    fb78:	b7 51       	subi	r27, 0x17	; 23
    fb7a:	a0 f0       	brcs	.+40     	; 0xfba4 <__fixunssfsi+0x38>
    fb7c:	d1 f0       	breq	.+52     	; 0xfbb2 <__fixunssfsi+0x46>
    fb7e:	66 0f       	add	r22, r22
    fb80:	77 1f       	adc	r23, r23
    fb82:	88 1f       	adc	r24, r24
    fb84:	99 1f       	adc	r25, r25
    fb86:	1a f0       	brmi	.+6      	; 0xfb8e <__fixunssfsi+0x22>
    fb88:	ba 95       	dec	r27
    fb8a:	c9 f7       	brne	.-14     	; 0xfb7e <__fixunssfsi+0x12>
    fb8c:	12 c0       	rjmp	.+36     	; 0xfbb2 <__fixunssfsi+0x46>
    fb8e:	b1 30       	cpi	r27, 0x01	; 1
    fb90:	81 f0       	breq	.+32     	; 0xfbb2 <__fixunssfsi+0x46>
    fb92:	26 d1       	rcall	.+588    	; 0xfde0 <__fp_zero>
    fb94:	b1 e0       	ldi	r27, 0x01	; 1
    fb96:	08 95       	ret
    fb98:	23 c1       	rjmp	.+582    	; 0xfde0 <__fp_zero>
    fb9a:	67 2f       	mov	r22, r23
    fb9c:	78 2f       	mov	r23, r24
    fb9e:	88 27       	eor	r24, r24
    fba0:	b8 5f       	subi	r27, 0xF8	; 248
    fba2:	39 f0       	breq	.+14     	; 0xfbb2 <__fixunssfsi+0x46>
    fba4:	b9 3f       	cpi	r27, 0xF9	; 249
    fba6:	cc f3       	brlt	.-14     	; 0xfb9a <__fixunssfsi+0x2e>
    fba8:	86 95       	lsr	r24
    fbaa:	77 95       	ror	r23
    fbac:	67 95       	ror	r22
    fbae:	b3 95       	inc	r27
    fbb0:	d9 f7       	brne	.-10     	; 0xfba8 <__fixunssfsi+0x3c>
    fbb2:	3e f4       	brtc	.+14     	; 0xfbc2 <__fixunssfsi+0x56>
    fbb4:	90 95       	com	r25
    fbb6:	80 95       	com	r24
    fbb8:	70 95       	com	r23
    fbba:	61 95       	neg	r22
    fbbc:	7f 4f       	sbci	r23, 0xFF	; 255
    fbbe:	8f 4f       	sbci	r24, 0xFF	; 255
    fbc0:	9f 4f       	sbci	r25, 0xFF	; 255
    fbc2:	08 95       	ret

0000fbc4 <__floatunsisf>:
    fbc4:	e8 94       	clt
    fbc6:	09 c0       	rjmp	.+18     	; 0xfbda <__floatsisf+0x12>

0000fbc8 <__floatsisf>:
    fbc8:	97 fb       	bst	r25, 7
    fbca:	3e f4       	brtc	.+14     	; 0xfbda <__floatsisf+0x12>
    fbcc:	90 95       	com	r25
    fbce:	80 95       	com	r24
    fbd0:	70 95       	com	r23
    fbd2:	61 95       	neg	r22
    fbd4:	7f 4f       	sbci	r23, 0xFF	; 255
    fbd6:	8f 4f       	sbci	r24, 0xFF	; 255
    fbd8:	9f 4f       	sbci	r25, 0xFF	; 255
    fbda:	99 23       	and	r25, r25
    fbdc:	a9 f0       	breq	.+42     	; 0xfc08 <__floatsisf+0x40>
    fbde:	f9 2f       	mov	r31, r25
    fbe0:	96 e9       	ldi	r25, 0x96	; 150
    fbe2:	bb 27       	eor	r27, r27
    fbe4:	93 95       	inc	r25
    fbe6:	f6 95       	lsr	r31
    fbe8:	87 95       	ror	r24
    fbea:	77 95       	ror	r23
    fbec:	67 95       	ror	r22
    fbee:	b7 95       	ror	r27
    fbf0:	f1 11       	cpse	r31, r1
    fbf2:	f8 cf       	rjmp	.-16     	; 0xfbe4 <__floatsisf+0x1c>
    fbf4:	fa f4       	brpl	.+62     	; 0xfc34 <__floatsisf+0x6c>
    fbf6:	bb 0f       	add	r27, r27
    fbf8:	11 f4       	brne	.+4      	; 0xfbfe <__floatsisf+0x36>
    fbfa:	60 ff       	sbrs	r22, 0
    fbfc:	1b c0       	rjmp	.+54     	; 0xfc34 <__floatsisf+0x6c>
    fbfe:	6f 5f       	subi	r22, 0xFF	; 255
    fc00:	7f 4f       	sbci	r23, 0xFF	; 255
    fc02:	8f 4f       	sbci	r24, 0xFF	; 255
    fc04:	9f 4f       	sbci	r25, 0xFF	; 255
    fc06:	16 c0       	rjmp	.+44     	; 0xfc34 <__floatsisf+0x6c>
    fc08:	88 23       	and	r24, r24
    fc0a:	11 f0       	breq	.+4      	; 0xfc10 <__floatsisf+0x48>
    fc0c:	96 e9       	ldi	r25, 0x96	; 150
    fc0e:	11 c0       	rjmp	.+34     	; 0xfc32 <__floatsisf+0x6a>
    fc10:	77 23       	and	r23, r23
    fc12:	21 f0       	breq	.+8      	; 0xfc1c <__floatsisf+0x54>
    fc14:	9e e8       	ldi	r25, 0x8E	; 142
    fc16:	87 2f       	mov	r24, r23
    fc18:	76 2f       	mov	r23, r22
    fc1a:	05 c0       	rjmp	.+10     	; 0xfc26 <__floatsisf+0x5e>
    fc1c:	66 23       	and	r22, r22
    fc1e:	71 f0       	breq	.+28     	; 0xfc3c <__floatsisf+0x74>
    fc20:	96 e8       	ldi	r25, 0x86	; 134
    fc22:	86 2f       	mov	r24, r22
    fc24:	70 e0       	ldi	r23, 0x00	; 0
    fc26:	60 e0       	ldi	r22, 0x00	; 0
    fc28:	2a f0       	brmi	.+10     	; 0xfc34 <__floatsisf+0x6c>
    fc2a:	9a 95       	dec	r25
    fc2c:	66 0f       	add	r22, r22
    fc2e:	77 1f       	adc	r23, r23
    fc30:	88 1f       	adc	r24, r24
    fc32:	da f7       	brpl	.-10     	; 0xfc2a <__floatsisf+0x62>
    fc34:	88 0f       	add	r24, r24
    fc36:	96 95       	lsr	r25
    fc38:	87 95       	ror	r24
    fc3a:	97 f9       	bld	r25, 7
    fc3c:	08 95       	ret

0000fc3e <fmax>:
    fc3e:	99 0f       	add	r25, r25
    fc40:	bb 0b       	sbc	r27, r27
    fc42:	55 0f       	add	r21, r21
    fc44:	aa 0b       	sbc	r26, r26
    fc46:	e0 e8       	ldi	r30, 0x80	; 128
    fc48:	fe ef       	ldi	r31, 0xFE	; 254
    fc4a:	16 16       	cp	r1, r22
    fc4c:	17 06       	cpc	r1, r23
    fc4e:	e8 07       	cpc	r30, r24
    fc50:	f9 07       	cpc	r31, r25
    fc52:	70 f0       	brcs	.+28     	; 0xfc70 <fmax+0x32>
    fc54:	12 16       	cp	r1, r18
    fc56:	13 06       	cpc	r1, r19
    fc58:	e4 07       	cpc	r30, r20
    fc5a:	f5 07       	cpc	r31, r21
    fc5c:	60 f0       	brcs	.+24     	; 0xfc76 <fmax+0x38>
    fc5e:	ba 17       	cp	r27, r26
    fc60:	3c f0       	brlt	.+14     	; 0xfc70 <fmax+0x32>
    fc62:	49 f4       	brne	.+18     	; 0xfc76 <fmax+0x38>
    fc64:	62 17       	cp	r22, r18
    fc66:	73 07       	cpc	r23, r19
    fc68:	84 07       	cpc	r24, r20
    fc6a:	95 07       	cpc	r25, r21
    fc6c:	a7 95       	ror	r26
    fc6e:	1b f4       	brvc	.+6      	; 0xfc76 <fmax+0x38>
    fc70:	b9 01       	movw	r22, r18
    fc72:	ca 01       	movw	r24, r20
    fc74:	ba 2f       	mov	r27, r26
    fc76:	b6 95       	lsr	r27
    fc78:	97 95       	ror	r25
    fc7a:	08 95       	ret

0000fc7c <fmin>:
    fc7c:	99 0f       	add	r25, r25
    fc7e:	bb 0b       	sbc	r27, r27
    fc80:	55 0f       	add	r21, r21
    fc82:	aa 0b       	sbc	r26, r26
    fc84:	e0 e8       	ldi	r30, 0x80	; 128
    fc86:	fe ef       	ldi	r31, 0xFE	; 254
    fc88:	16 16       	cp	r1, r22
    fc8a:	17 06       	cpc	r1, r23
    fc8c:	e8 07       	cpc	r30, r24
    fc8e:	f9 07       	cpc	r31, r25
    fc90:	70 f0       	brcs	.+28     	; 0xfcae <fmin+0x32>
    fc92:	12 16       	cp	r1, r18
    fc94:	13 06       	cpc	r1, r19
    fc96:	e4 07       	cpc	r30, r20
    fc98:	f5 07       	cpc	r31, r21
    fc9a:	60 f0       	brcs	.+24     	; 0xfcb4 <fmin+0x38>
    fc9c:	ba 17       	cp	r27, r26
    fc9e:	54 f0       	brlt	.+20     	; 0xfcb4 <fmin+0x38>
    fca0:	31 f4       	brne	.+12     	; 0xfcae <fmin+0x32>
    fca2:	26 17       	cp	r18, r22
    fca4:	37 07       	cpc	r19, r23
    fca6:	48 07       	cpc	r20, r24
    fca8:	59 07       	cpc	r21, r25
    fcaa:	a7 95       	ror	r26
    fcac:	1b f4       	brvc	.+6      	; 0xfcb4 <fmin+0x38>
    fcae:	b9 01       	movw	r22, r18
    fcb0:	ca 01       	movw	r24, r20
    fcb2:	ba 2f       	mov	r27, r26
    fcb4:	b6 95       	lsr	r27
    fcb6:	97 95       	ror	r25
    fcb8:	08 95       	ret

0000fcba <__fp_cmp>:
    fcba:	99 0f       	add	r25, r25
    fcbc:	00 08       	sbc	r0, r0
    fcbe:	55 0f       	add	r21, r21
    fcc0:	aa 0b       	sbc	r26, r26
    fcc2:	e0 e8       	ldi	r30, 0x80	; 128
    fcc4:	fe ef       	ldi	r31, 0xFE	; 254
    fcc6:	16 16       	cp	r1, r22
    fcc8:	17 06       	cpc	r1, r23
    fcca:	e8 07       	cpc	r30, r24
    fccc:	f9 07       	cpc	r31, r25
    fcce:	c0 f0       	brcs	.+48     	; 0xfd00 <__fp_cmp+0x46>
    fcd0:	12 16       	cp	r1, r18
    fcd2:	13 06       	cpc	r1, r19
    fcd4:	e4 07       	cpc	r30, r20
    fcd6:	f5 07       	cpc	r31, r21
    fcd8:	98 f0       	brcs	.+38     	; 0xfd00 <__fp_cmp+0x46>
    fcda:	62 1b       	sub	r22, r18
    fcdc:	73 0b       	sbc	r23, r19
    fcde:	84 0b       	sbc	r24, r20
    fce0:	95 0b       	sbc	r25, r21
    fce2:	39 f4       	brne	.+14     	; 0xfcf2 <__fp_cmp+0x38>
    fce4:	0a 26       	eor	r0, r26
    fce6:	61 f0       	breq	.+24     	; 0xfd00 <__fp_cmp+0x46>
    fce8:	23 2b       	or	r18, r19
    fcea:	24 2b       	or	r18, r20
    fcec:	25 2b       	or	r18, r21
    fcee:	21 f4       	brne	.+8      	; 0xfcf8 <__fp_cmp+0x3e>
    fcf0:	08 95       	ret
    fcf2:	0a 26       	eor	r0, r26
    fcf4:	09 f4       	brne	.+2      	; 0xfcf8 <__fp_cmp+0x3e>
    fcf6:	a1 40       	sbci	r26, 0x01	; 1
    fcf8:	a6 95       	lsr	r26
    fcfa:	8f ef       	ldi	r24, 0xFF	; 255
    fcfc:	81 1d       	adc	r24, r1
    fcfe:	81 1d       	adc	r24, r1
    fd00:	08 95       	ret

0000fd02 <__fp_inf>:
    fd02:	97 f9       	bld	r25, 7
    fd04:	9f 67       	ori	r25, 0x7F	; 127
    fd06:	80 e8       	ldi	r24, 0x80	; 128
    fd08:	70 e0       	ldi	r23, 0x00	; 0
    fd0a:	60 e0       	ldi	r22, 0x00	; 0
    fd0c:	08 95       	ret

0000fd0e <__fp_nan>:
    fd0e:	9f ef       	ldi	r25, 0xFF	; 255
    fd10:	80 ec       	ldi	r24, 0xC0	; 192
    fd12:	08 95       	ret

0000fd14 <__fp_powser>:
    fd14:	df 93       	push	r29
    fd16:	cf 93       	push	r28
    fd18:	1f 93       	push	r17
    fd1a:	0f 93       	push	r16
    fd1c:	ff 92       	push	r15
    fd1e:	ef 92       	push	r14
    fd20:	df 92       	push	r13
    fd22:	7b 01       	movw	r14, r22
    fd24:	8c 01       	movw	r16, r24
    fd26:	68 94       	set
    fd28:	05 c0       	rjmp	.+10     	; 0xfd34 <__fp_powser+0x20>
    fd2a:	da 2e       	mov	r13, r26
    fd2c:	ef 01       	movw	r28, r30
    fd2e:	72 d0       	rcall	.+228    	; 0xfe14 <__mulsf3x>
    fd30:	fe 01       	movw	r30, r28
    fd32:	e8 94       	clt
    fd34:	a5 91       	lpm	r26, Z+
    fd36:	25 91       	lpm	r18, Z+
    fd38:	35 91       	lpm	r19, Z+
    fd3a:	45 91       	lpm	r20, Z+
    fd3c:	55 91       	lpm	r21, Z+
    fd3e:	ae f3       	brts	.-22     	; 0xfd2a <__fp_powser+0x16>
    fd40:	ef 01       	movw	r28, r30
    fd42:	f3 dd       	rcall	.-1050   	; 0xf92a <__addsf3x>
    fd44:	fe 01       	movw	r30, r28
    fd46:	97 01       	movw	r18, r14
    fd48:	a8 01       	movw	r20, r16
    fd4a:	da 94       	dec	r13
    fd4c:	79 f7       	brne	.-34     	; 0xfd2c <__fp_powser+0x18>
    fd4e:	df 90       	pop	r13
    fd50:	ef 90       	pop	r14
    fd52:	ff 90       	pop	r15
    fd54:	0f 91       	pop	r16
    fd56:	1f 91       	pop	r17
    fd58:	cf 91       	pop	r28
    fd5a:	df 91       	pop	r29
    fd5c:	08 95       	ret

0000fd5e <__fp_pscA>:
    fd5e:	00 24       	eor	r0, r0
    fd60:	0a 94       	dec	r0
    fd62:	16 16       	cp	r1, r22
    fd64:	17 06       	cpc	r1, r23
    fd66:	18 06       	cpc	r1, r24
    fd68:	09 06       	cpc	r0, r25
    fd6a:	08 95       	ret

0000fd6c <__fp_pscB>:
    fd6c:	00 24       	eor	r0, r0
    fd6e:	0a 94       	dec	r0
    fd70:	12 16       	cp	r1, r18
    fd72:	13 06       	cpc	r1, r19
    fd74:	14 06       	cpc	r1, r20
    fd76:	05 06       	cpc	r0, r21
    fd78:	08 95       	ret

0000fd7a <__fp_round>:
    fd7a:	09 2e       	mov	r0, r25
    fd7c:	03 94       	inc	r0
    fd7e:	00 0c       	add	r0, r0
    fd80:	11 f4       	brne	.+4      	; 0xfd86 <__fp_round+0xc>
    fd82:	88 23       	and	r24, r24
    fd84:	52 f0       	brmi	.+20     	; 0xfd9a <__fp_round+0x20>
    fd86:	bb 0f       	add	r27, r27
    fd88:	40 f4       	brcc	.+16     	; 0xfd9a <__fp_round+0x20>
    fd8a:	bf 2b       	or	r27, r31
    fd8c:	11 f4       	brne	.+4      	; 0xfd92 <__fp_round+0x18>
    fd8e:	60 ff       	sbrs	r22, 0
    fd90:	04 c0       	rjmp	.+8      	; 0xfd9a <__fp_round+0x20>
    fd92:	6f 5f       	subi	r22, 0xFF	; 255
    fd94:	7f 4f       	sbci	r23, 0xFF	; 255
    fd96:	8f 4f       	sbci	r24, 0xFF	; 255
    fd98:	9f 4f       	sbci	r25, 0xFF	; 255
    fd9a:	08 95       	ret

0000fd9c <__fp_split3>:
    fd9c:	57 fd       	sbrc	r21, 7
    fd9e:	90 58       	subi	r25, 0x80	; 128
    fda0:	44 0f       	add	r20, r20
    fda2:	55 1f       	adc	r21, r21
    fda4:	59 f0       	breq	.+22     	; 0xfdbc <__fp_splitA+0x10>
    fda6:	5f 3f       	cpi	r21, 0xFF	; 255
    fda8:	71 f0       	breq	.+28     	; 0xfdc6 <__fp_splitA+0x1a>
    fdaa:	47 95       	ror	r20

0000fdac <__fp_splitA>:
    fdac:	88 0f       	add	r24, r24
    fdae:	97 fb       	bst	r25, 7
    fdb0:	99 1f       	adc	r25, r25
    fdb2:	61 f0       	breq	.+24     	; 0xfdcc <__fp_splitA+0x20>
    fdb4:	9f 3f       	cpi	r25, 0xFF	; 255
    fdb6:	79 f0       	breq	.+30     	; 0xfdd6 <__fp_splitA+0x2a>
    fdb8:	87 95       	ror	r24
    fdba:	08 95       	ret
    fdbc:	12 16       	cp	r1, r18
    fdbe:	13 06       	cpc	r1, r19
    fdc0:	14 06       	cpc	r1, r20
    fdc2:	55 1f       	adc	r21, r21
    fdc4:	f2 cf       	rjmp	.-28     	; 0xfdaa <__fp_split3+0xe>
    fdc6:	46 95       	lsr	r20
    fdc8:	f1 df       	rcall	.-30     	; 0xfdac <__fp_splitA>
    fdca:	08 c0       	rjmp	.+16     	; 0xfddc <__fp_splitA+0x30>
    fdcc:	16 16       	cp	r1, r22
    fdce:	17 06       	cpc	r1, r23
    fdd0:	18 06       	cpc	r1, r24
    fdd2:	99 1f       	adc	r25, r25
    fdd4:	f1 cf       	rjmp	.-30     	; 0xfdb8 <__fp_splitA+0xc>
    fdd6:	86 95       	lsr	r24
    fdd8:	71 05       	cpc	r23, r1
    fdda:	61 05       	cpc	r22, r1
    fddc:	08 94       	sec
    fdde:	08 95       	ret

0000fde0 <__fp_zero>:
    fde0:	e8 94       	clt

0000fde2 <__fp_szero>:
    fde2:	bb 27       	eor	r27, r27
    fde4:	66 27       	eor	r22, r22
    fde6:	77 27       	eor	r23, r23
    fde8:	cb 01       	movw	r24, r22
    fdea:	97 f9       	bld	r25, 7
    fdec:	08 95       	ret

0000fdee <inverse>:
    fdee:	9b 01       	movw	r18, r22
    fdf0:	ac 01       	movw	r20, r24
    fdf2:	60 e0       	ldi	r22, 0x00	; 0
    fdf4:	70 e0       	ldi	r23, 0x00	; 0
    fdf6:	80 e8       	ldi	r24, 0x80	; 128
    fdf8:	9f e3       	ldi	r25, 0x3F	; 63
    fdfa:	50 ce       	rjmp	.-864    	; 0xfa9c <__divsf3>

0000fdfc <__mulsf3>:
    fdfc:	0b d0       	rcall	.+22     	; 0xfe14 <__mulsf3x>
    fdfe:	bd cf       	rjmp	.-134    	; 0xfd7a <__fp_round>
    fe00:	ae df       	rcall	.-164    	; 0xfd5e <__fp_pscA>
    fe02:	28 f0       	brcs	.+10     	; 0xfe0e <__mulsf3+0x12>
    fe04:	b3 df       	rcall	.-154    	; 0xfd6c <__fp_pscB>
    fe06:	18 f0       	brcs	.+6      	; 0xfe0e <__mulsf3+0x12>
    fe08:	95 23       	and	r25, r21
    fe0a:	09 f0       	breq	.+2      	; 0xfe0e <__mulsf3+0x12>
    fe0c:	7a cf       	rjmp	.-268    	; 0xfd02 <__fp_inf>
    fe0e:	7f cf       	rjmp	.-258    	; 0xfd0e <__fp_nan>
    fe10:	11 24       	eor	r1, r1
    fe12:	e7 cf       	rjmp	.-50     	; 0xfde2 <__fp_szero>

0000fe14 <__mulsf3x>:
    fe14:	c3 df       	rcall	.-122    	; 0xfd9c <__fp_split3>
    fe16:	a0 f3       	brcs	.-24     	; 0xfe00 <__mulsf3+0x4>

0000fe18 <__mulsf3_pse>:
    fe18:	95 9f       	mul	r25, r21
    fe1a:	d1 f3       	breq	.-12     	; 0xfe10 <__mulsf3+0x14>
    fe1c:	95 0f       	add	r25, r21
    fe1e:	50 e0       	ldi	r21, 0x00	; 0
    fe20:	55 1f       	adc	r21, r21
    fe22:	62 9f       	mul	r22, r18
    fe24:	f0 01       	movw	r30, r0
    fe26:	72 9f       	mul	r23, r18
    fe28:	bb 27       	eor	r27, r27
    fe2a:	f0 0d       	add	r31, r0
    fe2c:	b1 1d       	adc	r27, r1
    fe2e:	63 9f       	mul	r22, r19
    fe30:	aa 27       	eor	r26, r26
    fe32:	f0 0d       	add	r31, r0
    fe34:	b1 1d       	adc	r27, r1
    fe36:	aa 1f       	adc	r26, r26
    fe38:	64 9f       	mul	r22, r20
    fe3a:	66 27       	eor	r22, r22
    fe3c:	b0 0d       	add	r27, r0
    fe3e:	a1 1d       	adc	r26, r1
    fe40:	66 1f       	adc	r22, r22
    fe42:	82 9f       	mul	r24, r18
    fe44:	22 27       	eor	r18, r18
    fe46:	b0 0d       	add	r27, r0
    fe48:	a1 1d       	adc	r26, r1
    fe4a:	62 1f       	adc	r22, r18
    fe4c:	73 9f       	mul	r23, r19
    fe4e:	b0 0d       	add	r27, r0
    fe50:	a1 1d       	adc	r26, r1
    fe52:	62 1f       	adc	r22, r18
    fe54:	83 9f       	mul	r24, r19
    fe56:	a0 0d       	add	r26, r0
    fe58:	61 1d       	adc	r22, r1
    fe5a:	22 1f       	adc	r18, r18
    fe5c:	74 9f       	mul	r23, r20
    fe5e:	33 27       	eor	r19, r19
    fe60:	a0 0d       	add	r26, r0
    fe62:	61 1d       	adc	r22, r1
    fe64:	23 1f       	adc	r18, r19
    fe66:	84 9f       	mul	r24, r20
    fe68:	60 0d       	add	r22, r0
    fe6a:	21 1d       	adc	r18, r1
    fe6c:	82 2f       	mov	r24, r18
    fe6e:	76 2f       	mov	r23, r22
    fe70:	6a 2f       	mov	r22, r26
    fe72:	11 24       	eor	r1, r1
    fe74:	9f 57       	subi	r25, 0x7F	; 127
    fe76:	50 40       	sbci	r21, 0x00	; 0
    fe78:	8a f0       	brmi	.+34     	; 0xfe9c <__mulsf3_pse+0x84>
    fe7a:	e1 f0       	breq	.+56     	; 0xfeb4 <__mulsf3_pse+0x9c>
    fe7c:	88 23       	and	r24, r24
    fe7e:	4a f0       	brmi	.+18     	; 0xfe92 <__mulsf3_pse+0x7a>
    fe80:	ee 0f       	add	r30, r30
    fe82:	ff 1f       	adc	r31, r31
    fe84:	bb 1f       	adc	r27, r27
    fe86:	66 1f       	adc	r22, r22
    fe88:	77 1f       	adc	r23, r23
    fe8a:	88 1f       	adc	r24, r24
    fe8c:	91 50       	subi	r25, 0x01	; 1
    fe8e:	50 40       	sbci	r21, 0x00	; 0
    fe90:	a9 f7       	brne	.-22     	; 0xfe7c <__mulsf3_pse+0x64>
    fe92:	9e 3f       	cpi	r25, 0xFE	; 254
    fe94:	51 05       	cpc	r21, r1
    fe96:	70 f0       	brcs	.+28     	; 0xfeb4 <__mulsf3_pse+0x9c>
    fe98:	34 cf       	rjmp	.-408    	; 0xfd02 <__fp_inf>
    fe9a:	a3 cf       	rjmp	.-186    	; 0xfde2 <__fp_szero>
    fe9c:	5f 3f       	cpi	r21, 0xFF	; 255
    fe9e:	ec f3       	brlt	.-6      	; 0xfe9a <__mulsf3_pse+0x82>
    fea0:	98 3e       	cpi	r25, 0xE8	; 232
    fea2:	dc f3       	brlt	.-10     	; 0xfe9a <__mulsf3_pse+0x82>
    fea4:	86 95       	lsr	r24
    fea6:	77 95       	ror	r23
    fea8:	67 95       	ror	r22
    feaa:	b7 95       	ror	r27
    feac:	f7 95       	ror	r31
    feae:	e7 95       	ror	r30
    feb0:	9f 5f       	subi	r25, 0xFF	; 255
    feb2:	c1 f7       	brne	.-16     	; 0xfea4 <__mulsf3_pse+0x8c>
    feb4:	fe 2b       	or	r31, r30
    feb6:	88 0f       	add	r24, r24
    feb8:	91 1d       	adc	r25, r1
    feba:	96 95       	lsr	r25
    febc:	87 95       	ror	r24
    febe:	97 f9       	bld	r25, 7
    fec0:	08 95       	ret
    fec2:	11 f4       	brne	.+4      	; 0xfec8 <__mulsf3_pse+0xb0>
    fec4:	0e f4       	brtc	.+2      	; 0xfec8 <__mulsf3_pse+0xb0>
    fec6:	23 cf       	rjmp	.-442    	; 0xfd0e <__fp_nan>
    fec8:	41 c0       	rjmp	.+130    	; 0xff4c <__fp_mpack>

0000feca <sqrt>:
    feca:	70 df       	rcall	.-288    	; 0xfdac <__fp_splitA>
    fecc:	d0 f3       	brcs	.-12     	; 0xfec2 <__mulsf3_pse+0xaa>
    fece:	99 23       	and	r25, r25
    fed0:	d9 f3       	breq	.-10     	; 0xfec8 <__mulsf3_pse+0xb0>
    fed2:	ce f3       	brts	.-14     	; 0xfec6 <__mulsf3_pse+0xae>
    fed4:	9f 57       	subi	r25, 0x7F	; 127
    fed6:	55 0b       	sbc	r21, r21
    fed8:	87 ff       	sbrs	r24, 7
    feda:	46 d0       	rcall	.+140    	; 0xff68 <__fp_norm2>
    fedc:	00 24       	eor	r0, r0
    fede:	a0 e6       	ldi	r26, 0x60	; 96
    fee0:	40 ea       	ldi	r20, 0xA0	; 160
    fee2:	90 01       	movw	r18, r0
    fee4:	80 58       	subi	r24, 0x80	; 128
    fee6:	56 95       	lsr	r21
    fee8:	97 95       	ror	r25
    feea:	28 f4       	brcc	.+10     	; 0xfef6 <sqrt+0x2c>
    feec:	80 5c       	subi	r24, 0xC0	; 192
    feee:	66 0f       	add	r22, r22
    fef0:	77 1f       	adc	r23, r23
    fef2:	88 1f       	adc	r24, r24
    fef4:	20 f0       	brcs	.+8      	; 0xfefe <sqrt+0x34>
    fef6:	26 17       	cp	r18, r22
    fef8:	37 07       	cpc	r19, r23
    fefa:	48 07       	cpc	r20, r24
    fefc:	30 f4       	brcc	.+12     	; 0xff0a <sqrt+0x40>
    fefe:	62 1b       	sub	r22, r18
    ff00:	73 0b       	sbc	r23, r19
    ff02:	84 0b       	sbc	r24, r20
    ff04:	20 29       	or	r18, r0
    ff06:	31 29       	or	r19, r1
    ff08:	4a 2b       	or	r20, r26
    ff0a:	a6 95       	lsr	r26
    ff0c:	17 94       	ror	r1
    ff0e:	07 94       	ror	r0
    ff10:	20 25       	eor	r18, r0
    ff12:	31 25       	eor	r19, r1
    ff14:	4a 27       	eor	r20, r26
    ff16:	58 f7       	brcc	.-42     	; 0xfeee <sqrt+0x24>
    ff18:	66 0f       	add	r22, r22
    ff1a:	77 1f       	adc	r23, r23
    ff1c:	88 1f       	adc	r24, r24
    ff1e:	20 f0       	brcs	.+8      	; 0xff28 <sqrt+0x5e>
    ff20:	26 17       	cp	r18, r22
    ff22:	37 07       	cpc	r19, r23
    ff24:	48 07       	cpc	r20, r24
    ff26:	30 f4       	brcc	.+12     	; 0xff34 <sqrt+0x6a>
    ff28:	62 0b       	sbc	r22, r18
    ff2a:	73 0b       	sbc	r23, r19
    ff2c:	84 0b       	sbc	r24, r20
    ff2e:	20 0d       	add	r18, r0
    ff30:	31 1d       	adc	r19, r1
    ff32:	41 1d       	adc	r20, r1
    ff34:	a0 95       	com	r26
    ff36:	81 f7       	brne	.-32     	; 0xff18 <sqrt+0x4e>
    ff38:	b9 01       	movw	r22, r18
    ff3a:	84 2f       	mov	r24, r20
    ff3c:	91 58       	subi	r25, 0x81	; 129
    ff3e:	88 0f       	add	r24, r24
    ff40:	96 95       	lsr	r25
    ff42:	87 95       	ror	r24
    ff44:	08 95       	ret

0000ff46 <square>:
    ff46:	9b 01       	movw	r18, r22
    ff48:	ac 01       	movw	r20, r24
    ff4a:	58 cf       	rjmp	.-336    	; 0xfdfc <__mulsf3>

0000ff4c <__fp_mpack>:
    ff4c:	9f 3f       	cpi	r25, 0xFF	; 255
    ff4e:	31 f0       	breq	.+12     	; 0xff5c <__fp_mpack_finite+0xc>

0000ff50 <__fp_mpack_finite>:
    ff50:	91 50       	subi	r25, 0x01	; 1
    ff52:	20 f4       	brcc	.+8      	; 0xff5c <__fp_mpack_finite+0xc>
    ff54:	87 95       	ror	r24
    ff56:	77 95       	ror	r23
    ff58:	67 95       	ror	r22
    ff5a:	b7 95       	ror	r27
    ff5c:	88 0f       	add	r24, r24
    ff5e:	91 1d       	adc	r25, r1
    ff60:	96 95       	lsr	r25
    ff62:	87 95       	ror	r24
    ff64:	97 f9       	bld	r25, 7
    ff66:	08 95       	ret

0000ff68 <__fp_norm2>:
    ff68:	91 50       	subi	r25, 0x01	; 1
    ff6a:	50 40       	sbci	r21, 0x00	; 0
    ff6c:	66 0f       	add	r22, r22
    ff6e:	77 1f       	adc	r23, r23
    ff70:	88 1f       	adc	r24, r24
    ff72:	d2 f7       	brpl	.-12     	; 0xff68 <__fp_norm2>
    ff74:	08 95       	ret

0000ff76 <__mulsi3>:
    ff76:	62 9f       	mul	r22, r18
    ff78:	d0 01       	movw	r26, r0
    ff7a:	73 9f       	mul	r23, r19
    ff7c:	f0 01       	movw	r30, r0
    ff7e:	82 9f       	mul	r24, r18
    ff80:	e0 0d       	add	r30, r0
    ff82:	f1 1d       	adc	r31, r1
    ff84:	64 9f       	mul	r22, r20
    ff86:	e0 0d       	add	r30, r0
    ff88:	f1 1d       	adc	r31, r1
    ff8a:	92 9f       	mul	r25, r18
    ff8c:	f0 0d       	add	r31, r0
    ff8e:	83 9f       	mul	r24, r19
    ff90:	f0 0d       	add	r31, r0
    ff92:	74 9f       	mul	r23, r20
    ff94:	f0 0d       	add	r31, r0
    ff96:	65 9f       	mul	r22, r21
    ff98:	f0 0d       	add	r31, r0
    ff9a:	99 27       	eor	r25, r25
    ff9c:	72 9f       	mul	r23, r18
    ff9e:	b0 0d       	add	r27, r0
    ffa0:	e1 1d       	adc	r30, r1
    ffa2:	f9 1f       	adc	r31, r25
    ffa4:	63 9f       	mul	r22, r19
    ffa6:	b0 0d       	add	r27, r0
    ffa8:	e1 1d       	adc	r30, r1
    ffaa:	f9 1f       	adc	r31, r25
    ffac:	bd 01       	movw	r22, r26
    ffae:	cf 01       	movw	r24, r30
    ffb0:	11 24       	eor	r1, r1
    ffb2:	08 95       	ret

0000ffb4 <__udivmodqi4>:
    ffb4:	99 1b       	sub	r25, r25
    ffb6:	79 e0       	ldi	r23, 0x09	; 9
    ffb8:	04 c0       	rjmp	.+8      	; 0xffc2 <__udivmodqi4_ep>

0000ffba <__udivmodqi4_loop>:
    ffba:	99 1f       	adc	r25, r25
    ffbc:	96 17       	cp	r25, r22
    ffbe:	08 f0       	brcs	.+2      	; 0xffc2 <__udivmodqi4_ep>
    ffc0:	96 1b       	sub	r25, r22

0000ffc2 <__udivmodqi4_ep>:
    ffc2:	88 1f       	adc	r24, r24
    ffc4:	7a 95       	dec	r23
    ffc6:	c9 f7       	brne	.-14     	; 0xffba <__udivmodqi4_loop>
    ffc8:	80 95       	com	r24
    ffca:	08 95       	ret

0000ffcc <__udivmodhi4>:
    ffcc:	aa 1b       	sub	r26, r26
    ffce:	bb 1b       	sub	r27, r27
    ffd0:	51 e1       	ldi	r21, 0x11	; 17
    ffd2:	07 c0       	rjmp	.+14     	; 0xffe2 <__udivmodhi4_ep>

0000ffd4 <__udivmodhi4_loop>:
    ffd4:	aa 1f       	adc	r26, r26
    ffd6:	bb 1f       	adc	r27, r27
    ffd8:	a6 17       	cp	r26, r22
    ffda:	b7 07       	cpc	r27, r23
    ffdc:	10 f0       	brcs	.+4      	; 0xffe2 <__udivmodhi4_ep>
    ffde:	a6 1b       	sub	r26, r22
    ffe0:	b7 0b       	sbc	r27, r23

0000ffe2 <__udivmodhi4_ep>:
    ffe2:	88 1f       	adc	r24, r24
    ffe4:	99 1f       	adc	r25, r25
    ffe6:	5a 95       	dec	r21
    ffe8:	a9 f7       	brne	.-22     	; 0xffd4 <__udivmodhi4_loop>
    ffea:	80 95       	com	r24
    ffec:	90 95       	com	r25
    ffee:	bc 01       	movw	r22, r24
    fff0:	cd 01       	movw	r24, r26
    fff2:	08 95       	ret

0000fff4 <__divmodhi4>:
    fff4:	97 fb       	bst	r25, 7
    fff6:	09 2e       	mov	r0, r25
    fff8:	07 26       	eor	r0, r23
    fffa:	0a d0       	rcall	.+20     	; 0x10010 <__divmodhi4_neg1>
    fffc:	77 fd       	sbrc	r23, 7
    fffe:	04 d0       	rcall	.+8      	; 0x10008 <__divmodhi4_neg2>
   10000:	e5 df       	rcall	.-54     	; 0xffcc <__udivmodhi4>
   10002:	06 d0       	rcall	.+12     	; 0x10010 <__divmodhi4_neg1>
   10004:	00 20       	and	r0, r0
   10006:	1a f4       	brpl	.+6      	; 0x1000e <__divmodhi4_exit>

00010008 <__divmodhi4_neg2>:
   10008:	70 95       	com	r23
   1000a:	61 95       	neg	r22
   1000c:	7f 4f       	sbci	r23, 0xFF	; 255

0001000e <__divmodhi4_exit>:
   1000e:	08 95       	ret

00010010 <__divmodhi4_neg1>:
   10010:	f6 f7       	brtc	.-4      	; 0x1000e <__divmodhi4_exit>
   10012:	90 95       	com	r25
   10014:	81 95       	neg	r24
   10016:	9f 4f       	sbci	r25, 0xFF	; 255
   10018:	08 95       	ret

0001001a <__udivmodsi4>:
   1001a:	a1 e2       	ldi	r26, 0x21	; 33
   1001c:	1a 2e       	mov	r1, r26
   1001e:	aa 1b       	sub	r26, r26
   10020:	bb 1b       	sub	r27, r27
   10022:	fd 01       	movw	r30, r26
   10024:	0d c0       	rjmp	.+26     	; 0x10040 <__udivmodsi4_ep>

00010026 <__udivmodsi4_loop>:
   10026:	aa 1f       	adc	r26, r26
   10028:	bb 1f       	adc	r27, r27
   1002a:	ee 1f       	adc	r30, r30
   1002c:	ff 1f       	adc	r31, r31
   1002e:	a2 17       	cp	r26, r18
   10030:	b3 07       	cpc	r27, r19
   10032:	e4 07       	cpc	r30, r20
   10034:	f5 07       	cpc	r31, r21
   10036:	20 f0       	brcs	.+8      	; 0x10040 <__udivmodsi4_ep>
   10038:	a2 1b       	sub	r26, r18
   1003a:	b3 0b       	sbc	r27, r19
   1003c:	e4 0b       	sbc	r30, r20
   1003e:	f5 0b       	sbc	r31, r21

00010040 <__udivmodsi4_ep>:
   10040:	66 1f       	adc	r22, r22
   10042:	77 1f       	adc	r23, r23
   10044:	88 1f       	adc	r24, r24
   10046:	99 1f       	adc	r25, r25
   10048:	1a 94       	dec	r1
   1004a:	69 f7       	brne	.-38     	; 0x10026 <__udivmodsi4_loop>
   1004c:	60 95       	com	r22
   1004e:	70 95       	com	r23
   10050:	80 95       	com	r24
   10052:	90 95       	com	r25
   10054:	9b 01       	movw	r18, r22
   10056:	ac 01       	movw	r20, r24
   10058:	bd 01       	movw	r22, r26
   1005a:	cf 01       	movw	r24, r30
   1005c:	08 95       	ret

0001005e <__divmodsi4>:
   1005e:	97 fb       	bst	r25, 7
   10060:	09 2e       	mov	r0, r25
   10062:	05 26       	eor	r0, r21
   10064:	0e d0       	rcall	.+28     	; 0x10082 <__divmodsi4_neg1>
   10066:	57 fd       	sbrc	r21, 7
   10068:	04 d0       	rcall	.+8      	; 0x10072 <__divmodsi4_neg2>
   1006a:	d7 df       	rcall	.-82     	; 0x1001a <__udivmodsi4>
   1006c:	0a d0       	rcall	.+20     	; 0x10082 <__divmodsi4_neg1>
   1006e:	00 1c       	adc	r0, r0
   10070:	38 f4       	brcc	.+14     	; 0x10080 <__divmodsi4_exit>

00010072 <__divmodsi4_neg2>:
   10072:	50 95       	com	r21
   10074:	40 95       	com	r20
   10076:	30 95       	com	r19
   10078:	21 95       	neg	r18
   1007a:	3f 4f       	sbci	r19, 0xFF	; 255
   1007c:	4f 4f       	sbci	r20, 0xFF	; 255
   1007e:	5f 4f       	sbci	r21, 0xFF	; 255

00010080 <__divmodsi4_exit>:
   10080:	08 95       	ret

00010082 <__divmodsi4_neg1>:
   10082:	f6 f7       	brtc	.-4      	; 0x10080 <__divmodsi4_exit>
   10084:	90 95       	com	r25
   10086:	80 95       	com	r24
   10088:	70 95       	com	r23
   1008a:	61 95       	neg	r22
   1008c:	7f 4f       	sbci	r23, 0xFF	; 255
   1008e:	8f 4f       	sbci	r24, 0xFF	; 255
   10090:	9f 4f       	sbci	r25, 0xFF	; 255
   10092:	08 95       	ret

00010094 <malloc>:
   10094:	cf 93       	push	r28
   10096:	df 93       	push	r29
   10098:	bc 01       	movw	r22, r24
   1009a:	82 30       	cpi	r24, 0x02	; 2
   1009c:	91 05       	cpc	r25, r1
   1009e:	10 f4       	brcc	.+4      	; 0x100a4 <malloc+0x10>
   100a0:	62 e0       	ldi	r22, 0x02	; 2
   100a2:	70 e0       	ldi	r23, 0x00	; 0
   100a4:	a0 91 b3 32 	lds	r26, 0x32B3
   100a8:	b0 91 b4 32 	lds	r27, 0x32B4
   100ac:	ed 01       	movw	r28, r26
   100ae:	e0 e0       	ldi	r30, 0x00	; 0
   100b0:	f0 e0       	ldi	r31, 0x00	; 0
   100b2:	40 e0       	ldi	r20, 0x00	; 0
   100b4:	50 e0       	ldi	r21, 0x00	; 0
   100b6:	21 c0       	rjmp	.+66     	; 0x100fa <malloc+0x66>
   100b8:	88 81       	ld	r24, Y
   100ba:	99 81       	ldd	r25, Y+1	; 0x01
   100bc:	86 17       	cp	r24, r22
   100be:	97 07       	cpc	r25, r23
   100c0:	69 f4       	brne	.+26     	; 0x100dc <malloc+0x48>
   100c2:	8a 81       	ldd	r24, Y+2	; 0x02
   100c4:	9b 81       	ldd	r25, Y+3	; 0x03
   100c6:	30 97       	sbiw	r30, 0x00	; 0
   100c8:	19 f0       	breq	.+6      	; 0x100d0 <malloc+0x3c>
   100ca:	93 83       	std	Z+3, r25	; 0x03
   100cc:	82 83       	std	Z+2, r24	; 0x02
   100ce:	04 c0       	rjmp	.+8      	; 0x100d8 <malloc+0x44>
   100d0:	90 93 b4 32 	sts	0x32B4, r25
   100d4:	80 93 b3 32 	sts	0x32B3, r24
   100d8:	fe 01       	movw	r30, r28
   100da:	34 c0       	rjmp	.+104    	; 0x10144 <malloc+0xb0>
   100dc:	68 17       	cp	r22, r24
   100de:	79 07       	cpc	r23, r25
   100e0:	38 f4       	brcc	.+14     	; 0x100f0 <malloc+0x5c>
   100e2:	41 15       	cp	r20, r1
   100e4:	51 05       	cpc	r21, r1
   100e6:	19 f0       	breq	.+6      	; 0x100ee <malloc+0x5a>
   100e8:	84 17       	cp	r24, r20
   100ea:	95 07       	cpc	r25, r21
   100ec:	08 f4       	brcc	.+2      	; 0x100f0 <malloc+0x5c>
   100ee:	ac 01       	movw	r20, r24
   100f0:	fe 01       	movw	r30, r28
   100f2:	8a 81       	ldd	r24, Y+2	; 0x02
   100f4:	9b 81       	ldd	r25, Y+3	; 0x03
   100f6:	9c 01       	movw	r18, r24
   100f8:	e9 01       	movw	r28, r18
   100fa:	20 97       	sbiw	r28, 0x00	; 0
   100fc:	e9 f6       	brne	.-70     	; 0x100b8 <malloc+0x24>
   100fe:	41 15       	cp	r20, r1
   10100:	51 05       	cpc	r21, r1
   10102:	a9 f1       	breq	.+106    	; 0x1016e <malloc+0xda>
   10104:	ca 01       	movw	r24, r20
   10106:	86 1b       	sub	r24, r22
   10108:	97 0b       	sbc	r25, r23
   1010a:	04 97       	sbiw	r24, 0x04	; 4
   1010c:	08 f4       	brcc	.+2      	; 0x10110 <malloc+0x7c>
   1010e:	ba 01       	movw	r22, r20
   10110:	e0 e0       	ldi	r30, 0x00	; 0
   10112:	f0 e0       	ldi	r31, 0x00	; 0
   10114:	2a c0       	rjmp	.+84     	; 0x1016a <malloc+0xd6>
   10116:	8d 91       	ld	r24, X+
   10118:	9c 91       	ld	r25, X
   1011a:	11 97       	sbiw	r26, 0x01	; 1
   1011c:	84 17       	cp	r24, r20
   1011e:	95 07       	cpc	r25, r21
   10120:	f9 f4       	brne	.+62     	; 0x10160 <malloc+0xcc>
   10122:	64 17       	cp	r22, r20
   10124:	75 07       	cpc	r23, r21
   10126:	81 f4       	brne	.+32     	; 0x10148 <malloc+0xb4>
   10128:	12 96       	adiw	r26, 0x02	; 2
   1012a:	8d 91       	ld	r24, X+
   1012c:	9c 91       	ld	r25, X
   1012e:	13 97       	sbiw	r26, 0x03	; 3
   10130:	30 97       	sbiw	r30, 0x00	; 0
   10132:	19 f0       	breq	.+6      	; 0x1013a <malloc+0xa6>
   10134:	93 83       	std	Z+3, r25	; 0x03
   10136:	82 83       	std	Z+2, r24	; 0x02
   10138:	04 c0       	rjmp	.+8      	; 0x10142 <malloc+0xae>
   1013a:	90 93 b4 32 	sts	0x32B4, r25
   1013e:	80 93 b3 32 	sts	0x32B3, r24
   10142:	fd 01       	movw	r30, r26
   10144:	32 96       	adiw	r30, 0x02	; 2
   10146:	4f c0       	rjmp	.+158    	; 0x101e6 <malloc+0x152>
   10148:	ca 01       	movw	r24, r20
   1014a:	86 1b       	sub	r24, r22
   1014c:	97 0b       	sbc	r25, r23
   1014e:	fd 01       	movw	r30, r26
   10150:	e8 0f       	add	r30, r24
   10152:	f9 1f       	adc	r31, r25
   10154:	61 93       	st	Z+, r22
   10156:	71 93       	st	Z+, r23
   10158:	02 97       	sbiw	r24, 0x02	; 2
   1015a:	8d 93       	st	X+, r24
   1015c:	9c 93       	st	X, r25
   1015e:	43 c0       	rjmp	.+134    	; 0x101e6 <malloc+0x152>
   10160:	fd 01       	movw	r30, r26
   10162:	82 81       	ldd	r24, Z+2	; 0x02
   10164:	93 81       	ldd	r25, Z+3	; 0x03
   10166:	9c 01       	movw	r18, r24
   10168:	d9 01       	movw	r26, r18
   1016a:	10 97       	sbiw	r26, 0x00	; 0
   1016c:	a1 f6       	brne	.-88     	; 0x10116 <malloc+0x82>
   1016e:	80 91 b1 32 	lds	r24, 0x32B1
   10172:	90 91 b2 32 	lds	r25, 0x32B2
   10176:	89 2b       	or	r24, r25
   10178:	41 f4       	brne	.+16     	; 0x1018a <malloc+0xf6>
   1017a:	80 91 f6 06 	lds	r24, 0x06F6
   1017e:	90 91 f7 06 	lds	r25, 0x06F7
   10182:	90 93 b2 32 	sts	0x32B2, r25
   10186:	80 93 b1 32 	sts	0x32B1, r24
   1018a:	40 91 f8 06 	lds	r20, 0x06F8
   1018e:	50 91 f9 06 	lds	r21, 0x06F9
   10192:	41 15       	cp	r20, r1
   10194:	51 05       	cpc	r21, r1
   10196:	41 f4       	brne	.+16     	; 0x101a8 <malloc+0x114>
   10198:	4d b7       	in	r20, 0x3d	; 61
   1019a:	5e b7       	in	r21, 0x3e	; 62
   1019c:	80 91 f4 06 	lds	r24, 0x06F4
   101a0:	90 91 f5 06 	lds	r25, 0x06F5
   101a4:	48 1b       	sub	r20, r24
   101a6:	59 0b       	sbc	r21, r25
   101a8:	20 91 b1 32 	lds	r18, 0x32B1
   101ac:	30 91 b2 32 	lds	r19, 0x32B2
   101b0:	24 17       	cp	r18, r20
   101b2:	35 07       	cpc	r19, r21
   101b4:	b0 f4       	brcc	.+44     	; 0x101e2 <malloc+0x14e>
   101b6:	ca 01       	movw	r24, r20
   101b8:	82 1b       	sub	r24, r18
   101ba:	93 0b       	sbc	r25, r19
   101bc:	86 17       	cp	r24, r22
   101be:	97 07       	cpc	r25, r23
   101c0:	80 f0       	brcs	.+32     	; 0x101e2 <malloc+0x14e>
   101c2:	ab 01       	movw	r20, r22
   101c4:	4e 5f       	subi	r20, 0xFE	; 254
   101c6:	5f 4f       	sbci	r21, 0xFF	; 255
   101c8:	84 17       	cp	r24, r20
   101ca:	95 07       	cpc	r25, r21
   101cc:	50 f0       	brcs	.+20     	; 0x101e2 <malloc+0x14e>
   101ce:	42 0f       	add	r20, r18
   101d0:	53 1f       	adc	r21, r19
   101d2:	50 93 b2 32 	sts	0x32B2, r21
   101d6:	40 93 b1 32 	sts	0x32B1, r20
   101da:	f9 01       	movw	r30, r18
   101dc:	61 93       	st	Z+, r22
   101de:	71 93       	st	Z+, r23
   101e0:	02 c0       	rjmp	.+4      	; 0x101e6 <malloc+0x152>
   101e2:	e0 e0       	ldi	r30, 0x00	; 0
   101e4:	f0 e0       	ldi	r31, 0x00	; 0
   101e6:	cf 01       	movw	r24, r30
   101e8:	df 91       	pop	r29
   101ea:	cf 91       	pop	r28
   101ec:	08 95       	ret

000101ee <free>:
   101ee:	cf 93       	push	r28
   101f0:	df 93       	push	r29
   101f2:	00 97       	sbiw	r24, 0x00	; 0
   101f4:	09 f4       	brne	.+2      	; 0x101f8 <free+0xa>
   101f6:	50 c0       	rjmp	.+160    	; 0x10298 <free+0xaa>
   101f8:	ec 01       	movw	r28, r24
   101fa:	22 97       	sbiw	r28, 0x02	; 2
   101fc:	1b 82       	std	Y+3, r1	; 0x03
   101fe:	1a 82       	std	Y+2, r1	; 0x02
   10200:	a0 91 b3 32 	lds	r26, 0x32B3
   10204:	b0 91 b4 32 	lds	r27, 0x32B4
   10208:	10 97       	sbiw	r26, 0x00	; 0
   1020a:	09 f1       	breq	.+66     	; 0x1024e <free+0x60>
   1020c:	40 e0       	ldi	r20, 0x00	; 0
   1020e:	50 e0       	ldi	r21, 0x00	; 0
   10210:	ac 17       	cp	r26, r28
   10212:	bd 07       	cpc	r27, r29
   10214:	08 f1       	brcs	.+66     	; 0x10258 <free+0x6a>
   10216:	bb 83       	std	Y+3, r27	; 0x03
   10218:	aa 83       	std	Y+2, r26	; 0x02
   1021a:	fe 01       	movw	r30, r28
   1021c:	21 91       	ld	r18, Z+
   1021e:	31 91       	ld	r19, Z+
   10220:	e2 0f       	add	r30, r18
   10222:	f3 1f       	adc	r31, r19
   10224:	ae 17       	cp	r26, r30
   10226:	bf 07       	cpc	r27, r31
   10228:	79 f4       	brne	.+30     	; 0x10248 <free+0x5a>
   1022a:	8d 91       	ld	r24, X+
   1022c:	9c 91       	ld	r25, X
   1022e:	11 97       	sbiw	r26, 0x01	; 1
   10230:	28 0f       	add	r18, r24
   10232:	39 1f       	adc	r19, r25
   10234:	2e 5f       	subi	r18, 0xFE	; 254
   10236:	3f 4f       	sbci	r19, 0xFF	; 255
   10238:	39 83       	std	Y+1, r19	; 0x01
   1023a:	28 83       	st	Y, r18
   1023c:	12 96       	adiw	r26, 0x02	; 2
   1023e:	8d 91       	ld	r24, X+
   10240:	9c 91       	ld	r25, X
   10242:	13 97       	sbiw	r26, 0x03	; 3
   10244:	9b 83       	std	Y+3, r25	; 0x03
   10246:	8a 83       	std	Y+2, r24	; 0x02
   10248:	41 15       	cp	r20, r1
   1024a:	51 05       	cpc	r21, r1
   1024c:	71 f4       	brne	.+28     	; 0x1026a <free+0x7c>
   1024e:	d0 93 b4 32 	sts	0x32B4, r29
   10252:	c0 93 b3 32 	sts	0x32B3, r28
   10256:	20 c0       	rjmp	.+64     	; 0x10298 <free+0xaa>
   10258:	12 96       	adiw	r26, 0x02	; 2
   1025a:	8d 91       	ld	r24, X+
   1025c:	9c 91       	ld	r25, X
   1025e:	13 97       	sbiw	r26, 0x03	; 3
   10260:	ad 01       	movw	r20, r26
   10262:	00 97       	sbiw	r24, 0x00	; 0
   10264:	11 f0       	breq	.+4      	; 0x1026a <free+0x7c>
   10266:	dc 01       	movw	r26, r24
   10268:	d3 cf       	rjmp	.-90     	; 0x10210 <free+0x22>
   1026a:	fa 01       	movw	r30, r20
   1026c:	d3 83       	std	Z+3, r29	; 0x03
   1026e:	c2 83       	std	Z+2, r28	; 0x02
   10270:	21 91       	ld	r18, Z+
   10272:	31 91       	ld	r19, Z+
   10274:	e2 0f       	add	r30, r18
   10276:	f3 1f       	adc	r31, r19
   10278:	ce 17       	cp	r28, r30
   1027a:	df 07       	cpc	r29, r31
   1027c:	69 f4       	brne	.+26     	; 0x10298 <free+0xaa>
   1027e:	88 81       	ld	r24, Y
   10280:	99 81       	ldd	r25, Y+1	; 0x01
   10282:	28 0f       	add	r18, r24
   10284:	39 1f       	adc	r19, r25
   10286:	2e 5f       	subi	r18, 0xFE	; 254
   10288:	3f 4f       	sbci	r19, 0xFF	; 255
   1028a:	fa 01       	movw	r30, r20
   1028c:	31 83       	std	Z+1, r19	; 0x01
   1028e:	20 83       	st	Z, r18
   10290:	8a 81       	ldd	r24, Y+2	; 0x02
   10292:	9b 81       	ldd	r25, Y+3	; 0x03
   10294:	93 83       	std	Z+3, r25	; 0x03
   10296:	82 83       	std	Z+2, r24	; 0x02
   10298:	df 91       	pop	r29
   1029a:	cf 91       	pop	r28
   1029c:	08 95       	ret

0001029e <__ftoa_engine>:
   1029e:	28 30       	cpi	r18, 0x08	; 8
   102a0:	08 f0       	brcs	.+2      	; 0x102a4 <__ftoa_engine+0x6>
   102a2:	27 e0       	ldi	r18, 0x07	; 7
   102a4:	33 27       	eor	r19, r19
   102a6:	da 01       	movw	r26, r20
   102a8:	99 0f       	add	r25, r25
   102aa:	31 1d       	adc	r19, r1
   102ac:	87 fd       	sbrc	r24, 7
   102ae:	91 60       	ori	r25, 0x01	; 1
   102b0:	00 96       	adiw	r24, 0x00	; 0
   102b2:	61 05       	cpc	r22, r1
   102b4:	71 05       	cpc	r23, r1
   102b6:	39 f4       	brne	.+14     	; 0x102c6 <__ftoa_engine+0x28>
   102b8:	32 60       	ori	r19, 0x02	; 2
   102ba:	2e 5f       	subi	r18, 0xFE	; 254
   102bc:	3d 93       	st	X+, r19
   102be:	30 e3       	ldi	r19, 0x30	; 48
   102c0:	2a 95       	dec	r18
   102c2:	e1 f7       	brne	.-8      	; 0x102bc <__ftoa_engine+0x1e>
   102c4:	08 95       	ret
   102c6:	9f 3f       	cpi	r25, 0xFF	; 255
   102c8:	30 f0       	brcs	.+12     	; 0x102d6 <__ftoa_engine+0x38>
   102ca:	80 38       	cpi	r24, 0x80	; 128
   102cc:	71 05       	cpc	r23, r1
   102ce:	61 05       	cpc	r22, r1
   102d0:	09 f0       	breq	.+2      	; 0x102d4 <__ftoa_engine+0x36>
   102d2:	3c 5f       	subi	r19, 0xFC	; 252
   102d4:	3c 5f       	subi	r19, 0xFC	; 252
   102d6:	3d 93       	st	X+, r19
   102d8:	91 30       	cpi	r25, 0x01	; 1
   102da:	08 f0       	brcs	.+2      	; 0x102de <__ftoa_engine+0x40>
   102dc:	80 68       	ori	r24, 0x80	; 128
   102de:	91 1d       	adc	r25, r1
   102e0:	df 93       	push	r29
   102e2:	cf 93       	push	r28
   102e4:	1f 93       	push	r17
   102e6:	0f 93       	push	r16
   102e8:	ff 92       	push	r15
   102ea:	ef 92       	push	r14
   102ec:	19 2f       	mov	r17, r25
   102ee:	98 7f       	andi	r25, 0xF8	; 248
   102f0:	96 95       	lsr	r25
   102f2:	e9 2f       	mov	r30, r25
   102f4:	96 95       	lsr	r25
   102f6:	96 95       	lsr	r25
   102f8:	e9 0f       	add	r30, r25
   102fa:	ff 27       	eor	r31, r31
   102fc:	e8 5b       	subi	r30, 0xB8	; 184
   102fe:	f2 4f       	sbci	r31, 0xF2	; 242
   10300:	99 27       	eor	r25, r25
   10302:	33 27       	eor	r19, r19
   10304:	ee 24       	eor	r14, r14
   10306:	ff 24       	eor	r15, r15
   10308:	a7 01       	movw	r20, r14
   1030a:	e7 01       	movw	r28, r14
   1030c:	05 90       	lpm	r0, Z+
   1030e:	08 94       	sec
   10310:	07 94       	ror	r0
   10312:	28 f4       	brcc	.+10     	; 0x1031e <__ftoa_engine+0x80>
   10314:	36 0f       	add	r19, r22
   10316:	e7 1e       	adc	r14, r23
   10318:	f8 1e       	adc	r15, r24
   1031a:	49 1f       	adc	r20, r25
   1031c:	51 1d       	adc	r21, r1
   1031e:	66 0f       	add	r22, r22
   10320:	77 1f       	adc	r23, r23
   10322:	88 1f       	adc	r24, r24
   10324:	99 1f       	adc	r25, r25
   10326:	06 94       	lsr	r0
   10328:	a1 f7       	brne	.-24     	; 0x10312 <__ftoa_engine+0x74>
   1032a:	05 90       	lpm	r0, Z+
   1032c:	07 94       	ror	r0
   1032e:	28 f4       	brcc	.+10     	; 0x1033a <__ftoa_engine+0x9c>
   10330:	e7 0e       	add	r14, r23
   10332:	f8 1e       	adc	r15, r24
   10334:	49 1f       	adc	r20, r25
   10336:	56 1f       	adc	r21, r22
   10338:	c1 1d       	adc	r28, r1
   1033a:	77 0f       	add	r23, r23
   1033c:	88 1f       	adc	r24, r24
   1033e:	99 1f       	adc	r25, r25
   10340:	66 1f       	adc	r22, r22
   10342:	06 94       	lsr	r0
   10344:	a1 f7       	brne	.-24     	; 0x1032e <__ftoa_engine+0x90>
   10346:	05 90       	lpm	r0, Z+
   10348:	07 94       	ror	r0
   1034a:	28 f4       	brcc	.+10     	; 0x10356 <__ftoa_engine+0xb8>
   1034c:	f8 0e       	add	r15, r24
   1034e:	49 1f       	adc	r20, r25
   10350:	56 1f       	adc	r21, r22
   10352:	c7 1f       	adc	r28, r23
   10354:	d1 1d       	adc	r29, r1
   10356:	88 0f       	add	r24, r24
   10358:	99 1f       	adc	r25, r25
   1035a:	66 1f       	adc	r22, r22
   1035c:	77 1f       	adc	r23, r23
   1035e:	06 94       	lsr	r0
   10360:	a1 f7       	brne	.-24     	; 0x1034a <__ftoa_engine+0xac>
   10362:	05 90       	lpm	r0, Z+
   10364:	07 94       	ror	r0
   10366:	20 f4       	brcc	.+8      	; 0x10370 <__ftoa_engine+0xd2>
   10368:	49 0f       	add	r20, r25
   1036a:	56 1f       	adc	r21, r22
   1036c:	c7 1f       	adc	r28, r23
   1036e:	d8 1f       	adc	r29, r24
   10370:	99 0f       	add	r25, r25
   10372:	66 1f       	adc	r22, r22
   10374:	77 1f       	adc	r23, r23
   10376:	88 1f       	adc	r24, r24
   10378:	06 94       	lsr	r0
   1037a:	a9 f7       	brne	.-22     	; 0x10366 <__ftoa_engine+0xc8>
   1037c:	84 91       	lpm	r24, Z+
   1037e:	10 95       	com	r17
   10380:	17 70       	andi	r17, 0x07	; 7
   10382:	41 f0       	breq	.+16     	; 0x10394 <__ftoa_engine+0xf6>
   10384:	d6 95       	lsr	r29
   10386:	c7 95       	ror	r28
   10388:	57 95       	ror	r21
   1038a:	47 95       	ror	r20
   1038c:	f7 94       	ror	r15
   1038e:	e7 94       	ror	r14
   10390:	1a 95       	dec	r17
   10392:	c1 f7       	brne	.-16     	; 0x10384 <__ftoa_engine+0xe6>
   10394:	ee ee       	ldi	r30, 0xEE	; 238
   10396:	fc e0       	ldi	r31, 0x0C	; 12
   10398:	68 94       	set
   1039a:	15 90       	lpm	r1, Z+
   1039c:	15 91       	lpm	r17, Z+
   1039e:	35 91       	lpm	r19, Z+
   103a0:	65 91       	lpm	r22, Z+
   103a2:	95 91       	lpm	r25, Z+
   103a4:	05 90       	lpm	r0, Z+
   103a6:	7f e2       	ldi	r23, 0x2F	; 47
   103a8:	73 95       	inc	r23
   103aa:	e1 18       	sub	r14, r1
   103ac:	f1 0a       	sbc	r15, r17
   103ae:	43 0b       	sbc	r20, r19
   103b0:	56 0b       	sbc	r21, r22
   103b2:	c9 0b       	sbc	r28, r25
   103b4:	d0 09       	sbc	r29, r0
   103b6:	c0 f7       	brcc	.-16     	; 0x103a8 <__ftoa_engine+0x10a>
   103b8:	e1 0c       	add	r14, r1
   103ba:	f1 1e       	adc	r15, r17
   103bc:	43 1f       	adc	r20, r19
   103be:	56 1f       	adc	r21, r22
   103c0:	c9 1f       	adc	r28, r25
   103c2:	d0 1d       	adc	r29, r0
   103c4:	7e f4       	brtc	.+30     	; 0x103e4 <__ftoa_engine+0x146>
   103c6:	70 33       	cpi	r23, 0x30	; 48
   103c8:	11 f4       	brne	.+4      	; 0x103ce <__ftoa_engine+0x130>
   103ca:	8a 95       	dec	r24
   103cc:	e6 cf       	rjmp	.-52     	; 0x1039a <__ftoa_engine+0xfc>
   103ce:	e8 94       	clt
   103d0:	01 50       	subi	r16, 0x01	; 1
   103d2:	30 f0       	brcs	.+12     	; 0x103e0 <__ftoa_engine+0x142>
   103d4:	08 0f       	add	r16, r24
   103d6:	0a f4       	brpl	.+2      	; 0x103da <__ftoa_engine+0x13c>
   103d8:	00 27       	eor	r16, r16
   103da:	02 17       	cp	r16, r18
   103dc:	08 f4       	brcc	.+2      	; 0x103e0 <__ftoa_engine+0x142>
   103de:	20 2f       	mov	r18, r16
   103e0:	23 95       	inc	r18
   103e2:	02 2f       	mov	r16, r18
   103e4:	7a 33       	cpi	r23, 0x3A	; 58
   103e6:	28 f0       	brcs	.+10     	; 0x103f2 <__ftoa_engine+0x154>
   103e8:	79 e3       	ldi	r23, 0x39	; 57
   103ea:	7d 93       	st	X+, r23
   103ec:	2a 95       	dec	r18
   103ee:	e9 f7       	brne	.-6      	; 0x103ea <__ftoa_engine+0x14c>
   103f0:	10 c0       	rjmp	.+32     	; 0x10412 <__ftoa_engine+0x174>
   103f2:	7d 93       	st	X+, r23
   103f4:	2a 95       	dec	r18
   103f6:	89 f6       	brne	.-94     	; 0x1039a <__ftoa_engine+0xfc>
   103f8:	06 94       	lsr	r0
   103fa:	97 95       	ror	r25
   103fc:	67 95       	ror	r22
   103fe:	37 95       	ror	r19
   10400:	17 95       	ror	r17
   10402:	17 94       	ror	r1
   10404:	e1 18       	sub	r14, r1
   10406:	f1 0a       	sbc	r15, r17
   10408:	43 0b       	sbc	r20, r19
   1040a:	56 0b       	sbc	r21, r22
   1040c:	c9 0b       	sbc	r28, r25
   1040e:	d0 09       	sbc	r29, r0
   10410:	98 f0       	brcs	.+38     	; 0x10438 <__ftoa_engine+0x19a>
   10412:	23 95       	inc	r18
   10414:	7e 91       	ld	r23, -X
   10416:	73 95       	inc	r23
   10418:	7a 33       	cpi	r23, 0x3A	; 58
   1041a:	08 f0       	brcs	.+2      	; 0x1041e <__ftoa_engine+0x180>
   1041c:	70 e3       	ldi	r23, 0x30	; 48
   1041e:	7c 93       	st	X, r23
   10420:	20 13       	cpse	r18, r16
   10422:	b8 f7       	brcc	.-18     	; 0x10412 <__ftoa_engine+0x174>
   10424:	7e 91       	ld	r23, -X
   10426:	70 61       	ori	r23, 0x10	; 16
   10428:	7d 93       	st	X+, r23
   1042a:	30 f0       	brcs	.+12     	; 0x10438 <__ftoa_engine+0x19a>
   1042c:	83 95       	inc	r24
   1042e:	71 e3       	ldi	r23, 0x31	; 49
   10430:	7d 93       	st	X+, r23
   10432:	70 e3       	ldi	r23, 0x30	; 48
   10434:	2a 95       	dec	r18
   10436:	e1 f7       	brne	.-8      	; 0x10430 <__ftoa_engine+0x192>
   10438:	11 24       	eor	r1, r1
   1043a:	ef 90       	pop	r14
   1043c:	ff 90       	pop	r15
   1043e:	0f 91       	pop	r16
   10440:	1f 91       	pop	r17
   10442:	cf 91       	pop	r28
   10444:	df 91       	pop	r29
   10446:	99 27       	eor	r25, r25
   10448:	87 fd       	sbrc	r24, 7
   1044a:	90 95       	com	r25
   1044c:	08 95       	ret

0001044e <isspace>:
   1044e:	91 11       	cpse	r25, r1
   10450:	33 c1       	rjmp	.+614    	; 0x106b8 <__ctype_isfalse>
   10452:	80 32       	cpi	r24, 0x20	; 32
   10454:	19 f0       	breq	.+6      	; 0x1045c <isspace+0xe>
   10456:	89 50       	subi	r24, 0x09	; 9
   10458:	85 50       	subi	r24, 0x05	; 5
   1045a:	d0 f7       	brcc	.-12     	; 0x10450 <isspace+0x2>
   1045c:	08 95       	ret

0001045e <tolower>:
   1045e:	91 11       	cpse	r25, r1
   10460:	08 95       	ret
   10462:	81 54       	subi	r24, 0x41	; 65
   10464:	8a 51       	subi	r24, 0x1A	; 26
   10466:	08 f4       	brcc	.+2      	; 0x1046a <tolower+0xc>
   10468:	80 5e       	subi	r24, 0xE0	; 224
   1046a:	85 5a       	subi	r24, 0xA5	; 165
   1046c:	08 95       	ret

0001046e <strchr_P>:
   1046e:	fc 01       	movw	r30, r24
   10470:	05 90       	lpm	r0, Z+
   10472:	06 16       	cp	r0, r22
   10474:	21 f0       	breq	.+8      	; 0x1047e <strchr_P+0x10>
   10476:	00 20       	and	r0, r0
   10478:	d9 f7       	brne	.-10     	; 0x10470 <strchr_P+0x2>
   1047a:	c0 01       	movw	r24, r0
   1047c:	08 95       	ret
   1047e:	31 97       	sbiw	r30, 0x01	; 1
   10480:	cf 01       	movw	r24, r30
   10482:	08 95       	ret

00010484 <strnlen_P>:
   10484:	fc 01       	movw	r30, r24
   10486:	05 90       	lpm	r0, Z+
   10488:	61 50       	subi	r22, 0x01	; 1
   1048a:	70 40       	sbci	r23, 0x00	; 0
   1048c:	01 10       	cpse	r0, r1
   1048e:	d8 f7       	brcc	.-10     	; 0x10486 <strnlen_P+0x2>
   10490:	80 95       	com	r24
   10492:	90 95       	com	r25
   10494:	8e 0f       	add	r24, r30
   10496:	9f 1f       	adc	r25, r31
   10498:	08 95       	ret

0001049a <strnlen>:
   1049a:	fc 01       	movw	r30, r24
   1049c:	61 50       	subi	r22, 0x01	; 1
   1049e:	70 40       	sbci	r23, 0x00	; 0
   104a0:	01 90       	ld	r0, Z+
   104a2:	01 10       	cpse	r0, r1
   104a4:	d8 f7       	brcc	.-10     	; 0x1049c <strnlen+0x2>
   104a6:	80 95       	com	r24
   104a8:	90 95       	com	r25
   104aa:	8e 0f       	add	r24, r30
   104ac:	9f 1f       	adc	r25, r31
   104ae:	08 95       	ret

000104b0 <fgetc>:
   104b0:	cf 93       	push	r28
   104b2:	df 93       	push	r29
   104b4:	ec 01       	movw	r28, r24
   104b6:	4b 81       	ldd	r20, Y+3	; 0x03
   104b8:	40 ff       	sbrs	r20, 0
   104ba:	1a c0       	rjmp	.+52     	; 0x104f0 <fgetc+0x40>
   104bc:	46 ff       	sbrs	r20, 6
   104be:	0a c0       	rjmp	.+20     	; 0x104d4 <fgetc+0x24>
   104c0:	4f 7b       	andi	r20, 0xBF	; 191
   104c2:	4b 83       	std	Y+3, r20	; 0x03
   104c4:	8e 81       	ldd	r24, Y+6	; 0x06
   104c6:	9f 81       	ldd	r25, Y+7	; 0x07
   104c8:	01 96       	adiw	r24, 0x01	; 1
   104ca:	9f 83       	std	Y+7, r25	; 0x07
   104cc:	8e 83       	std	Y+6, r24	; 0x06
   104ce:	8a 81       	ldd	r24, Y+2	; 0x02
   104d0:	28 2f       	mov	r18, r24
   104d2:	2b c0       	rjmp	.+86     	; 0x1052a <fgetc+0x7a>
   104d4:	42 ff       	sbrs	r20, 2
   104d6:	13 c0       	rjmp	.+38     	; 0x104fe <fgetc+0x4e>
   104d8:	e8 81       	ld	r30, Y
   104da:	f9 81       	ldd	r31, Y+1	; 0x01
   104dc:	80 81       	ld	r24, Z
   104de:	28 2f       	mov	r18, r24
   104e0:	33 27       	eor	r19, r19
   104e2:	27 fd       	sbrc	r18, 7
   104e4:	30 95       	com	r19
   104e6:	21 15       	cp	r18, r1
   104e8:	31 05       	cpc	r19, r1
   104ea:	29 f4       	brne	.+10     	; 0x104f6 <fgetc+0x46>
   104ec:	40 62       	ori	r20, 0x20	; 32
   104ee:	4b 83       	std	Y+3, r20	; 0x03
   104f0:	2f ef       	ldi	r18, 0xFF	; 255
   104f2:	3f ef       	ldi	r19, 0xFF	; 255
   104f4:	1b c0       	rjmp	.+54     	; 0x1052c <fgetc+0x7c>
   104f6:	31 96       	adiw	r30, 0x01	; 1
   104f8:	f9 83       	std	Y+1, r31	; 0x01
   104fa:	e8 83       	st	Y, r30
   104fc:	11 c0       	rjmp	.+34     	; 0x10520 <fgetc+0x70>
   104fe:	ea 85       	ldd	r30, Y+10	; 0x0a
   10500:	fb 85       	ldd	r31, Y+11	; 0x0b
   10502:	ce 01       	movw	r24, r28
   10504:	09 95       	icall
   10506:	9c 01       	movw	r18, r24
   10508:	97 ff       	sbrs	r25, 7
   1050a:	0a c0       	rjmp	.+20     	; 0x10520 <fgetc+0x70>
   1050c:	9b 81       	ldd	r25, Y+3	; 0x03
   1050e:	2f 5f       	subi	r18, 0xFF	; 255
   10510:	3f 4f       	sbci	r19, 0xFF	; 255
   10512:	11 f0       	breq	.+4      	; 0x10518 <fgetc+0x68>
   10514:	80 e2       	ldi	r24, 0x20	; 32
   10516:	01 c0       	rjmp	.+2      	; 0x1051a <fgetc+0x6a>
   10518:	80 e1       	ldi	r24, 0x10	; 16
   1051a:	89 2b       	or	r24, r25
   1051c:	8b 83       	std	Y+3, r24	; 0x03
   1051e:	e8 cf       	rjmp	.-48     	; 0x104f0 <fgetc+0x40>
   10520:	8e 81       	ldd	r24, Y+6	; 0x06
   10522:	9f 81       	ldd	r25, Y+7	; 0x07
   10524:	01 96       	adiw	r24, 0x01	; 1
   10526:	9f 83       	std	Y+7, r25	; 0x07
   10528:	8e 83       	std	Y+6, r24	; 0x06
   1052a:	30 e0       	ldi	r19, 0x00	; 0
   1052c:	c9 01       	movw	r24, r18
   1052e:	df 91       	pop	r29
   10530:	cf 91       	pop	r28
   10532:	08 95       	ret

00010534 <fprintf_P>:
   10534:	0f 93       	push	r16
   10536:	1f 93       	push	r17
   10538:	df 93       	push	r29
   1053a:	cf 93       	push	r28
   1053c:	cd b7       	in	r28, 0x3d	; 61
   1053e:	de b7       	in	r29, 0x3e	; 62
   10540:	0f 81       	ldd	r16, Y+7	; 0x07
   10542:	18 85       	ldd	r17, Y+8	; 0x08
   10544:	9e 01       	movw	r18, r28
   10546:	25 5f       	subi	r18, 0xF5	; 245
   10548:	3f 4f       	sbci	r19, 0xFF	; 255
   1054a:	f8 01       	movw	r30, r16
   1054c:	83 81       	ldd	r24, Z+3	; 0x03
   1054e:	88 60       	ori	r24, 0x08	; 8
   10550:	83 83       	std	Z+3, r24	; 0x03
   10552:	c8 01       	movw	r24, r16
   10554:	69 85       	ldd	r22, Y+9	; 0x09
   10556:	7a 85       	ldd	r23, Y+10	; 0x0a
   10558:	a9 01       	movw	r20, r18
   1055a:	0e 94 8d 74 	call	0xe91a	; 0xe91a <vfprintf>
   1055e:	f8 01       	movw	r30, r16
   10560:	23 81       	ldd	r18, Z+3	; 0x03
   10562:	27 7f       	andi	r18, 0xF7	; 247
   10564:	23 83       	std	Z+3, r18	; 0x03
   10566:	cf 91       	pop	r28
   10568:	df 91       	pop	r29
   1056a:	1f 91       	pop	r17
   1056c:	0f 91       	pop	r16
   1056e:	08 95       	ret

00010570 <fputc>:
   10570:	0f 93       	push	r16
   10572:	1f 93       	push	r17
   10574:	cf 93       	push	r28
   10576:	df 93       	push	r29
   10578:	8c 01       	movw	r16, r24
   1057a:	eb 01       	movw	r28, r22
   1057c:	8b 81       	ldd	r24, Y+3	; 0x03
   1057e:	81 ff       	sbrs	r24, 1
   10580:	1b c0       	rjmp	.+54     	; 0x105b8 <fputc+0x48>
   10582:	82 ff       	sbrs	r24, 2
   10584:	0d c0       	rjmp	.+26     	; 0x105a0 <fputc+0x30>
   10586:	2e 81       	ldd	r18, Y+6	; 0x06
   10588:	3f 81       	ldd	r19, Y+7	; 0x07
   1058a:	8c 81       	ldd	r24, Y+4	; 0x04
   1058c:	9d 81       	ldd	r25, Y+5	; 0x05
   1058e:	28 17       	cp	r18, r24
   10590:	39 07       	cpc	r19, r25
   10592:	64 f4       	brge	.+24     	; 0x105ac <fputc+0x3c>
   10594:	e8 81       	ld	r30, Y
   10596:	f9 81       	ldd	r31, Y+1	; 0x01
   10598:	01 93       	st	Z+, r16
   1059a:	f9 83       	std	Y+1, r31	; 0x01
   1059c:	e8 83       	st	Y, r30
   1059e:	06 c0       	rjmp	.+12     	; 0x105ac <fputc+0x3c>
   105a0:	e8 85       	ldd	r30, Y+8	; 0x08
   105a2:	f9 85       	ldd	r31, Y+9	; 0x09
   105a4:	80 2f       	mov	r24, r16
   105a6:	09 95       	icall
   105a8:	89 2b       	or	r24, r25
   105aa:	31 f4       	brne	.+12     	; 0x105b8 <fputc+0x48>
   105ac:	8e 81       	ldd	r24, Y+6	; 0x06
   105ae:	9f 81       	ldd	r25, Y+7	; 0x07
   105b0:	01 96       	adiw	r24, 0x01	; 1
   105b2:	9f 83       	std	Y+7, r25	; 0x07
   105b4:	8e 83       	std	Y+6, r24	; 0x06
   105b6:	02 c0       	rjmp	.+4      	; 0x105bc <fputc+0x4c>
   105b8:	0f ef       	ldi	r16, 0xFF	; 255
   105ba:	1f ef       	ldi	r17, 0xFF	; 255
   105bc:	c8 01       	movw	r24, r16
   105be:	df 91       	pop	r29
   105c0:	cf 91       	pop	r28
   105c2:	1f 91       	pop	r17
   105c4:	0f 91       	pop	r16
   105c6:	08 95       	ret

000105c8 <ungetc>:
   105c8:	9c 01       	movw	r18, r24
   105ca:	fb 01       	movw	r30, r22
   105cc:	83 81       	ldd	r24, Z+3	; 0x03
   105ce:	80 ff       	sbrs	r24, 0
   105d0:	11 c0       	rjmp	.+34     	; 0x105f4 <ungetc+0x2c>
   105d2:	86 fd       	sbrc	r24, 6
   105d4:	0f c0       	rjmp	.+30     	; 0x105f4 <ungetc+0x2c>
   105d6:	9f ef       	ldi	r25, 0xFF	; 255
   105d8:	2f 3f       	cpi	r18, 0xFF	; 255
   105da:	39 07       	cpc	r19, r25
   105dc:	59 f0       	breq	.+22     	; 0x105f4 <ungetc+0x2c>
   105de:	22 83       	std	Z+2, r18	; 0x02
   105e0:	80 64       	ori	r24, 0x40	; 64
   105e2:	8f 7d       	andi	r24, 0xDF	; 223
   105e4:	83 83       	std	Z+3, r24	; 0x03
   105e6:	86 81       	ldd	r24, Z+6	; 0x06
   105e8:	97 81       	ldd	r25, Z+7	; 0x07
   105ea:	01 97       	sbiw	r24, 0x01	; 1
   105ec:	97 83       	std	Z+7, r25	; 0x07
   105ee:	86 83       	std	Z+6, r24	; 0x06
   105f0:	30 e0       	ldi	r19, 0x00	; 0
   105f2:	02 c0       	rjmp	.+4      	; 0x105f8 <ungetc+0x30>
   105f4:	2f ef       	ldi	r18, 0xFF	; 255
   105f6:	3f ef       	ldi	r19, 0xFF	; 255
   105f8:	c9 01       	movw	r24, r18
   105fa:	08 95       	ret

000105fc <__ultoa_invert>:
   105fc:	fa 01       	movw	r30, r20
   105fe:	aa 27       	eor	r26, r26
   10600:	28 30       	cpi	r18, 0x08	; 8
   10602:	51 f1       	breq	.+84     	; 0x10658 <__ultoa_invert+0x5c>
   10604:	20 31       	cpi	r18, 0x10	; 16
   10606:	81 f1       	breq	.+96     	; 0x10668 <__ultoa_invert+0x6c>
   10608:	e8 94       	clt
   1060a:	6f 93       	push	r22
   1060c:	6e 7f       	andi	r22, 0xFE	; 254
   1060e:	6e 5f       	subi	r22, 0xFE	; 254
   10610:	7f 4f       	sbci	r23, 0xFF	; 255
   10612:	8f 4f       	sbci	r24, 0xFF	; 255
   10614:	9f 4f       	sbci	r25, 0xFF	; 255
   10616:	af 4f       	sbci	r26, 0xFF	; 255
   10618:	b1 e0       	ldi	r27, 0x01	; 1
   1061a:	3e d0       	rcall	.+124    	; 0x10698 <__ultoa_invert+0x9c>
   1061c:	b4 e0       	ldi	r27, 0x04	; 4
   1061e:	3c d0       	rcall	.+120    	; 0x10698 <__ultoa_invert+0x9c>
   10620:	67 0f       	add	r22, r23
   10622:	78 1f       	adc	r23, r24
   10624:	89 1f       	adc	r24, r25
   10626:	9a 1f       	adc	r25, r26
   10628:	a1 1d       	adc	r26, r1
   1062a:	68 0f       	add	r22, r24
   1062c:	79 1f       	adc	r23, r25
   1062e:	8a 1f       	adc	r24, r26
   10630:	91 1d       	adc	r25, r1
   10632:	a1 1d       	adc	r26, r1
   10634:	6a 0f       	add	r22, r26
   10636:	71 1d       	adc	r23, r1
   10638:	81 1d       	adc	r24, r1
   1063a:	91 1d       	adc	r25, r1
   1063c:	a1 1d       	adc	r26, r1
   1063e:	20 d0       	rcall	.+64     	; 0x10680 <__ultoa_invert+0x84>
   10640:	09 f4       	brne	.+2      	; 0x10644 <__ultoa_invert+0x48>
   10642:	68 94       	set
   10644:	3f 91       	pop	r19
   10646:	2a e0       	ldi	r18, 0x0A	; 10
   10648:	26 9f       	mul	r18, r22
   1064a:	11 24       	eor	r1, r1
   1064c:	30 19       	sub	r19, r0
   1064e:	30 5d       	subi	r19, 0xD0	; 208
   10650:	31 93       	st	Z+, r19
   10652:	de f6       	brtc	.-74     	; 0x1060a <__ultoa_invert+0xe>
   10654:	cf 01       	movw	r24, r30
   10656:	08 95       	ret
   10658:	46 2f       	mov	r20, r22
   1065a:	47 70       	andi	r20, 0x07	; 7
   1065c:	40 5d       	subi	r20, 0xD0	; 208
   1065e:	41 93       	st	Z+, r20
   10660:	b3 e0       	ldi	r27, 0x03	; 3
   10662:	0f d0       	rcall	.+30     	; 0x10682 <__ultoa_invert+0x86>
   10664:	c9 f7       	brne	.-14     	; 0x10658 <__ultoa_invert+0x5c>
   10666:	f6 cf       	rjmp	.-20     	; 0x10654 <__ultoa_invert+0x58>
   10668:	46 2f       	mov	r20, r22
   1066a:	4f 70       	andi	r20, 0x0F	; 15
   1066c:	40 5d       	subi	r20, 0xD0	; 208
   1066e:	4a 33       	cpi	r20, 0x3A	; 58
   10670:	18 f0       	brcs	.+6      	; 0x10678 <__ultoa_invert+0x7c>
   10672:	49 5d       	subi	r20, 0xD9	; 217
   10674:	31 fd       	sbrc	r19, 1
   10676:	40 52       	subi	r20, 0x20	; 32
   10678:	41 93       	st	Z+, r20
   1067a:	02 d0       	rcall	.+4      	; 0x10680 <__ultoa_invert+0x84>
   1067c:	a9 f7       	brne	.-22     	; 0x10668 <__ultoa_invert+0x6c>
   1067e:	ea cf       	rjmp	.-44     	; 0x10654 <__ultoa_invert+0x58>
   10680:	b4 e0       	ldi	r27, 0x04	; 4
   10682:	a6 95       	lsr	r26
   10684:	97 95       	ror	r25
   10686:	87 95       	ror	r24
   10688:	77 95       	ror	r23
   1068a:	67 95       	ror	r22
   1068c:	ba 95       	dec	r27
   1068e:	c9 f7       	brne	.-14     	; 0x10682 <__ultoa_invert+0x86>
   10690:	00 97       	sbiw	r24, 0x00	; 0
   10692:	61 05       	cpc	r22, r1
   10694:	71 05       	cpc	r23, r1
   10696:	08 95       	ret
   10698:	9b 01       	movw	r18, r22
   1069a:	ac 01       	movw	r20, r24
   1069c:	0a 2e       	mov	r0, r26
   1069e:	06 94       	lsr	r0
   106a0:	57 95       	ror	r21
   106a2:	47 95       	ror	r20
   106a4:	37 95       	ror	r19
   106a6:	27 95       	ror	r18
   106a8:	ba 95       	dec	r27
   106aa:	c9 f7       	brne	.-14     	; 0x1069e <__ultoa_invert+0xa2>
   106ac:	62 0f       	add	r22, r18
   106ae:	73 1f       	adc	r23, r19
   106b0:	84 1f       	adc	r24, r20
   106b2:	95 1f       	adc	r25, r21
   106b4:	a0 1d       	adc	r26, r0
   106b6:	08 95       	ret

000106b8 <__ctype_isfalse>:
   106b8:	99 27       	eor	r25, r25
   106ba:	88 27       	eor	r24, r24

000106bc <__ctype_istrue>:
   106bc:	08 95       	ret

000106be <_exit>:
   106be:	f8 94       	cli

000106c0 <__stop_program>:
   106c0:	ff cf       	rjmp	.-2      	; 0x106c0 <__stop_program>
